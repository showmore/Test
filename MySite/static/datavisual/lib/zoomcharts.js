!function (t, e, i) {
    var n = t.L, s = {};
    s.version = "0.7.3", "object" == typeof module && "object" == typeof module.exports ? module.exports = s : "function" == typeof define && define.amd && define(s), s.noConflict = function () {
        return t.L = n, this
    }, t.L = s, s.Util = {
        extend: function (t) {
            var e, i, n, s, o = Array.prototype.slice.call(arguments, 1);
            for (i = 0, n = o.length; n > i; i++) {
                s = o[i] || {};
                for (e in s)s.hasOwnProperty(e) && (t[e] = s[e])
            }
            return t
        }, bind: function (t, e) {
            var i = arguments.length > 2 ? Array.prototype.slice.call(arguments, 2) : null;
            return function () {
                return t.apply(e, i || arguments)
            }
        }, stamp: function () {
            var t = 0, e = "_leaflet_id";
            return function (i) {
                return i[e] = i[e] || ++t, i[e]
            }
        }(), invokeEach: function (t, e, i) {
            var n, s;
            if ("object" == typeof t) {
                s = Array.prototype.slice.call(arguments, 3);
                for (n in t)e.apply(i, [n, t[n]].concat(s));
                return !0
            }
            return !1
        }, limitExecByInterval: function (t, e, i) {
            var n, s;
            return function o() {
                var r = arguments;
                return n ? void(s = !0) : (n = !0, setTimeout(function () {
                        n = !1, s && (o.apply(i, r), s = !1)
                    }, e), void t.apply(i, r))
            }
        }, falseFn: function () {
            return !1
        }, formatNum: function (t, e) {
            var i = Math.pow(10, e || 5);
            return Math.round(t * i) / i
        }, trim: function (t) {
            return t.trim ? t.trim() : t.replace(/^\s+|\s+$/g, "")
        }, splitWords: function (t) {
            return s.Util.trim(t).split(/\s+/)
        }, setOptions: function (t, e) {
            return t.options = s.extend({}, t.options, e), t.options
        }, getParamString: function (t, e, i) {
            var n = [];
            for (var s in t)n.push(encodeURIComponent(i ? s.toUpperCase() : s) + "=" + encodeURIComponent(t[s]));
            return (e && -1 !== e.indexOf("?") ? "&" : "?") + n.join("&")
        }, template: function (t, e) {
            return t.replace(/\{ *([\w_]+) *\}/g, function (t, n) {
                var s = e[n];
                if (s === i)throw new Error("No value provided for variable " + t);
                return "function" == typeof s && (s = s(e)), s
            })
        }, isArray: Array.isArray || function (t) {
            return "[object Array]" === Object.prototype.toString.call(t)
        }, emptyImageUrl: "data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs="
    }, function () {
        function e(e) {
            var i, n, s = ["webkit", "moz", "o", "ms"];
            for (i = 0; i < s.length && !n; i++)n = t[s[i] + e];
            return n
        }

        function i(e) {
            var i = +new Date, s = Math.max(0, 16 - (i - n));
            return n = i + s, t.setTimeout(e, s)
        }

        var n = 0, o = t.requestAnimationFrame || e("RequestAnimationFrame") || i, r = t.cancelAnimationFrame || e("CancelAnimationFrame") || e("CancelRequestAnimationFrame") || function (e) {
                t.clearTimeout(e)
            };
        s.Util.requestAnimFrame = function (e, n, r, a) {
            return e = s.bind(e, n), r && o === i ? void e() : o.call(t, e, a)
        }, s.Util.cancelAnimFrame = function (e) {
            e && r.call(t, e)
        }
    }(), s.extend = s.Util.extend, s.bind = s.Util.bind, s.stamp = s.Util.stamp, s.setOptions = s.Util.setOptions, s.Class = function () {
    }, s.Class.extend = function (t) {
        var e = function () {
            this.initialize && this.initialize.apply(this, arguments), this._initHooks && this.callInitHooks()
        }, i = function () {
        };
        i.prototype = this.prototype;
        var n = new i;
        n.constructor = e, e.prototype = n;
        for (var o in this)this.hasOwnProperty(o) && "prototype" !== o && (e[o] = this[o]);
        t.statics && (s.extend(e, t.statics), delete t.statics), t.includes && (s.Util.extend.apply(null, [n].concat(t.includes)), delete t.includes), t.options && n.options && (t.options = s.extend({}, n.options, t.options)), s.extend(n, t), n._initHooks = [];
        var r = this;
        return e.__super__ = r.prototype, n.callInitHooks = function () {
            if (!this._initHooksCalled) {
                r.prototype.callInitHooks && r.prototype.callInitHooks.call(this), this._initHooksCalled = !0;
                for (var t = 0, e = n._initHooks.length; e > t; t++)n._initHooks[t].call(this)
            }
        }, e
    }, s.Class.include = function (t) {
        s.extend(this.prototype, t)
    }, s.Class.mergeOptions = function (t) {
        s.extend(this.prototype.options, t)
    }, s.Class.addInitHook = function (t) {
        var e = Array.prototype.slice.call(arguments, 1), i = "function" == typeof t ? t : function () {
                this[t].apply(this, e)
            };
        this.prototype._initHooks = this.prototype._initHooks || [], this.prototype._initHooks.push(i)
    };
    var o = "_leaflet_events";
    s.Mixin = {}, s.Mixin.Events = {
        addEventListener: function (t, e, i) {
            if (s.Util.invokeEach(t, this.addEventListener, this, e, i))return this;
            var n, r, a, h, l, u, c, p = this[o] = this[o] || {}, d = i && i !== this && s.stamp(i);
            for (t = s.Util.splitWords(t), n = 0, r = t.length; r > n; n++)a = {
                action: e,
                context: i || this
            }, h = t[n], d ? (l = h + "_idx", u = l + "_len", c = p[l] = p[l] || {}, c[d] || (c[d] = [], p[u] = (p[u] || 0) + 1), c[d].push(a)) : (p[h] = p[h] || [], p[h].push(a));
            return this
        }, hasEventListeners: function (t) {
            var e = this[o];
            return !!e && (t in e && e[t].length > 0 || t + "_idx" in e && e[t + "_idx_len"] > 0)
        }, removeEventListener: function (t, e, i) {
            if (!this[o])return this;
            if (!t)return this.clearAllEventListeners();
            if (s.Util.invokeEach(t, this.removeEventListener, this, e, i))return this;
            var n, r, a, h, l, u, c, p, d, f = this[o], m = i && i !== this && s.stamp(i);
            for (t = s.Util.splitWords(t), n = 0, r = t.length; r > n; n++)if (a = t[n], u = a + "_idx", c = u + "_len", p = f[u], e) {
                if (h = m && p ? p[m] : f[a]) {
                    for (l = h.length - 1; l >= 0; l--)h[l].action !== e || i && h[l].context !== i || (d = h.splice(l, 1), d[0].action = s.Util.falseFn);
                    i && p && 0 === h.length && (delete p[m], f[c]--)
                }
            } else delete f[a], delete f[u], delete f[c];
            return this
        }, clearAllEventListeners: function () {
            return delete this[o], this
        }, fireEvent: function (t, e) {
            if (!this.hasEventListeners(t))return this;
            var i, n, r, a, h, l = s.Util.extend({}, e, {
                type: t,
                target: this
            }), u = this[o];
            if (u[t])for (i = u[t].slice(), n = 0, r = i.length; r > n; n++)i[n].action.call(i[n].context, l);
            a = u[t + "_idx"];
            for (h in a)if (i = a[h].slice())for (n = 0, r = i.length; r > n; n++)i[n].action.call(i[n].context, l);
            return this
        }, addOneTimeEventListener: function (t, e, i) {
            if (s.Util.invokeEach(t, this.addOneTimeEventListener, this, e, i))return this;
            var n = s.bind(function () {
                this.removeEventListener(t, e, i).removeEventListener(t, n, i)
            }, this);
            return this.addEventListener(t, e, i).addEventListener(t, n, i)
        }
    }, s.Mixin.Events.on = s.Mixin.Events.addEventListener, s.Mixin.Events.off = s.Mixin.Events.removeEventListener, s.Mixin.Events.once = s.Mixin.Events.addOneTimeEventListener, s.Mixin.Events.fire = s.Mixin.Events.fireEvent, function () {
        var n = "ActiveXObject" in t, o = n && !e.addEventListener, r = navigator.userAgent.toLowerCase(), a = -1 !== r.indexOf("webkit"), h = -1 !== r.indexOf("chrome"), l = -1 !== r.indexOf("phantom"), u = -1 !== r.indexOf("android"), c = -1 !== r.search("android [23]"), p = -1 !== r.indexOf("gecko"), d = typeof orientation != i + "", f = t.navigator && t.navigator.msPointerEnabled && t.navigator.msMaxTouchPoints && !t.PointerEvent, m = t.PointerEvent && t.navigator.pointerEnabled && t.navigator.maxTouchPoints || f, g = "devicePixelRatio" in t && t.devicePixelRatio > 1 || "matchMedia" in t && t.matchMedia("(min-resolution:144dpi)") && t.matchMedia("(min-resolution:144dpi)").matches, y = e.documentElement, v = n && "transition" in y.style, S = "WebKitCSSMatrix" in t && "m11" in new t.WebKitCSSMatrix && !c, C = "MozPerspective" in y.style, b = "OTransition" in y.style, x = !t.L_DISABLE_3D && (v || S || C || b) && !l, _ = !t.L_NO_TOUCH && !l && function () {
                var t = "ontouchstart";
                if (m || t in y)return !0;
                var i = e.createElement("div"), n = !1;
                return i.setAttribute ? (i.setAttribute(t, "return;"), "function" == typeof i[t] && (n = !0), i.removeAttribute(t), i = null, n) : !1
            }();
        s.Browser = {
            ie: n,
            ielt9: o,
            webkit: a,
            gecko: p && !a && !t.opera && !n,
            android: u,
            android23: c,
            chrome: h,
            ie3d: v,
            webkit3d: S,
            gecko3d: C,
            opera3d: b,
            any3d: x,
            mobile: d,
            mobileWebkit: d && a,
            mobileWebkit3d: d && S,
            mobileOpera: d && t.opera,
            touch: _,
            msPointer: f,
            pointer: m,
            retina: g
        }
    }(), s.Point = function (t, e, i) {
        this.x = i ? Math.round(t) : t, this.y = i ? Math.round(e) : e
    }, s.Point.prototype = {
        clone: function () {
            return new s.Point(this.x, this.y)
        }, add: function (t) {
            return this.clone()._add(s.point(t))
        }, _add: function (t) {
            return this.x += t.x, this.y += t.y, this
        }, subtract: function (t) {
            return this.clone()._subtract(s.point(t))
        }, _subtract: function (t) {
            return this.x -= t.x, this.y -= t.y, this
        }, divideBy: function (t) {
            return this.clone()._divideBy(t)
        }, _divideBy: function (t) {
            return this.x /= t, this.y /= t, this
        }, multiplyBy: function (t) {
            return this.clone()._multiplyBy(t)
        }, _multiplyBy: function (t) {
            return this.x *= t, this.y *= t, this
        }, round: function () {
            return this.clone()._round()
        }, _round: function () {
            return this.x = Math.round(this.x), this.y = Math.round(this.y), this
        }, floor: function () {
            return this.clone()._floor()
        }, _floor: function () {
            return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this
        }, distanceTo: function (t) {
            t = s.point(t);
            var e = t.x - this.x, i = t.y - this.y;
            return Math.sqrt(e * e + i * i)
        }, equals: function (t) {
            return t = s.point(t), t.x === this.x && t.y === this.y
        }, contains: function (t) {
            return t = s.point(t), Math.abs(t.x) <= Math.abs(this.x) && Math.abs(t.y) <= Math.abs(this.y)
        }, toString: function () {
            return "Point(" + s.Util.formatNum(this.x) + ", " + s.Util.formatNum(this.y) + ")"
        }
    }, s.point = function (t, e, n) {
        return t instanceof s.Point ? t : s.Util.isArray(t) ? new s.Point(t[0], t[1]) : t === i || null === t ? t : new s.Point(t, e, n)
    }, s.Bounds = function (t, e) {
        if (t)for (var i = e ? [t, e] : t, n = 0, s = i.length; s > n; n++)this.extend(i[n])
    }, s.Bounds.prototype = {
        extend: function (t) {
            return t = s.point(t), this.min || this.max ? (this.min.x = Math.min(t.x, this.min.x), this.max.x = Math.max(t.x, this.max.x), this.min.y = Math.min(t.y, this.min.y), this.max.y = Math.max(t.y, this.max.y)) : (this.min = t.clone(), this.max = t.clone()), this
        }, getCenter: function (t) {
            return new s.Point((this.min.x + this.max.x) / 2, (this.min.y + this.max.y) / 2, t)
        }, getBottomLeft: function () {
            return new s.Point(this.min.x, this.max.y)
        }, getTopRight: function () {
            return new s.Point(this.max.x, this.min.y)
        }, getSize: function () {
            return this.max.subtract(this.min)
        }, contains: function (t) {
            var e, i;
            return t = "number" == typeof t[0] || t instanceof s.Point ? s.point(t) : s.bounds(t), t instanceof s.Bounds ? (e = t.min, i = t.max) : e = i = t, e.x >= this.min.x && i.x <= this.max.x && e.y >= this.min.y && i.y <= this.max.y
        }, intersects: function (t) {
            t = s.bounds(t);
            var e = this.min, i = this.max, n = t.min, o = t.max, r = o.x >= e.x && n.x <= i.x, a = o.y >= e.y && n.y <= i.y;
            return r && a
        }, isValid: function () {
            return !(!this.min || !this.max)
        }
    }, s.bounds = function (t, e) {
        return !t || t instanceof s.Bounds ? t : new s.Bounds(t, e)
    }, s.Transformation = function (t, e, i, n) {
        this._a = t, this._b = e, this._c = i, this._d = n
    }, s.Transformation.prototype = {
        transform: function (t, e) {
            return this._transform(t.clone(), e)
        }, _transform: function (t, e) {
            return e = e || 1, t.x = e * (this._a * t.x + this._b), t.y = e * (this._c * t.y + this._d), t
        }, untransform: function (t, e) {
            return e = e || 1, new s.Point((t.x / e - this._b) / this._a, (t.y / e - this._d) / this._c)
        }
    }, s.DomUtil = {
        get: function (t) {
            return "string" == typeof t ? e.getElementById(t) : t
        }, getStyle: function (t, i) {
            var n = t.style[i];
            if (!n && t.currentStyle && (n = t.currentStyle[i]), (!n || "auto" === n) && e.defaultView) {
                var s = e.defaultView.getComputedStyle(t, null);
                n = s ? s[i] : null
            }
            return "auto" === n ? null : n
        }, getViewportOffset: function (t) {
            var i, n = 0, o = 0, r = t, a = e.body, h = e.documentElement;
            do {
                if (n += r.offsetTop || 0, o += r.offsetLeft || 0, n += parseInt(s.DomUtil.getStyle(r, "borderTopWidth"), 10) || 0, o += parseInt(s.DomUtil.getStyle(r, "borderLeftWidth"), 10) || 0, i = s.DomUtil.getStyle(r, "position"), r.offsetParent === a && "absolute" === i)break;
                if ("fixed" === i) {
                    n += a.scrollTop || h.scrollTop || 0, o += a.scrollLeft || h.scrollLeft || 0;
                    break
                }
                if ("relative" === i && !r.offsetLeft) {
                    var l = s.DomUtil.getStyle(r, "width"), u = s.DomUtil.getStyle(r, "max-width"), c = r.getBoundingClientRect();
                    ("none" !== l || "none" !== u) && (o += c.left + r.clientLeft), n += c.top + (a.scrollTop || h.scrollTop || 0);
                    break
                }
                r = r.offsetParent
            } while (r);
            r = t;
            do {
                if (r === a)break;
                n -= r.scrollTop || 0, o -= r.scrollLeft || 0, r = r.parentNode
            } while (r);
            return new s.Point(o, n)
        }, documentIsLtr: function () {
            return s.DomUtil._docIsLtrCached || (s.DomUtil._docIsLtrCached = !0, s.DomUtil._docIsLtr = "ltr" === s.DomUtil.getStyle(e.body, "direction")), s.DomUtil._docIsLtr
        }, create: function (t, i, n) {
            var s = e.createElement(t);
            return s.className = i, n && n.appendChild(s), s
        }, hasClass: function (t, e) {
            if (t.classList !== i)return t.classList.contains(e);
            var n = s.DomUtil._getClass(t);
            return n.length > 0 && new RegExp("(^|\\s)" + e + "(\\s|$)").test(n)
        }, addClass: function (t, e) {
            if (t.classList !== i)for (var n = s.Util.splitWords(e), o = 0, r = n.length; r > o; o++)t.classList.add(n[o]); else if (!s.DomUtil.hasClass(t, e)) {
                var a = s.DomUtil._getClass(t);
                s.DomUtil._setClass(t, (a ? a + " " : "") + e)
            }
        }, removeClass: function (t, e) {
            t.classList !== i ? t.classList.remove(e) : s.DomUtil._setClass(t, s.Util.trim((" " + s.DomUtil._getClass(t) + " ").replace(" " + e + " ", " ")))
        }, _setClass: function (t, e) {
            t.className.baseVal === i ? t.className = e : t.className.baseVal = e
        }, _getClass: function (t) {
            return t.className.baseVal === i ? t.className : t.className.baseVal
        }, setOpacity: function (t, e) {
            if ("opacity" in t.style) t.style.opacity = e; else if ("filter" in t.style) {
                var i = !1, n = "DXImageTransform.Microsoft.Alpha";
                try {
                    i = t.filters.item(n)
                } catch (s) {
                    if (1 === e)return
                }
                e = Math.round(100 * e), i ? (i.Enabled = 100 !== e, i.Opacity = e) : t.style.filter += " progid:" + n + "(opacity=" + e + ")"
            }
        }, testProp: function (t) {
            for (var i = e.documentElement.style, n = 0; n < t.length; n++)if (t[n] in i)return t[n];
            return !1
        }, getTranslateString: function (t) {
            var e = s.Browser.webkit3d, i = "translate" + (e ? "3d" : "") + "(", n = (e ? ",0" : "") + ")";
            return i + t.x + "px," + t.y + "px" + n
        }, getScaleString: function (t, e) {
            var i = s.DomUtil.getTranslateString(e.add(e.multiplyBy(-1 * t))), n = " scale(" + t + ") ";
            return i + n
        }, setPosition: function (t, e, i) {
            t._leaflet_pos = e, !i && s.Browser.any3d ? t.style[s.DomUtil.TRANSFORM] = s.DomUtil.getTranslateString(e) : (t.style.left = e.x + "px", t.style.top = e.y + "px")
        }, getPosition: function (t) {
            return t._leaflet_pos
        }
    }, s.DomUtil.TRANSFORM = s.DomUtil.testProp(["transform", "WebkitTransform", "OTransform", "MozTransform", "msTransform"]), s.DomUtil.TRANSITION = s.DomUtil.testProp(["webkitTransition", "transition", "OTransition", "MozTransition", "msTransition"]), s.DomUtil.TRANSITION_END = "webkitTransition" === s.DomUtil.TRANSITION || "OTransition" === s.DomUtil.TRANSITION ? s.DomUtil.TRANSITION + "End" : "transitionend", function () {
        if ("onselectstart" in e) s.extend(s.DomUtil, {
            disableTextSelection: function () {
                s.DomEvent.on(t, "selectstart", s.DomEvent.preventDefault)
            }, enableTextSelection: function () {
                s.DomEvent.off(t, "selectstart", s.DomEvent.preventDefault)
            }
        }); else {
            var i = s.DomUtil.testProp(["userSelect", "WebkitUserSelect", "OUserSelect", "MozUserSelect", "msUserSelect"]);
            s.extend(s.DomUtil, {
                disableTextSelection: function () {
                    if (i) {
                        var t = e.documentElement.style;
                        this._userSelect = t[i], t[i] = "none"
                    }
                }, enableTextSelection: function () {
                    i && (e.documentElement.style[i] = this._userSelect, delete this._userSelect)
                }
            })
        }
        s.extend(s.DomUtil, {
            disableImageDrag: function () {
                s.DomEvent.on(t, "dragstart", s.DomEvent.preventDefault)
            }, enableImageDrag: function () {
                s.DomEvent.off(t, "dragstart", s.DomEvent.preventDefault)
            }
        })
    }(), s.LatLng = function (t, e, n) {
        if (t = parseFloat(t), e = parseFloat(e), isNaN(t) || isNaN(e))throw new Error("Invalid LatLng object: (" + t + ", " + e + ")");
        this.lat = t, this.lng = e, n !== i && (this.alt = parseFloat(n))
    }, s.extend(s.LatLng, {
        DEG_TO_RAD: Math.PI / 180,
        RAD_TO_DEG: 180 / Math.PI,
        MAX_MARGIN: 1e-9
    }), s.LatLng.prototype = {
        equals: function (t) {
            if (!t)return !1;
            t = s.latLng(t);
            var e = Math.max(Math.abs(this.lat - t.lat), Math.abs(this.lng - t.lng));
            return e <= s.LatLng.MAX_MARGIN
        }, toString: function (t) {
            return "LatLng(" + s.Util.formatNum(this.lat, t) + ", " + s.Util.formatNum(this.lng, t) + ")"
        }, distanceTo: function (t) {
            t = s.latLng(t);
            var e = 6378137, i = s.LatLng.DEG_TO_RAD, n = (t.lat - this.lat) * i, o = (t.lng - this.lng) * i, r = this.lat * i, a = t.lat * i, h = Math.sin(n / 2), l = Math.sin(o / 2), u = h * h + l * l * Math.cos(r) * Math.cos(a);
            return 2 * e * Math.atan2(Math.sqrt(u), Math.sqrt(1 - u))
        }, wrap: function (t, e) {
            var i = this.lng;
            return t = t || -180, e = e || 180, i = (i + e) % (e - t) + (t > i || i === e ? e : t), new s.LatLng(this.lat, i)
        }
    }, s.latLng = function (t, e) {
        return t instanceof s.LatLng ? t : s.Util.isArray(t) ? "number" == typeof t[0] || "string" == typeof t[0] ? new s.LatLng(t[0], t[1], t[2]) : null : t === i || null === t ? t : "object" == typeof t && "lat" in t ? new s.LatLng(t.lat, "lng" in t ? t.lng : t.lon) : e === i ? null : new s.LatLng(t, e)
    }, s.LatLngBounds = function (t, e) {
        if (t)for (var i = e ? [t, e] : t, n = 0, s = i.length; s > n; n++)this.extend(i[n])
    }, s.LatLngBounds.prototype = {
        extend: function (t) {
            if (!t)return this;
            var e = s.latLng(t);
            return t = null !== e ? e : s.latLngBounds(t), t instanceof s.LatLng ? this._southWest || this._northEast ? (this._southWest.lat = Math.min(t.lat, this._southWest.lat), this._southWest.lng = Math.min(t.lng, this._southWest.lng), this._northEast.lat = Math.max(t.lat, this._northEast.lat), this._northEast.lng = Math.max(t.lng, this._northEast.lng)) : (this._southWest = new s.LatLng(t.lat, t.lng), this._northEast = new s.LatLng(t.lat, t.lng)) : t instanceof s.LatLngBounds && (this.extend(t._southWest), this.extend(t._northEast)), this
        }, pad: function (t) {
            var e = this._southWest, i = this._northEast, n = Math.abs(e.lat - i.lat) * t, o = Math.abs(e.lng - i.lng) * t;
            return new s.LatLngBounds(new s.LatLng(e.lat - n, e.lng - o), new s.LatLng(i.lat + n, i.lng + o))
        }, getCenter: function () {
            return new s.LatLng((this._southWest.lat + this._northEast.lat) / 2, (this._southWest.lng + this._northEast.lng) / 2)
        }, getSouthWest: function () {
            return this._southWest
        }, getNorthEast: function () {
            return this._northEast
        }, getNorthWest: function () {
            return new s.LatLng(this.getNorth(), this.getWest())
        }, getSouthEast: function () {
            return new s.LatLng(this.getSouth(), this.getEast())
        }, getWest: function () {
            return this._southWest.lng
        }, getSouth: function () {
            return this._southWest.lat
        }, getEast: function () {
            return this._northEast.lng
        }, getNorth: function () {
            return this._northEast.lat
        }, contains: function (t) {
            t = "number" == typeof t[0] || t instanceof s.LatLng ? s.latLng(t) : s.latLngBounds(t);
            var e, i, n = this._southWest, o = this._northEast;
            return t instanceof s.LatLngBounds ? (e = t.getSouthWest(), i = t.getNorthEast()) : e = i = t, e.lat >= n.lat && i.lat <= o.lat && e.lng >= n.lng && i.lng <= o.lng
        }, intersects: function (t) {
            t = s.latLngBounds(t);
            var e = this._southWest, i = this._northEast, n = t.getSouthWest(), o = t.getNorthEast(), r = o.lat >= e.lat && n.lat <= i.lat, a = o.lng >= e.lng && n.lng <= i.lng;
            return r && a
        }, toBBoxString: function () {
            return [this.getWest(), this.getSouth(), this.getEast(), this.getNorth()].join(",")
        }, equals: function (t) {
            return t ? (t = s.latLngBounds(t), this._southWest.equals(t.getSouthWest()) && this._northEast.equals(t.getNorthEast())) : !1
        }, isValid: function () {
            return !(!this._southWest || !this._northEast)
        }
    }, s.latLngBounds = function (t, e) {
        return !t || t instanceof s.LatLngBounds ? t : new s.LatLngBounds(t, e)
    }, s.Projection = {}, s.Projection.SphericalMercator = {
        MAX_LATITUDE: 85.0511287798,
        project: function (t) {
            var e = s.LatLng.DEG_TO_RAD, i = this.MAX_LATITUDE, n = Math.max(Math.min(i, t.lat), -i), o = t.lng * e, r = n * e;
            return r = Math.log(Math.tan(Math.PI / 4 + r / 2)), new s.Point(o, r)
        },
        unproject: function (t) {
            var e = s.LatLng.RAD_TO_DEG, i = t.x * e, n = (2 * Math.atan(Math.exp(t.y)) - Math.PI / 2) * e;
            return new s.LatLng(n, i)
        }
    }, s.Projection.LonLat = {
        project: function (t) {
            return new s.Point(t.lng, t.lat)
        }, unproject: function (t) {
            return new s.LatLng(t.y, t.x)
        }
    }, s.CRS = {
        latLngToPoint: function (t, e) {
            var i = this.projection.project(t), n = this.scale(e);
            return this.transformation._transform(i, n)
        }, pointToLatLng: function (t, e) {
            var i = this.scale(e), n = this.transformation.untransform(t, i);
            return this.projection.unproject(n)
        }, project: function (t) {
            return this.projection.project(t)
        }, scale: function (t) {
            return 256 * Math.pow(2, t)
        }, getSize: function (t) {
            var e = this.scale(t);
            return s.point(e, e)
        }
    }, s.CRS.Simple = s.extend({}, s.CRS, {
        projection: s.Projection.LonLat,
        transformation: new s.Transformation(1, 0, -1, 0),
        scale: function (t) {
            return Math.pow(2, t)
        }
    }), s.CRS.EPSG3857 = s.extend({}, s.CRS, {
        code: "EPSG:3857",
        projection: s.Projection.SphericalMercator,
        transformation: new s.Transformation(.5 / Math.PI, .5, -.5 / Math.PI, .5),
        project: function (t) {
            var e = this.projection.project(t), i = 6378137;
            return e.multiplyBy(i)
        }
    }), s.CRS.EPSG900913 = s.extend({}, s.CRS.EPSG3857, {code: "EPSG:900913"}), s.CRS.EPSG4326 = s.extend({}, s.CRS, {
        code: "EPSG:4326",
        projection: s.Projection.LonLat,
        transformation: new s.Transformation(1 / 360, .5, -1 / 360, .5)
    }), s.Map = s.Class.extend({
        includes: s.Mixin.Events,
        options: {
            crs: s.CRS.EPSG3857,
            fadeAnimation: s.DomUtil.TRANSITION && !s.Browser.android23,
            trackResize: !0,
            markerZoomAnimation: s.DomUtil.TRANSITION && s.Browser.any3d
        },
        initialize: function (t, e) {
            e = s.setOptions(this, e), this._initContainer(t), this._initLayout(), this._onResize = s.bind(this._onResize, this), this._initEvents(), e.maxBounds && this.setMaxBounds(e.maxBounds), e.center && e.zoom !== i && this.setView(s.latLng(e.center), e.zoom, {reset: !0}), this._handlers = [], this._layers = {}, this._zoomBoundLayers = {}, this._tileLayersNum = 0, this.callInitHooks(), this._addLayers(e.layers)
        },
        setView: function (t, e) {
            return e = e === i ? this.getZoom() : e, this._resetView(s.latLng(t), this._limitZoom(e)), this
        },
        setZoom: function (t, e) {
            return this._loaded ? this.setView(this.getCenter(), t, {zoom: e}) : (this._zoom = this._limitZoom(t), this)
        },
        zoomIn: function (t, e) {
            return this.setZoom(this._zoom + (t || 1), e)
        },
        zoomOut: function (t, e) {
            return this.setZoom(this._zoom - (t || 1), e)
        },
        setZoomAround: function (t, e, i) {
            var n = this.getZoomScale(e), o = this.getSize().divideBy(2), r = t instanceof s.Point ? t : this.latLngToContainerPoint(t), a = r.subtract(o).multiplyBy(1 - 1 / n), h = this.containerPointToLatLng(o.add(a));
            return this.setView(h, e, {zoom: i})
        },
        fitBounds: function (t, e) {
            e = e || {}, t = t.getBounds ? t.getBounds() : s.latLngBounds(t);
            var i = s.point(e.paddingTopLeft || e.padding || [0, 0]), n = s.point(e.paddingBottomRight || e.padding || [0, 0]), o = this.getBoundsZoom(t, !1, i.add(n)), r = n.subtract(i).divideBy(2), a = this.project(t.getSouthWest(), o), h = this.project(t.getNorthEast(), o), l = this.unproject(a.add(h).divideBy(2).add(r), o);
            return o = e && e.maxZoom ? Math.min(e.maxZoom, o) : o, this.setView(l, o, e)
        },
        fitWorld: function (t) {
            return this.fitBounds([[-90, -180], [90, 180]], t)
        },
        panTo: function (t, e) {
            return this.setView(t, this._zoom, {pan: e})
        },
        panBy: function (t) {
            return this.fire("movestart"), this._rawPanBy(s.point(t)), this.fire("move"), this.fire("moveend")
        },
        setMaxBounds: function (t) {
            return t = s.latLngBounds(t), this.options.maxBounds = t, t ? (this._loaded && this._panInsideMaxBounds(), this.on("moveend", this._panInsideMaxBounds, this)) : this.off("moveend", this._panInsideMaxBounds, this)
        },
        panInsideBounds: function (t, e) {
            var i = this.getCenter(), n = this._limitCenter(i, this._zoom, t);
            return i.equals(n) ? this : this.panTo(n, e)
        },
        addLayer: function (t) {
            var e = s.stamp(t);
            return this._layers[e] ? this : (this._layers[e] = t, !t.options || isNaN(t.options.maxZoom) && isNaN(t.options.minZoom) || (this._zoomBoundLayers[e] = t, this._updateZoomLevels()), this.options.zoomAnimation && s.TileLayer && t instanceof s.TileLayer && (this._tileLayersNum++, this._tileLayersToLoad++, t.on("load", this._onTileLayerLoad, this)), this._loaded && this._layerAdd(t), this)
        },
        removeLayer: function (t) {
            var e = s.stamp(t);
            return this._layers[e] ? (this._loaded && t.onRemove(this), delete this._layers[e], this._loaded && this.fire("layerremove", {layer: t}), this._zoomBoundLayers[e] && (delete this._zoomBoundLayers[e], this._updateZoomLevels()), this.options.zoomAnimation && s.TileLayer && t instanceof s.TileLayer && (this._tileLayersNum--, this._tileLayersToLoad--, t.off("load", this._onTileLayerLoad, this)), this) : this
        },
        hasLayer: function (t) {
            return t ? s.stamp(t) in this._layers : !1
        },
        eachLayer: function (t, e) {
            for (var i in this._layers)t.call(e, this._layers[i]);
            return this
        },
        invalidateSize: function (t) {
            if (!this._loaded)return this;
            t = s.extend({animate: !1, pan: !0}, t === !0 ? {animate: !0} : t);
            var e = this.getSize();
            this._sizeChanged = !0, this._initialCenter = null;
            var i = this.getSize(), n = e.divideBy(2).round(), o = i.divideBy(2).round(), r = n.subtract(o);
            return r.x || r.y ? (t.animate && t.pan ? this.panBy(r) : (t.pan && this._rawPanBy(r), this.fire("move"), t.debounceMoveend ? (clearTimeout(this._sizeTimer), this._sizeTimer = setTimeout(s.bind(this.fire, this, "moveend"), 200)) : this.fire("moveend")), this.fire("resize", {
                    oldSize: e,
                    newSize: i
                })) : this
        },
        addHandler: function (t, e) {
            if (!e)return this;
            var i = this[t] = new e(this);
            return this._handlers.push(i), this.options[t] && i.enable(), this
        },
        remove: function () {
            this._loaded && this.fire("unload"), this._initEvents("off");
            try {
                delete this._container._leaflet
            } catch (t) {
                this._container._leaflet = i
            }
            return this._clearPanes(), this._clearControlPos && this._clearControlPos(), this._clearHandlers(), this
        },
        getCenter: function () {
            return this._checkIfLoaded(), this._initialCenter && !this._moved() ? this._initialCenter : this.layerPointToLatLng(this._getCenterLayerPoint())
        },
        getZoom: function () {
            return this._zoom
        },
        getBounds: function () {
            var t = this.getPixelBounds(), e = this.unproject(t.getBottomLeft()), i = this.unproject(t.getTopRight());
            return new s.LatLngBounds(e, i)
        },
        getMinZoom: function () {
            return this.options.minZoom === i ? this._layersMinZoom === i ? 0 : this._layersMinZoom : this.options.minZoom
        },
        getMaxZoom: function () {
            return this.options.maxZoom === i ? this._layersMaxZoom === i ? 1 / 0 : this._layersMaxZoom : this.options.maxZoom
        },
        getBoundsZoom: function (t, e, i) {
            t = s.latLngBounds(t);
            var n, o = this.getMinZoom() - (e ? 1 : 0), r = this.getMaxZoom(), a = this.getSize(), h = t.getNorthWest(), l = t.getSouthEast(), u = !0;
            i = s.point(i || [0, 0]);
            do o++, n = this.project(l, o).subtract(this.project(h, o)).add(i), u = e ? n.x < a.x || n.y < a.y : a.contains(n); while (u && r >= o);
            return u && e ? null : e ? o : o - 1
        },
        getSize: function () {
            return (!this._size || this._sizeChanged) && (this._size = new s.Point(this._container.clientWidth, this._container.clientHeight), this._sizeChanged = !1), this._size.clone()
        },
        getPixelBounds: function () {
            var t = this._getTopLeftPoint();
            return new s.Bounds(t, t.add(this.getSize()))
        },
        getPixelOrigin: function () {
            return this._checkIfLoaded(), this._initialTopLeftPoint
        },
        getPanes: function () {
            return this._panes
        },
        getContainer: function () {
            return this._container
        },
        getZoomScale: function (t) {
            var e = this.options.crs;
            return e.scale(t) / e.scale(this._zoom)
        },
        getScaleZoom: function (t) {
            return this._zoom + Math.log(t) / Math.LN2
        },
        project: function (t, e) {
            return e = e === i ? this._zoom : e, this.options.crs.latLngToPoint(s.latLng(t), e)
        },
        unproject: function (t, e) {
            return e = e === i ? this._zoom : e, this.options.crs.pointToLatLng(s.point(t), e)
        },
        layerPointToLatLng: function (t) {
            var e = s.point(t).add(this.getPixelOrigin());
            return this.unproject(e)
        },
        latLngToLayerPoint: function (t) {
            var e = this.project(s.latLng(t))._round();
            return e._subtract(this.getPixelOrigin())
        },
        containerPointToLayerPoint: function (t) {
            return s.point(t).subtract(this._getMapPanePos())
        },
        layerPointToContainerPoint: function (t) {
            return s.point(t).add(this._getMapPanePos())
        },
        containerPointToLatLng: function (t) {
            var e = this.containerPointToLayerPoint(s.point(t));
            return this.layerPointToLatLng(e)
        },
        latLngToContainerPoint: function (t) {
            return this.layerPointToContainerPoint(this.latLngToLayerPoint(s.latLng(t)))
        },
        mouseEventToContainerPoint: function (t) {
            return s.DomEvent.getMousePosition(t, this._container)
        },
        mouseEventToLayerPoint: function (t) {
            return this.containerPointToLayerPoint(this.mouseEventToContainerPoint(t))
        },
        mouseEventToLatLng: function (t) {
            return this.layerPointToLatLng(this.mouseEventToLayerPoint(t))
        },
        _initContainer: function (t) {
            var e = this._container = s.DomUtil.get(t);
            if (!e)throw new Error("Map container not found.");
            if (e._leaflet)throw new Error("Map container is already initialized.");
            e._leaflet = !0
        },
        _initLayout: function () {
            var t = this._container;
            s.DomUtil.addClass(t, "leaflet-container" + (s.Browser.touch ? " leaflet-touch" : "") + (s.Browser.retina ? " leaflet-retina" : "") + (s.Browser.ielt9 ? " leaflet-oldie" : "") + (this.options.fadeAnimation ? " leaflet-fade-anim" : ""));
            var e = s.DomUtil.getStyle(t, "position");
            "absolute" !== e && "relative" !== e && "fixed" !== e && (t.style.position = "relative"), this._initPanes(), this._initControlPos && this._initControlPos()
        },
        _initPanes: function () {
            var t = this._panes = {};
            this._mapPane = t.mapPane = this._createPane("leaflet-map-pane", this._container), this._tilePane = t.tilePane = this._createPane("leaflet-tile-pane", this._mapPane), t.objectsPane = this._createPane("leaflet-objects-pane", this._mapPane), t.shadowPane = this._createPane("leaflet-shadow-pane"), t.overlayPane = this._createPane("leaflet-overlay-pane"), t.markerPane = this._createPane("leaflet-marker-pane"), t.popupPane = this._createPane("leaflet-popup-pane");
            var e = " leaflet-zoom-hide";
            this.options.markerZoomAnimation || (s.DomUtil.addClass(t.markerPane, e), s.DomUtil.addClass(t.shadowPane, e), s.DomUtil.addClass(t.popupPane, e))
        },
        _createPane: function (t, e) {
            return s.DomUtil.create("div", t, e || this._panes.objectsPane)
        },
        _clearPanes: function () {
            this._container.removeChild(this._mapPane)
        },
        _addLayers: function (t) {
            t = t ? s.Util.isArray(t) ? t : [t] : [];
            for (var e = 0, i = t.length; i > e; e++)this.addLayer(t[e])
        },
        _resetView: function (t, e, i, n) {
            var o = this._zoom !== e;
            n || (this.fire("movestart"), o && this.fire("zoomstart")), this._zoom = e, this._initialCenter = t, this._initialTopLeftPoint = this._getNewTopLeftPoint(t), i ? this._initialTopLeftPoint._add(this._getMapPanePos()) : s.DomUtil.setPosition(this._mapPane, new s.Point(0, 0)), this._tileLayersToLoad = this._tileLayersNum;
            var r = !this._loaded;
            this._loaded = !0, this.fire("viewreset", {hard: !i}), r && (this.fire("load"), this.eachLayer(this._layerAdd, this)), this.fire("move"), (o || n) && this.fire("zoomend"), this.fire("moveend", {hard: !i})
        },
        _rawPanBy: function (t) {
            s.DomUtil.setPosition(this._mapPane, this._getMapPanePos().subtract(t))
        },
        _getZoomSpan: function () {
            return this.getMaxZoom() - this.getMinZoom()
        },
        _updateZoomLevels: function () {
            var t, e = 1 / 0, n = -1 / 0, s = this._getZoomSpan();
            for (t in this._zoomBoundLayers) {
                var o = this._zoomBoundLayers[t];
                isNaN(o.options.minZoom) || (e = Math.min(e, o.options.minZoom)), isNaN(o.options.maxZoom) || (n = Math.max(n, o.options.maxZoom))
            }
            t === i ? this._layersMaxZoom = this._layersMinZoom = i : (this._layersMaxZoom = n, this._layersMinZoom = e), s !== this._getZoomSpan() && this.fire("zoomlevelschange")
        },
        _panInsideMaxBounds: function () {
            this.panInsideBounds(this.options.maxBounds)
        },
        _checkIfLoaded: function () {
            if (!this._loaded)throw new Error("Set map center and zoom first.")
        },
        _initEvents: function (e) {
            if (s.DomEvent) {
                e = e || "on", s.DomEvent[e](this._container, "click", this._onMouseClick, this);
                var i, n, o = ["dblclick", "mousedown", "mouseup", "mouseenter", "mouseleave", "mousemove", "contextmenu"];
                for (i = 0, n = o.length; n > i; i++)s.DomEvent[e](this._container, o[i], this._fireMouseEvent, this);
                this.options.trackResize && s.DomEvent[e](t, "resize", this._onResize, this)
            }
        },
        _onResize: function () {
            s.Util.cancelAnimFrame(this._resizeRequest), this._resizeRequest = s.Util.requestAnimFrame(function () {
                this.invalidateSize({debounceMoveend: !0})
            }, this, !1, this._container)
        },
        _onMouseClick: function (t) {
            !this._loaded || !t._simulated && (this.dragging && this.dragging.moved() || this.boxZoom && this.boxZoom.moved()) || s.DomEvent._skipped(t) || (this.fire("preclick"), this._fireMouseEvent(t))
        },
        _fireMouseEvent: function (t) {
            if (this._loaded && !s.DomEvent._skipped(t)) {
                var e = t.type;
                if (e = "mouseenter" === e ? "mouseover" : "mouseleave" === e ? "mouseout" : e, this.hasEventListeners(e)) {
                    "contextmenu" === e && s.DomEvent.preventDefault(t);
                    var i = this.mouseEventToContainerPoint(t), n = this.containerPointToLayerPoint(i), o = this.layerPointToLatLng(n);
                    this.fire(e, {
                        latlng: o,
                        layerPoint: n,
                        containerPoint: i,
                        originalEvent: t
                    })
                }
            }
        },
        _onTileLayerLoad: function () {
            this._tileLayersToLoad--, this._tileLayersNum && !this._tileLayersToLoad && this.fire("tilelayersload")
        },
        _clearHandlers: function () {
            for (var t = 0, e = this._handlers.length; e > t; t++)this._handlers[t].disable()
        },
        whenReady: function (t, e) {
            return this._loaded ? t.call(e || this, this) : this.on("load", t, e), this
        },
        _layerAdd: function (t) {
            t.onAdd(this), this.fire("layeradd", {layer: t})
        },
        _getMapPanePos: function () {
            return s.DomUtil.getPosition(this._mapPane)
        },
        _moved: function () {
            var t = this._getMapPanePos();
            return t && !t.equals([0, 0])
        },
        _getTopLeftPoint: function () {
            return this.getPixelOrigin().subtract(this._getMapPanePos())
        },
        _getNewTopLeftPoint: function (t, e) {
            var i = this.getSize()._divideBy(2);
            return this.project(t, e)._subtract(i)._round()
        },
        _latLngToNewLayerPoint: function (t, e, i) {
            var n = this._getNewTopLeftPoint(i, e).add(this._getMapPanePos());
            return this.project(t, e)._subtract(n)
        },
        _getCenterLayerPoint: function () {
            return this.containerPointToLayerPoint(this.getSize()._divideBy(2))
        },
        _getCenterOffset: function (t) {
            return this.latLngToLayerPoint(t).subtract(this._getCenterLayerPoint())
        },
        _limitCenter: function (t, e, i) {
            if (!i)return t;
            var n = this.project(t, e), o = this.getSize().divideBy(2), r = new s.Bounds(n.subtract(o), n.add(o)), a = this._getBoundsOffset(r, i, e);
            return this.unproject(n.add(a), e)
        },
        _limitOffset: function (t, e) {
            if (!e)return t;
            var i = this.getPixelBounds(), n = new s.Bounds(i.min.add(t), i.max.add(t));
            return t.add(this._getBoundsOffset(n, e))
        },
        _getBoundsOffset: function (t, e, i) {
            var n = this.project(e.getNorthWest(), i).subtract(t.min), o = this.project(e.getSouthEast(), i).subtract(t.max), r = this._rebound(n.x, -o.x), a = this._rebound(n.y, -o.y);
            return new s.Point(r, a)
        },
        _rebound: function (t, e) {
            return t + e > 0 ? Math.round(t - e) / 2 : Math.max(0, Math.ceil(t)) - Math.max(0, Math.floor(e))
        },
        _limitZoom: function (t) {
            var e = this.getMinZoom(), i = this.getMaxZoom();
            return Math.max(e, Math.min(i, t))
        }
    }), s.map = function (t, e) {
        return new s.Map(t, e)
    }, s.Projection.Mercator = {
        MAX_LATITUDE: 85.0840591556,
        R_MINOR: 6356752.314245179,
        R_MAJOR: 6378137,
        project: function (t) {
            var e = s.LatLng.DEG_TO_RAD, i = this.MAX_LATITUDE, n = Math.max(Math.min(i, t.lat), -i), o = this.R_MAJOR, r = this.R_MINOR, a = t.lng * e * o, h = n * e, l = r / o, u = Math.sqrt(1 - l * l), c = u * Math.sin(h);
            c = Math.pow((1 - c) / (1 + c), .5 * u);
            var p = Math.tan(.5 * (.5 * Math.PI - h)) / c;
            return h = -o * Math.log(p), new s.Point(a, h)
        },
        unproject: function (t) {
            for (var e, i = s.LatLng.RAD_TO_DEG, n = this.R_MAJOR, o = this.R_MINOR, r = t.x * i / n, a = o / n, h = Math.sqrt(1 - a * a), l = Math.exp(-t.y / n), u = Math.PI / 2 - 2 * Math.atan(l), c = 15, p = 1e-7, d = c, f = .1; Math.abs(f) > p && --d > 0;)e = h * Math.sin(u), f = Math.PI / 2 - 2 * Math.atan(l * Math.pow((1 - e) / (1 + e), .5 * h)) - u, u += f;
            return new s.LatLng(u * i, r)
        }
    }, s.CRS.EPSG3395 = s.extend({}, s.CRS, {
        code: "EPSG:3395",
        projection: s.Projection.Mercator,
        transformation: function () {
            var t = s.Projection.Mercator, e = t.R_MAJOR, i = .5 / (Math.PI * e);
            return new s.Transformation(i, .5, -i, .5)
        }()
    }), s.TileLayer = s.Class.extend({
        includes: s.Mixin.Events,
        options: {
            minZoom: 0,
            maxZoom: 18,
            tileSize: 256,
            subdomains: "abc",
            errorTileUrl: "",
            attribution: "",
            zoomOffset: 0,
            opacity: 1,
            unloadInvisibleTiles: s.Browser.mobile,
            updateWhenIdle: s.Browser.mobile
        },
        initialize: function (t, e) {
            e = s.setOptions(this, e), e.detectRetina && s.Browser.retina && e.maxZoom > 0 && (e.tileSize = Math.floor(e.tileSize / 2), e.zoomOffset++, e.minZoom > 0 && e.minZoom--, this.options.maxZoom--), e.bounds && (e.bounds = s.latLngBounds(e.bounds)), this._url = t;
            var i = this.options.subdomains;
            "string" == typeof i && (this.options.subdomains = i.split(""))
        },
        onAdd: function (t) {
            this._map = t, this._animated = t._zoomAnimated, this._initContainer(), t.on({
                viewreset: this._reset,
                moveend: this._update
            }, this), this._animated && t.on({
                zoomanim: this._animateZoom,
                zoomend: this._endZoomAnim
            }, this), this.options.updateWhenIdle || (this._limitedUpdate = s.Util.limitExecByInterval(this._update, 150, this), t.on("move", this._limitedUpdate, this)), this._reset(), this._update()
        },
        addTo: function (t) {
            return t.addLayer(this), this
        },
        onRemove: function (t) {
            this._container.parentNode.removeChild(this._container), t.off({
                viewreset: this._reset,
                moveend: this._update
            }, this), this._animated && t.off({
                zoomanim: this._animateZoom,
                zoomend: this._endZoomAnim
            }, this), this.options.updateWhenIdle || t.off("move", this._limitedUpdate, this), this._container = null, this._map = null
        },
        bringToFront: function () {
            var t = this._map._panes.tilePane;
            return this._container && (t.appendChild(this._container), this._setAutoZIndex(t, Math.max)), this
        },
        bringToBack: function () {
            var t = this._map._panes.tilePane;
            return this._container && (t.insertBefore(this._container, t.firstChild), this._setAutoZIndex(t, Math.min)), this
        },
        getAttribution: function () {
            return this.options.attribution
        },
        getContainer: function () {
            return this._container
        },
        setOpacity: function (t) {
            return this.options.opacity = t, this._map && this._updateOpacity(), this
        },
        setZIndex: function (t) {
            return this.options.zIndex = t, this._updateZIndex(), this
        },
        setUrl: function (t, e) {
            return this._url = t, e || this.redraw(), this
        },
        redraw: function () {
            return this._map && (this._reset({hard: !0}), this._update()), this
        },
        _updateZIndex: function () {
            this._container && this.options.zIndex !== i && (this._container.style.zIndex = this.options.zIndex)
        },
        _setAutoZIndex: function (t, e) {
            var i, n, s, o = t.children, r = -e(1 / 0, -1 / 0);
            for (n = 0, s = o.length; s > n; n++)o[n] !== this._container && (i = parseInt(o[n].style.zIndex, 10), isNaN(i) || (r = e(r, i)));
            this.options.zIndex = this._container.style.zIndex = (isFinite(r) ? r : 0) + e(1, -1)
        },
        _updateOpacity: function () {
            var t, e = this._tiles;
            if (s.Browser.ielt9)for (t in e)s.DomUtil.setOpacity(e[t], this.options.opacity); else s.DomUtil.setOpacity(this._container, this.options.opacity)
        },
        _initContainer: function () {
            var t = this._map._panes.tilePane;
            if (!this._container) {
                if (this._container = s.DomUtil.create("div", "leaflet-layer"), this._updateZIndex(), this._animated) {
                    var e = "leaflet-tile-container";
                    this._bgBuffer = s.DomUtil.create("div", e, this._container), this._tileContainer = s.DomUtil.create("div", e, this._container)
                } else this._tileContainer = this._container;
                t.appendChild(this._container), this.options.opacity < 1 && this._updateOpacity()
            }
        },
        _reset: function (t) {
            for (var e in this._tiles)this.fire("tileunload", {tile: this._tiles[e]});
            this._tiles = {}, this._tilesToLoad = 0, this.options.reuseTiles && (this._unusedTiles = []), this._tileContainer.innerHTML = "", this._animated && t && t.hard && this._clearBgBuffer(), this._initContainer()
        },
        _getTileSize: function () {
            var t = this._map, e = t.getZoom() + this.options.zoomOffset, i = this.options.maxNativeZoom, n = this.options.tileSize;
            return i && e > i && (n = Math.round(t.getZoomScale(e) / t.getZoomScale(i) * n)), n
        },
        _update: function () {
            if (this._map) {
                var t = this._map, e = t.getPixelBounds(), i = t.getZoom(), n = this._getTileSize();
                if (!(i > this.options.maxZoom || i < this.options.minZoom)) {
                    var o = s.bounds(e.min.divideBy(n)._floor(), e.max.divideBy(n)._floor());
                    this._addTilesFromCenterOut(o), (this.options.unloadInvisibleTiles || this.options.reuseTiles) && this._removeOtherTiles(o)
                }
            }
        },
        _addTilesFromCenterOut: function (t) {
            var i, n, o, r = [], a = t.getCenter();
            for (i = t.min.y; i <= t.max.y; i++)for (n = t.min.x; n <= t.max.x; n++)o = new s.Point(n, i), this._tileShouldBeLoaded(o) && r.push(o);
            var h = r.length;
            if (0 !== h) {
                r.sort(function (t, e) {
                    return t.distanceTo(a) - e.distanceTo(a)
                });
                var l = e.createDocumentFragment();
                for (this._tilesToLoad || this.fire("loading"), this._tilesToLoad += h, n = 0; h > n; n++)this._addTile(r[n], l);
                this._tileContainer.appendChild(l)
            }
        },
        _tileShouldBeLoaded: function (t) {
            if (t.x + ":" + t.y in this._tiles)return !1;
            var e = this.options;
            if (!e.continuousWorld) {
                var i = this._getWrapTileNum();
                if (e.noWrap && (t.x < 0 || t.x >= i.x) || t.y < 0 || t.y >= i.y)return !1
            }
            if (e.bounds) {
                var n = e.tileSize, s = t.multiplyBy(n), o = s.add([n, n]), r = this._map.unproject(s), a = this._map.unproject(o);
                if (e.continuousWorld || e.noWrap || (r = r.wrap(), a = a.wrap()), !e.bounds.intersects([r, a]))return !1
            }
            return !0
        },
        _removeOtherTiles: function (t) {
            var e, i, n, s;
            for (s in this._tiles)e = s.split(":"), i = parseInt(e[0], 10), n = parseInt(e[1], 10), (i < t.min.x || i > t.max.x || n < t.min.y || n > t.max.y) && this._removeTile(s)
        },
        _removeTile: function (t) {
            var e = this._tiles[t];
            this.fire("tileunload", {
                tile: e,
                url: e.src
            }), this.options.reuseTiles ? (s.DomUtil.removeClass(e, "leaflet-tile-loaded"), this._unusedTiles.push(e)) : e.parentNode === this._tileContainer && this._tileContainer.removeChild(e), s.Browser.android || (e.onload = null, e.src = s.Util.emptyImageUrl), delete this._tiles[t]
        },
        _addTile: function (t, e) {
            var i = this._getTilePos(t), n = this._getTile();
            s.DomUtil.setPosition(n, i, s.Browser.chrome), this._tiles[t.x + ":" + t.y] = n, this._loadTile(n, t), n.parentNode !== this._tileContainer && e.appendChild(n)
        },
        _getZoomForUrl: function () {
            var t = this.options, e = this._map.getZoom();
            return t.zoomReverse && (e = t.maxZoom - e), e += t.zoomOffset, t.maxNativeZoom ? Math.min(e, t.maxNativeZoom) : e
        },
        _getTilePos: function (t) {
            var e = this._map.getPixelOrigin(), i = this._getTileSize();
            return t.multiplyBy(i).subtract(e)
        },
        getTileUrl: function (t) {
            return s.Util.template(this._url, s.extend({
                s: this._getSubdomain(t),
                z: t.z,
                x: t.x,
                y: t.y
            }, this.options))
        },
        _getWrapTileNum: function () {
            var t = this._map.options.crs, e = t.getSize(this._map.getZoom());
            return e.divideBy(this._getTileSize())._floor()
        },
        _adjustTilePoint: function (t) {
            var e = this._getWrapTileNum();
            this.options.continuousWorld || this.options.noWrap || (t.x = (t.x % e.x + e.x) % e.x), this.options.tms && (t.y = e.y - t.y - 1), t.z = this._getZoomForUrl()
        },
        _getSubdomain: function (t) {
            var e = Math.abs(t.x + t.y) % this.options.subdomains.length;
            return this.options.subdomains[e]
        },
        _getTile: function () {
            if (this.options.reuseTiles && this._unusedTiles.length > 0) {
                var t = this._unusedTiles.pop();
                return this._resetTile(t), t
            }
            return this._createTile()
        },
        _resetTile: function () {
        },
        _createTile: function () {
            var t = s.DomUtil.create("img", "leaflet-tile");
            return t.style.width = t.style.height = this._getTileSize() + "px", t.galleryimg = "no", t.onselectstart = t.onmousemove = s.Util.falseFn, s.Browser.ielt9 && this.options.opacity !== i && s.DomUtil.setOpacity(t, this.options.opacity), s.Browser.mobileWebkit3d && (t.style.WebkitBackfaceVisibility = "hidden"), t
        },
        _loadTile: function (t, e) {
            t._layer = this, t.onload = this._tileOnLoad, t.onerror = this._tileOnError, this._adjustTilePoint(e), t.src = this.getTileUrl(e), this.fire("tileloadstart", {
                tile: t,
                url: t.src
            })
        },
        _tileLoaded: function () {
            this._tilesToLoad--, this._animated && s.DomUtil.addClass(this._tileContainer, "leaflet-zoom-animated"), this._tilesToLoad || (this.fire("load"), this._animated && (clearTimeout(this._clearBgBufferTimer), this._clearBgBufferTimer = setTimeout(s.bind(this._clearBgBuffer, this), 500)))
        },
        _tileOnLoad: function () {
            var t = this._layer;
            this.src !== s.Util.emptyImageUrl && (s.DomUtil.addClass(this, "leaflet-tile-loaded"), t.fire("tileload", {
                tile: this,
                url: this.src
            })), t._tileLoaded()
        },
        _tileOnError: function () {
            var t = this._layer;
            t.fire("tileerror", {tile: this, url: this.src});
            var e = t.options.errorTileUrl;
            e && (this.src = e), t._tileLoaded()
        }
    }), s.tileLayer = function (t, e) {
        return new s.TileLayer(t, e)
    }, s.TileLayer.WMS = s.TileLayer.extend({
        defaultWmsParams: {
            service: "WMS",
            request: "GetMap",
            version: "1.1.1",
            layers: "",
            styles: "",
            format: "image/jpeg",
            transparent: !1
        }, initialize: function (t, e) {
            this._url = t;
            var i = s.extend({}, this.defaultWmsParams), n = e.tileSize || this.options.tileSize;
            i.width = i.height = e.detectRetina && s.Browser.retina ? 2 * n : n;
            for (var o in e)this.options.hasOwnProperty(o) || "crs" === o || (i[o] = e[o]);
            this.wmsParams = i, s.setOptions(this, e)
        }, onAdd: function (t) {
            this._crs = this.options.crs || t.options.crs, this._wmsVersion = parseFloat(this.wmsParams.version);
            var e = this._wmsVersion >= 1.3 ? "crs" : "srs";
            this.wmsParams[e] = this._crs.code, s.TileLayer.prototype.onAdd.call(this, t)
        }, getTileUrl: function (t) {
            var e = this._map, i = this.options.tileSize, n = t.multiplyBy(i), o = n.add([i, i]), r = this._crs.project(e.unproject(n, t.z)), a = this._crs.project(e.unproject(o, t.z)), h = this._wmsVersion >= 1.3 && this._crs === s.CRS.EPSG4326 ? [a.y, r.x, r.y, a.x].join(",") : [r.x, a.y, a.x, r.y].join(","), l = s.Util.template(this._url, {s: this._getSubdomain(t)});
            return l + s.Util.getParamString(this.wmsParams, l, !0) + "&BBOX=" + h
        }, setParams: function (t, e) {
            return s.extend(this.wmsParams, t), e || this.redraw(), this
        }
    }), s.tileLayer.wms = function (t, e) {
        return new s.TileLayer.WMS(t, e)
    }, s.TileLayer.Canvas = s.TileLayer.extend({
        options: {async: !1},
        initialize: function (t) {
            s.setOptions(this, t)
        },
        redraw: function () {
            this._map && (this._reset({hard: !0}), this._update());
            for (var t in this._tiles)this._redrawTile(this._tiles[t]);
            return this
        },
        _redrawTile: function (t) {
            this.drawTile(t, t._tilePoint, this._map._zoom)
        },
        _createTile: function () {
            var t = s.DomUtil.create("canvas", "leaflet-tile");
            return t.width = t.height = this.options.tileSize, t.onselectstart = t.onmousemove = s.Util.falseFn, t
        },
        _loadTile: function (t, e) {
            t._layer = this, t._tilePoint = e, this._redrawTile(t), this.options.async || this.tileDrawn(t)
        },
        drawTile: function () {
        },
        tileDrawn: function (t) {
            this._tileOnLoad.call(t)
        }
    }), s.tileLayer.canvas = function (t) {
        return new s.TileLayer.Canvas(t)
    }, s.ImageOverlay = s.Class.extend({
        includes: s.Mixin.Events,
        options: {opacity: 1},
        initialize: function (t, e, i) {
            this._url = t, this._bounds = s.latLngBounds(e), s.setOptions(this, i)
        },
        onAdd: function (t) {
            this._map = t, this._image || this._initImage(), t._panes.overlayPane.appendChild(this._image), t.on("viewreset", this._reset, this), t.options.zoomAnimation && s.Browser.any3d && t.on("zoomanim", this._animateZoom, this), this._reset()
        },
        onRemove: function (t) {
            t.getPanes().overlayPane.removeChild(this._image), t.off("viewreset", this._reset, this), t.options.zoomAnimation && t.off("zoomanim", this._animateZoom, this)
        },
        addTo: function (t) {
            return t.addLayer(this), this
        },
        setOpacity: function (t) {
            return this.options.opacity = t, this._updateOpacity(), this
        },
        bringToFront: function () {
            return this._image && this._map._panes.overlayPane.appendChild(this._image), this
        },
        bringToBack: function () {
            var t = this._map._panes.overlayPane;
            return this._image && t.insertBefore(this._image, t.firstChild), this
        },
        setUrl: function (t) {
            this._url = t, this._image.src = this._url
        },
        getAttribution: function () {
            return this.options.attribution
        },
        _initImage: function () {
            this._image = s.DomUtil.create("img", "leaflet-image-layer"), this._map.options.zoomAnimation && s.Browser.any3d ? s.DomUtil.addClass(this._image, "leaflet-zoom-animated") : s.DomUtil.addClass(this._image, "leaflet-zoom-hide"), this._updateOpacity(), s.extend(this._image, {
                galleryimg: "no",
                onselectstart: s.Util.falseFn,
                onmousemove: s.Util.falseFn,
                onload: s.bind(this._onImageLoad, this),
                src: this._url
            })
        },
        _animateZoom: function (t) {
            var e = this._map, i = this._image, n = e.getZoomScale(t.zoom), o = this._bounds.getNorthWest(), r = this._bounds.getSouthEast(), a = e._latLngToNewLayerPoint(o, t.zoom, t.center), h = e._latLngToNewLayerPoint(r, t.zoom, t.center)._subtract(a), l = a._add(h._multiplyBy(.5 * (1 - 1 / n)));
            i.style[s.DomUtil.TRANSFORM] = s.DomUtil.getTranslateString(l) + " scale(" + n + ") "
        },
        _reset: function () {
            var t = this._image, e = this._map.latLngToLayerPoint(this._bounds.getNorthWest()), i = this._map.latLngToLayerPoint(this._bounds.getSouthEast())._subtract(e);
            s.DomUtil.setPosition(t, e), t.style.width = i.x + "px", t.style.height = i.y + "px"
        },
        _onImageLoad: function () {
            this.fire("load")
        },
        _updateOpacity: function () {
            s.DomUtil.setOpacity(this._image, this.options.opacity)
        }
    }), s.imageOverlay = function (t, e, i) {
        return new s.ImageOverlay(t, e, i)
    }, s.Icon = s.Class.extend({
        options: {className: ""}, initialize: function (t) {
            s.setOptions(this, t)
        }, createIcon: function (t) {
            return this._createIcon("icon", t)
        }, createShadow: function (t) {
            return this._createIcon("shadow", t)
        }, _createIcon: function (t, e) {
            var i = this._getIconUrl(t);
            if (!i) {
                if ("icon" === t)throw new Error("iconUrl not set in Icon options (see the docs).");
                return null
            }
            var n;
            return n = e && "IMG" === e.tagName ? this._createImg(i, e) : this._createImg(i), this._setIconStyles(n, t), n
        }, _setIconStyles: function (t, e) {
            var i, n = this.options, o = s.point(n[e + "Size"]);
            i = s.point("shadow" === e ? n.shadowAnchor || n.iconAnchor : n.iconAnchor), !i && o && (i = o.divideBy(2, !0)), t.className = "leaflet-marker-" + e + " " + n.className, i && (t.style.marginLeft = -i.x + "px", t.style.marginTop = -i.y + "px"), o && (t.style.width = o.x + "px", t.style.height = o.y + "px")
        }, _createImg: function (t, i) {
            return i = i || e.createElement("img"), i.src = t, i
        }, _getIconUrl: function (t) {
            return s.Browser.retina && this.options[t + "RetinaUrl"] ? this.options[t + "RetinaUrl"] : this.options[t + "Url"]
        }
    }), s.icon = function (t) {
        return new s.Icon(t)
    }, s.Icon.Default = s.Icon.extend({
        options: {
            iconSize: [25, 41],
            iconAnchor: [12, 41],
            popupAnchor: [1, -34],
            shadowSize: [41, 41]
        }, _getIconUrl: function (t) {
            var e = t + "Url";
            if (this.options[e])return this.options[e];
            s.Browser.retina && "icon" === t && (t += "-2x");
            var i = s.Icon.Default.imagePath;
            if (!i)throw new Error("Couldn't autodetect L.Icon.Default.imagePath, set it manually.");
            return i + "/marker-" + t + ".png"
        }
    }), s.Icon.Default.imagePath = function () {
        var t, i, n, s, o, r = e.getElementsByTagName("script"), a = /[\/^]leaflet[\-\._]?([\w\-\._]*)\.js\??/;
        for (t = 0, i = r.length; i > t; t++)if (n = r[t].src, s = n.match(a))return o = n.split(a)[0], (o ? o + "/" : "") + "images"
    }(), s.Marker = s.Class.extend({
        includes: s.Mixin.Events,
        options: {
            icon: new s.Icon.Default,
            title: "",
            alt: "",
            clickable: !0,
            draggable: !1,
            keyboard: !0,
            zIndexOffset: 0,
            opacity: 1,
            riseOnHover: !1,
            riseOffset: 250
        },
        initialize: function (t, e) {
            s.setOptions(this, e), this._latlng = s.latLng(t)
        },
        onAdd: function (t) {
            this._map = t, t.on("viewreset", this.update, this), this._initIcon(), this.update(), this.fire("add"), t.options.zoomAnimation && t.options.markerZoomAnimation && t.on("zoomanim", this._animateZoom, this)
        },
        addTo: function (t) {
            return t.addLayer(this), this
        },
        onRemove: function (t) {
            this.dragging && this.dragging.disable(), this._removeIcon(), this._removeShadow(), this.fire("remove"), t.off({
                viewreset: this.update,
                zoomanim: this._animateZoom
            }, this), this._map = null
        },
        getLatLng: function () {
            return this._latlng
        },
        setLatLng: function (t) {
            return this._latlng = s.latLng(t), this.update(), this.fire("move", {latlng: this._latlng})
        },
        setZIndexOffset: function (t) {
            return this.options.zIndexOffset = t, this.update(), this
        },
        setIcon: function (t) {
            return this.options.icon = t, this._map && (this._initIcon(), this.update()), this._popup && this.bindPopup(this._popup), this
        },
        update: function () {
            if (this._icon) {
                var t = this._map.latLngToLayerPoint(this._latlng).round();
                this._setPos(t)
            }
            return this
        },
        _initIcon: function () {
            var t = this.options, e = this._map, i = e.options.zoomAnimation && e.options.markerZoomAnimation, n = i ? "leaflet-zoom-animated" : "leaflet-zoom-hide", o = t.icon.createIcon(this._icon), r = !1;
            o !== this._icon && (this._icon && this._removeIcon(), r = !0, t.title && (o.title = t.title), t.alt && (o.alt = t.alt)), s.DomUtil.addClass(o, n), t.keyboard && (o.tabIndex = "0"), this._icon = o, this._initInteraction(), t.riseOnHover && s.DomEvent.on(o, "mouseover", this._bringToFront, this).on(o, "mouseout", this._resetZIndex, this);
            var a = t.icon.createShadow(this._shadow), h = !1;
            a !== this._shadow && (this._removeShadow(), h = !0), a && s.DomUtil.addClass(a, n), this._shadow = a, t.opacity < 1 && this._updateOpacity();
            var l = this._map._panes;
            r && l.markerPane.appendChild(this._icon), a && h && l.shadowPane.appendChild(this._shadow)
        },
        _removeIcon: function () {
            this.options.riseOnHover && s.DomEvent.off(this._icon, "mouseover", this._bringToFront).off(this._icon, "mouseout", this._resetZIndex), this._map._panes.markerPane.removeChild(this._icon), this._icon = null
        },
        _removeShadow: function () {
            this._shadow && this._map._panes.shadowPane.removeChild(this._shadow), this._shadow = null
        },
        _setPos: function (t) {
            s.DomUtil.setPosition(this._icon, t), this._shadow && s.DomUtil.setPosition(this._shadow, t), this._zIndex = t.y + this.options.zIndexOffset, this._resetZIndex()
        },
        _updateZIndex: function (t) {
            this._icon.style.zIndex = this._zIndex + t
        },
        _animateZoom: function (t) {
            var e = this._map._latLngToNewLayerPoint(this._latlng, t.zoom, t.center).round();
            this._setPos(e)
        },
        _initInteraction: function () {
            if (this.options.clickable) {
                var t = this._icon, e = ["dblclick", "mousedown", "mouseover", "mouseout", "contextmenu"];
                s.DomUtil.addClass(t, "leaflet-clickable"), s.DomEvent.on(t, "click", this._onMouseClick, this), s.DomEvent.on(t, "keypress", this._onKeyPress, this);
                for (var i = 0; i < e.length; i++)s.DomEvent.on(t, e[i], this._fireMouseEvent, this);
                s.Handler.MarkerDrag && (this.dragging = new s.Handler.MarkerDrag(this), this.options.draggable && this.dragging.enable())
            }
        },
        _onMouseClick: function (t) {
            var e = this.dragging && this.dragging.moved();
            (this.hasEventListeners(t.type) || e) && s.DomEvent.stopPropagation(t), e || (this.dragging && this.dragging._enabled || !this._map.dragging || !this._map.dragging.moved()) && this.fire(t.type, {
                originalEvent: t,
                latlng: this._latlng
            })
        },
        _onKeyPress: function (t) {
            13 === t.keyCode && this.fire("click", {
                originalEvent: t,
                latlng: this._latlng
            })
        },
        _fireMouseEvent: function (t) {
            this.fire(t.type, {
                originalEvent: t,
                latlng: this._latlng
            }), "contextmenu" === t.type && this.hasEventListeners(t.type) && s.DomEvent.preventDefault(t), "mousedown" !== t.type ? s.DomEvent.stopPropagation(t) : s.DomEvent.preventDefault(t)
        },
        setOpacity: function (t) {
            return this.options.opacity = t, this._map && this._updateOpacity(), this
        },
        _updateOpacity: function () {
            s.DomUtil.setOpacity(this._icon, this.options.opacity), this._shadow && s.DomUtil.setOpacity(this._shadow, this.options.opacity)
        },
        _bringToFront: function () {
            this._updateZIndex(this.options.riseOffset)
        },
        _resetZIndex: function () {
            this._updateZIndex(0)
        }
    }), s.marker = function (t, e) {
        return new s.Marker(t, e)
    }, s.DivIcon = s.Icon.extend({
        options: {
            iconSize: [12, 12],
            className: "leaflet-div-icon",
            html: !1
        }, createIcon: function (t) {
            var i = t && "DIV" === t.tagName ? t : e.createElement("div"), n = this.options;
            return i.innerHTML = n.html !== !1 ? n.html : "", n.bgPos && (i.style.backgroundPosition = -n.bgPos.x + "px " + -n.bgPos.y + "px"), this._setIconStyles(i, "icon"), i
        }, createShadow: function () {
            return null
        }
    }), s.divIcon = function (t) {
        return new s.DivIcon(t)
    }, s.Map.mergeOptions({closePopupOnClick: !0}), s.Popup = s.Class.extend({
        includes: s.Mixin.Events,
        options: {
            minWidth: 50,
            maxWidth: 300,
            autoPan: !0,
            closeButton: !0,
            offset: [0, 7],
            autoPanPadding: [5, 5],
            keepInView: !1,
            className: "",
            zoomAnimation: !0
        },
        initialize: function (t, e) {
            s.setOptions(this, t), this._source = e, this._animated = s.Browser.any3d && this.options.zoomAnimation, this._isOpen = !1
        },
        onAdd: function (t) {
            this._map = t, this._container || this._initLayout();
            var e = t.options.fadeAnimation;
            e && s.DomUtil.setOpacity(this._container, 0), t._panes.popupPane.appendChild(this._container), t.on(this._getEvents(), this), this.update(), e && s.DomUtil.setOpacity(this._container, 1), this.fire("open"), t.fire("popupopen", {popup: this}), this._source && this._source.fire("popupopen", {popup: this})
        },
        addTo: function (t) {
            return t.addLayer(this), this
        },
        openOn: function (t) {
            return t.openPopup(this), this
        },
        onRemove: function (t) {
            t._panes.popupPane.removeChild(this._container), s.Util.falseFn(this._container.offsetWidth), t.off(this._getEvents(), this), t.options.fadeAnimation && s.DomUtil.setOpacity(this._container, 0), this._map = null, this.fire("close"), t.fire("popupclose", {popup: this}), this._source && this._source.fire("popupclose", {popup: this})
        },
        getLatLng: function () {
            return this._latlng
        },
        setLatLng: function (t) {
            return this._latlng = s.latLng(t), this._map && (this._updatePosition(), this._adjustPan()), this
        },
        getContent: function () {
            return this._content
        },
        setContent: function (t) {
            return this._content = t, this.update(), this
        },
        update: function () {
            this._map && (this._container.style.visibility = "hidden", this._updateContent(), this._updateLayout(), this._updatePosition(), this._container.style.visibility = "", this._adjustPan())
        },
        _getEvents: function () {
            var t = {viewreset: this._updatePosition};
            return this._animated && (t.zoomanim = this._zoomAnimation), ("closeOnClick" in this.options ? this.options.closeOnClick : this._map.options.closePopupOnClick) && (t.preclick = this._close), this.options.keepInView && (t.moveend = this._adjustPan), t
        },
        _close: function () {
            this._map && this._map.closePopup(this)
        },
        _initLayout: function () {
            var t, e = "leaflet-popup", i = e + " " + this.options.className + " leaflet-zoom-" + (this._animated ? "animated" : "hide"), n = this._container = s.DomUtil.create("div", i);
            this.options.closeButton && (t = this._closeButton = s.DomUtil.create("a", e + "-close-button", n), t.href = "#close", t.innerHTML = "&#215;", s.DomEvent.disableClickPropagation(t), s.DomEvent.on(t, "click", this._onCloseButtonClick, this));
            var o = this._wrapper = s.DomUtil.create("div", e + "-content-wrapper", n);
            s.DomEvent.disableClickPropagation(o), this._contentNode = s.DomUtil.create("div", e + "-content", o), s.DomEvent.disableScrollPropagation(this._contentNode), s.DomEvent.on(o, "contextmenu", s.DomEvent.stopPropagation), this._tipContainer = s.DomUtil.create("div", e + "-tip-container", n), this._tip = s.DomUtil.create("div", e + "-tip", this._tipContainer)
        },
        _updateContent: function () {
            if (this._content) {
                if ("string" == typeof this._content) this._contentNode.innerHTML = this._content; else {
                    for (; this._contentNode.hasChildNodes();)this._contentNode.removeChild(this._contentNode.firstChild);
                    this._contentNode.appendChild(this._content)
                }
                this.fire("contentupdate")
            }
        },
        _updateLayout: function () {
            var t = this._contentNode, e = t.style;
            e.width = "", e.whiteSpace = "nowrap";
            var i = t.offsetWidth;
            i = Math.min(i, this.options.maxWidth), i = Math.max(i, this.options.minWidth), e.width = i + 1 + "px", e.whiteSpace = "", e.height = "";
            var n = t.offsetHeight, o = this.options.maxHeight, r = "leaflet-popup-scrolled";
            o && n > o ? (e.height = o + "px", s.DomUtil.addClass(t, r)) : s.DomUtil.removeClass(t, r), this._containerWidth = this._container.offsetWidth
        },
        _updatePosition: function () {
            if (this._map) {
                var t = this._map.latLngToLayerPoint(this._latlng), e = this._animated, i = s.point(this.options.offset);
                e && s.DomUtil.setPosition(this._container, t), this._containerBottom = -i.y - (e ? 0 : t.y), this._containerLeft = -Math.round(this._containerWidth / 2) + i.x + (e ? 0 : t.x), this._container.style.bottom = this._containerBottom + "px", this._container.style.left = this._containerLeft + "px"
            }
        },
        _zoomAnimation: function (t) {
            var e = this._map._latLngToNewLayerPoint(this._latlng, t.zoom, t.center);
            s.DomUtil.setPosition(this._container, e)
        },
        _adjustPan: function () {
            if (this.options.autoPan) {
                var t = this._map, e = this._container.offsetHeight, i = this._containerWidth, n = new s.Point(this._containerLeft, -e - this._containerBottom);
                this._animated && n._add(s.DomUtil.getPosition(this._container));
                var o = t.layerPointToContainerPoint(n), r = s.point(this.options.autoPanPadding), a = s.point(this.options.autoPanPaddingTopLeft || r), h = s.point(this.options.autoPanPaddingBottomRight || r), l = t.getSize(), u = 0, c = 0;
                o.x + i + h.x > l.x && (u = o.x + i - l.x + h.x), o.x - u - a.x < 0 && (u = o.x - a.x), o.y + e + h.y > l.y && (c = o.y + e - l.y + h.y), o.y - c - a.y < 0 && (c = o.y - a.y), (u || c) && t.fire("autopanstart").panBy([u, c])
            }
        },
        _onCloseButtonClick: function (t) {
            this._close(), s.DomEvent.stop(t)
        }
    }), s.popup = function (t, e) {
        return new s.Popup(t, e)
    }, s.Map.include({
        openPopup: function (t, e, i) {
            if (this.closePopup(), !(t instanceof s.Popup)) {
                var n = t;
                t = new s.Popup(i).setLatLng(e).setContent(n)
            }
            return t._isOpen = !0, this._popup = t, this.addLayer(t)
        }, closePopup: function (t) {
            return t && t !== this._popup || (t = this._popup, this._popup = null), t && (this.removeLayer(t), t._isOpen = !1), this
        }
    }), s.Marker.include({
        openPopup: function () {
            return this._popup && this._map && !this._map.hasLayer(this._popup) && (this._popup.setLatLng(this._latlng), this._map.openPopup(this._popup)), this
        }, closePopup: function () {
            return this._popup && this._popup._close(), this
        }, togglePopup: function () {
            return this._popup && (this._popup._isOpen ? this.closePopup() : this.openPopup()), this
        }, bindPopup: function (t, e) {
            var i = s.point(this.options.icon.options.popupAnchor || [0, 0]);
            return i = i.add(s.Popup.prototype.options.offset), e && e.offset && (i = i.add(e.offset)), e = s.extend({offset: i}, e), this._popupHandlersAdded || (this.on("click", this.togglePopup, this).on("remove", this.closePopup, this).on("move", this._movePopup, this), this._popupHandlersAdded = !0), t instanceof s.Popup ? (s.setOptions(t, e), this._popup = t) : this._popup = new s.Popup(e, this).setContent(t), this
        }, setPopupContent: function (t) {
            return this._popup && this._popup.setContent(t), this
        }, unbindPopup: function () {
            return this._popup && (this._popup = null, this.off("click", this.togglePopup, this).off("remove", this.closePopup, this).off("move", this._movePopup, this), this._popupHandlersAdded = !1), this
        }, getPopup: function () {
            return this._popup
        }, _movePopup: function (t) {
            this._popup.setLatLng(t.latlng)
        }
    }), s.LayerGroup = s.Class.extend({
        initialize: function (t) {
            this._layers = {};
            var e, i;
            if (t)for (e = 0, i = t.length; i > e; e++)this.addLayer(t[e])
        }, addLayer: function (t) {
            var e = this.getLayerId(t);
            return this._layers[e] = t, this._map && this._map.addLayer(t), this
        }, removeLayer: function (t) {
            var e = t in this._layers ? t : this.getLayerId(t);
            return this._map && this._layers[e] && this._map.removeLayer(this._layers[e]), delete this._layers[e], this
        }, hasLayer: function (t) {
            return t ? t in this._layers || this.getLayerId(t) in this._layers : !1
        }, clearLayers: function () {
            return this.eachLayer(this.removeLayer, this), this
        }, invoke: function (t) {
            var e, i, n = Array.prototype.slice.call(arguments, 1);
            for (e in this._layers)i = this._layers[e], i[t] && i[t].apply(i, n);
            return this
        }, onAdd: function (t) {
            this._map = t, this.eachLayer(t.addLayer, t)
        }, onRemove: function (t) {
            this.eachLayer(t.removeLayer, t), this._map = null
        }, addTo: function (t) {
            return t.addLayer(this), this
        }, eachLayer: function (t, e) {
            for (var i in this._layers)t.call(e, this._layers[i]);
            return this
        }, getLayer: function (t) {
            return this._layers[t]
        }, getLayers: function () {
            var t = [];
            for (var e in this._layers)t.push(this._layers[e]);
            return t
        }, setZIndex: function (t) {
            return this.invoke("setZIndex", t)
        }, getLayerId: function (t) {
            return s.stamp(t)
        }
    }), s.layerGroup = function (t) {
        return new s.LayerGroup(t)
    }, s.FeatureGroup = s.LayerGroup.extend({
        includes: s.Mixin.Events,
        statics: {EVENTS: "click dblclick mouseover mouseout mousemove contextmenu popupopen popupclose"},
        addLayer: function (t) {
            return this.hasLayer(t) ? this : ("on" in t && t.on(s.FeatureGroup.EVENTS, this._propagateEvent, this), s.LayerGroup.prototype.addLayer.call(this, t), this._popupContent && t.bindPopup && t.bindPopup(this._popupContent, this._popupOptions), this.fire("layeradd", {layer: t}))
        },
        removeLayer: function (t) {
            return this.hasLayer(t) ? (t in this._layers && (t = this._layers[t]), t.off(s.FeatureGroup.EVENTS, this._propagateEvent, this), s.LayerGroup.prototype.removeLayer.call(this, t), this._popupContent && this.invoke("unbindPopup"), this.fire("layerremove", {layer: t})) : this
        },
        bindPopup: function (t, e) {
            return this._popupContent = t, this._popupOptions = e, this.invoke("bindPopup", t, e)
        },
        openPopup: function (t) {
            for (var e in this._layers) {
                this._layers[e].openPopup(t);
                break
            }
            return this
        },
        setStyle: function (t) {
            return this.invoke("setStyle", t)
        },
        bringToFront: function () {
            return this.invoke("bringToFront")
        },
        bringToBack: function () {
            return this.invoke("bringToBack")
        },
        getBounds: function () {
            var t = new s.LatLngBounds;
            return this.eachLayer(function (e) {
                t.extend(e instanceof s.Marker ? e.getLatLng() : e.getBounds())
            }), t
        },
        _propagateEvent: function (t) {
            t = s.extend({layer: t.target, target: this}, t), this.fire(t.type, t)
        }
    }), s.featureGroup = function (t) {
        return new s.FeatureGroup(t)
    }, s.Path = s.Class.extend({
        includes: [s.Mixin.Events],
        statics: {
            CLIP_PADDING: function () {
                var e = s.Browser.mobile ? 1280 : 2e3, i = (e / Math.max(t.outerWidth, t.outerHeight) - 1) / 2;
                return Math.max(0, Math.min(.5, i))
            }()
        },
        options: {
            stroke: !0,
            color: "#0033ff",
            dashArray: null,
            lineCap: null,
            lineJoin: null,
            weight: 5,
            opacity: .5,
            fill: !1,
            fillColor: null,
            fillOpacity: .2,
            clickable: !0
        },
        initialize: function (t) {
            s.setOptions(this, t)
        },
        onAdd: function (t) {
            this._map = t, this._container || (this._initElements(), this._initEvents()), this.projectLatlngs(), this._updatePath(), this._container && this._map._pathRoot.appendChild(this._container), this.fire("add"), t.on({
                viewreset: this.projectLatlngs,
                moveend: this._updatePath
            }, this)
        },
        addTo: function (t) {
            return t.addLayer(this), this
        },
        onRemove: function (t) {
            t._pathRoot.removeChild(this._container), this.fire("remove"), this._map = null, s.Browser.vml && (this._container = null, this._stroke = null, this._fill = null), t.off({
                viewreset: this.projectLatlngs,
                moveend: this._updatePath
            }, this)
        },
        projectLatlngs: function () {
        },
        setStyle: function (t) {
            return s.setOptions(this, t), this._container && this._updateStyle(), this
        },
        redraw: function () {
            return this._map && (this.projectLatlngs(), this._updatePath()), this
        }
    }), s.Map.include({
        _updatePathViewport: function () {
            var t = s.Path.CLIP_PADDING, e = this.getSize(), i = s.DomUtil.getPosition(this._mapPane), n = i.multiplyBy(-1)._subtract(e.multiplyBy(t)._round()), o = n.add(e.multiplyBy(1 + 2 * t)._round());
            this._pathViewport = new s.Bounds(n, o)
        }
    }), s.Path.SVG_NS = "http://www.w3.org/2000/svg", s.Browser.svg = !(!e.createElementNS || !e.createElementNS(s.Path.SVG_NS, "svg").createSVGRect), s.Path = s.Path.extend({
        statics: {SVG: s.Browser.svg},
        bringToFront: function () {
            var t = this._map._pathRoot, e = this._container;
            return e && t.lastChild !== e && t.appendChild(e), this
        },
        bringToBack: function () {
            var t = this._map._pathRoot, e = this._container, i = t.firstChild;
            return e && i !== e && t.insertBefore(e, i), this
        },
        getPathString: function () {
        },
        _createElement: function (t) {
            return e.createElementNS(s.Path.SVG_NS, t)
        },
        _initElements: function () {
            this._map._initPathRoot(), this._initPath(), this._initStyle()
        },
        _initPath: function () {
            this._container = this._createElement("g"), this._path = this._createElement("path"), this.options.className && s.DomUtil.addClass(this._path, this.options.className), this._container.appendChild(this._path)
        },
        _initStyle: function () {
            this.options.stroke && (this._path.setAttribute("stroke-linejoin", "round"), this._path.setAttribute("stroke-linecap", "round")), this.options.fill && this._path.setAttribute("fill-rule", "evenodd"), this.options.pointerEvents && this._path.setAttribute("pointer-events", this.options.pointerEvents), this.options.clickable || this.options.pointerEvents || this._path.setAttribute("pointer-events", "none"), this._updateStyle()
        },
        _updateStyle: function () {
            this.options.stroke ? (this._path.setAttribute("stroke", this.options.color), this._path.setAttribute("stroke-opacity", this.options.opacity), this._path.setAttribute("stroke-width", this.options.weight), this.options.dashArray ? this._path.setAttribute("stroke-dasharray", this.options.dashArray) : this._path.removeAttribute("stroke-dasharray"), this.options.lineCap && this._path.setAttribute("stroke-linecap", this.options.lineCap), this.options.lineJoin && this._path.setAttribute("stroke-linejoin", this.options.lineJoin)) : this._path.setAttribute("stroke", "none"), this.options.fill ? (this._path.setAttribute("fill", this.options.fillColor || this.options.color), this._path.setAttribute("fill-opacity", this.options.fillOpacity)) : this._path.setAttribute("fill", "none")
        },
        _updatePath: function () {
            var t = this.getPathString();
            t || (t = "M0 0"), this._path.setAttribute("d", t)
        },
        _initEvents: function () {
            if (this.options.clickable) {
                (s.Browser.svg || !s.Browser.vml) && s.DomUtil.addClass(this._path, "leaflet-clickable"), s.DomEvent.on(this._container, "click", this._onMouseClick, this);
                for (var t = ["dblclick", "mousedown", "mouseover", "mouseout", "mousemove", "contextmenu"], e = 0; e < t.length; e++)s.DomEvent.on(this._container, t[e], this._fireMouseEvent, this)
            }
        },
        _onMouseClick: function (t) {
            this._map.dragging && this._map.dragging.moved() || this._fireMouseEvent(t)
        },
        _fireMouseEvent: function (t) {
            if (this.hasEventListeners(t.type)) {
                var e = this._map, i = e.mouseEventToContainerPoint(t), n = e.containerPointToLayerPoint(i), o = e.layerPointToLatLng(n);
                this.fire(t.type, {
                    latlng: o,
                    layerPoint: n,
                    containerPoint: i,
                    originalEvent: t
                }), "contextmenu" === t.type && s.DomEvent.preventDefault(t), "mousemove" !== t.type && s.DomEvent.stopPropagation(t)
            }
        }
    }), s.Map.include({
        _initPathRoot: function () {
            this._pathRoot || (this._pathRoot = s.Path.prototype._createElement("svg"), this._panes.overlayPane.appendChild(this._pathRoot), this.options.zoomAnimation && s.Browser.any3d ? (s.DomUtil.addClass(this._pathRoot, "leaflet-zoom-animated"), this.on({
                    zoomanim: this._animatePathZoom,
                    zoomend: this._endPathZoom
                })) : s.DomUtil.addClass(this._pathRoot, "leaflet-zoom-hide"), this.on("moveend", this._updateSvgViewport), this._updateSvgViewport())
        }, _animatePathZoom: function (t) {
            var e = this.getZoomScale(t.zoom), i = this._getCenterOffset(t.center)._multiplyBy(-e)._add(this._pathViewport.min);
            this._pathRoot.style[s.DomUtil.TRANSFORM] = s.DomUtil.getTranslateString(i) + " scale(" + e + ") ", this._pathZooming = !0
        }, _endPathZoom: function () {
            this._pathZooming = !1
        }, _updateSvgViewport: function () {
            if (!this._pathZooming) {
                this._updatePathViewport();
                var t = this._pathViewport, e = t.min, i = t.max, n = i.x - e.x, o = i.y - e.y, r = this._pathRoot, a = this._panes.overlayPane;
                s.Browser.mobileWebkit && a.removeChild(r), s.DomUtil.setPosition(r, e), r.setAttribute("width", n), r.setAttribute("height", o), r.setAttribute("viewBox", [e.x, e.y, n, o].join(" ")), s.Browser.mobileWebkit && a.appendChild(r)
            }
        }
    }), s.Path.include({
        bindPopup: function (t, e) {
            return t instanceof s.Popup ? this._popup = t : ((!this._popup || e) && (this._popup = new s.Popup(e, this)), this._popup.setContent(t)), this._popupHandlersAdded || (this.on("click", this._openPopup, this).on("remove", this.closePopup, this), this._popupHandlersAdded = !0), this
        }, unbindPopup: function () {
            return this._popup && (this._popup = null, this.off("click", this._openPopup).off("remove", this.closePopup), this._popupHandlersAdded = !1), this
        }, openPopup: function (t) {
            return this._popup && (t = t || this._latlng || this._latlngs[Math.floor(this._latlngs.length / 2)], this._openPopup({latlng: t})), this
        }, closePopup: function () {
            return this._popup && this._popup._close(), this
        }, _openPopup: function (t) {
            this._popup.setLatLng(t.latlng), this._map.openPopup(this._popup)
        }
    }), s.Browser.vml = !s.Browser.svg && function () {
            try {
                var t = e.createElement("div");
                t.innerHTML = '<v:shape adj="1"/>';
                var i = t.firstChild;
                return i.style.behavior = "url(#default#VML)", i && "object" == typeof i.adj
            } catch (n) {
                return !1
            }
        }(), s.Path = s.Browser.svg || !s.Browser.vml ? s.Path : s.Path.extend({
            statics: {
                VML: !0,
                CLIP_PADDING: .02
            }, _createElement: function () {
                try {
                    return e.namespaces.add("lvml", "urn:schemas-microsoft-com:vml"), function (t) {
                        return e.createElement("<lvml:" + t + ' class="lvml">')
                    }
                } catch (t) {
                    return function (t) {
                        return e.createElement("<" + t + ' xmlns="urn:schemas-microsoft.com:vml" class="lvml">')
                    }
                }
            }(), _initPath: function () {
                var t = this._container = this._createElement("shape");
                s.DomUtil.addClass(t, "leaflet-vml-shape" + (this.options.className ? " " + this.options.className : "")), this.options.clickable && s.DomUtil.addClass(t, "leaflet-clickable"), t.coordsize = "1 1", this._path = this._createElement("path"), t.appendChild(this._path), this._map._pathRoot.appendChild(t)
            }, _initStyle: function () {
                this._updateStyle()
            }, _updateStyle: function () {
                var t = this._stroke, e = this._fill, i = this.options, n = this._container;
                n.stroked = i.stroke, n.filled = i.fill, i.stroke ? (t || (t = this._stroke = this._createElement("stroke"), t.endcap = "round", n.appendChild(t)), t.weight = i.weight + "px", t.color = i.color, t.opacity = i.opacity, t.dashStyle = i.dashArray ? s.Util.isArray(i.dashArray) ? i.dashArray.join(" ") : i.dashArray.replace(/( *, *)/g, " ") : "", i.lineCap && (t.endcap = i.lineCap.replace("butt", "flat")), i.lineJoin && (t.joinstyle = i.lineJoin)) : t && (n.removeChild(t), this._stroke = null), i.fill ? (e || (e = this._fill = this._createElement("fill"), n.appendChild(e)), e.color = i.fillColor || i.color, e.opacity = i.fillOpacity) : e && (n.removeChild(e), this._fill = null)
            }, _updatePath: function () {
                var t = this._container.style;
                t.display = "none", this._path.v = this.getPathString() + " ", t.display = ""
            }
        }), s.Map.include(s.Browser.svg || !s.Browser.vml ? {} : {
            _initPathRoot: function () {
                if (!this._pathRoot) {
                    var t = this._pathRoot = e.createElement("div");
                    t.className = "leaflet-vml-container", this._panes.overlayPane.appendChild(t), this.on("moveend", this._updatePathViewport), this._updatePathViewport()
                }
            }
        }), s.Browser.canvas = function () {
        return !!e.createElement("canvas").getContext
    }(), s.Path = s.Path.SVG && !t.L_PREFER_CANVAS || !s.Browser.canvas ? s.Path : s.Path.extend({
            statics: {
                CANVAS: !0,
                SVG: !1
            }, redraw: function () {
                return this._map && (this.projectLatlngs(), this._requestUpdate()), this
            }, setStyle: function (t) {
                return s.setOptions(this, t), this._map && (this._updateStyle(), this._requestUpdate()), this
            }, onRemove: function (t) {
                t.off("viewreset", this.projectLatlngs, this).off("moveend", this._updatePath, this), this.options.clickable && (this._map.off("click", this._onClick, this), this._map.off("mousemove", this._onMouseMove, this)), this._requestUpdate(), this.fire("remove"), this._map = null
            }, _requestUpdate: function () {
                this._map && !s.Path._updateRequest && (s.Path._updateRequest = s.Util.requestAnimFrame(this._fireMapMoveEnd, this._map))
            }, _fireMapMoveEnd: function () {
                s.Path._updateRequest = null, this.fire("moveend")
            }, _initElements: function () {
                this._map._initPathRoot(), this._ctx = this._map._canvasCtx
            }, _updateStyle: function () {
                var t = this.options;
                t.stroke && (this._ctx.lineWidth = t.weight, this._ctx.strokeStyle = t.color), t.fill && (this._ctx.fillStyle = t.fillColor || t.color)
            }, _drawPath: function () {
                var t, e, i, n, o, r;
                for (this._ctx.beginPath(), t = 0, i = this._parts.length; i > t; t++) {
                    for (e = 0, n = this._parts[t].length; n > e; e++)o = this._parts[t][e], r = (0 === e ? "move" : "line") + "To", this._ctx[r](o.x, o.y);
                    this instanceof s.Polygon && this._ctx.closePath()
                }
            }, _checkIfEmpty: function () {
                return !this._parts.length
            }, _updatePath: function () {
                if (!this._checkIfEmpty()) {
                    var t = this._ctx, e = this.options;
                    this._drawPath(), t.save(), this._updateStyle(), e.fill && (t.globalAlpha = e.fillOpacity, t.fill()), e.stroke && (t.globalAlpha = e.opacity, t.stroke()), t.restore()
                }
            }, _initEvents: function () {
                this.options.clickable && (this._map.on("mousemove", this._onMouseMove, this), this._map.on("click", this._onClick, this))
            }, _onClick: function (t) {
                this._containsPoint(t.layerPoint) && this.fire("click", t)
            }, _onMouseMove: function (t) {
                this._map && !this._map._animatingZoom && (this._containsPoint(t.layerPoint) ? (this._ctx.canvas.style.cursor = "pointer", this._mouseInside = !0, this.fire("mouseover", t)) : this._mouseInside && (this._ctx.canvas.style.cursor = "", this._mouseInside = !1, this.fire("mouseout", t)))
            }
        }), s.Map.include(s.Path.SVG && !t.L_PREFER_CANVAS || !s.Browser.canvas ? {} : {
            _initPathRoot: function () {
                var t, i = this._pathRoot;
                i || (i = this._pathRoot = e.createElement("canvas"), i.style.position = "absolute", t = this._canvasCtx = i.getContext("2d"), t.lineCap = "round", t.lineJoin = "round", this._panes.overlayPane.appendChild(i), this.options.zoomAnimation && (this._pathRoot.className = "leaflet-zoom-animated", this.on("zoomanim", this._animatePathZoom), this.on("zoomend", this._endPathZoom)), this.on("moveend", this._updateCanvasViewport), this._updateCanvasViewport())
            }, _updateCanvasViewport: function () {
                if (!this._pathZooming) {
                    this._updatePathViewport();
                    var t = this._pathViewport, e = t.min, i = t.max.subtract(e), n = this._pathRoot;
                    s.DomUtil.setPosition(n, e), n.width = i.x, n.height = i.y, n.getContext("2d").translate(-e.x, -e.y)
                }
            }
        }), s.LineUtil = {
        simplify: function (t, e) {
            if (!e || !t.length)return t.slice();
            var i = e * e;
            return t = this._reducePoints(t, i), t = this._simplifyDP(t, i)
        }, pointToSegmentDistance: function (t, e, i) {
            return Math.sqrt(this._sqClosestPointOnSegment(t, e, i, !0))
        }, closestPointOnSegment: function (t, e, i) {
            return this._sqClosestPointOnSegment(t, e, i)
        }, _simplifyDP: function (t, e) {
            var n = t.length, s = typeof Uint8Array != i + "" ? Uint8Array : Array, o = new s(n);
            o[0] = o[n - 1] = 1, this._simplifyDPStep(t, o, e, 0, n - 1);
            var r, a = [];
            for (r = 0; n > r; r++)o[r] && a.push(t[r]);
            return a
        }, _simplifyDPStep: function (t, e, i, n, s) {
            var o, r, a, h = 0;
            for (r = n + 1; s - 1 >= r; r++)a = this._sqClosestPointOnSegment(t[r], t[n], t[s], !0), a > h && (o = r, h = a);
            h > i && (e[o] = 1, this._simplifyDPStep(t, e, i, n, o), this._simplifyDPStep(t, e, i, o, s))
        }, _reducePoints: function (t, e) {
            for (var i = [t[0]], n = 1, s = 0, o = t.length; o > n; n++)this._sqDist(t[n], t[s]) > e && (i.push(t[n]), s = n);
            return o - 1 > s && i.push(t[o - 1]), i
        }, clipSegment: function (t, e, i, n) {
            var s, o, r, a = n ? this._lastCode : this._getBitCode(t, i), h = this._getBitCode(e, i);
            for (this._lastCode = h; ;) {
                if (!(a | h))return [t, e];
                if (a & h)return !1;
                s = a || h, o = this._getEdgeIntersection(t, e, s, i), r = this._getBitCode(o, i), s === a ? (t = o, a = r) : (e = o, h = r)
            }
        }, _getEdgeIntersection: function (t, e, i, n) {
            var o = e.x - t.x, r = e.y - t.y, a = n.min, h = n.max;
            return 8 & i ? new s.Point(t.x + o * (h.y - t.y) / r, h.y) : 4 & i ? new s.Point(t.x + o * (a.y - t.y) / r, a.y) : 2 & i ? new s.Point(h.x, t.y + r * (h.x - t.x) / o) : 1 & i ? new s.Point(a.x, t.y + r * (a.x - t.x) / o) : void 0
        }, _getBitCode: function (t, e) {
            var i = 0;
            return t.x < e.min.x ? i |= 1 : t.x > e.max.x && (i |= 2), t.y < e.min.y ? i |= 4 : t.y > e.max.y && (i |= 8), i
        }, _sqDist: function (t, e) {
            var i = e.x - t.x, n = e.y - t.y;
            return i * i + n * n
        }, _sqClosestPointOnSegment: function (t, e, i, n) {
            var o, r = e.x, a = e.y, h = i.x - r, l = i.y - a, u = h * h + l * l;
            return u > 0 && (o = ((t.x - r) * h + (t.y - a) * l) / u, o > 1 ? (r = i.x, a = i.y) : o > 0 && (r += h * o, a += l * o)), h = t.x - r, l = t.y - a, n ? h * h + l * l : new s.Point(r, a)
        }
    }, s.Polyline = s.Path.extend({
        initialize: function (t, e) {
            s.Path.prototype.initialize.call(this, e), this._latlngs = this._convertLatLngs(t)
        }, options: {smoothFactor: 1, noClip: !1}, projectLatlngs: function () {
            this._originalPoints = [];
            for (var t = 0, e = this._latlngs.length; e > t; t++)this._originalPoints[t] = this._map.latLngToLayerPoint(this._latlngs[t])
        }, getPathString: function () {
            for (var t = 0, e = this._parts.length, i = ""; e > t; t++)i += this._getPathPartStr(this._parts[t]);
            return i
        }, getLatLngs: function () {
            return this._latlngs
        }, setLatLngs: function (t) {
            return this._latlngs = this._convertLatLngs(t), this.redraw()
        }, addLatLng: function (t) {
            return this._latlngs.push(s.latLng(t)), this.redraw()
        }, spliceLatLngs: function () {
            var t = [].splice.apply(this._latlngs, arguments);
            return this._convertLatLngs(this._latlngs, !0), this.redraw(), t
        }, closestLayerPoint: function (t) {
            for (var e, i, n = 1 / 0, o = this._parts, r = null, a = 0, h = o.length; h > a; a++)for (var l = o[a], u = 1, c = l.length; c > u; u++) {
                e = l[u - 1], i = l[u];
                var p = s.LineUtil._sqClosestPointOnSegment(t, e, i, !0);
                n > p && (n = p, r = s.LineUtil._sqClosestPointOnSegment(t, e, i))
            }
            return r && (r.distance = Math.sqrt(n)), r
        }, getBounds: function () {
            return new s.LatLngBounds(this.getLatLngs())
        }, _convertLatLngs: function (t, e) {
            var i, n, o = e ? t : [];
            for (i = 0, n = t.length; n > i; i++) {
                if (s.Util.isArray(t[i]) && "number" != typeof t[i][0])return;
                o[i] = s.latLng(t[i])
            }
            return o
        }, _initEvents: function () {
            s.Path.prototype._initEvents.call(this)
        }, _getPathPartStr: function (t) {
            for (var e, i = s.Path.VML, n = 0, o = t.length, r = ""; o > n; n++)e = t[n], i && e._round(), r += (n ? "L" : "M") + e.x + " " + e.y;
            return r
        }, _clipPoints: function () {
            var t, e, i, n = this._originalPoints, o = n.length;
            if (this.options.noClip)return void(this._parts = [n]);
            this._parts = [];
            var r = this._parts, a = this._map._pathViewport, h = s.LineUtil;
            for (t = 0, e = 0; o - 1 > t; t++)i = h.clipSegment(n[t], n[t + 1], a, t), i && (r[e] = r[e] || [], r[e].push(i[0]), (i[1] !== n[t + 1] || t === o - 2) && (r[e].push(i[1]), e++))
        }, _simplifyPoints: function () {
            for (var t = this._parts, e = s.LineUtil, i = 0, n = t.length; n > i; i++)t[i] = e.simplify(t[i], this.options.smoothFactor)
        }, _updatePath: function () {
            this._map && (this._clipPoints(), this._simplifyPoints(), s.Path.prototype._updatePath.call(this))
        }
    }), s.polyline = function (t, e) {
        return new s.Polyline(t, e)
    }, s.PolyUtil = {}, s.PolyUtil.clipPolygon = function (t, e) {
        var i, n, o, r, a, h, l, u, c, p = [1, 4, 2, 8], d = s.LineUtil;
        for (n = 0, l = t.length; l > n; n++)t[n]._code = d._getBitCode(t[n], e);
        for (r = 0; 4 > r; r++) {
            for (u = p[r], i = [], n = 0, l = t.length, o = l - 1; l > n; o = n++)a = t[n], h = t[o], a._code & u ? h._code & u || (c = d._getEdgeIntersection(h, a, u, e), c._code = d._getBitCode(c, e), i.push(c)) : (h._code & u && (c = d._getEdgeIntersection(h, a, u, e), c._code = d._getBitCode(c, e), i.push(c)), i.push(a));
            t = i
        }
        return t
    }, s.Polygon = s.Polyline.extend({
        options: {fill: !0}, initialize: function (t, e) {
            s.Polyline.prototype.initialize.call(this, t, e), this._initWithHoles(t)
        }, _initWithHoles: function (t) {
            var e, i, n;
            if (t && s.Util.isArray(t[0]) && "number" != typeof t[0][0])for (this._latlngs = this._convertLatLngs(t[0]), this._holes = t.slice(1), e = 0, i = this._holes.length; i > e; e++)n = this._holes[e] = this._convertLatLngs(this._holes[e]), n[0].equals(n[n.length - 1]) && n.pop();
            t = this._latlngs, t.length >= 2 && t[0].equals(t[t.length - 1]) && t.pop()
        }, projectLatlngs: function () {
            if (s.Polyline.prototype.projectLatlngs.call(this), this._holePoints = [], this._holes) {
                var t, e, i, n;
                for (t = 0, i = this._holes.length; i > t; t++)for (this._holePoints[t] = [], e = 0, n = this._holes[t].length; n > e; e++)this._holePoints[t][e] = this._map.latLngToLayerPoint(this._holes[t][e])
            }
        }, setLatLngs: function (t) {
            return t && s.Util.isArray(t[0]) && "number" != typeof t[0][0] ? (this._initWithHoles(t), this.redraw()) : s.Polyline.prototype.setLatLngs.call(this, t)
        }, _clipPoints: function () {
            var t = this._originalPoints, e = [];
            if (this._parts = [t].concat(this._holePoints), !this.options.noClip) {
                for (var i = 0, n = this._parts.length; n > i; i++) {
                    var o = s.PolyUtil.clipPolygon(this._parts[i], this._map._pathViewport);
                    o.length && e.push(o)
                }
                this._parts = e
            }
        }, _getPathPartStr: function (t) {
            var e = s.Polyline.prototype._getPathPartStr.call(this, t);
            return e + (s.Browser.svg ? "z" : "x")
        }
    }), s.polygon = function (t, e) {
        return new s.Polygon(t, e)
    }, function () {
        function t(t) {
            return s.FeatureGroup.extend({
                initialize: function (t, e) {
                    this._layers = {}, this._options = e, this.setLatLngs(t)
                }, setLatLngs: function (e) {
                    var i = 0, n = e.length;
                    for (this.eachLayer(function (t) {
                        n > i ? t.setLatLngs(e[i++]) : this.removeLayer(t)
                    }, this); n > i;)this.addLayer(new t(e[i++], this._options));
                    return this
                }, getLatLngs: function () {
                    var t = [];
                    return this.eachLayer(function (e) {
                        t.push(e.getLatLngs())
                    }), t
                }
            })
        }

        s.MultiPolyline = t(s.Polyline), s.MultiPolygon = t(s.Polygon), s.multiPolyline = function (t, e) {
            return new s.MultiPolyline(t, e)
        }, s.multiPolygon = function (t, e) {
            return new s.MultiPolygon(t, e)
        }
    }(), s.Rectangle = s.Polygon.extend({
        initialize: function (t, e) {
            s.Polygon.prototype.initialize.call(this, this._boundsToLatLngs(t), e)
        }, setBounds: function (t) {
            this.setLatLngs(this._boundsToLatLngs(t))
        }, _boundsToLatLngs: function (t) {
            return t = s.latLngBounds(t), [t.getSouthWest(), t.getNorthWest(), t.getNorthEast(), t.getSouthEast()]
        }
    }), s.rectangle = function (t, e) {
        return new s.Rectangle(t, e)
    }, s.Circle = s.Path.extend({
        initialize: function (t, e, i) {
            s.Path.prototype.initialize.call(this, i), this._latlng = s.latLng(t), this._mRadius = e
        }, options: {fill: !0}, setLatLng: function (t) {
            return this._latlng = s.latLng(t), this.redraw()
        }, setRadius: function (t) {
            return this._mRadius = t, this.redraw()
        }, projectLatlngs: function () {
            var t = this._getLngRadius(), e = this._latlng, i = this._map.latLngToLayerPoint([e.lat, e.lng - t]);
            this._point = this._map.latLngToLayerPoint(e), this._radius = Math.max(this._point.x - i.x, 1)
        }, getBounds: function () {
            var t = this._getLngRadius(), e = this._mRadius / 40075017 * 360, i = this._latlng;
            return new s.LatLngBounds([i.lat - e, i.lng - t], [i.lat + e, i.lng + t])
        }, getLatLng: function () {
            return this._latlng
        }, getPathString: function () {
            var t = this._point, e = this._radius;
            return this._checkIfEmpty() ? "" : s.Browser.svg ? "M" + t.x + "," + (t.y - e) + "A" + e + "," + e + ",0,1,1," + (t.x - .1) + "," + (t.y - e) + " z" : (t._round(), e = Math.round(e), "AL " + t.x + "," + t.y + " " + e + "," + e + " 0,23592600")
        }, getRadius: function () {
            return this._mRadius
        }, _getLatRadius: function () {
            return this._mRadius / 40075017 * 360
        }, _getLngRadius: function () {
            return this._getLatRadius() / Math.cos(s.LatLng.DEG_TO_RAD * this._latlng.lat)
        }, _checkIfEmpty: function () {
            if (!this._map)return !1;
            var t = this._map._pathViewport, e = this._radius, i = this._point;
            return i.x - e > t.max.x || i.y - e > t.max.y || i.x + e < t.min.x || i.y + e < t.min.y
        }
    }), s.circle = function (t, e, i) {
        return new s.Circle(t, e, i)
    }, s.CircleMarker = s.Circle.extend({
        options: {radius: 10, weight: 2},
        initialize: function (t, e) {
            s.Circle.prototype.initialize.call(this, t, null, e), this._radius = this.options.radius
        },
        projectLatlngs: function () {
            this._point = this._map.latLngToLayerPoint(this._latlng)
        },
        _updateStyle: function () {
            s.Circle.prototype._updateStyle.call(this), this.setRadius(this.options.radius)
        },
        setLatLng: function (t) {
            return s.Circle.prototype.setLatLng.call(this, t), this._popup && this._popup._isOpen && this._popup.setLatLng(t), this
        },
        setRadius: function (t) {
            return this.options.radius = this._radius = t, this.redraw()
        },
        getRadius: function () {
            return this._radius
        }
    }), s.circleMarker = function (t, e) {
        return new s.CircleMarker(t, e)
    }, s.Polyline.include(s.Path.CANVAS ? {
            _containsPoint: function (t, e) {
                var i, n, o, r, a, h, l, u = this.options.weight / 2;
                for (s.Browser.touch && (u += 10), i = 0, r = this._parts.length; r > i; i++)for (l = this._parts[i], n = 0, a = l.length, o = a - 1; a > n; o = n++)if ((e || 0 !== n) && (h = s.LineUtil.pointToSegmentDistance(t, l[o], l[n]), u >= h))return !0;
                return !1
            }
        } : {}), s.Polygon.include(s.Path.CANVAS ? {
            _containsPoint: function (t) {
                var e, i, n, o, r, a, h, l, u = !1;
                if (s.Polyline.prototype._containsPoint.call(this, t, !0))return !0;
                for (o = 0, h = this._parts.length; h > o; o++)for (e = this._parts[o], r = 0, l = e.length, a = l - 1; l > r; a = r++)i = e[r], n = e[a], i.y > t.y != n.y > t.y && t.x < (n.x - i.x) * (t.y - i.y) / (n.y - i.y) + i.x && (u = !u);
                return u
            }
        } : {}), s.Circle.include(s.Path.CANVAS ? {
            _drawPath: function () {
                var t = this._point;
                this._ctx.beginPath(), this._ctx.arc(t.x, t.y, this._radius, 0, 2 * Math.PI, !1)
            }, _containsPoint: function (t) {
                var e = this._point, i = this.options.stroke ? this.options.weight / 2 : 0;
                return t.distanceTo(e) <= this._radius + i
            }
        } : {}), s.CircleMarker.include(s.Path.CANVAS ? {
            _updateStyle: function () {
                s.Path.prototype._updateStyle.call(this)
            }
        } : {}), s.GeoJSON = s.FeatureGroup.extend({
        initialize: function (t, e) {
            s.setOptions(this, e), this._layers = {}, t && this.addData(t)
        }, addData: function (t) {
            var e, i, n, o = s.Util.isArray(t) ? t : t.features;
            if (o) {
                for (e = 0, i = o.length; i > e; e++)n = o[e], (n.geometries || n.geometry || n.features || n.coordinates) && this.addData(o[e]);
                return this
            }
            var r = this.options;
            if (!r.filter || r.filter(t)) {
                var a = s.GeoJSON.geometryToLayer(t, r.pointToLayer, r.coordsToLatLng, r);
                return a.feature = s.GeoJSON.asFeature(t), a.defaultOptions = a.options, this.resetStyle(a), r.onEachFeature && r.onEachFeature(t, a), this.addLayer(a)
            }
        }, resetStyle: function (t) {
            var e = this.options.style;
            e && (s.Util.extend(t.options, t.defaultOptions), this._setLayerStyle(t, e))
        }, setStyle: function (t) {
            this.eachLayer(function (e) {
                this._setLayerStyle(e, t)
            }, this)
        }, _setLayerStyle: function (t, e) {
            "function" == typeof e && (e = e(t.feature)), t.setStyle && t.setStyle(e)
        }
    }), s.extend(s.GeoJSON, {
        geometryToLayer: function (t, e, i, n) {
            var o, r, a, h, l = "Feature" === t.type ? t.geometry : t, u = l.coordinates, c = [];
            switch (i = i || this.coordsToLatLng, l.type) {
                case"Point":
                    return o = i(u), e ? e(t, o) : new s.Marker(o);
                case"MultiPoint":
                    for (a = 0, h = u.length; h > a; a++)o = i(u[a]), c.push(e ? e(t, o) : new s.Marker(o));
                    return new s.FeatureGroup(c);
                case"LineString":
                    return r = this.coordsToLatLngs(u, 0, i), new s.Polyline(r, n);
                case"Polygon":
                    if (2 === u.length && !u[1].length)throw new Error("Invalid GeoJSON object.");
                    return r = this.coordsToLatLngs(u, 1, i), new s.Polygon(r, n);
                case"MultiLineString":
                    return r = this.coordsToLatLngs(u, 1, i), new s.MultiPolyline(r, n);
                case"MultiPolygon":
                    return r = this.coordsToLatLngs(u, 2, i), new s.MultiPolygon(r, n);
                case"GeometryCollection":
                    for (a = 0, h = l.geometries.length; h > a; a++)c.push(this.geometryToLayer({
                        geometry: l.geometries[a],
                        type: "Feature",
                        properties: t.properties
                    }, e, i, n));
                    return new s.FeatureGroup(c);
                default:
                    throw new Error("Invalid GeoJSON object.")
            }
        }, coordsToLatLng: function (t) {
            return new s.LatLng(t[1], t[0], t[2])
        }, coordsToLatLngs: function (t, e, i) {
            var n, s, o, r = [];
            for (s = 0, o = t.length; o > s; s++)n = e ? this.coordsToLatLngs(t[s], e - 1, i) : (i || this.coordsToLatLng)(t[s]), r.push(n);
            return r
        }, latLngToCoords: function (t) {
            var e = [t.lng, t.lat];
            return t.alt !== i && e.push(t.alt), e
        }, latLngsToCoords: function (t) {
            for (var e = [], i = 0, n = t.length; n > i; i++)e.push(s.GeoJSON.latLngToCoords(t[i]));
            return e
        }, getFeature: function (t, e) {
            return t.feature ? s.extend({}, t.feature, {geometry: e}) : s.GeoJSON.asFeature(e)
        }, asFeature: function (t) {
            return "Feature" === t.type ? t : {
                    type: "Feature",
                    properties: {},
                    geometry: t
                }
        }
    });
    var r = {
        toGeoJSON: function () {
            return s.GeoJSON.getFeature(this, {
                type: "Point",
                coordinates: s.GeoJSON.latLngToCoords(this.getLatLng())
            })
        }
    };
    s.Marker.include(r), s.Circle.include(r), s.CircleMarker.include(r), s.Polyline.include({
        toGeoJSON: function () {
            return s.GeoJSON.getFeature(this, {
                type: "LineString",
                coordinates: s.GeoJSON.latLngsToCoords(this.getLatLngs())
            })
        }
    }), s.Polygon.include({
        toGeoJSON: function () {
            var t, e, i, n = [s.GeoJSON.latLngsToCoords(this.getLatLngs())];
            if (n[0].push(n[0][0]), this._holes)for (t = 0, e = this._holes.length; e > t; t++)i = s.GeoJSON.latLngsToCoords(this._holes[t]), i.push(i[0]), n.push(i);
            return s.GeoJSON.getFeature(this, {type: "Polygon", coordinates: n})
        }
    }), function () {
        function t(t) {
            return function () {
                var e = [];
                return this.eachLayer(function (t) {
                    e.push(t.toGeoJSON().geometry.coordinates)
                }), s.GeoJSON.getFeature(this, {type: t, coordinates: e})
            }
        }

        s.MultiPolyline.include({toGeoJSON: t("MultiLineString")}), s.MultiPolygon.include({toGeoJSON: t("MultiPolygon")}), s.LayerGroup.include({
            toGeoJSON: function () {
                var e, i = this.feature && this.feature.geometry, n = [];
                if (i && "MultiPoint" === i.type)return t("MultiPoint").call(this);
                var o = i && "GeometryCollection" === i.type;
                return this.eachLayer(function (t) {
                    t.toGeoJSON && (e = t.toGeoJSON(), n.push(o ? e.geometry : s.GeoJSON.asFeature(e)))
                }), o ? s.GeoJSON.getFeature(this, {
                        geometries: n,
                        type: "GeometryCollection"
                    }) : {type: "FeatureCollection", features: n}
            }
        })
    }(), s.geoJson = function (t, e) {
        return new s.GeoJSON(t, e)
    }, s.DomEvent = {
        addListener: function (t, e, i, n) {
            var o, r, a, h = s.stamp(i), l = "_leaflet_" + e + h;
            return t[l] ? this : (o = function (e) {
                    return i.call(n || t, e || s.DomEvent._getEvent())
                }, s.Browser.pointer && 0 === e.indexOf("touch") ? this.addPointerListener(t, e, o, h) : (s.Browser.touch && "dblclick" === e && this.addDoubleTapListener && this.addDoubleTapListener(t, o, h), "addEventListener" in t ? "mousewheel" === e ? (t.addEventListener("DOMMouseScroll", o, !1), t.addEventListener(e, o, !1)) : "mouseenter" === e || "mouseleave" === e ? (r = o, a = "mouseenter" === e ? "mouseover" : "mouseout", o = function (e) {
                                    return s.DomEvent._checkMouse(t, e) ? r(e) : void 0
                                }, t.addEventListener(a, o, !1)) : "click" === e && s.Browser.android ? (r = o, o = function (t) {
                                        return s.DomEvent._filterClick(t, r)
                                    }, t.addEventListener(e, o, !1)) : t.addEventListener(e, o, !1) : "attachEvent" in t && t.attachEvent("on" + e, o), t[l] = o, this))
        }, removeListener: function (t, e, i) {
            var n = s.stamp(i), o = "_leaflet_" + e + n, r = t[o];
            return r ? (s.Browser.pointer && 0 === e.indexOf("touch") ? this.removePointerListener(t, e, n) : s.Browser.touch && "dblclick" === e && this.removeDoubleTapListener ? this.removeDoubleTapListener(t, n) : "removeEventListener" in t ? "mousewheel" === e ? (t.removeEventListener("DOMMouseScroll", r, !1), t.removeEventListener(e, r, !1)) : "mouseenter" === e || "mouseleave" === e ? t.removeEventListener("mouseenter" === e ? "mouseover" : "mouseout", r, !1) : t.removeEventListener(e, r, !1) : "detachEvent" in t && t.detachEvent("on" + e, r), t[o] = null, this) : this
        }, stopPropagation: function (t) {
            return t.stopPropagation ? t.stopPropagation() : t.cancelBubble = !0, s.DomEvent._skipped(t), this
        }, disableScrollPropagation: function (t) {
            var e = s.DomEvent.stopPropagation;
            return s.DomEvent.on(t, "mousewheel", e).on(t, "MozMousePixelScroll", e)
        }, disableClickPropagation: function (t) {
            for (var e = s.DomEvent.stopPropagation, i = s.Draggable.START.length - 1; i >= 0; i--)s.DomEvent.on(t, s.Draggable.START[i], e);
            return s.DomEvent.on(t, "click", s.DomEvent._fakeStop).on(t, "dblclick", e)
        }, preventDefault: function (t) {
            return t.preventDefault ? t.preventDefault() : t.returnValue = !1, this
        }, stop: function (t) {
            return s.DomEvent.preventDefault(t).stopPropagation(t)
        }, getMousePosition: function (t, e) {
            if (!e)return new s.Point(t.clientX, t.clientY);
            var i = e.getBoundingClientRect();
            return new s.Point(t.clientX - i.left - e.clientLeft, t.clientY - i.top - e.clientTop)
        }, getWheelDelta: function (t) {
            var e = 0;
            return t.wheelDelta && (e = t.wheelDelta / 120), t.detail && (e = -t.detail / 3), e
        }, _skipEvents: {}, _fakeStop: function (t) {
            s.DomEvent._skipEvents[t.type] = !0
        }, _skipped: function (t) {
            var e = this._skipEvents[t.type];
            return this._skipEvents[t.type] = !1, e
        }, _checkMouse: function (t, e) {
            var i = e.relatedTarget;
            if (!i)return !0;
            try {
                for (; i && i !== t;)i = i.parentNode
            } catch (n) {
                return !1
            }
            return i !== t
        }, _getEvent: function () {
            var e = t.event;
            if (!e)for (var i = arguments.callee.caller; i && (e = i.arguments[0], !e || t.Event !== e.constructor);)i = i.caller;
            return e
        }, _filterClick: function (t, e) {
            var i = t.timeStamp || t.originalEvent.timeStamp, n = s.DomEvent._lastClick && i - s.DomEvent._lastClick;
            return n && n > 100 && 500 > n || t.target._simulatedClick && !t._simulated ? void s.DomEvent.stop(t) : (s.DomEvent._lastClick = i, e(t))
        }
    }, s.DomEvent.on = s.DomEvent.addListener, s.DomEvent.off = s.DomEvent.removeListener, s.Draggable = s.Class.extend({
        includes: s.Mixin.Events,
        statics: {
            START: s.Browser.touch ? ["touchstart", "mousedown"] : ["mousedown"],
            END: {
                mousedown: "mouseup",
                touchstart: "touchend",
                pointerdown: "touchend",
                MSPointerDown: "touchend"
            },
            MOVE: {
                mousedown: "mousemove",
                touchstart: "touchmove",
                pointerdown: "touchmove",
                MSPointerDown: "touchmove"
            }
        },
        initialize: function (t, e) {
            this._element = t, this._dragStartTarget = e || t
        },
        enable: function () {
            if (!this._enabled) {
                for (var t = s.Draggable.START.length - 1; t >= 0; t--)s.DomEvent.on(this._dragStartTarget, s.Draggable.START[t], this._onDown, this);
                this._enabled = !0
            }
        },
        disable: function () {
            if (this._enabled) {
                for (var t = s.Draggable.START.length - 1; t >= 0; t--)s.DomEvent.off(this._dragStartTarget, s.Draggable.START[t], this._onDown, this);
                this._enabled = !1, this._moved = !1
            }
        },
        _onDown: function (t) {
            if (this._moved = !1, !(t.shiftKey || 1 !== t.which && 1 !== t.button && !t.touches || (s.DomEvent.stopPropagation(t), s.Draggable._disabled || (s.DomUtil.disableImageDrag(), s.DomUtil.disableTextSelection(), this._moving)))) {
                var i = t.touches ? t.touches[0] : t;
                this._startPoint = new s.Point(i.clientX, i.clientY), this._startPos = this._newPos = s.DomUtil.getPosition(this._element), s.DomEvent.on(e, s.Draggable.MOVE[t.type], this._onMove, this).on(e, s.Draggable.END[t.type], this._onUp, this)
            }
        },
        _onMove: function (t) {
            if (t.touches && t.touches.length > 1)return void(this._moved = !0);
            var i = t.touches && 1 === t.touches.length ? t.touches[0] : t, n = new s.Point(i.clientX, i.clientY), o = n.subtract(this._startPoint);
            (o.x || o.y) && (s.Browser.touch && Math.abs(o.x) + Math.abs(o.y) < 3 || (s.DomEvent.preventDefault(t), this._moved || (this.fire("dragstart"), this._moved = !0, this._startPos = s.DomUtil.getPosition(this._element).subtract(o), s.DomUtil.addClass(e.body, "leaflet-dragging"), this._lastTarget = t.target || t.srcElement, s.DomUtil.addClass(this._lastTarget, "leaflet-drag-target")), this._newPos = this._startPos.add(o), this._moving = !0, s.Util.cancelAnimFrame(this._animRequest), this._animRequest = s.Util.requestAnimFrame(this._updatePosition, this, !0, this._dragStartTarget)))
        },
        _updatePosition: function () {
            this.fire("predrag"), s.DomUtil.setPosition(this._element, this._newPos), this.fire("drag")
        },
        _onUp: function () {
            s.DomUtil.removeClass(e.body, "leaflet-dragging"), this._lastTarget && (s.DomUtil.removeClass(this._lastTarget, "leaflet-drag-target"), this._lastTarget = null);
            for (var t in s.Draggable.MOVE)s.DomEvent.off(e, s.Draggable.MOVE[t], this._onMove).off(e, s.Draggable.END[t], this._onUp);
            s.DomUtil.enableImageDrag(), s.DomUtil.enableTextSelection(), this._moved && this._moving && (s.Util.cancelAnimFrame(this._animRequest), this.fire("dragend", {distance: this._newPos.distanceTo(this._startPos)})), this._moving = !1
        }
    }), s.Handler = s.Class.extend({
        initialize: function (t) {
            this._map = t
        }, enable: function () {
            this._enabled || (this._enabled = !0, this.addHooks())
        }, disable: function () {
            this._enabled && (this._enabled = !1, this.removeHooks())
        }, enabled: function () {
            return !!this._enabled
        }
    }), s.Map.mergeOptions({
        dragging: !0,
        inertia: !s.Browser.android23,
        inertiaDeceleration: 3400,
        inertiaMaxSpeed: 1 / 0,
        inertiaThreshold: s.Browser.touch ? 32 : 18,
        easeLinearity: .25,
        worldCopyJump: !1
    }), s.Map.Drag = s.Handler.extend({
        addHooks: function () {
            if (!this._draggable) {
                var t = this._map;
                this._draggable = new s.Draggable(t._mapPane, t._container), this._draggable.on({
                    dragstart: this._onDragStart,
                    drag: this._onDrag,
                    dragend: this._onDragEnd
                }, this), t.options.worldCopyJump && (this._draggable.on("predrag", this._onPreDrag, this), t.on("viewreset", this._onViewReset, this), t.whenReady(this._onViewReset, this))
            }
            this._draggable.enable()
        }, removeHooks: function () {
            this._draggable.disable()
        }, moved: function () {
            return this._draggable && this._draggable._moved
        }, _onDragStart: function () {
            var t = this._map;
            t._panAnim && t._panAnim.stop(), t.fire("movestart").fire("dragstart"), t.options.inertia && (this._positions = [], this._times = [])
        }, _onDrag: function () {
            if (this._map.options.inertia) {
                var t = this._lastTime = +new Date, e = this._lastPos = this._draggable._newPos;
                this._positions.push(e), this._times.push(t), t - this._times[0] > 200 && (this._positions.shift(), this._times.shift())
            }
            this._map.fire("move").fire("drag")
        }, _onViewReset: function () {
            var t = this._map.getSize()._divideBy(2), e = this._map.latLngToLayerPoint([0, 0]);
            this._initialWorldOffset = e.subtract(t).x, this._worldWidth = this._map.project([0, 180]).x
        }, _onPreDrag: function () {
            var t = this._worldWidth, e = Math.round(t / 2), i = this._initialWorldOffset, n = this._draggable._newPos.x, s = (n - e + i) % t + e - i, o = (n + e + i) % t - e - i, r = Math.abs(s + i) < Math.abs(o + i) ? s : o;
            this._draggable._newPos.x = r
        }, _onDragEnd: function (t) {
            var e = this._map, i = e.options, n = +new Date - this._lastTime, o = !i.inertia || n > i.inertiaThreshold || !this._positions[0];
            if (e.fire("dragend", t), o) e.fire("moveend"); else {
                var r = this._lastPos.subtract(this._positions[0]), a = (this._lastTime + n - this._times[0]) / 1e3, h = i.easeLinearity, l = r.multiplyBy(h / a), u = l.distanceTo([0, 0]), c = Math.min(i.inertiaMaxSpeed, u), p = l.multiplyBy(c / u), d = c / (i.inertiaDeceleration * h), f = p.multiplyBy(-d / 2).round();
                f.x && f.y ? (f = e._limitOffset(f, e.options.maxBounds), s.Util.requestAnimFrame(function () {
                        e.panBy(f, {duration: d, easeLinearity: h, noMoveStart: !0})
                    })) : e.fire("moveend")
            }
        }
    }), s.Map.addInitHook("addHandler", "dragging", s.Map.Drag), s.Map.mergeOptions({doubleClickZoom: !0}), s.Map.DoubleClickZoom = s.Handler.extend({
        addHooks: function () {
            this._map.on("dblclick", this._onDoubleClick, this)
        }, removeHooks: function () {
            this._map.off("dblclick", this._onDoubleClick, this)
        }, _onDoubleClick: function (t) {
            var e = this._map, i = e.getZoom() + (t.originalEvent.shiftKey ? -1 : 1);
            "center" === e.options.doubleClickZoom ? e.setZoom(i) : e.setZoomAround(t.containerPoint, i)
        }
    }), s.Map.addInitHook("addHandler", "doubleClickZoom", s.Map.DoubleClickZoom), s.Map.mergeOptions({scrollWheelZoom: !0}), s.Map.ScrollWheelZoom = s.Handler.extend({
        addHooks: function () {
            s.DomEvent.on(this._map._container, "mousewheel", this._onWheelScroll, this), s.DomEvent.on(this._map._container, "MozMousePixelScroll", s.DomEvent.preventDefault), this._delta = 0
        }, removeHooks: function () {
            s.DomEvent.off(this._map._container, "mousewheel", this._onWheelScroll), s.DomEvent.off(this._map._container, "MozMousePixelScroll", s.DomEvent.preventDefault)
        }, _onWheelScroll: function (t) {
            var e = s.DomEvent.getWheelDelta(t);
            this._delta += e, this._lastMousePos = this._map.mouseEventToContainerPoint(t), this._startTime || (this._startTime = +new Date);
            var i = Math.max(40 - (+new Date - this._startTime), 0);
            clearTimeout(this._timer), this._timer = setTimeout(s.bind(this._performZoom, this), i), s.DomEvent.preventDefault(t), s.DomEvent.stopPropagation(t)
        }, _performZoom: function () {
            var t = this._map, e = this._delta, i = t.getZoom();
            e = e > 0 ? Math.ceil(e) : Math.floor(e), e = Math.max(Math.min(e, 4), -4), e = t._limitZoom(i + e) - i, this._delta = 0, this._startTime = null, e && ("center" === t.options.scrollWheelZoom ? t.setZoom(i + e) : t.setZoomAround(this._lastMousePos, i + e))
        }
    }), s.Map.addInitHook("addHandler", "scrollWheelZoom", s.Map.ScrollWheelZoom), s.extend(s.DomEvent, {
        _touchstart: s.Browser.msPointer ? "MSPointerDown" : s.Browser.pointer ? "pointerdown" : "touchstart",
        _touchend: s.Browser.msPointer ? "MSPointerUp" : s.Browser.pointer ? "pointerup" : "touchend",
        addDoubleTapListener: function (t, i, n) {
            function o(t) {
                var e;
                if (s.Browser.pointer ? (f.push(t.pointerId), e = f.length) : e = t.touches.length, !(e > 1)) {
                    var i = Date.now(), n = i - (a || i);
                    h = t.touches ? t.touches[0] : t, l = n > 0 && u >= n, a = i
                }
            }

            function r(t) {
                if (s.Browser.pointer) {
                    var e = f.indexOf(t.pointerId);
                    if (-1 === e)return;
                    f.splice(e, 1)
                }
                if (l) {
                    if (s.Browser.pointer) {
                        var n, o = {};
                        for (var r in h)n = h[r], o[r] = "function" == typeof n ? n.bind(h) : n;
                        h = o
                    }
                    h.type = "dblclick", i(h), a = null
                }
            }

            var a, h, l = !1, u = 250, c = "_leaflet_", p = this._touchstart, d = this._touchend, f = [];
            t[c + p + n] = o, t[c + d + n] = r;
            var m = s.Browser.pointer ? e.documentElement : t;
            return t.addEventListener(p, o, !1), m.addEventListener(d, r, !1), s.Browser.pointer && m.addEventListener(s.DomEvent.POINTER_CANCEL, r, !1), this
        },
        removeDoubleTapListener: function (t, i) {
            var n = "_leaflet_";
            return t.removeEventListener(this._touchstart, t[n + this._touchstart + i], !1), (s.Browser.pointer ? e.documentElement : t).removeEventListener(this._touchend, t[n + this._touchend + i], !1), s.Browser.pointer && e.documentElement.removeEventListener(s.DomEvent.POINTER_CANCEL, t[n + this._touchend + i], !1), this
        }
    }), s.extend(s.DomEvent, {
        POINTER_DOWN: s.Browser.msPointer ? "MSPointerDown" : "pointerdown",
        POINTER_MOVE: s.Browser.msPointer ? "MSPointerMove" : "pointermove",
        POINTER_UP: s.Browser.msPointer ? "MSPointerUp" : "pointerup",
        POINTER_CANCEL: s.Browser.msPointer ? "MSPointerCancel" : "pointercancel",
        _pointers: [],
        _pointerDocumentListener: !1,
        addPointerListener: function (t, e, i, n) {
            switch (e) {
                case"touchstart":
                    return this.addPointerListenerStart(t, e, i, n);
                case"touchend":
                    return this.addPointerListenerEnd(t, e, i, n);
                case"touchmove":
                    return this.addPointerListenerMove(t, e, i, n);
                default:
                    throw"Unknown touch event type"
            }
        },
        addPointerListenerStart: function (t, i, n, o) {
            var r = "_leaflet_", a = this._pointers, h = function (t) {
                s.DomEvent.preventDefault(t);
                for (var e = !1, i = 0; i < a.length; i++)if (a[i].pointerId === t.pointerId) {
                    e = !0;
                    break
                }
                e || a.push(t), t.touches = a.slice(), t.changedTouches = [t], n(t)
            };
            if (t[r + "touchstart" + o] = h, t.addEventListener(this.POINTER_DOWN, h, !1), !this._pointerDocumentListener) {
                var l = function (t) {
                    for (var e = 0; e < a.length; e++)if (a[e].pointerId === t.pointerId) {
                        a.splice(e, 1);
                        break
                    }
                };
                e.documentElement.addEventListener(this.POINTER_UP, l, !1), e.documentElement.addEventListener(this.POINTER_CANCEL, l, !1), this._pointerDocumentListener = !0
            }
            return this
        },
        addPointerListenerMove: function (t, e, i, n) {
            function s(t) {
                if (t.pointerType !== t.MSPOINTER_TYPE_MOUSE && "mouse" !== t.pointerType || 0 !== t.buttons) {
                    for (var e = 0; e < r.length; e++)if (r[e].pointerId === t.pointerId) {
                        r[e] = t;
                        break
                    }
                    t.touches = r.slice(), t.changedTouches = [t], i(t)
                }
            }

            var o = "_leaflet_", r = this._pointers;
            return t[o + "touchmove" + n] = s, t.addEventListener(this.POINTER_MOVE, s, !1), this
        },
        addPointerListenerEnd: function (t, e, i, n) {
            var s = "_leaflet_", o = this._pointers, r = function (t) {
                for (var e = 0; e < o.length; e++)if (o[e].pointerId === t.pointerId) {
                    o.splice(e, 1);
                    break
                }
                t.touches = o.slice(), t.changedTouches = [t], i(t)
            };
            return t[s + "touchend" + n] = r, t.addEventListener(this.POINTER_UP, r, !1), t.addEventListener(this.POINTER_CANCEL, r, !1), this
        },
        removePointerListener: function (t, e, i) {
            var n = "_leaflet_", s = t[n + e + i];
            switch (e) {
                case"touchstart":
                    t.removeEventListener(this.POINTER_DOWN, s, !1);
                    break;
                case"touchmove":
                    t.removeEventListener(this.POINTER_MOVE, s, !1);
                    break;
                case"touchend":
                    t.removeEventListener(this.POINTER_UP, s, !1), t.removeEventListener(this.POINTER_CANCEL, s, !1)
            }
            return this
        }
    }), s.Map.mergeOptions({
        touchZoom: s.Browser.touch && !s.Browser.android23,
        bounceAtZoomLimits: !0
    }), s.Map.TouchZoom = s.Handler.extend({
        addHooks: function () {
            s.DomEvent.on(this._map._container, "touchstart", this._onTouchStart, this)
        }, removeHooks: function () {
            s.DomEvent.off(this._map._container, "touchstart", this._onTouchStart, this)
        }, _onTouchStart: function (t) {
            var i = this._map;
            if (t.touches && 2 === t.touches.length && !i._animatingZoom && !this._zooming) {
                var n = i.mouseEventToLayerPoint(t.touches[0]), o = i.mouseEventToLayerPoint(t.touches[1]), r = i._getCenterLayerPoint();
                this._startCenter = n.add(o)._divideBy(2), this._startDist = n.distanceTo(o), this._moved = !1, this._zooming = !0, this._centerOffset = r.subtract(this._startCenter), i._panAnim && i._panAnim.stop(), s.DomEvent.on(e, "touchmove", this._onTouchMove, this).on(e, "touchend", this._onTouchEnd, this), s.DomEvent.preventDefault(t)
            }
        }, _onTouchMove: function (t) {
            var e = this._map;
            if (t.touches && 2 === t.touches.length && this._zooming) {
                var i = e.mouseEventToLayerPoint(t.touches[0]), n = e.mouseEventToLayerPoint(t.touches[1]);
                this._scale = i.distanceTo(n) / this._startDist, this._delta = i._add(n)._divideBy(2)._subtract(this._startCenter), 1 !== this._scale && (e.options.bounceAtZoomLimits || !(e.getZoom() === e.getMinZoom() && this._scale < 1 || e.getZoom() === e.getMaxZoom() && this._scale > 1)) && (this._moved || (s.DomUtil.addClass(e._mapPane, "leaflet-touching"), e.fire("movestart").fire("zoomstart"), this._moved = !0), s.Util.cancelAnimFrame(this._animRequest), this._animRequest = s.Util.requestAnimFrame(this._updateOnMove, this, !0, this._map._container), s.DomEvent.preventDefault(t))
            }
        }, _updateOnMove: function () {
            var t = this._map, e = this._getScaleOrigin(), i = t.layerPointToLatLng(e), n = t.getScaleZoom(this._scale);
            t._animateZoom(i, n, this._startCenter, this._scale, this._delta, !1, !0)
        }, _onTouchEnd: function () {
            if (!this._moved || !this._zooming)return void(this._zooming = !1);
            var t = this._map;
            this._zooming = !1, s.DomUtil.removeClass(t._mapPane, "leaflet-touching"), s.Util.cancelAnimFrame(this._animRequest), s.DomEvent.off(e, "touchmove", this._onTouchMove).off(e, "touchend", this._onTouchEnd);
            var i = this._getScaleOrigin(), n = t.layerPointToLatLng(i), o = t.getZoom(), r = t.getScaleZoom(this._scale) - o, a = r > 0 ? Math.ceil(r) : Math.floor(r), h = t._limitZoom(o + a), l = t.getZoomScale(h) / this._scale;
            t._animateZoom(n, h, i, l)
        }, _getScaleOrigin: function () {
            var t = this._centerOffset.subtract(this._delta).divideBy(this._scale);
            return this._startCenter.add(t)
        }
    }), s.Map.addInitHook("addHandler", "touchZoom", s.Map.TouchZoom), s.Map.mergeOptions({
        tap: !0,
        tapTolerance: 15
    }), s.Map.Tap = s.Handler.extend({
        addHooks: function () {
            s.DomEvent.on(this._map._container, "touchstart", this._onDown, this)
        }, removeHooks: function () {
            s.DomEvent.off(this._map._container, "touchstart", this._onDown, this)
        }, _onDown: function (t) {
            if (t.touches) {
                if (s.DomEvent.preventDefault(t), this._fireClick = !0, t.touches.length > 1)return this._fireClick = !1, void clearTimeout(this._holdTimeout);
                var i = t.touches[0], n = i.target;
                this._startPos = this._newPos = new s.Point(i.clientX, i.clientY), n.tagName && "a" === n.tagName.toLowerCase() && s.DomUtil.addClass(n, "leaflet-active"), this._holdTimeout = setTimeout(s.bind(function () {
                    this._isTapValid() && (this._fireClick = !1, this._onUp(), this._simulateEvent("contextmenu", i))
                }, this), 1e3), s.DomEvent.on(e, "touchmove", this._onMove, this).on(e, "touchend", this._onUp, this)
            }
        }, _onUp: function (t) {
            if (clearTimeout(this._holdTimeout), s.DomEvent.off(e, "touchmove", this._onMove, this).off(e, "touchend", this._onUp, this), this._fireClick && t && t.changedTouches) {
                var i = t.changedTouches[0], n = i.target;
                n && n.tagName && "a" === n.tagName.toLowerCase() && s.DomUtil.removeClass(n, "leaflet-active"), this._isTapValid() && this._simulateEvent("click", i)
            }
        }, _isTapValid: function () {
            return this._newPos.distanceTo(this._startPos) <= this._map.options.tapTolerance
        }, _onMove: function (t) {
            var e = t.touches[0];
            this._newPos = new s.Point(e.clientX, e.clientY)
        }, _simulateEvent: function (i, n) {
            var s = e.createEvent("MouseEvents");
            s._simulated = !0, n.target._simulatedClick = !0, s.initMouseEvent(i, !0, !0, t, 1, n.screenX, n.screenY, n.clientX, n.clientY, !1, !1, !1, !1, 0, null), n.target.dispatchEvent(s)
        }
    }), s.Browser.touch && !s.Browser.pointer && s.Map.addInitHook("addHandler", "tap", s.Map.Tap), s.Map.mergeOptions({boxZoom: !0}), s.Map.BoxZoom = s.Handler.extend({
        initialize: function (t) {
            this._map = t, this._container = t._container, this._pane = t._panes.overlayPane, this._moved = !1
        }, addHooks: function () {
            s.DomEvent.on(this._container, "mousedown", this._onMouseDown, this)
        }, removeHooks: function () {
            s.DomEvent.off(this._container, "mousedown", this._onMouseDown), this._moved = !1
        }, moved: function () {
            return this._moved
        }, _onMouseDown: function (t) {
            return this._moved = !1, !t.shiftKey || 1 !== t.which && 1 !== t.button ? !1 : (s.DomUtil.disableTextSelection(), s.DomUtil.disableImageDrag(), this._startLayerPoint = this._map.mouseEventToLayerPoint(t), void s.DomEvent.on(e, "mousemove", this._onMouseMove, this).on(e, "mouseup", this._onMouseUp, this).on(e, "keydown", this._onKeyDown, this))
        }, _onMouseMove: function (t) {
            this._moved || (this._box = s.DomUtil.create("div", "leaflet-zoom-box", this._pane), s.DomUtil.setPosition(this._box, this._startLayerPoint), this._container.style.cursor = "crosshair", this._map.fire("boxzoomstart"));
            var e = this._startLayerPoint, i = this._box, n = this._map.mouseEventToLayerPoint(t), o = n.subtract(e), r = new s.Point(Math.min(n.x, e.x), Math.min(n.y, e.y));
            s.DomUtil.setPosition(i, r), this._moved = !0, i.style.width = Math.max(0, Math.abs(o.x) - 4) + "px", i.style.height = Math.max(0, Math.abs(o.y) - 4) + "px"
        }, _finish: function () {
            this._moved && (this._pane.removeChild(this._box), this._container.style.cursor = ""), s.DomUtil.enableTextSelection(), s.DomUtil.enableImageDrag(), s.DomEvent.off(e, "mousemove", this._onMouseMove).off(e, "mouseup", this._onMouseUp).off(e, "keydown", this._onKeyDown)
        }, _onMouseUp: function (t) {
            this._finish();
            var e = this._map, i = e.mouseEventToLayerPoint(t);
            if (!this._startLayerPoint.equals(i)) {
                var n = new s.LatLngBounds(e.layerPointToLatLng(this._startLayerPoint), e.layerPointToLatLng(i));
                e.fitBounds(n), e.fire("boxzoomend", {boxZoomBounds: n})
            }
        }, _onKeyDown: function (t) {
            27 === t.keyCode && this._finish()
        }
    }), s.Map.addInitHook("addHandler", "boxZoom", s.Map.BoxZoom), s.Map.mergeOptions({
        keyboard: !0,
        keyboardPanOffset: 80,
        keyboardZoomOffset: 1
    }), s.Map.Keyboard = s.Handler.extend({
        keyCodes: {
            left: [37],
            right: [39],
            down: [40],
            up: [38],
            zoomIn: [187, 107, 61, 171],
            zoomOut: [189, 109, 173]
        }, initialize: function (t) {
            this._map = t, this._setPanOffset(t.options.keyboardPanOffset), this._setZoomOffset(t.options.keyboardZoomOffset)
        }, addHooks: function () {
            var t = this._map._container;
            -1 === t.tabIndex && (t.tabIndex = "0"), s.DomEvent.on(t, "focus", this._onFocus, this).on(t, "blur", this._onBlur, this).on(t, "mousedown", this._onMouseDown, this), this._map.on("focus", this._addHooks, this).on("blur", this._removeHooks, this)
        }, removeHooks: function () {
            this._removeHooks();
            var t = this._map._container;
            s.DomEvent.off(t, "focus", this._onFocus, this).off(t, "blur", this._onBlur, this).off(t, "mousedown", this._onMouseDown, this), this._map.off("focus", this._addHooks, this).off("blur", this._removeHooks, this)
        }, _onMouseDown: function () {
            if (!this._focused) {
                var i = e.body, n = e.documentElement, s = i.scrollTop || n.scrollTop, o = i.scrollLeft || n.scrollLeft;
                this._map._container.focus(), t.scrollTo(o, s)
            }
        }, _onFocus: function () {
            this._focused = !0, this._map.fire("focus")
        }, _onBlur: function () {
            this._focused = !1, this._map.fire("blur")
        }, _setPanOffset: function (t) {
            var e, i, n = this._panKeys = {}, s = this.keyCodes;
            for (e = 0, i = s.left.length; i > e; e++)n[s.left[e]] = [-1 * t, 0];
            for (e = 0, i = s.right.length; i > e; e++)n[s.right[e]] = [t, 0];
            for (e = 0, i = s.down.length; i > e; e++)n[s.down[e]] = [0, t];
            for (e = 0, i = s.up.length; i > e; e++)n[s.up[e]] = [0, -1 * t]
        }, _setZoomOffset: function (t) {
            var e, i, n = this._zoomKeys = {}, s = this.keyCodes;
            for (e = 0, i = s.zoomIn.length; i > e; e++)n[s.zoomIn[e]] = t;
            for (e = 0, i = s.zoomOut.length; i > e; e++)n[s.zoomOut[e]] = -t
        }, _addHooks: function () {
            s.DomEvent.on(e, "keydown", this._onKeyDown, this)
        }, _removeHooks: function () {
            s.DomEvent.off(e, "keydown", this._onKeyDown, this)
        }, _onKeyDown: function (t) {
            var e = t.keyCode, i = this._map;
            if (e in this._panKeys) {
                if (i._panAnim && i._panAnim._inProgress)return;
                i.panBy(this._panKeys[e]), i.options.maxBounds && i.panInsideBounds(i.options.maxBounds)
            } else {
                if (!(e in this._zoomKeys))return;
                i.setZoom(i.getZoom() + this._zoomKeys[e])
            }
            s.DomEvent.stop(t)
        }
    }), s.Map.addInitHook("addHandler", "keyboard", s.Map.Keyboard), s.Handler.MarkerDrag = s.Handler.extend({
        initialize: function (t) {
            this._marker = t
        }, addHooks: function () {
            var t = this._marker._icon;
            this._draggable || (this._draggable = new s.Draggable(t, t)), this._draggable.on("dragstart", this._onDragStart, this).on("drag", this._onDrag, this).on("dragend", this._onDragEnd, this), this._draggable.enable(), s.DomUtil.addClass(this._marker._icon, "leaflet-marker-draggable")
        }, removeHooks: function () {
            this._draggable.off("dragstart", this._onDragStart, this).off("drag", this._onDrag, this).off("dragend", this._onDragEnd, this), this._draggable.disable(), s.DomUtil.removeClass(this._marker._icon, "leaflet-marker-draggable")
        }, moved: function () {
            return this._draggable && this._draggable._moved
        }, _onDragStart: function () {
            this._marker.closePopup().fire("movestart").fire("dragstart")
        }, _onDrag: function () {
            var t = this._marker, e = t._shadow, i = s.DomUtil.getPosition(t._icon), n = t._map.layerPointToLatLng(i);
            e && s.DomUtil.setPosition(e, i), t._latlng = n, t.fire("move", {latlng: n}).fire("drag")
        }, _onDragEnd: function (t) {
            this._marker.fire("moveend").fire("dragend", t)
        }
    }), s.Control = s.Class.extend({
        options: {position: "topright"},
        initialize: function (t) {
            s.setOptions(this, t)
        },
        getPosition: function () {
            return this.options.position
        },
        setPosition: function (t) {
            var e = this._map;
            return e && e.removeControl(this), this.options.position = t, e && e.addControl(this), this
        },
        getContainer: function () {
            return this._container
        },
        addTo: function (t) {
            this._map = t;
            var e = this._container = this.onAdd(t), i = this.getPosition(), n = t._controlCorners[i];
            return s.DomUtil.addClass(e, "leaflet-control"), -1 !== i.indexOf("bottom") ? n.insertBefore(e, n.firstChild) : n.appendChild(e), this
        },
        removeFrom: function (t) {
            var e = this.getPosition(), i = t._controlCorners[e];
            return i.removeChild(this._container), this._map = null, this.onRemove && this.onRemove(t), this
        },
        _refocusOnMap: function () {
            this._map && this._map.getContainer().focus()
        }
    }), s.control = function (t) {
        return new s.Control(t)
    }, s.Map.include({
        addControl: function (t) {
            return t.addTo(this), this
        }, removeControl: function (t) {
            return t.removeFrom(this), this
        }, _initControlPos: function () {
            function t(t, o) {
                var r = i + t + " " + i + o;
                e[t + o] = s.DomUtil.create("div", r, n)
            }

            var e = this._controlCorners = {}, i = "leaflet-", n = this._controlContainer = s.DomUtil.create("div", i + "control-container", this._container);
            t("top", "left"), t("top", "right"), t("bottom", "left"), t("bottom", "right")
        }, _clearControlPos: function () {
            this._container.removeChild(this._controlContainer)
        }
    }), s.Control.Zoom = s.Control.extend({
        options: {
            position: "topleft",
            zoomInText: "+",
            zoomInTitle: "Zoom in",
            zoomOutText: "-",
            zoomOutTitle: "Zoom out"
        }, onAdd: function (t) {
            var e = "leaflet-control-zoom", i = s.DomUtil.create("div", e + " leaflet-bar");
            return this._map = t, this._zoomInButton = this._createButton(this.options.zoomInText, this.options.zoomInTitle, e + "-in", i, this._zoomIn, this), this._zoomOutButton = this._createButton(this.options.zoomOutText, this.options.zoomOutTitle, e + "-out", i, this._zoomOut, this), this._updateDisabled(), t.on("zoomend zoomlevelschange", this._updateDisabled, this), i
        }, onRemove: function (t) {
            t.off("zoomend zoomlevelschange", this._updateDisabled, this)
        }, _zoomIn: function (t) {
            this._map.zoomIn(t.shiftKey ? 3 : 1)
        }, _zoomOut: function (t) {
            this._map.zoomOut(t.shiftKey ? 3 : 1)
        }, _createButton: function (t, e, i, n, o, r) {
            var a = s.DomUtil.create("a", i, n);
            a.innerHTML = t, a.href = "#", a.title = e;
            var h = s.DomEvent.stopPropagation;
            return s.DomEvent.on(a, "click", h).on(a, "mousedown", h).on(a, "dblclick", h).on(a, "click", s.DomEvent.preventDefault).on(a, "click", o, r).on(a, "click", this._refocusOnMap, r), a
        }, _updateDisabled: function () {
            var t = this._map, e = "leaflet-disabled";
            s.DomUtil.removeClass(this._zoomInButton, e), s.DomUtil.removeClass(this._zoomOutButton, e), t._zoom === t.getMinZoom() && s.DomUtil.addClass(this._zoomOutButton, e), t._zoom === t.getMaxZoom() && s.DomUtil.addClass(this._zoomInButton, e)
        }
    }), s.Map.mergeOptions({zoomControl: !0}), s.Map.addInitHook(function () {
        this.options.zoomControl && (this.zoomControl = new s.Control.Zoom, this.addControl(this.zoomControl))
    }), s.control.zoom = function (t) {
        return new s.Control.Zoom(t)
    }, s.Control.Attribution = s.Control.extend({
        options: {
            position: "bottomright",
            prefix: '<a href="http://leafletjs.com" title="A JS library for interactive maps">Leaflet</a>'
        }, initialize: function (t) {
            s.setOptions(this, t), this._attributions = {}
        }, onAdd: function (t) {
            this._container = s.DomUtil.create("div", "leaflet-control-attribution"), s.DomEvent.disableClickPropagation(this._container);
            for (var e in t._layers)t._layers[e].getAttribution && this.addAttribution(t._layers[e].getAttribution());
            return t.on("layeradd", this._onLayerAdd, this).on("layerremove", this._onLayerRemove, this), this._update(), this._container
        }, onRemove: function (t) {
            t.off("layeradd", this._onLayerAdd).off("layerremove", this._onLayerRemove)
        }, setPrefix: function (t) {
            return this.options.prefix = t, this._update(), this
        }, addAttribution: function (t) {
            return t ? (this._attributions[t] || (this._attributions[t] = 0), this._attributions[t]++, this._update(), this) : void 0
        }, removeAttribution: function (t) {
            return t ? (this._attributions[t] && (this._attributions[t]--, this._update()), this) : void 0
        }, _update: function () {
            if (this._map) {
                var t = [];
                for (var e in this._attributions)this._attributions[e] && t.push(e);
                var i = [];
                this.options.prefix && i.push(this.options.prefix), t.length && i.push(t.join(", ")), this._container.innerHTML = i.join(" | ")
            }
        }, _onLayerAdd: function (t) {
            t.layer.getAttribution && this.addAttribution(t.layer.getAttribution())
        }, _onLayerRemove: function (t) {
            t.layer.getAttribution && this.removeAttribution(t.layer.getAttribution())
        }
    }), s.Map.mergeOptions({attributionControl: !0}), s.Map.addInitHook(function () {
        this.options.attributionControl && (this.attributionControl = (new s.Control.Attribution).addTo(this))
    }), s.control.attribution = function (t) {
        return new s.Control.Attribution(t)
    }, s.Control.Scale = s.Control.extend({
        options: {
            position: "bottomleft",
            maxWidth: 100,
            metric: !0,
            imperial: !0,
            updateWhenIdle: !1
        }, onAdd: function (t) {
            this._map = t;
            var e = "leaflet-control-scale", i = s.DomUtil.create("div", e), n = this.options;
            return this._addScales(n, e, i), t.on(n.updateWhenIdle ? "moveend" : "move", this._update, this), t.whenReady(this._update, this), i
        }, onRemove: function (t) {
            t.off(this.options.updateWhenIdle ? "moveend" : "move", this._update, this)
        }, _addScales: function (t, e, i) {
            t.metric && (this._mScale = s.DomUtil.create("div", e + "-line", i)), t.imperial && (this._iScale = s.DomUtil.create("div", e + "-line", i))
        }, _update: function () {
            var t = this._map.getBounds(), e = t.getCenter().lat, i = 6378137 * Math.PI * Math.cos(e * Math.PI / 180), n = i * (t.getNorthEast().lng - t.getSouthWest().lng) / 180, s = this._map.getSize(), o = this.options, r = 0;
            s.x > 0 && (r = n * (o.maxWidth / s.x)), this._updateScales(o, r)
        }, _updateScales: function (t, e) {
            t.metric && e && this._updateMetric(e), t.imperial && e && this._updateImperial(e)
        }, _updateMetric: function (t) {
            var e = this._getRoundNum(t);
            this._mScale.style.width = this._getScaleWidth(e / t) + "px", this._mScale.innerHTML = 1e3 > e ? e + " m" : e / 1e3 + " km"
        }, _updateImperial: function (t) {
            var e, i, n, s = 3.2808399 * t, o = this._iScale;
            s > 5280 ? (e = s / 5280, i = this._getRoundNum(e), o.style.width = this._getScaleWidth(i / e) + "px", o.innerHTML = i + " mi") : (n = this._getRoundNum(s), o.style.width = this._getScaleWidth(n / s) + "px", o.innerHTML = n + " ft")
        }, _getScaleWidth: function (t) {
            return Math.round(this.options.maxWidth * t) - 10
        }, _getRoundNum: function (t) {
            var e = Math.pow(10, (Math.floor(t) + "").length - 1), i = t / e;
            return i = i >= 10 ? 10 : i >= 5 ? 5 : i >= 3 ? 3 : i >= 2 ? 2 : 1, e * i
        }
    }), s.control.scale = function (t) {
        return new s.Control.Scale(t)
    }, s.Control.Layers = s.Control.extend({
        options: {
            collapsed: !0,
            position: "topright",
            autoZIndex: !0
        }, initialize: function (t, e, i) {
            s.setOptions(this, i), this._layers = {}, this._lastZIndex = 0, this._handlingClick = !1;
            for (var n in t)this._addLayer(t[n], n);
            for (n in e)this._addLayer(e[n], n, !0)
        }, onAdd: function (t) {
            return this._initLayout(), this._update(), t.on("layeradd", this._onLayerChange, this).on("layerremove", this._onLayerChange, this), this._container
        }, onRemove: function (t) {
            t.off("layeradd", this._onLayerChange, this).off("layerremove", this._onLayerChange, this)
        }, addBaseLayer: function (t, e) {
            return this._addLayer(t, e), this._update(), this
        }, addOverlay: function (t, e) {
            return this._addLayer(t, e, !0), this._update(), this
        }, removeLayer: function (t) {
            var e = s.stamp(t);
            return delete this._layers[e], this._update(), this
        }, _initLayout: function () {
            var t = "leaflet-control-layers", e = this._container = s.DomUtil.create("div", t);
            e.setAttribute("aria-haspopup", !0), s.Browser.touch ? s.DomEvent.on(e, "click", s.DomEvent.stopPropagation) : s.DomEvent.disableClickPropagation(e).disableScrollPropagation(e);
            var i = this._form = s.DomUtil.create("form", t + "-list");
            if (this.options.collapsed) {
                s.Browser.android || s.DomEvent.on(e, "mouseover", this._expand, this).on(e, "mouseout", this._collapse, this);
                var n = this._layersLink = s.DomUtil.create("a", t + "-toggle", e);
                n.href = "#", n.title = "Layers", s.Browser.touch ? s.DomEvent.on(n, "click", s.DomEvent.stop).on(n, "click", this._expand, this) : s.DomEvent.on(n, "focus", this._expand, this), s.DomEvent.on(i, "click", function () {
                    setTimeout(s.bind(this._onInputClick, this), 0)
                }, this), this._map.on("click", this._collapse, this)
            } else this._expand();
            this._baseLayersList = s.DomUtil.create("div", t + "-base", i), this._separator = s.DomUtil.create("div", t + "-separator", i), this._overlaysList = s.DomUtil.create("div", t + "-overlays", i), e.appendChild(i)
        }, _addLayer: function (t, e, i) {
            var n = s.stamp(t);
            this._layers[n] = {
                layer: t,
                name: e,
                overlay: i
            }, this.options.autoZIndex && t.setZIndex && (this._lastZIndex++, t.setZIndex(this._lastZIndex))
        }, _update: function () {
            if (this._container) {
                this._baseLayersList.innerHTML = "", this._overlaysList.innerHTML = "";
                var t, e, i = !1, n = !1;
                for (t in this._layers)e = this._layers[t], this._addItem(e), n = n || e.overlay, i = i || !e.overlay;
                this._separator.style.display = n && i ? "" : "none"
            }
        }, _onLayerChange: function (t) {
            var e = this._layers[s.stamp(t.layer)];
            if (e) {
                this._handlingClick || this._update();
                var i = e.overlay ? "layeradd" === t.type ? "overlayadd" : "overlayremove" : "layeradd" === t.type ? "baselayerchange" : null;
                i && this._map.fire(i, e)
            }
        }, _createRadioElement: function (t, i) {
            var n = '<input type="radio" class="leaflet-control-layers-selector" name="' + t + '"';
            i && (n += ' checked="checked"'), n += "/>";
            var s = e.createElement("div");
            return s.innerHTML = n, s.firstChild
        }, _addItem: function (t) {
            var i, n = e.createElement("label"), o = this._map.hasLayer(t.layer);
            t.overlay ? (i = e.createElement("input"), i.type = "checkbox", i.className = "leaflet-control-layers-selector", i.defaultChecked = o) : i = this._createRadioElement("leaflet-base-layers", o), i.layerId = s.stamp(t.layer), s.DomEvent.on(i, "click", this._onInputClick, this);
            var r = e.createElement("span");
            r.innerHTML = " " + t.name, n.appendChild(i), n.appendChild(r);
            var a = t.overlay ? this._overlaysList : this._baseLayersList;
            return a.appendChild(n), n
        }, _onInputClick: function () {
            var t, e, i, n = this._form.getElementsByTagName("input"), s = n.length;
            for (this._handlingClick = !0, t = 0; s > t; t++)e = n[t], i = this._layers[e.layerId], e.checked && !this._map.hasLayer(i.layer) ? this._map.addLayer(i.layer) : !e.checked && this._map.hasLayer(i.layer) && this._map.removeLayer(i.layer);
            this._handlingClick = !1, this._refocusOnMap()
        }, _expand: function () {
            s.DomUtil.addClass(this._container, "leaflet-control-layers-expanded")
        }, _collapse: function () {
            this._container.className = this._container.className.replace(" leaflet-control-layers-expanded", "")
        }
    }), s.control.layers = function (t, e, i) {
        return new s.Control.Layers(t, e, i)
    }, s.PosAnimation = s.Class.extend({
        includes: s.Mixin.Events,
        run: function (t, e, i, n) {
            this.stop(), this._el = t, this._inProgress = !0, this._newPos = e, this.fire("start"), t.style[s.DomUtil.TRANSITION] = "all " + (i || .25) + "s cubic-bezier(0,0," + (n || .5) + ",1)", s.DomEvent.on(t, s.DomUtil.TRANSITION_END, this._onTransitionEnd, this), s.DomUtil.setPosition(t, e), s.Util.falseFn(t.offsetWidth), this._stepTimer = setInterval(s.bind(this._onStep, this), 50)
        },
        stop: function () {
            this._inProgress && (s.DomUtil.setPosition(this._el, this._getPos()), this._onTransitionEnd(), s.Util.falseFn(this._el.offsetWidth))
        },
        _onStep: function () {
            var t = this._getPos();
            return t ? (this._el._leaflet_pos = t, void this.fire("step")) : void this._onTransitionEnd()
        },
        _transformRe: /([-+]?(?:\d*\.)?\d+)\D*, ([-+]?(?:\d*\.)?\d+)\D*\)/,
        _getPos: function () {
            var e, i, n, o = this._el, r = t.getComputedStyle(o);
            if (s.Browser.any3d) {
                if (n = r[s.DomUtil.TRANSFORM].match(this._transformRe), !n)return;
                e = parseFloat(n[1]), i = parseFloat(n[2])
            } else e = parseFloat(r.left), i = parseFloat(r.top);
            return new s.Point(e, i, !0)
        },
        _onTransitionEnd: function () {
            s.DomEvent.off(this._el, s.DomUtil.TRANSITION_END, this._onTransitionEnd, this), this._inProgress && (this._inProgress = !1, this._el.style[s.DomUtil.TRANSITION] = "", this._el._leaflet_pos = this._newPos, clearInterval(this._stepTimer), this.fire("step").fire("end"))
        }
    }), s.Map.include({
        setView: function (t, e, n) {
            if (e = e === i ? this._zoom : this._limitZoom(e), t = this._limitCenter(s.latLng(t), e, this.options.maxBounds), n = n || {}, this._panAnim && this._panAnim.stop(), this._loaded && !n.reset && n !== !0) {
                n.animate !== i && (n.zoom = s.extend({animate: n.animate}, n.zoom), n.pan = s.extend({animate: n.animate}, n.pan));
                var o = this._zoom !== e ? this._tryAnimatedZoom && this._tryAnimatedZoom(t, e, n.zoom) : this._tryAnimatedPan(t, n.pan);
                if (o)return clearTimeout(this._sizeTimer), this
            }
            return this._resetView(t, e), this
        }, panBy: function (t, e) {
            if (t = s.point(t).round(), e = e || {}, !t.x && !t.y)return this;
            if (this._panAnim || (this._panAnim = new s.PosAnimation, this._panAnim.on({
                    step: this._onPanTransitionStep,
                    end: this._onPanTransitionEnd
                }, this)), e.noMoveStart || this.fire("movestart"), e.animate !== !1) {
                s.DomUtil.addClass(this._mapPane, "leaflet-pan-anim");
                var i = this._getMapPanePos().subtract(t);
                this._panAnim.run(this._mapPane, i, e.duration || .25, e.easeLinearity)
            } else this._rawPanBy(t), this.fire("move").fire("moveend");
            return this
        }, _onPanTransitionStep: function () {
            this.fire("move")
        }, _onPanTransitionEnd: function () {
            s.DomUtil.removeClass(this._mapPane, "leaflet-pan-anim"), this.fire("moveend")
        }, _tryAnimatedPan: function (t, e) {
            var i = this._getCenterOffset(t)._floor();
            return (e && e.animate) === !0 || this.getSize().contains(i) ? (this.panBy(i, e), !0) : !1
        }
    }), s.PosAnimation = s.DomUtil.TRANSITION ? s.PosAnimation : s.PosAnimation.extend({
            run: function (t, e, i, n) {
                this.stop(), this._el = t, this._inProgress = !0, this._duration = i || .25, this._easeOutPower = 1 / Math.max(n || .5, .2), this._startPos = s.DomUtil.getPosition(t), this._offset = e.subtract(this._startPos), this._startTime = +new Date, this.fire("start"), this._animate()
            }, stop: function () {
                this._inProgress && (this._step(), this._complete())
            }, _animate: function () {
                this._animId = s.Util.requestAnimFrame(this._animate, this), this._step()
            }, _step: function () {
                var t = +new Date - this._startTime, e = 1e3 * this._duration;
                e > t ? this._runFrame(this._easeOut(t / e)) : (this._runFrame(1), this._complete())
            }, _runFrame: function (t) {
                var e = this._startPos.add(this._offset.multiplyBy(t));
                s.DomUtil.setPosition(this._el, e), this.fire("step")
            }, _complete: function () {
                s.Util.cancelAnimFrame(this._animId), this._inProgress = !1, this.fire("end")
            }, _easeOut: function (t) {
                return 1 - Math.pow(1 - t, this._easeOutPower)
            }
        }), s.Map.mergeOptions({
        zoomAnimation: !0,
        zoomAnimationThreshold: 4
    }), s.DomUtil.TRANSITION && s.Map.addInitHook(function () {
        this._zoomAnimated = this.options.zoomAnimation && s.DomUtil.TRANSITION && s.Browser.any3d && !s.Browser.android23 && !s.Browser.mobileOpera, this._zoomAnimated && s.DomEvent.on(this._mapPane, s.DomUtil.TRANSITION_END, this._catchTransitionEnd, this)
    }), s.Map.include(s.DomUtil.TRANSITION ? {
            _catchTransitionEnd: function (t) {
                this._animatingZoom && t.propertyName.indexOf("transform") >= 0 && this._onZoomTransitionEnd()
            }, _nothingToAnimate: function () {
                return !this._container.getElementsByClassName("leaflet-zoom-animated").length
            }, _tryAnimatedZoom: function (t, e, i) {
                if (this._animatingZoom)return !0;
                if (i = i || {}, !this._zoomAnimated || i.animate === !1 || this._nothingToAnimate() || Math.abs(e - this._zoom) > this.options.zoomAnimationThreshold)return !1;
                var n = this.getZoomScale(e), s = this._getCenterOffset(t)._divideBy(1 - 1 / n), o = this._getCenterLayerPoint()._add(s);
                return i.animate === !0 || this.getSize().contains(s) ? (this.fire("movestart").fire("zoomstart"), this._animateZoom(t, e, o, n, null, !0), !0) : !1
            }, _animateZoom: function (t, e, i, n, o, r, a) {
                a || (this._animatingZoom = !0), s.DomUtil.addClass(this._mapPane, "leaflet-zoom-anim"), this._animateToCenter = t, this._animateToZoom = e, s.Draggable && (s.Draggable._disabled = !0), s.Util.requestAnimFrame(function () {
                    this.fire("zoomanim", {
                        center: t,
                        zoom: e,
                        origin: i,
                        scale: n,
                        delta: o,
                        backwards: r
                    })
                }, this)
            }, _onZoomTransitionEnd: function () {
                this._animatingZoom = !1, s.DomUtil.removeClass(this._mapPane, "leaflet-zoom-anim"), this._resetView(this._animateToCenter, this._animateToZoom, !0, !0), s.Draggable && (s.Draggable._disabled = !1)
            }
        } : {}), s.TileLayer.include({
        _animateZoom: function (t) {
            this._animating || (this._animating = !0, this._prepareBgBuffer());
            var e = this._bgBuffer, i = s.DomUtil.TRANSFORM, n = t.delta ? s.DomUtil.getTranslateString(t.delta) : e.style[i], o = s.DomUtil.getScaleString(t.scale, t.origin);
            e.style[i] = t.backwards ? o + " " + n : n + " " + o
        }, _endZoomAnim: function () {
            var t = this._tileContainer, e = this._bgBuffer;
            t.style.visibility = "", t.parentNode.appendChild(t), s.Util.falseFn(e.offsetWidth), this._animating = !1
        }, _clearBgBuffer: function () {
            var t = this._map;
            !t || t._animatingZoom || t.touchZoom._zooming || (this._bgBuffer.innerHTML = "", this._bgBuffer.style[s.DomUtil.TRANSFORM] = "")
        }, _prepareBgBuffer: function () {
            var t = this._tileContainer, e = this._bgBuffer, i = this._getLoadedTilesPercentage(e), n = this._getLoadedTilesPercentage(t);
            return e && i > .5 && .5 > n ? (t.style.visibility = "hidden", void this._stopLoadingImages(t)) : (e.style.visibility = "hidden", e.style[s.DomUtil.TRANSFORM] = "", this._tileContainer = e, e = this._bgBuffer = t, this._stopLoadingImages(e), void clearTimeout(this._clearBgBufferTimer))
        }, _getLoadedTilesPercentage: function (t) {
            var e, i, n = t.getElementsByTagName("img"), s = 0;
            for (e = 0, i = n.length; i > e; e++)n[e].complete && s++;
            return s / i
        }, _stopLoadingImages: function (t) {
            var e, i, n, o = Array.prototype.slice.call(t.getElementsByTagName("img"));
            for (e = 0, i = o.length; i > e; e++)n = o[e], n.complete || (n.onload = s.Util.falseFn, n.onerror = s.Util.falseFn, n.src = s.Util.emptyImageUrl, n.parentNode.removeChild(n))
        }
    }), s.Map.include({
        _defaultLocateOptions: {
            watch: !1,
            setView: !1,
            maxZoom: 1 / 0,
            timeout: 1e4,
            maximumAge: 0,
            enableHighAccuracy: !1
        }, locate: function (t) {
            if (t = this._locateOptions = s.extend(this._defaultLocateOptions, t), !navigator.geolocation)return this._handleGeolocationError({
                code: 0,
                message: "Geolocation not supported."
            }), this;
            var e = s.bind(this._handleGeolocationResponse, this), i = s.bind(this._handleGeolocationError, this);
            return t.watch ? this._locationWatchId = navigator.geolocation.watchPosition(e, i, t) : navigator.geolocation.getCurrentPosition(e, i, t), this
        }, stopLocate: function () {
            return navigator.geolocation && navigator.geolocation.clearWatch(this._locationWatchId), this._locateOptions && (this._locateOptions.setView = !1), this
        }, _handleGeolocationError: function (t) {
            var e = t.code, i = t.message || (1 === e ? "permission denied" : 2 === e ? "position unavailable" : "timeout");
            this._locateOptions.setView && !this._loaded && this.fitWorld(), this.fire("locationerror", {
                code: e,
                message: "Geolocation error: " + i + "."
            })
        }, _handleGeolocationResponse: function (t) {
            var e = t.coords.latitude, i = t.coords.longitude, n = new s.LatLng(e, i), o = 180 * t.coords.accuracy / 40075017, r = o / Math.cos(s.LatLng.DEG_TO_RAD * e), a = s.latLngBounds([e - o, i - r], [e + o, i + r]), h = this._locateOptions;
            if (h.setView) {
                var l = Math.min(this.getBoundsZoom(a), h.maxZoom);
                this.setView(n, l)
            }
            var u = {latlng: n, bounds: a, timestamp: t.timestamp};
            for (var c in t.coords)"number" == typeof t.coords[c] && (u[c] = t.coords[c]);
            this.fire("locationfound", u)
        }
    })
}(window, document);
var ZoomCharts;
!function (t) {
    t.PackageInfo = {
        LibraryName: "zoomcharts",
        Version: "1.8.1",
        Revision: "8641570f88f8707f3547b003191e370e8ce39093",
        Built: "2015-09-07"
    }
}(ZoomCharts || (ZoomCharts = {})), this.__extends = function (t, e) {
    function i() {
        this.constructor = t
    }

    t.__baseType = e;
    for (var n in e)e.hasOwnProperty(n) && (t[n] = e[n]);
    i.prototype = e.prototype, t.prototype = new i
};
var ZoomCharts;
!function (t) {
    var e;
    !function (t) {
        var e;
        !function (t) {
            var e = function () {
                function t() {
                }

                return t.clamp_css_byte = function (t) {
                    return t = Math.round(t), 0 > t ? 0 : t > 255 ? 255 : t
                }, t.clamp_css_float = function (t) {
                    return 0 > t ? 0 : t > 1 ? 1 : t
                }, t.parse_css_int = function (e) {
                    return t.clamp_css_byte("%" === e[e.length - 1] ? parseFloat(e) / 100 * 255 : parseInt(e, 10))
                }, t.parse_css_float = function (e) {
                    return t.clamp_css_float("%" === e[e.length - 1] ? parseFloat(e) / 100 : parseFloat(e))
                }, t.css_hue_to_rgb = function (t, e, i) {
                    return 0 > i ? i += 1 : i > 1 && (i -= 1), 1 > 6 * i ? t + (e - t) * i * 6 : 1 > 2 * i ? e : 2 > 3 * i ? t + (e - t) * (2 / 3 - i) * 6 : t
                }, t.parseCSSColor = function (e) {
                    if (null == e)return {R: 0, G: 0, B: 0, A: 0};
                    var i = e.replace(RegExp(" ", "g"), "").toLowerCase();
                    if (i in t.kCSSColorTable) {
                        var n = t.kCSSColorTable[i];
                        return {R: n[0], G: n[1], B: n[2], A: n[3]}
                    }
                    if ("#" === i[0]) {
                        if (4 === i.length) {
                            var s = parseInt(i.substr(1), 16);
                            return s >= 0 && 4095 >= s ? {
                                    R: (3840 & s) >> 4 | (3840 & s) >> 8,
                                    G: 240 & s | (240 & s) >> 4,
                                    B: 15 & s | (15 & s) << 4,
                                    A: 1
                                } : null
                        }
                        if (7 === i.length) {
                            var s = parseInt(i.substr(1), 16);
                            return s >= 0 && 16777215 > s ? {
                                    R: (16711680 & s) >> 16,
                                    G: (65280 & s) >> 8,
                                    B: 255 & s,
                                    A: 1
                                } : null
                        }
                        return null
                    }
                    var o = i.indexOf("("), r = i.indexOf(")");
                    if (-1 !== o && r + 1 === i.length) {
                        var a = i.substr(0, o), h = i.substr(o + 1, r - (o + 1)).split(","), l = 1;
                        if ("rgba" === a) {
                            if (4 !== h.length)return null;
                            l = t.parse_css_float(h.pop())
                        }
                        if ("rgba" === a || "rgb" === a)return 3 !== h.length ? null : {
                                R: t.parse_css_int(h[0]),
                                G: t.parse_css_int(h[1]),
                                B: t.parse_css_int(h[2]),
                                A: l
                            };
                        if ("hsla" === a) {
                            if (4 !== h.length)return null;
                            l = t.parse_css_float(h.pop())
                        }
                        if ("hsla" === a || "hsl" === a) {
                            if (3 !== h.length)return null;
                            var u = (parseFloat(h[0]) % 360 + 360) % 360 / 360, c = t.parse_css_float(h[1]), p = t.parse_css_float(h[2]), d = .5 >= p ? p * (c + 1) : p + c - p * c, f = 2 * p - d;
                            return {
                                R: t.clamp_css_byte(255 * t.css_hue_to_rgb(f, d, u + 1 / 3)),
                                G: t.clamp_css_byte(255 * t.css_hue_to_rgb(f, d, u)),
                                B: t.clamp_css_byte(255 * t.css_hue_to_rgb(f, d, u - 1 / 3)),
                                A: l
                            }
                        }
                    }
                    return null
                }, t.kCSSColorTable = {
                    transparent: [0, 0, 0, 0],
                    aliceblue: [240, 248, 255, 1],
                    antiquewhite: [250, 235, 215, 1],
                    aqua: [0, 255, 255, 1],
                    aquamarine: [127, 255, 212, 1],
                    azure: [240, 255, 255, 1],
                    beige: [245, 245, 220, 1],
                    bisque: [255, 228, 196, 1],
                    black: [0, 0, 0, 1],
                    blanchedalmond: [255, 235, 205, 1],
                    blue: [0, 0, 255, 1],
                    blueviolet: [138, 43, 226, 1],
                    brown: [165, 42, 42, 1],
                    burlywood: [222, 184, 135, 1],
                    cadetblue: [95, 158, 160, 1],
                    chartreuse: [127, 255, 0, 1],
                    chocolate: [210, 105, 30, 1],
                    coral: [255, 127, 80, 1],
                    cornflowerblue: [100, 149, 237, 1],
                    cornsilk: [255, 248, 220, 1],
                    crimson: [220, 20, 60, 1],
                    cyan: [0, 255, 255, 1],
                    darkblue: [0, 0, 139, 1],
                    darkcyan: [0, 139, 139, 1],
                    darkgoldenrod: [184, 134, 11, 1],
                    darkgray: [169, 169, 169, 1],
                    darkgreen: [0, 100, 0, 1],
                    darkgrey: [169, 169, 169, 1],
                    darkkhaki: [189, 183, 107, 1],
                    darkmagenta: [139, 0, 139, 1],
                    darkolivegreen: [85, 107, 47, 1],
                    darkorange: [255, 140, 0, 1],
                    darkorchid: [153, 50, 204, 1],
                    darkred: [139, 0, 0, 1],
                    darksalmon: [233, 150, 122, 1],
                    darkseagreen: [143, 188, 143, 1],
                    darkslateblue: [72, 61, 139, 1],
                    darkslategray: [47, 79, 79, 1],
                    darkslategrey: [47, 79, 79, 1],
                    darkturquoise: [0, 206, 209, 1],
                    darkviolet: [148, 0, 211, 1],
                    deeppink: [255, 20, 147, 1],
                    deepskyblue: [0, 191, 255, 1],
                    dimgray: [105, 105, 105, 1],
                    dimgrey: [105, 105, 105, 1],
                    dodgerblue: [30, 144, 255, 1],
                    firebrick: [178, 34, 34, 1],
                    floralwhite: [255, 250, 240, 1],
                    forestgreen: [34, 139, 34, 1],
                    fuchsia: [255, 0, 255, 1],
                    gainsboro: [220, 220, 220, 1],
                    ghostwhite: [248, 248, 255, 1],
                    gold: [255, 215, 0, 1],
                    goldenrod: [218, 165, 32, 1],
                    gray: [128, 128, 128, 1],
                    green: [0, 128, 0, 1],
                    greenyellow: [173, 255, 47, 1],
                    grey: [128, 128, 128, 1],
                    honeydew: [240, 255, 240, 1],
                    hotpink: [255, 105, 180, 1],
                    indianred: [205, 92, 92, 1],
                    indigo: [75, 0, 130, 1],
                    ivory: [255, 255, 240, 1],
                    khaki: [240, 230, 140, 1],
                    lavender: [230, 230, 250, 1],
                    lavenderblush: [255, 240, 245, 1],
                    lawngreen: [124, 252, 0, 1],
                    lemonchiffon: [255, 250, 205, 1],
                    lightblue: [173, 216, 230, 1],
                    lightcoral: [240, 128, 128, 1],
                    lightcyan: [224, 255, 255, 1],
                    lightgoldenrodyellow: [250, 250, 210, 1],
                    lightgray: [211, 211, 211, 1],
                    lightgreen: [144, 238, 144, 1],
                    lightgrey: [211, 211, 211, 1],
                    lightpink: [255, 182, 193, 1],
                    lightsalmon: [255, 160, 122, 1],
                    lightseagreen: [32, 178, 170, 1],
                    lightskyblue: [135, 206, 250, 1],
                    lightslategray: [119, 136, 153, 1],
                    lightslategrey: [119, 136, 153, 1],
                    lightsteelblue: [176, 196, 222, 1],
                    lightyellow: [255, 255, 224, 1],
                    lime: [0, 255, 0, 1],
                    limegreen: [50, 205, 50, 1],
                    linen: [250, 240, 230, 1],
                    magenta: [255, 0, 255, 1],
                    maroon: [128, 0, 0, 1],
                    mediumaquamarine: [102, 205, 170, 1],
                    mediumblue: [0, 0, 205, 1],
                    mediumorchid: [186, 85, 211, 1],
                    mediumpurple: [147, 112, 219, 1],
                    mediumseagreen: [60, 179, 113, 1],
                    mediumslateblue: [123, 104, 238, 1],
                    mediumspringgreen: [0, 250, 154, 1],
                    mediumturquoise: [72, 209, 204, 1],
                    mediumvioletred: [199, 21, 133, 1],
                    midnightblue: [25, 25, 112, 1],
                    mintcream: [245, 255, 250, 1],
                    mistyrose: [255, 228, 225, 1],
                    moccasin: [255, 228, 181, 1],
                    navajowhite: [255, 222, 173, 1],
                    navy: [0, 0, 128, 1],
                    oldlace: [253, 245, 230, 1],
                    olive: [128, 128, 0, 1],
                    olivedrab: [107, 142, 35, 1],
                    orange: [255, 165, 0, 1],
                    orangered: [255, 69, 0, 1],
                    orchid: [218, 112, 214, 1],
                    palegoldenrod: [238, 232, 170, 1],
                    palegreen: [152, 251, 152, 1],
                    paleturquoise: [175, 238, 238, 1],
                    palevioletred: [219, 112, 147, 1],
                    papayawhip: [255, 239, 213, 1],
                    peachpuff: [255, 218, 185, 1],
                    peru: [205, 133, 63, 1],
                    pink: [255, 192, 203, 1],
                    plum: [221, 160, 221, 1],
                    powderblue: [176, 224, 230, 1],
                    purple: [128, 0, 128, 1],
                    red: [255, 0, 0, 1],
                    rosybrown: [188, 143, 143, 1],
                    royalblue: [65, 105, 225, 1],
                    saddlebrown: [139, 69, 19, 1],
                    salmon: [250, 128, 114, 1],
                    sandybrown: [244, 164, 96, 1],
                    seagreen: [46, 139, 87, 1],
                    seashell: [255, 245, 238, 1],
                    sienna: [160, 82, 45, 1],
                    silver: [192, 192, 192, 1],
                    skyblue: [135, 206, 235, 1],
                    slateblue: [106, 90, 205, 1],
                    slategray: [112, 128, 144, 1],
                    slategrey: [112, 128, 144, 1],
                    snow: [255, 250, 250, 1],
                    springgreen: [0, 255, 127, 1],
                    steelblue: [70, 130, 180, 1],
                    tan: [210, 180, 140, 1],
                    teal: [0, 128, 128, 1],
                    thistle: [216, 191, 216, 1],
                    tomato: [255, 99, 71, 1],
                    turquoise: [64, 224, 208, 1],
                    violet: [238, 130, 238, 1],
                    wheat: [245, 222, 179, 1],
                    white: [255, 255, 255, 1],
                    whitesmoke: [245, 245, 245, 1],
                    yellow: [255, 255, 0, 1],
                    yellowgreen: [154, 205, 50, 1]
                }, t
            }();
            t.CssColorParser = e
        }(e = t.Base || (t.Base = {}))
    }(e = t.Internal || (t.Internal = {}))
}(ZoomCharts || (ZoomCharts = {}));
var ZoomCharts;
!function (t) {
    var e;
    !function (t) {
        var e;
        !function (t) {
            var e = function () {
                function t(t, e, i) {
                    this.isFilling = i, this.lineDash = e, this.g = t, this.beginPath()
                }

                return t.prototype.beginPath = function () {
                    this.remaining = this.lineDash[0], this.dashes = [], this.pos = 0, this.x0 = 0, this.y0 = 0, this.x = 0, this.y = 0, this.hasPos = !1
                }, t.prototype.moveTo = function (t, e) {
                    this.y = e, this.x = t, this.isFilling && this.dashes.push(0, t, e), this.g.moveTo(t, e), this.x0 = t, this.y0 = e, this.hasPos = !0
                }, t.prototype.lineTo = function (t, e) {
                    this.isFilling && this.g.lineTo(t, e);
                    var i = t - this.x, n = e - this.y, s = this.x, o = this.y;
                    this.x = t, this.y = e;
                    var r = Math.sqrt(i * i + n * n), a = 1 / r;
                    i *= a, n *= a;
                    for (var h = this.lineDash.length, l = this.pos, u = this.remaining; ;) {
                        var c = Math.min(r, u);
                        if (s += i * c, o += n * c, l % 2 === 0 ? this.isFilling ? this.dashes.push(1, s, o) : this.g.lineTo(s, o) : this.isFilling ? this.dashes.push(0, s, o) : this.g.moveTo(s, o), !(r > c)) {
                            u -= c;
                            break
                        }
                        l = (l + 1) % h, u = this.lineDash[l], r -= c
                    }
                    return this.pos = l, this.remaining = u, this.hasPos = !0
                }, t.prototype.arc = function (t, e, i, n, s, o) {
                    var r = 2 * Math.PI, a = Math.min(.6, 2 / i), h = Math.cos(a), l = Math.sin(a), u = Math.sin(n) * i, c = Math.cos(n) * i, p = Math.sin(s) * i, d = Math.cos(s) * i;
                    if (this.hasPos || (this.moveTo(t + c, e + u), this.hasPos = !0), o) {
                        s > n && (n += r);
                        for (var f = (n - s) / a, m = f; m >= 0; m--) {
                            if (0 >= m - 1) {
                                this.lineTo(t + d, e + p);
                                break
                            }
                            this.lineTo(t + c, e + u);
                            var g = c * h + u * l, y = -c * l + u * h;
                            c = g, u = y
                        }
                    } else {
                        n > s && (n -= 2 * Math.PI);
                        for (var f = (s - n) / a, m = f; m >= 0; m--) {
                            if (0 >= m - 1) {
                                this.lineTo(t + d, e + p);
                                break
                            }
                            this.lineTo(t + c, e + u);
                            var g = c * h - u * l, y = c * l + u * h;
                            c = g, u = y
                        }
                    }
                }, t.prototype.bezierCurveTo = function () {
                    throw new Error("Bezier curves in dashed line context haven't been implemented yet")
                }, t.prototype.closePath = function () {
                    return this.lineTo(this.x0, this.y0)
                }, t.prototype.strokeDashes = function () {
                    for (var t = this.dashes, e = 0; e < t.length; e += 3) {
                        var i = t[e], n = t[e + 1], s = t[e + 2];
                        0 === i ? this.g.moveTo(n, s) : this.g.lineTo(n, s)
                    }
                }, t
            }();
            t.GraphicsDashedLineContext = e;
            var i = function () {
                function i() {
                }

                return i.stroke = function (t, e) {
                    e.lineWidth && (t.lineWidth = e.lineWidth), t.strokeStyle = e.lineColor, e.lineDash && "undefined" != typeof t.setLineDash ? (t.setLineDash(e.lineDash), t.stroke(), t.setLineDash([])) : t.stroke(), e.lineWidth && (t.lineWidth = 1)
                }, i.strokeWithShadow = function (t, e) {
                    return e.shadowColor && (t.shadowOffsetX = e.shadowOffsetX, t.shadowOffsetY = e.shadowOffsetY, t.shadowBlur = e.shadowBlur, t.shadowColor = e.shadowColor), e.lineWidth && (t.lineWidth = e.lineWidth), t.strokeStyle = e.lineColor, t.stroke(), e.lineWidth && (t.lineWidth = 1), e.shadowColor ? (t.shadowBlur = 0, t.shadowColor = "transparent") : void 0
                }, i.beginStroke = function (t, i, n) {
                    return void 0 === n && (n = !1), t.beginPath(), i.lineColor && i.lineDash && i.lineDash.length > 1 && "undefined" == typeof t.setLineDash ? (n && !i.fillColor && (n = !1), new e(t, i.lineDash, n)) : t
                }, i.endStroke = function (t, n, s, o) {
                    void 0 === o && (o = !1), n instanceof e ? (n.isFilling && (i.fill(t, s), t.beginPath(), n.strokeDashes()), i.strokeWithShadow(t, s)) : o ? i.paint(t, s) : i.stroke(t, s)
                }, i.beginStrokeAndFill = function (t, e) {
                    return i.beginStroke(t, e, !0)
                }, i.endStrokeAndFill = function (t, e, n) {
                    return i.endStroke(t, e, n, !0)
                }, i.fill = function (t, e) {
                    e.fillColor && (t.fillStyle = e.fillColor, e.shadowColor && (t.shadowOffsetX = e.shadowOffsetX, t.shadowOffsetY = e.shadowOffsetY, t.shadowBlur = e.shadowBlur, t.shadowColor = e.shadowColor), t.fill(), e.shadowColor && (t.shadowBlur = 0, t.shadowColor = "transparent"))
                }, i.fillGradient = function (t, e, n, s, o, r) {
                    if (e.fillGradient) {
                        for (var a = t.createLinearGradient(n, s, o, r), h = 0; h < e.fillGradient.length; h++) {
                            var l = e.fillGradient[h];
                            a.addColorStop(l[0], l[1])
                        }
                        var u = e.fillColor;
                        e.fillColor = a, i.fill(t, e), e.fillColor = u
                    } else i.fill(t, e)
                }, i.paint = function (t, e) {
                    e.shadowColor && (t.shadowOffsetX = e.shadowOffsetX, t.shadowOffsetY = e.shadowOffsetY, t.shadowBlur = e.shadowBlur, t.shadowColor = e.shadowColor), e.fillColor && (t.fillStyle = e.fillColor, t.fill()), e.lineColor && (t.lineWidth = e.lineWidth ? e.lineWidth : 1, t.strokeStyle = e.lineColor, e.lineDash ? (t.setLineDash(e.lineDash), t.stroke(), t.setLineDash([])) : t.stroke()), e.shadowColor && (t.shadowBlur = 0, t.shadowColor = "transparent")
                }, i.textStyle = function (t, e) {
                    e.fillColor && (t.fillStyle = e.fillColor), e.font && (t.font = e.font), e.shadowColor && (t.shadowOffsetX = e.shadowOffsetX, t.shadowOffsetY = e.shadowOffsetY, t.shadowBlur = e.shadowBlur, t.shadowColor = e.shadowColor)
                }, i.textStyleNoShadow = function (t, e) {
                    e.fillColor && (t.fillStyle = e.fillColor), e.font && (t.font = e.font)
                }, i.rectStyle = function (t, e) {
                    void 0 !== e.lineColor && (t.strokeStyle = e.lineColor), void 0 !== e.fillColor && (t.fillStyle = e.fillColor), void 0 !== e.lineWidth && (t.lineWidth = e.lineWidth)
                }, i.pushClip = function (t, e, i, n, s) {
                    t.save(), t.beginPath(), t.rect(e, i, n, s), t.clip()
                }, i.popClip = function (t) {
                    return t.restore()
                }, i.arcBetweenTwoPoints = function (t, e, i, n, s, o, r, a) {
                    var h = (s + r) / 2, l = (o + a) / 2, u = a - o, c = s - r, p = u * u + c * c;
                    if (0 !== p) {
                        var d = Math.sqrt(p);
                        n = Math.min(Math.max(n, d / 2), 3 * d);
                        var f = Math.sqrt(n * n / p - .25), m = h + u * f, g = l + c * f, y = h - u * f, v = l - c * f, S = (m - e) * (m - e) + (g - i) * (g - i), C = (y - e) * (y - e) + (v - i) * (v - i);
                        S > C ? (e = y, i = v) : (e = m, i = g);
                        var b = Math.atan2(o - i, s - e), x = Math.atan2(a - i, r - e);
                        b > x && (x += 2 * Math.PI);
                        var _ = Math.abs(b - x) > Math.PI;
                        t.arc(e, i, n, b, x, _)
                    }
                }, i.strokeMarker = function (t, e, n, s, o) {
                    var r = 1.41421356237 * o;
                    switch (e) {
                        case"rect":
                        case"square":
                            t.moveTo(n - o, s - o), t.lineTo(n + o, s - o), t.lineTo(n + o, s + o), t.lineTo(n - o, s + o);
                            break;
                        case"romb":
                        case"rhombus":
                            r = .9 * r, t.moveTo(n - r, s), t.lineTo(n, s - r), t.lineTo(n + r, s), t.lineTo(n, s + r);
                            break;
                        case"triangle":
                            var a = 3 * i.SQRT3D6 * o;
                            t.moveTo(n - o, s + a), t.lineTo(n + o, s + a), t.lineTo(n, s - a);
                            break;
                        case"triangle2":
                            t.moveTo(n - r, s - r), t.lineTo(n + r, s - r), t.lineTo(n, s + r);
                            break;
                        case"circle":
                            t.arc(n, s, o, 0, 2 * Math.PI, !0);
                            break;
                        default:
                            throw new Error("Unknown marker shape " + e + ". Valid values are `square`, `rhombus`, `triangle`, `triangle2`, `circle`.")
                    }
                    t.closePath()
                }, i.strokeBalloon = function (t, e, i, n, s) {
                    n = Math.max(n, 2 * s);
                    var o = 5, r = 4, a = (s + 2 * r) / 2, h = e, l = i;
                    t.moveTo(h, l), h += 3, l += o + 1, t.lineTo(h, l), h += n - r, t.lineTo(h, l), t.arc(h, l + a, a, -Math.PI / 2, Math.PI / 2), l += 2 * a, h -= n - r, t.lineTo(h, l), t.arc(h, l - a, a, .5 * Math.PI, 1.3 * Math.PI), t.closePath()
                }, i.strokeBalloon2 = function (t, e, i, n, s) {
                    var o = 4, r = (s + 2 * o) / 2;
                    n = Math.max(n, 2 * s) / 2 - o;
                    var a = e + n, h = i - r;
                    t.moveTo(a, h), t.arc(a, h + r, r, -Math.PI / 2, Math.PI / 2, !1), h += 2 * r, a -= 2 * n, t.lineTo(a, h), t.arc(a, h - r, r, .5 * Math.PI, 1.5 * Math.PI, !1), t.closePath()
                }, i.applyColorToImage = function (t, e, n) {
                    void 0 === n && (n = !0);
                    var s = i.parseColor(e), o = s.R, r = s.G, a = s.B, h = document.createElement("canvas"), l = h.width = t.width, u = h.height = t.height, c = h.getContext("2d");
                    c.drawImage(t, 0, 0);
                    var p = c.getImageData(0, 0, l, u), d = p.data;
                    if (n)for (var f = 0; f <= d.length; f += 4)255 === d[f + 3] && (d[f] = d[f] * o >> 8, d[f + 1] = d[f + 1] * r >> 8, d[f + 2] = d[f + 2] * a >> 8); else for (var f = 0; f <= d.length; f += 4)d[f] = d[f] * o >> 8, d[f + 1] = d[f + 1] * r >> 8, d[f + 2] = d[f + 2] * a >> 8;
                    return c.putImageData(p, 0, 0), h
                }, i.cropImageToCircle = function (t, e) {
                    var i = Math.min(t.width, t.height), n = Math.max(t.width, t.height), s = Math.min(n, 2 * i), o = document.createElement("canvas");
                    o.width = s, o.height = s;
                    var r = o.getContext("2d"), a = t.width, h = t.height;
                    r.fillStyle = "rgba(0,0,0,1)", r.beginPath(), r.arc(s / 2, s / 2, s / 2, 0, 2 * -Math.PI, !1), r.fill();
                    var l = r.globalCompositeOperation;
                    if (r.globalCompositeOperation = "source-in", "crop" === e) {
                        var u = Math.min(a, h) / 2;
                        r.drawImage(t, a / 2 - u, h / 2 - u, 2 * u, 2 * u, 0, 0, s, s)
                    } else if ("letterbox" === e) {
                        r.fillStyle = "black", r.fillRect(0, 0, s, s);
                        var c = s / Math.max(a, h);
                        r.drawImage(t, 0, 0, a, h, s / 2 - a / 2 * c, s / 2 - h / 2 * c, a * c, h * c)
                    } else if ("fit" === e) {
                        r.fillStyle = "black", r.fillRect(0, 0, s, s);
                        var c = s / Math.sqrt(a * a + h * h);
                        r.drawImage(t, 0, 0, a, h, s / 2 - a / 2 * c, s / 2 - h / 2 * c, a * c, h * c)
                    } else r.drawImage(t, 0, 0, a, h, 0, 0, s, s);
                    return r.globalCompositeOperation = l, o
                }, i.parseColor = function (e) {
                    return t.CssColorParser.parseCSSColor(e)
                }, i.normalizeColor = function (e) {
                    var i = t.CssColorParser.parseCSSColor(e), n = i.R, s = i.G, o = i.B, r = i.A;
                    return "rgba(" + n + "," + s + "," + o + "," + r.toFixed(3) + ")"
                }, i.deriveColor = function (t, e, n) {
                    var s = i.parseColor(t), o = s.R, r = s.G, a = s.B, h = s.A;
                    return i.deriveColorRGBA(o, r, a, h, e, n)
                }, i.deriveColorRGBA = function (t, e, i, n, s, o) {
                    var r = 255 * (s - 1);
                    return t = Math.round(Math.min(255, Math.max(0, t + r))), e = Math.round(Math.min(255, Math.max(0, e + r))), i = Math.round(Math.min(255, Math.max(0, i + r))), n = Math.min(1, n * o), "rgba(" + t + "," + e + "," + i + "," + n.toFixed(3) + ")"
                }, i.blendColors = function (t, e, n) {
                    var s = i.parseColor(t), o = s.R, r = s.G, a = s.B, h = s.A;
                    s = i.parseColor(e);
                    var l = s.R, u = s.G, c = s.B, p = s.A, d = Math.round(l * n + o * (1 - n)), f = Math.round(u * n + r * (1 - n)), m = Math.round(c * n + a * (1 - n)), g = p * n + h * (1 - n);
                    return "rgba(" + d + "," + f + "," + m + "," + g.toFixed(3) + ")"
                }, i.colorTone = function (t, e, n) {
                    var s = i.parseColor(t), o = i.deriveColor(t, e, n);
                    return {color: o, opacity: s.A}
                }, i.copyHue = function (t, e) {
                    var n = i.parseColor(t), s = n.R, o = n.G, r = n.B;
                    n = i.parseColor(e);
                    var a = n.R, h = n.G, l = n.B, u = n.A, c = (s + o + r) / 765, p = (a + h + l) / 765, d = Math.round(s / c * p), f = Math.round(o / c * p), m = Math.round(r / c * p), g = u;
                    return "rgba(" + d + "," + f + "," + m + "," + g.toFixed(3) + ")"
                }, i.inverseColor = function (t) {
                    var e = i.parseColor(t), n = e.R, s = e.G, o = e.B, r = e.A;
                    return n = 255 - n, s = 255 - s, o = 255 - o, "rgba(" + n + "," + s + "," + o + "," + r.toFixed(3) + ")"
                }, i.applyShadow = function (t, e) {
                    e.shadowColor && (t.shadowOffsetX = e.shadowOffsetX, t.shadowOffsetY = e.shadowOffsetY, t.shadowBlur = e.shadowBlur, t.shadowColor = e.shadowColor)
                }, i.clearShadow = function (t) {
                    t.shadowBlur = 0, t.shadowColor = "transparent"
                }, i.drawImageInSquare = function (t, e, i, n, s, o, r, a, h) {
                    var l = h / Math.max(s, o), u = s * l, c = o * l;
                    t.drawImage(e, i, n, s, o, r - u, a - c, 2 * u, 2 * c)
                }, i.getTextHeight = function (t, e) {
                    var n = i._heightCache;
                    if (n.hasOwnProperty(e))return n[e];
                    var s = i._heightElem;
                    if (!s) {
                        var o = document.body, r = document.createElement("div");
                        r.style.position = "absolute", r.style.left = "-999px", i._heightElem = s = document.createElement("div"), s.appendChild(document.createTextNode("Mg9!")), s.style.padding = "0 !important", r.appendChild(s), o.appendChild(r)
                    }
                    s.style.font = e, s.style.lineHeight = "1em";
                    var a = n[e] = s.clientHeight;
                    return a
                }, i.setLineDash = 1, i.SQRT3D6 = Math.sqrt(3) / 6, i._heightElem = null, i._heightCache = {}, i
            }();
            t.Graphics = i
        }(e = t.Base || (t.Base = {}))
    }(e = t.Internal || (t.Internal = {}))
}(ZoomCharts || (ZoomCharts = {}));
var ZoomCharts;
!function (t) {
    var e;
    !function () {
        "undefined" == typeof String.prototype.trim && (String.prototype.trim = function () {
            return this.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "")
        }), "undefined" != typeof module && module.exports && (module.exports.Internal = t.Internal)
    }(e = t.Internal || (t.Internal = {}))
}(ZoomCharts || (ZoomCharts = {}));
var ZoomCharts;
!function (t) {
    var e;
    !function (t) {
        var e;
        !function (t) {
            var e = {}.hasOwnProperty, i = function () {
                function t() {
                }

                return t.exportSymbol = function (t, e) {
                    "undefined" != typeof window && (window[t] = e), "undefined" != typeof module && module.exports && (module.exports[t] = e)
                }, t.extendStyle = function (t, e) {
                    for (var i in e) {
                        var n = e[i];
                        void 0 !== n && (t[i] = n)
                    }
                    return t
                }, t.extend = function (t, e) {
                    if (t || (t = {}), !e)return t;
                    for (var i in e) {
                        var n = e[i];
                        e.hasOwnProperty(i) && (t[i] = n)
                    }
                    return t
                }, t.extendDataItem = function (e, i) {
                    for (var n in i) {
                        var s = i[n];
                        i.hasOwnProperty(n) && ("style" === n && e.style ? t.extendDeep(e.style, s) : e[n] = s)
                    }
                    return e
                }, t.extendDeep = function (e, i) {
                    if (null == e)throw new Error("Target object is not defined.");
                    if (!t.isObjectOrArray(e))throw new Error("Target is not an object.");
                    for (var n in i)if (i.hasOwnProperty(n)) {
                        var s = i[n], o = e[n];
                        t.isObjectOrArray(o) && t.isObjectOrArray(s) && !t.isDomObject(o) && !t.isDomObject(s) ? this.extendDeep(o, s) : e[n] = s
                    }
                }, t.extendCopy = function (t, e, i) {
                    if (void 0 === i && (i = null), !e)return t;
                    for (var n in e)if (e.hasOwnProperty(n)) {
                        var s = e[n];
                        if (i && (s = i(n, s)), void 0 !== s) {
                            var o = t[n];
                            this.isDomObject(s) ? t[n] = s : this.isObjectOrArray(o) && this.isObjectOrArray(s) ? this.extendCopy(o, s, i) : t[n] = this.isObjectOrArray(s) ? this.isArray(s) ? this.extendCopy([], s, i) : this.extendCopy({}, s, i) : s
                        }
                    }
                    return t
                }, t.clone = function (e) {
                    if (null == e)return e;
                    var i;
                    i = t.isObjectOrArray(e) ? new e.constructor : e.constructor();
                    for (var n in e)if (e.hasOwnProperty(n)) {
                        var s = e[n];
                        i[n] = s
                    }
                    return i
                }, t.isArray = function (t) {
                    return t instanceof Array
                }, t.isObjectOrArray = function (t) {
                    return null !== t && "object" == typeof t
                }, t.isDomObject = function (t) {
                    return null !== t && t instanceof Element
                }, t.isFunction = function (t) {
                    return "function" == typeof t
                }, t.isNumber = function (t) {
                    return !isNaN(t) && ("number" == typeof t || t instanceof Number)
                }, t.tryParseInt = function (t, e) {
                    void 0 === e && (e = 0);
                    var i = parseInt(t, 10);
                    return isNaN(i) ? e : i
                }, t.tryParseFloat = function (t, e) {
                    void 0 === e && (e = 0);
                    var i = parseFloat(t);
                    return isNaN(i) ? e : i
                }, t.isString = function (t) {
                    return "string" == typeof t || t instanceof String
                }, t.getFunctionName = function (t) {
                    return t.name ? t.name : t.toString().match(/^function\s?([^\s(]*)/)[1]
                }, t.hasProperty = function (t, i) {
                    return e.call(t, i)
                }, t.hasProperties = function (t) {
                    if (!t)return !1;
                    for (var e in t)if (t.hasOwnProperty(e))return !0;
                    return !1
                }, t.removeProperty = function (t) {
                    for (var e in t)if (t.hasOwnProperty(e))return delete t[e], e;
                    return null
                }, t.removePropertyValue = function (t) {
                    for (var e in t) {
                        var i = t[e];
                        if (t.hasOwnProperty(e))return delete t[e], {key: e, value: i}
                    }
                    return null
                }, t.countProperties = function (t) {
                    var e = 0;
                    for (var i in t)t.hasOwnProperty(i) && (e += 1);
                    return e
                }, t.realClone = function (t) {
                    if (this.isFunction(t) || this.isDomObject(t))return t;
                    if (this.isArray(t)) {
                        for (var e = [], i = 0; i < t.length; i++)e[i] = this.realClone(t[i]);
                        return e
                    }
                    if (this.isObjectOrArray(t)) {
                        var n = new t.constructor;
                        for (var s in t)t.hasOwnProperty(s) && (n[s] = this.realClone(t[s]));
                        return n
                    }
                    return t
                }, t.realCloneSafe = function (t, e) {
                    if (void 0 === e && (e = []), this.isFunction(t) || this.isDomObject(t))return t;
                    if (this.isArray(t)) {
                        for (var i = 0; i < e.length; i++) {
                            var n = e[i];
                            if (n.from === t)return n.to
                        }
                        var s = [];
                        e.push({from: t, to: s});
                        for (var i = 0; i < t.length; i++)s[i] = this.realCloneSafe(t[i], e);
                        return s
                    }
                    if (this.isObjectOrArray(t)) {
                        for (var i = 0; i < e.length; i++) {
                            var n = e[i];
                            if (n.from === t)return n.to
                        }
                        var o = new t.constructor;
                        e.push({from: t, to: o});
                        for (var r in t)t.hasOwnProperty(r) && (o[r] = this.realCloneSafe(t[r], e));
                        return o
                    }
                    return t
                }, t.removeFromArray = function (t, e) {
                    var i = !1;
                    for (var n in t) {
                        var s = t[n];
                        s === e && (t.splice(n, 1), i = !0)
                    }
                    return i
                }, t.arrayToMap = function (t, e) {
                    for (var i = {}, n = 0; n < t.length; n++) {
                        var s = t[n];
                        s.index = n, i[s[e]] = s
                    }
                    return i
                }, t.log = function (t, e) {
                    console && (void 0 !== e && null !== e ? console.info(t, e) : console.info(t))
                }, t.warn = function (t, e, i) {
                    if (void 0 === i && (i = null), console) {
                        if (i) {
                            var n = (new Date).getTime();
                            if (this._previousConsoleMessages[t] > n)return;
                            i === !0 && (i = 5e3), this._previousConsoleMessages[t] = n + i
                        }
                        void 0 !== e && null !== e ? console.warn(t, e) : console.warn(t)
                    }
                }, t.error = function (t, e) {
                    console && (void 0 !== e && null !== e ? console.error(t, e) : console.error(t))
                }, t.getExtension = function (t) {
                    var e = /(?:\.([^.]+))?$/;
                    return e.exec(t)[1]
                }, t.createDom = function (t, e, i, n) {
                    void 0 === e && (e = null), void 0 === i && (i = null), void 0 === n && (n = null);
                    var s = document.createElement(t);
                    return null !== e && (s.className = e), null !== i && (s.innerHTML = i), null !== n && n.appendChild(s), s
                }, t.createStyledDom = function (t, e, i, n) {
                    void 0 === i && (i = null), void 0 === n && (n = null);
                    var s = document.createElement(t);
                    if (e)for (var o in e) {
                        var r = e[o];
                        e.hasOwnProperty(o) && (s.style[o] = r)
                    }
                    return null !== i && (s.innerHTML = i), null !== n && n.appendChild(s), s
                }, t.isStyleSheetDefined = function (t, e) {
                    if (void 0 === e && (e = null), "undefined" == typeof document)return !1;
                    try {
                        for (var i = 0; i < document.styleSheets.length; i++) {
                            if (null !== e) {
                                var n = document.styleSheets[i].href;
                                if (!n || -1 === n.indexOf(e))continue
                            }
                            var s = document.styleSheets[i], o = void 0;
                            if (o = s.rules ? s.rules : s.cssRules, null != o)for (var r = 0; r < o.length; ++r)if (o[r].selectorText === t)return !0
                        }
                    } catch (a) {
                        return !1
                    }
                    return !1
                }, t.hasClass = function (t, e) {
                    return t.className.length > 0 && new RegExp("(^|\\s)" + e + "(\\s|$)").test(t.className)
                }, t.addClass = function (e, i, n) {
                    void 0 === n && (n = !0), n && t.hasClass(e, i) || (0 === e.className.length ? e.className = i : e.className += " " + i)
                }, t.toggleClass = function (e, i) {
                    var n = t.hasClass(e, i);
                    n ? t.removeClass(e, i) : t.addClass(e, i)
                }, t.removeClass = function (t, e) {
                    var i = function (t, i) {
                        return i === e ? "" : t
                    };
                    t.className = t.className.replace(/(\S+)\s*/g, i).replace(/(^\s+|\s+$)/, "")
                }, t.listen = function (t, e, i) {
                    t.addEventListener ? t.addEventListener(e, i) : t.attachEvent("on" + e, i)
                }, t.unlisten = function (t, e, i) {
                    t.removeEventListener ? t.removeEventListener(e, i) : t.detachEvent("on" + e, i)
                }, t.stopPropagation = function (t) {
                    t.preventDefault ? (t.preventDefault(), t.stopPropagation()) : t.returnValue = !1
                }, t.createEvent = function (t) {
                    var e;
                    return document.createEvent ? (e = document.createEvent("Event"), e.initEvent(t, !0, !0)) : e = document.createEventObject(), e
                }, t.canvasScaling = function () {
                    var t = 1;
                    return window.devicePixelRatio ? t = window.devicePixelRatio : window.screen.systemXDPI && (t = window.screen.systemXDPI / window.screen.logicalXDPI), {
                        x: t,
                        y: t
                    }
                }, t.convertPointFromPageToNode = function (t, e, i, n, s) {
                    if (window.webkitConvertPointFromPageToNode) {
                        var o = window.webkitConvertPointFromPageToNode(t, new WebKitPoint(e, i));
                        if (o)return o
                    }
                    var r = t.getBoundingClientRect();
                    return {x: n - r.left, y: s - r.top}
                }, t.elementPos = function (t) {
                    var e = t.getBoundingClientRect(), i = e.top + (window.pageYOffset || document.documentElement.scrollTop) - (document.documentElement.clientTop || 0), n = e.left + (window.pageXOffset || document.documentElement.scrollLeft) - (document.documentElement.clientLeft || 0);
                    return {left: n, top: i}
                }, t.isParentOf = function (t, e) {
                    for (; e;) {
                        if (e === t)return !0;
                        e = e.parentElement
                    }
                    return !1
                }, t.fadeIn = function (t) {
                    t.style.display = "block"
                }, t.fadeOut = function (t) {
                    t.style.display = "none"
                }, t.hide = function (t) {
                    t.style.display = "none"
                }, t.show = function (t) {
                    t.style.display = "block"
                }, t.getProp = function (t, e, i) {
                    void 0 === i && (i = !1);
                    for (var n = 0, s = e.split("."); n < s.length; n++) {
                        var o = s[n];
                        if (null == t || !t.hasOwnProperty(o))return void 0;
                        if (i && n === s.length - 1) {
                            var r = t[o];
                            delete t[o], t = r
                        } else t = t[o]
                    }
                    return t
                }, t.wrapValue = function (t, e) {
                    for (var i = t, n = 0, s = e.split(".").reverse(); n < s.length; n++) {
                        var o = s[n], r = {};
                        r[o] = i, i = r
                    }
                    return i
                }, t.hasProp = function (e, i) {
                    return void 0 !== t.getProp(e, i)
                }, t.getScroll = function () {
                    var t = document.documentElement, e = document.body, i = t && t.scrollLeft || e && e.scrollLeft || 0, n = t && t.scrollTop || e && e.scrollTop || 0;
                    return {left: i, top: n}
                }, t.sign = function (t) {
                    return t ? 0 > t ? -1 : 1 : 0
                }, t.reversePolyline = function (t) {
                    var e = [];
                    if (t.length % 2 !== 0)throw new Error("The length of a given polyline must be dividable by 2");
                    for (var i = t.length - 1; i >= 0; i += -2)e.push(t[i - 1], t[i]);
                    return e
                }, t.toleranceMax = function (t, e, i) {
                    return t >= e * i ? t : e
                }, t.toleranceMin = function (t, e, i) {
                    return e >= t * i ? t : e
                }, t.detectBrowser = function () {
                    var t = navigator.userAgent, e = t.match(/(opera|chrome|safari|firefox|msie|phantomjs)\/?\s*(\.?\d+(\.\d+)*)/i);
                    return e ? e[1].toLowerCase() : (navigator.appName || "").toLowerCase()
                }, t.getIdentifier = function () {
                    return t.nextIdentifier++
                }, t.getIdentifierStr = function () {
                    return t.SeparatorChar + (t.nextIdentifier++).toString()
                }, t.doPostRequest = function (t, e, i, n, s) {
                    this.isString(i) || (i = JSON.stringify(i)), this.doRequestRaw(t, e, "POST", i, n, s)
                }, t.doRequest = function (t, e, i, n, s) {
                    if (i && i.length) {
                        t += -1 !== t.indexOf("?") ? "&" : "?";
                        for (var o = 0; o < i.length; o++) {
                            var r = i[o];
                            o > 0 && (t += "&"), t += encodeURIComponent(r[0]) + "=" + encodeURIComponent(r[1])
                        }
                    }
                    this.doRequestRaw(t, e, "GET", "", n, s)
                }, t.doRequestRaw = function (t, e, i, n, s, o) {
                    var r;
                    if ("undefined" != typeof XMLHttpRequest) r = new XMLHttpRequest; else {
                        if ("undefined" == typeof ActiveXObject)throw new Error("Cannot create XMLHttpRequest. Please verify if the feature is not disabled in the browser configuration.");
                        r = new ActiveXObject("Microsoft.XMLHTTP")
                    }
                    r.onreadystatechange = function () {
                        4 === r.readyState && (200 === r.status ? s(r.responseText) : o(r.responseText))
                    }, r.open(i, t, !0), r.timeout = e, r.ontimeout = function () {
                        o('{"error": "Request timeout."}')
                    }, r.send(n)
                }, t.openUrl = function (e) {
                    return t.isString(e) ? window.open(e) : window.open(e.url, e.name, e.specs, e.replace)
                }, t.parseData = function (e, i, n, s) {
                    void 0 === s && (s = !0);
                    var o = null;
                    if (i = i.toLowerCase(), "json" === i || "geojson" === i)if (t.isString(e))try {
                        o = JSON.parse(e)
                    } catch (r) {
                        s && n.error("Error: failed to parse JSON response: " + r + ": " + e), o = {error: "Error: failed to parse JSON response"}
                    } else o = e; else s && n.error("Unsupported data format: " + i);
                    return o
                }, t.numberFormat = function (t, e, i, n) {
                    void 0 === e && (e = 2), void 0 === i && (i = "."), void 0 === n && (n = "");
                    var s = parseFloat(t);
                    if (isNaN(s))return "";
                    var o;
                    0 > s ? (o = "-", s = -s) : o = "";
                    for (var r = 0 | s, a = s - r, h = i + a.toFixed(e).substr(2); ;) {
                        if (h = (r % 1e3).toFixed(0) + h, !(r > 1e3))break;
                        r = r / 1e3 | 0, h = n + h
                    }
                    return o + h
                }, t.buildImage = function (t, e, i) {
                    var n = new Image, s = function () {
                        return e(n)
                    }, o = function () {
                        return i(n)
                    };
                    return n.src = t, n.complete ? n.width > 0 ? s() : setTimeout(s, 0) : (n.onload = s, n.onerror = o), n
                }, t.sort = function (t, e) {
                    e || (e = function (t, e) {
                        return t - e
                    });
                    for (var i, n, s = t, o = 0 | s.length, r = 0; o - 2 >= r; r += 2)i = s[r], n = s[r + 1], e(i, n) > 0 && (s[r] = n, s[r + 1] = i);
                    for (var a = s.slice(0), h = 2; o > h;) {
                        for (var l = h << 1, u = 0; o - 1 >= u; u += l) {
                            var c = u, p = u + h;
                            if (p >= o)for (var r = c; o - 1 >= r; r++)a[r] = s[r]; else {
                                var d = p, f = Math.min(p + h, o), m = u;
                                for (i = s[c], n = s[p]; ;)if (e(i, n) <= 0) {
                                    if (a[m] = i, m = m + 1 | 0, c = c + 1 | 0, c === d) {
                                        for (a[m] = n, m = m + 1 | 0, p = p + 1 | 0; f > p;)a[m] = s[p], m = m + 1 | 0, p = p + 1 | 0;
                                        break
                                    }
                                    i = s[c]
                                } else {
                                    if (a[m] = n, m = m + 1 | 0, p = p + 1 | 0, p === f) {
                                        for (a[m] = i, m = m + 1 | 0, c = c + 1 | 0; d > c;)a[m] = s[c], m = m + 1 | 0, c = c + 1 | 0;
                                        break
                                    }
                                    n = s[p]
                                }
                            }
                        }
                        h = l;
                        var g = a;
                        a = s, s = g
                    }
                    if (t !== s) {
                        for (var r = 0; o - 1 >= r; r++)t[r] = s[r];
                        s.length = 0
                    } else a.length = 0;
                    return t
                }, t.binSearch = function (t, e) {
                    for (var i = 0, n = t.length - 1; n > i;) {
                        var s = (n + i) / 2 | 0;
                        if (t[s] < e) i = s + 1; else {
                            if (!(t[s] > e)) {
                                for (; s > 0 && t[s - 1] === e;)s -= 1;
                                return s
                            }
                            n = s
                        }
                    }
                    return i < t.length && t[i] < e ? i + 1 : i
                }, t.listenResize = function (e, i) {
                    if (window.getComputedStyle) {
                        var n = function () {
                            i(), t.updateResize(e)
                        };
                        "static" === window.getComputedStyle(e).position && (e.style.position = "relative"), (e.__resizeTriggers__ = document.createElement("div")).className = "DVSL-resize-triggers", e.__resizeTriggers__.innerHTML = '<div class="DVSL-expand-trigger"><div></div></div><div class="DVSL-contract-trigger"></div>', e.insertBefore(e.__resizeTriggers__, e.firstChild), t.updateResize(e), e.__resizeListener__ = n, e.addEventListener("scroll", n, !0)
                    }
                    e.onresize = i
                }, t.updateResize = function (t) {
                    var e = t.__resizeTriggers__;
                    if (e) {
                        var i = e.firstElementChild, n = e.lastElementChild, s = i.firstElementChild;
                        n.scrollLeft = n.scrollWidth, n.scrollTop = n.scrollHeight, s.style.width = i.offsetWidth + 1 + "px", s.style.height = i.offsetHeight + 1 + "px", i.scrollLeft = i.scrollWidth, i.scrollTop = i.scrollHeight
                    }
                }, t.unlistenResize = function (t) {
                    t.removeEventListener("scroll", t.__resizeListener__), t.__resizeListener__ = void 0, t.__resizeTriggers__ = !t.removeChild(t.__resizeTriggers__), t.onresize = void 0
                }, t.decodeEntities = function (e) {
                    return -1 === e.indexOf("&") ? e : (t.decodeTextarea || (t.decodeTextarea = document.createElement("textarea")), t.decodeTextarea.innerHTML = e, t.decodeTextarea.value)
                }, t.aggregate = function (t, e, i) {
                    for (var n = 0, s = this.aggregationCallbacks[t], o = s.start; e();) {
                        var r = i();
                        s.increment(o, r), n += 1
                    }
                    return n > 0 ? s.result(o, n) : null
                }, t._previousConsoleMessages = {}, t.SeparatorChar = String.fromCharCode(63743), t.nextIdentifier = 0, t.decodeTextarea = null, t.aggregationCallbacks = {
                    sum: {
                        start: 0,
                        increment: function (t, e) {
                            return t + e
                        },
                        result: function (t) {
                            return t
                        }
                    }, min: {
                        start: 1 / 0, increment: function (t, e) {
                            return Math.min(t, e)
                        }, result: function (t) {
                            return t
                        }
                    }, max: {
                        start: -1 / 0, increment: function (t, e) {
                            return Math.max(t, e)
                        }, result: function (t) {
                            return t
                        }
                    }, avg: {
                        start: 0, increment: function (t, e) {
                            return t + e
                        }, result: function (t, e) {
                            return t / e
                        }
                    }, count: {
                        start: 0, increment: function () {
                            return 0
                        }, result: function (t, e) {
                            return e
                        }
                    }, first: {
                        start: null, increment: function (t, e) {
                            return null !== t && void 0 !== t ? t : e
                        }, result: function (t) {
                            return t
                        }
                    }, last: {
                        start: null, increment: function (t, e) {
                            return null !== e && void 0 !== e ? e : t
                        }, result: function (t) {
                            return t
                        }
                    }
                }, t
            }();
            if (t.Helpers = i, "undefined" != typeof window) {
                var n = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.msRequestAnimationFrame || window.oRequestAnimationFrame, s = window.cancelAnimationFrame || window.mozCancelAnimationFrame || window.webkitCancelAnimationFrame || window.msCancelRequestAnimationFrame || window.oCancelAnimationFrame;
                if (!n) {
                    var o = 0;
                    n = function (t) {
                        var e = (new Date).getTime(), i = Math.max(0, 16 - (e - o)), n = window.setTimeout(function () {
                            return t(e + i)
                        }, i);
                        return o = e + i, n
                    }, s = window.clearTimeout
                }
                s || (s = function () {
                }), i.requestAnimationFrame = function (t) {
                    return n.call(window, t)
                }, i.cancelAnimationFrame = function (t) {
                    return s.call(window, t)
                };
                var r = (new Date).getTime();
                "performance" in window == !1 ? i.performanceNow = function () {
                        return (new Date).getTime() - r
                    } : "now" in window.performance == !1 ? (performance.timing && performance.timing.navigationStart && (r = performance.timing.navigationStart), i.performanceNow = function () {
                            return (new Date).getTime() - r
                        }) : i.performanceNow = function () {
                            return window.performance.now()
                        };
                var a = r - i.performanceNow();
                i.timeToPerfNow = function (t) {
                    return t - a
                }
            }
        }(e = t.Base || (t.Base = {}))
    }(e = t.Internal || (t.Internal = {}))
}(ZoomCharts || (ZoomCharts = {}));
var ZoomCharts;
!function (t) {
    var e;
    !function (t) {
        var e;
        !function (t) {
            t.LicenseBannerSupportedBy = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMgAAAA/CAMAAACSEXcNAAACc1BMVEVMaXEAmcwAmcwyMjIzMzMAmcwzMzMzMzMzMzMzMzMAmcwzMzMzMzMzMjIAmcwzMzMzMzMAmcwzMzMzMzMAmcxEREQZGRkzMzM3NzczMzMAmcwzMzMzMzMzMzP///8AmcwAms4AmcwAm9AAAAAzMzMAms0zMjIzMjIzMzMAmc0DmMsAmcwAmcwAms0zMzMAmcwzMzMyMjIjIyP///8AmcwAmcwCmcsAms0zMzMzMzM0NDQzMjIAmcwzMzMAmcwzMzMyMjEAmcwAmcwAmcwAmcwAmcwzMzMzMzMAmc0zMzMzMjL////MMzMAAAAFBQUDAwNVVVUAmcwzMzMzMzMAmcwzMjIAmcwzMzMAms0zMzMzMzMEBAREREQAAAAAmcwzMzMAmcwAmc0Ams3///8zMzMzMzMAms7MMzP////KysoAmcwzMzMzMzMAms0zMzMAms0zMzPMMzMAm88AAAAxMTEzMjIxMTH///////9aWlr///9iYmIAmcwAmcwzMzMAms0zMzMzMzMREREzMzP///81NTUfHx8FBQUAAAA5OTn///8MDAwAAAAAmcwhISEAAAD///8DAwMyLi23t7cAAAD///9dXV0zMzMzMzMzMzMzMzPOMjL///9VVVVtbW0QEBCIiIhRUVEdHR0AmcwzMzMzMzPVLiyOjo5QUFBubm6VlZWIiIh9fX0AAACfn5+zs7PTLy3WLizXLSrQMTD///8cHBxiYmIiIiLj4+Pc3Nxubm4AAACIiIgzMzPMMzMAmczMMzM2LivXLSrULiytra1AQEAhISFaWlpgYGAyMC8JCQkCAgIzMzMAmcwAAADMMzMAms0q0h8SAAAAyXRSTlMA51rQTWX71QT0MRwKFwIN4fkp+NGe5+S+QrxUATBZIVDMVCIQl9wG6M0D4hYOY/3svBEMxvYIQ/FoqGDWW/EjhBqPJ6+GVyHcbUBTCIjy8GnufDUSm6mANMGVVcYzSrnKesEv/gI44R5vHUSOX4m3UHiA73PKqjgqQBiycqJLa0ew5D0SJul4u9MG9Kor2URN3uFEZiSuOtgeoCdHvaXSiaahLrG2epC6jXlumZlieNRJre5B6JzHZFN2zDezCzBruLY5cZyQlizU6ioiAAAJa0lEQVR42u2Y6V8TSRqA3xDOxQiYrIiQgIZLIOEyBMJ9X7oRkBsQEVgukQUEV0VRQXHAE+/bGdXRHXXnnt2Zvc8PSe38SVtvdSfdnUhsh98PZJfnQzpVXU3XU/XWWxVgnQ+Pc2OEzOlhGSxcAYTshtVkN3nU36+0poFcriyAC1s2cyI/h9XEeqwvPf135BzIZfOWD1PkawsAfPTdIgsN9rHwao6QV/j93BUy1goArWNkbDe9kGtjc4TSTidyjHxPL3idc4hYvsfml8glAD2OzMryiMy1U5OP2Iiyjy3kcf9naEWsL/vbSDsVuEErzsEecvrRa93ZNt0MvLK+wXhkt14QXoS87P+UtB89+zHAOFmEFabvzUVCFvQgEjl7IP36fSsAuXE0fXL+Y3h4nlYcs1KRv/fNsNDSk89++Pdr0srdauNFjtHm1OLGaYBvz6fDSjNz77vnm61pIhHs1++JnqtouwjkMato30N+za+RbMLYA/OPpWsEmy/SSSQvYIVJ09O46sPFLhXBTmMFlvCKFQ4RLLzRUfqcTRDH9/Tz/2wl12GFmSWXcLGf/QfAvFikhcxwPdvcBle/xYr5GUHkB1IAjKupLiIX2wBenJ64DytNepu1Va9fIK8BPrW26+dQhFzTXyK0K4RW7Ca/gUes4gFwIhc36+lT5JK+fQHgG3rrmnOxt7LmcH3+F/RzpZl8YCXkYv8MwOJ5Yv3mLC72CULOTwKQtofE+uAo9D23EuuxI7zIy3mih8ljtOpfAEfo9eF9x2I/zZrTIfkaP1eaI9U63b10jK+vdNVHLh+gkTKp032FPXt8j9ZgZqvWVR+gFx3VhaPVOtr6QDXeYtd7k5cB0R24zNXB6Ruw6vAhv5ytOm03WfyfELlifZ4OHwIYKXyswE/hcnUfrLPOOv/f9DTW19drYe3jH2yz2UZgdUnaXlSys6thf2/CMkT8qIg3/CTyh4eHa+NguUQWKew8Gp+E1RCZpo+mBMEy8amxi9j5ySqIhNFHgzfA8ijiDUwm7lrTsTZFSu1I18mmgYGmk13MqHctimy3UxKjgCeqAotJKy1StWyRJFzmOwbAycA2WhEDlIzC4gvFhc61b4gsvhBpABeCbueXq+IEkWmAHlV5fqBrp6ID8/OxnQs90YHlPfR6BkX8QUQE/hXnA6NbpZTsBQcbkyIjCzNgP+22Aj0Ek0S7PeRPTaOHKvKS7cl5OTG9tM4rplNhovWKQz4il9na5vgAX3VK7JNxrT8nYsy2+KWofQOCJ8IjHF26nX1HGR+gVmfGWnJFgoHeBU/84gPivVNTU5X0UXVzKmWC5S7tkDIFH5gwqgA5ZJeSXMjPg9eUpsZkqqkowQk5CBK8cMGLH5pqyBMVc8zAETccYHPSncuJ+ApVqfnAUMXbBPxO8BZZ+zK5mpRsm5iANACoVTvL8WeAUuIiklfINEoV4sqcBJCQoLF7JCSKC5ZUm5gsFJESXM6JoK9gnOUiF+AuUiuuyAVKQ4gTE8tHKOKVaJcwCi7s59NxYo4mp0YYhJydWzsVLD9HYsCc4gas2WLZ56cWi6hDb8Vyo93szzpNWx22tAzVp8YzkyoAuM0PeWbs4VPTSqUyFp9TIs1BoGXTGrvPMnE4xWYrY2Mf6WCARVlDgrBthCgqFCH4xW3b6GBNzQOGjZCQFJWDpYqiDrbs9/qY+FyQy16Wm8aWbLmx2ciJxA55lwf5x6lyscB1Iq1xEFuh0jj2/zDVCwygRhZjHa5/t6xVjwEXzu6ovCdGQIJPMgaRASCGG+0Gr2JDhiFy+5TJ7rZrNGELL+fix1nYL5muRAPEYUeVKnCywSX9pmFpH7iQhXpVnIhvoFv6FbJfpZDYQEyvCXvfBDDKPEqEY0hxgxlc6MUmPsDD1EvAQSEu/Cb2Zt+b7vvICXCQjeMa7Zpusc0wL7Lp7RtiEEbgTXgreyv4vplxYpKPg5gMtz1SKuKDBzAhFWCoRUEBxojHDTEfw6gOXBiilU89i2wIpoWWCHCHz14xtM8sIR2Uc/jykaTjbcL+s4MWt8Nf6MuGPIpEx4snKGj25rT39BltIw6AZxHYxxJFmTCb0jS0zYCDSykFzxgUHkU0TITFsUeRoFBaDOecsk+F+nLJF6dJ2eNZxNvGCLWUqUACi6eaYoAEHE1NhoxTpGeRH6PgKmZ4mSK5sTYBGSIwbONJuSOOzcJERxa6kCwjsMwhskS6u7vD5YlgNCG+AQG+8kSg0rlfqseF1bnVTikCykk8WBnAIx01drkzUiZLpIzbG2sHZ2+Xb6prkSUCKuMfMh1HBkmkdLF4muITqTvmYmAMFCXbZYlgtBjliLANJ3RQSMqyRNAl3BLA5mQWGFF2iiISkK381ubOflPJcS+v4w1sOqY6373YD9NXNMoR0XbTLlcJO6JcEWQTOwYNAxJZIzqFSDsIu/7I2LVrF906BIo2dr1bBI8RT+SIjOC5xV++iJRUjEq22e0UHws7pWv9z7/k+QLnjUcTBbDz3SIYIpkquSJxwjJGkQjZIrlYzx0vKIeABw+Ool39V//h+SumAURR4pUBskRUuBZb5IaWkEQn3r6zn8GDtCAimUA/ej3ITq5J4lPT1FtEnuEdTYf5AmY0eSLQYqMUbHD0uqxqCRF/Je7l+cBhxARc6S6C55nuEUAioG5oFjjKb9HmdwBAwYa5cwePArUy3EXugob/nS5bhP9p5FdQFhYWPm4JtlUuIQJGbJdZb5yuOlHJDh/xae4iPUpsVOAdltuSBlU2dWpj2WBY2RB7RxgTcafDTeQL6KVJN+r9RGBaLf2FuJSI/1OblGxwE8G0zKOOpiJi7sASIl2uIl/ehUO4UXoS2eEuAoPBNoGlZwSiWRKVbNXuIhH1NoSd/G+K2z8N4kXcOSkV+fJztpRK4X1FQFUQ6zh93GqZ9XBoHHnq2KZD67UgEREwKrkW0eB/4lQK3/7WuD8gF34mpQkTsMksFvnt36A3j05IEggU06Z7wcFeWiqW3nTM3oa67NqCxsqRTXE4qJu0Wm20EPbiYuCJysaCWuMZR9lfS4kDCT11WQW1ueURbIwGs7B9XRwsQROeCPP45fCMajzbBWbuX0JrjON2SnIpG/+7n98FyBhFtxhYc5TakcTSJgyPhE9GK/j/rqw9jifzu3hn1w7Fj+xrTAKsRcwau4TEg7BGyTipEWmw9bJmVcylW3MUioquoigDrLPO+/JfZ6Pep8PFvkUAAAAASUVORK5CYII=", t.LicenseBannerDevelopment = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMgAAAA/CAMAAACSEXcNAAACu1BMVEVMaXEzMzMCmMszMzMzMzMzMzMzMzNbW1tERET///8AAAAAmcwzMzMZGRkzMzMAAAAAmcwAmc0AmcwzMzMAmcwzMzP///8zMzMAmcwzMzMzMzMzMzMAAAAzMjIAmcw3NzczMzMvLy8Amcz///8Am88Amc0BmcwzMjIAmcwzMzP///////8AmcwzMzMAmcwzMzMzMzMzMzMAAAAyMjL///8zMzMAmcwAms4NDQ0zMzMAAABiYmKOjo4AmcwAmcwAms0zMzMAmc0fHx8zMzIAAAAzMzMAmcwzMzMzMjJSUlIzMzMzMjIAms7MMzMQEBAAAAD///////8CAgIAAAA4ODj///9dXV0AmcwAmcwAmcwBAQEAmc0AmcwzMzMAms4zMzMyMjL///+zs7MAAAAvLS0AmcwAmcwzMzMzMzMzMjIAmc0AmcwAms0zMzMzMzMAms0zMzMAAAAfHx8AmcwAms0zMzMAms0zMzMAms0zMzMzMzMzMzMzMzMzMzMzMzMzMzPMMzP///8zMzMICAgzMzMAms0Ams3MMzMKCgozMjJ+fn4yMjL///+UlJT///8DAwP///8FBQUzMzMAmcwzMzMAmcwzMjEzMzNHR0cZGRkAAAAlJSX////KysppaWkAmcwAmcwAmcwzMzNAQEAhISGrq6t+fn5RUVEzMzMzMzMAmcwzMzPS0tLOMjKhoaFLS0tubm5vb2+NjY1CQkImJibVLizXLSp0dHRERETd3d0dHR2RkZEgICBxcXF9fX3GxsYQEBBWVlaHh4czMzMAmczPMTHTLy3WLSvFxcXKysokJCQcHBxPT09oaGikpKQSEhLQMTDPMjGpqam4uLhLS0sYGBiLi4sODg6dnZ2UlJTh4eE1NTVWVlbj4+OFhYUsKScCAgIkISAvLy8DAwMzMzMAmcwAAADMMzMAms3Q4KV9AAAA3nRSTlMATQL01gTiQZ5ZIs0c5/szZVvR0DFCEij5ClQMiAa8vgGDFS9VDwfdIegeDOdh8CT4/u+8BhX9gvQREbKQxvaU8eXpXbvt65AZu2tAUQnjVVNNq2bSJK4dJoze4KswNKuZGHjN3xmlDnG4e9bKsCFCwUSPR016bDzB+aaAWokuAuE1V/JHObd4ecqbN0FaO/BH8UsrZJqdZ8jVmdsqb6FgsNvTnMZKZ5E0fnS1QSeFoo2mVcS3erAwslWhddhHgGjSqYgeLl7UPTM4behncmfB6vJsVVFqHIuBPF6Wf2TjcLnEAAAL9ElEQVR42u2X91uUxxbHBynKCqywYSEIhhVpS5W6u6wgXZSA9N67SFFEkBKvil4VIxYswRI1GqPRxFTTNTG5yU29vXHvb7tz82fcM2X3fd9d2KzyPFHu4/eXnXJm5nxm5j1nFv262j3a2Nj4Alr8cnYxGAx+6PFq9ZqqS+uG27fsX7IAECcAcUCPpJjx8fHBgAVjhKXlGLm8VoQ8DpAJGJq9cqEcKwBD0LovHwOINwx1WShIFSdITWW/0QOLEoRzDO+sr6io3zlMifYvRpA1RlBNPuLaUUOqq39tkE0E5NkFhatIcHx5hdBQsRwaTpFSSFvlyco2cxgLDjt5MiwYWajjQUxvYoAAMgH5JLE3xs3SKa1bTMyGAOvco3Xr3Q2/QwTEWdwTCLMIA5JXSXVJcGTJ6rCwthC0BdyO5BycJN1o9H2mfsuBmugkY1J0d9p+aPM8tTUyFdojD6wQsfjc6A939IjNDu0ZrHNmINNRI07ZsR6OLg1+gSaXHkSdVoQ77opdH9owJgLc4KDqcQp3DHeIj49XwNDY/nhQA71gdbmK7NhdMGA6kdoeMEqV1MbPwbPdKyc1NfrypXRo9UQSeZIPXjyovVZcvWyKBQHjjgaz1o4xEA+hKT6G2SWGGwQ5nWCNbhu71rOW7CiDWI5a6L2xy1wPH0KgSxYg0W0UoypS3NhtkQSXeBltyjefXZZ4iQMbCYhUob1s5zkvJz5D2wQ4R2uQQXHDGALV+pqVSuMRAfFMlzqWjCy0hYfjmm6v7hxhE7rXrdoaSUth5ML0sA3rbxjpcoo1GM6YQWJdnELZbvc7U6fB6lDDbG5jfDgl2QRtD2L5cYQe6plQKBShUN51RQHq70B1HnQbukYaDmUbDHvp3oeZVEFvWfsSIW34Rtak+5LCDkuQAWo6UBGyBL6k/G4a1tIG6GcfvIJsSBqUMulimVr6yfZO908zkNBch96VzgEbMq9AhTmhHZ3Q8ks2SK7MIcBzcwSikajXIE5YR63ThNCP9iQ6NDhYZO8kcongQz3FdrvWszI4JDhsTXuq0Spr1BvFH04FOZQtkuOqCUYBxGvFBmHQSovwqyUkXchCGwneJgbi4TZn+GXzdAqBDYm1P5V4Xw9xjHLUCs+QyvY+ZKH9xGSFuZoGtUvmWhuZqZ6u7DFknUf4t8yPLFtrGW6JzTgH8Zk7IXaQGzg5T7a4zH3rIweTtFPSGWKVI6UgK8gDTAgF3fQ2qsgdsZkQY8g1eg1ZKBcaX7cN8qwLVGYDkbV49DoFPtOA9DKyrTQpiCdJmQIISZhrUBcslmsTRBsuPqCVPkMTDhNDL4ySDbANAnOD+vey07QOQ8tDYHNZlLKt4EibIGQv8hFxeqNNkJXC/6yOqB4XDxZ8yTEpdtsGcYAKqY+MJSKR+H2KruS76QVANpVs/CWQn/NRK4nwdoJkhhoE2QGCxk2W2afFd7Mt3RSFTibZcbH6fO0CWbt2rZ99IKPcKw9HRw/7QFCnOV/u6hRWXmXkoR/thEJksG2OgWijvSey1y6QvSw3Dk74POj1mZy1CwQlTr+ebXoySG7KMNwnlkNq5z6GSp40qpKMdoGQ2zJtBwhLOC7eiCvKPhDQBr8RR/pQ4GY7jKCcMFpexVObtbak1t5cs+Ymex22r7MJQqPWIVhi1B6QurXg8iZz6xm7QUA+9Bk0zvJdjugVslXiIHreLEgdgqqWDP8iCH1G9NgBQkNQqLP9IFLFk1tJk906ccDdKv3Wv/oN1/so34zhlY+QHSdC83aivSABkjeKItAaZJ5/iJmk3ZzbDiAu8nC8KVj99r9c70MYoIq85BmC7ALZsJ6kX3uvlhBEG+bO7EPkIS2ASA7wCvy+TP8JrRan7PY5QN4jPV4DfSdJRLMPBM0aQCrT2h1jm+YBcb5CcnmM6Vv3IHHIGiQGnvU8nAeiyVxTTy+Z8jQU0uk2r1vORao1IdYgt5EX/59uNwj/a+Sk2uvt7dc54gLezRN+p2lma5ye2HSikz4+wrXWILsV0LFe5eCdOauFB2ls/OiYt/feXLoGiXg5RmvtsAJ5H+2HoJv/cCBoItYg1pn5QJxfN0iViaQgPCxzxRIQsUbQPCDDliB/uI0OCInSbhDkLX55zH8iSNsjtovtRHOBBDbyfnj5D4ntu2gsizTOoZ1SkD9+TV2tQg8LghJVJhQPp9kYG49Gh6713NDldB2SgAiaVjCLDuR8oseU1p06WeQ++YxU9SQApw6IQX73NaqPhpS5GgmqBFOhHgy1Smmn6fSenYwaVI12+vkEkE31qaur6xCuPalqecXtROeoanB6yFR3fgE6A5BEuyc3qm6M9QbSPZrYeAPsJ7mJtep9yUOYfybvAcZ7z6O+HPqmXFxiCSOpiu737a9uQ8pMJmxpaLGJ/9tIT64PJhf+y+QaUq0NQYtPN5N4Ft86vDX9Z1pMA45FqD4vo0TpL6NFqpCdIpSa5NVo8SqkL3lVd3rk5eGqHcHoqZ7qqZ7qyVMxRo8if9Owwjjs/zg99sdyVvggAz2KlvHZ5LhUf03Sw5tBcVkyNK9kLRhn6YT6wTioc/sSfBDNr+ew1JGlrLCnaEEgKvyjOsK6eylOuXDhsDsuQfOpBesP42JRNU8P9oW0clXz0kODgBYE8gqbxxpkWUREWdFZfu7W0uEUddlZd+GC6Peoy4pasY4cFm7G8ocE4TfOPw7H0Zu+rRrHzcBvdXEJNG2jLfTIuVEh8SELWjhINQYJRv54m78/B0GgP+PtzL5FBu6RHjk/pAR8Fenc30FcBa1qBPoTvVPbS5WlHyEu7hsMLCyGeXQUJK4agXALB+F8BOZiczlZZxsubb6IsxBy31egP6zBMiSHlsP7yLgZXN78DnEjC6foP8AM5MMU/MYFVEiNpnQw6/dBQSKQiAy4I3H79G+4Y11EaQFxEn+DqFLwTNy5W4gLMyQlfpdQ3UEf7xM+7XLwrRhmnPpAn4JbqMflWE6cvWgBIscp55VBeRg2OOOI8vxb4L/7d0Xqsn/gb2HhH5VlencZMQpSHm29TwvqPWBNlLAMfxqBCmBYWTP+O4IaQiIQ5O4Op9SsbroHW32HrF5QmsAsrmlw3rEEM8ib/Pc5cFBThpq+YwfHlg1KwfKlOG+PGpzUEY9fxCqEGvHvLUBU+EUo3LoAp58nk8n+jTOJAwh9imfRq/gnuU5dFAFGP0CfwmT9JhauqAyXk92E3YeaFchLmrsy2V3Y6jLNdjD9mDs4pdHs0yFZsZwBLBNAfiotLCx85yqt89XA8aXASpadBI/JWnRPpCD8g02IgOWZvqcg1JumN87RGw5GTNx6mQBC7LjT1iDnkDumAg/zXkIHNU3MoFrzr2a4J5l8AI43g+gwk0wIJjDdKzAjW45+DBexTo7vIAuQ66byXZziSqQWQFDTsf80u2M5GDXTPhhpCXKXg5yzApHhz9G5DDruKNlX2dU81g+HmKBsxsXvapS0nvEJv0jX0UFmn7GdtlznINelINfwX1X4G0uQt7GK5eqIjALWKIBkVaME5Rc4E4zYzOhVat0ggPBhcnDaEqQYLsbn5lCqzNgOdaq/4Xio6zG+yOrlLIPch2tfUM5aqCt82e34bSlIROm7V88mMAf+IgPp6I07iw/K/TFs1hc4S75tpkUE8hlpKcD/JEb+ssIWf9TUiv0LZ7AAwoaVTGluSUBkspJqfFiJbmmmSuQH4whN+fEMJetPyMMz8sL7GP/A6kGteKYQ7PUJcvwq3y8S/Omy4NtZpRQE3XHHn3EHqKpp89G84/j4W3sQUkOcxAWfiUDUemg5dyECjFKO4ynFNQi5pRh/clgA4cNK7yWIQUBTpRfKwOd7YH+8nBBcgwPg2vPWPphXX2o6rmO0ju/rPuJfUZOGpBK27PGUo8gCpAxr1GwLXKmK0FFXMu1m183n6fAiaAOLoiKyG65B4CS0HIugQ8DoCJQSjkBLmSvi8yj5MOjiNToURKxBEUegGERLrrAI1/nNMIv6CB/A63rccmszb9gMG2taNog6w5ZjHiNNHnqCpdZ/nGCfZQncwCeapMkuM1nJVCtYLn59i1s/RP8PKnPlr5v/ATeU1EkHfFh/AAAAAElFTkSuQmCC", t.ErrorImage = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVQIHWP4zwAAAgEBAMVfG14AAAAASUVORK5CYII="
        }(e = t.Resources || (t.Resources = {}))
    }(e = t.Internal || (t.Internal = {}))
}(ZoomCharts || (ZoomCharts = {}));
var ZoomCharts;
!function (t) {
    var e;
    !function (t) {
        var e;
        !function (t) {
            var e = function () {
                function t() {
                    this.id = "default", this.url = null, this.urlParameters = [], this.postprocessorFunction = null, this.preloaded = null, this.format = "JSON", this.requestTimeout = 4e4, this.numberOfParallelRequests = 3
                }

                return t
            }();
            t.SettingsData = e;
            var i = function () {
                function e(t, e) {
                    this.removed = !1, this.requestScheduled = !1, this.requestsRunning = !1, this.requestCount = 0, this.dataSettings = e, this.chart = t, this.settings = t.settings
                }

                return e.doRequest = function (e, i, n, s, o) {
                    if (i.urlParameters.length) {
                        n = n.slice();
                        for (var r = 0; r < i.urlParameters.length; r++) {
                            var a = i.urlParameters[r];
                            n.push([a.name, a.value])
                        }
                    }
                    var h;
                    h = i.postprocessorFunction ? function (t) {
                            return s(i.postprocessorFunction(t))
                        } : s, t.Helpers.doRequest(e, i.requestTimeout, n, h, o)
                }, e.prototype.buildRequest = function () {
                    return null
                }, e.prototype.dataFunc = function () {
                    throw new Error("Must be implemented in the base class")
                }, e.prototype.verifyData = function () {
                    return !0
                }, e.prototype.addVerifiedData = function () {
                    return {}
                }, e.prototype.requestFailedPermanently = function () {
                }, e.prototype.removeData = function () {
                    return null
                }, e.prototype.exportData = function () {
                    for (var t = [], e = 0; e < arguments.length; e++)t[e - 0] = arguments[e];
                    return null
                }, e.prototype.remove = function () {
                    this.removed = !0
                }, e.prototype.hasPendingRequests = function () {
                    return this.removed ? !1 : this.requestCount > 0
                }, e.prototype.addData = function (t) {
                    this._dataArrived(null, t)
                }, e.prototype.applyPreloadedData = function () {
                    this.dataSettings.preloaded && this._dataArrived(null, this.dataSettings.preloaded)
                }, e.prototype.scheduleRequests = function (t) {
                    var e = this;
                    void 0 === t && (t = !1), t ? this._runRequests() : this.requestScheduled || (this.requestScheduled = !0, setTimeout(function () {
                            return e._runRequests()
                        }, 0))
                }, e.prototype._runRequests = function () {
                    var t = this;
                    if (!this.removed && !this.requestsRunning) {
                        this.requestScheduled = !1;
                        var e;
                        try {
                            for (this.requestsRunning = !0; this.requestCount < this.dataSettings.numberOfParallelRequests && (e = this.buildRequest(), null !== e);)!function (e) {
                                var i = function (i) {
                                    return t._dataArrived(e, i)
                                }, n = function (i) {
                                    return t._dataError(e, i)
                                };
                                t.requestCount += 1, t.chart.log("Requesting data for", e), t.dataFunc(e, i, n)
                            }(e)
                        } finally {
                            this.requestsRunning = !1
                        }
                    }
                }, e.prototype._dataError = function (e, i) {
                    if (!this.removed) {
                        if (this.requestCount -= 1, e && this.chart.error("Data request resulted in error", e), i) {
                            var n = t.Helpers.parseData(i, this.dataSettings.format, this.chart);
                            n.error && this.chart.error(n.error)
                        }
                        this.requestFailedPermanently(e), this._runRequests()
                    }
                }, e.prototype._dataArrived = function (e, i) {
                    if (!this.removed) {
                        this.requestCount -= 1, e && this.chart.log("Data arrived for request", e);
                        var n, s = !1;
                        if (i ? (n = t.Helpers.parseData(i, this.dataSettings.format, this.chart), n.error && this.chart.error(n.error), s = this.verifyData(e, n)) : this.chart.error("Data request returned empty result"), s) {
                            var o = this.addVerifiedData(e, n);
                            o.dataArrived = {}, o.dataArrived[this.dataSettings.id] = !0, this.chart.events.notifySceneChanges(o)
                        } else e && this.requestFailedPermanently(e);
                        this._runRequests()
                    }
                }, e
            }();
            t.Data = i
        }(e = t.Base || (t.Base = {}))
    }(e = t.Internal || (t.Internal = {}))
}(ZoomCharts || (ZoomCharts = {}));
var ZoomCharts;
!function (t) {
    var e;
    !function (t) {
        var e;
        !function (t) {
            var e = function () {
                function t(t, e, i, n) {
                    this.consumed = !1, this.defaultPrevented = !1, this.x = 0, this.y = 0, this.dx = 0, this.dy = 0, this.wheely = 0, this.wheelx = 0, this.identifier = "0", this.pressed = !1, this.touch = !1, this.pageX = 0, this.pageY = 0, this.shiftKey = !1, this.altKey = !1, this.ctrlKey = !1, this.target = null, this.isRightMB = !1, this._vx = null, this._vy = null, this.velocityPointer = null, this._leaving = !1, this.swipeUp = !1, this.swipeDown = !1, this.swipeLeft = !1, this.swipeRight = !1, this.swipeSpeed = null, this.capture = !1, this.hovered = !1, this.noDefault = !1, this.cursor = null, this.changedPointerCount = 1, this.identifier = n, this.timeStamp = i, this.y = e, this.x = t
                }

                return t.prototype.preventDefault = function () {
                    this.defaultPrevented = !0
                }, Object.defineProperty(t.prototype, "vx", {
                    get: function () {
                        return null === this._vx && null !== this.velocityPointer && this.velocityPointer.calculatePosAndSpeed(this), this._vx || 0
                    }, set: function (t) {
                        this._vx = t
                    }, enumerable: !0, configurable: !0
                }), Object.defineProperty(t.prototype, "vy", {
                    get: function () {
                        return null === this._vy && null !== this.velocityPointer && this.velocityPointer.calculatePosAndSpeed(this), this._vy || 0
                    }, set: function (t) {
                        this._vy = t
                    }, enumerable: !0, configurable: !0
                }), t.prototype.distance = function (t) {
                    return Math.sqrt((t.x - this.x) * (t.x - this.x) + (t.y - this.y) * (t.y - this.y))
                }, t.prototype.isWithinDistance = function (t, e, i) {
                    if (!t)return !1;
                    var n = this.pageX - t.pageX, s = this.pageY - t.pageY;
                    return e * e > n * n + s * s && (null == i || t.timeStamp + i > this.timeStamp)
                }, t
            }();
            t.MouseEvent = e;
            var i = function () {
                function t(t, e) {
                    this.noClick = !1, this.scrolling = !1, this.settings = e, this.identifier = t.identifier, this.touch = !1, this.x = t.x, this.y = t.y, this.pageX = t.pageX, this.pageY = t.pageY, this.timeStamp = t.timeStamp, this.pts = [[this.x, this.y, this.timeStamp]]
                }

                return t.prototype.moveTo = function (t) {
                    t.timeStamp === this.timeStamp && this.pts.pop(), this.timeStamp = t.timeStamp, t.x || t.y ? (t.dx = t.x - this.x, t.dy = t.y - this.y, this.x = t.x, this.y = t.y) : (t.dx = 0, t.dy = 0, t.x = this.x, t.y = this.y), this.pts.push([this.x, this.y, this.timeStamp]), this.pts.length > 6 && this.pts.shift()
                }, t.prototype.getPosAndSpeed = function (t) {
                    t.touch = this.touch, t.velocityPointer = this, t.vx = null, t.vy = null
                }, t.prototype.calculatePosAndSpeed = function (t) {
                    var e, i = 250, n = 50, s = t.timeStamp - i, o = 0;
                    for (o = 0; o < this.pts.length && (e = this.pts[o], !(e[2] > s)); o++);
                    return i = t.timeStamp - e[2], o === this.pts.length || n > i ? (t.vx = 0, void(t.vy = 0)) : (t.vx = (this.x - e[0]) / i, void(t.vy = (this.y - e[1]) / i))
                }, t
            }(), n = function () {
                function n(e, i, n) {
                    var s = this;
                    void 0 === n && (n = null), this.scaleX = 1, this.scaleY = 1, this.nextFakeMouseId = 1, this.doubleClickTimeout = null, this.longPressTimeout = null, this.longPressInitiator = null, this.listeners = {}, this.downPointers = {}, this.inPointers = {}, this.containerList = [], this.clickCounter = 1, this.lastClickEvent = null, this.ID_MOUSE = "mouse", this.settings = i, this.container = e, this.lastEvent = null, this.lastTouchEvent = null, this.clickEvent = null, "undefined" != typeof PointerEvent ? (this.container.style["touch-action"] = "none", this.containerEvents = {
                            pointerdown: function (t) {
                                return s.filterEvent(t, function (t) {
                                    return s.handlePointerDown(t)
                                })
                            }, contextmenu: function (t) {
                                return s.filterEvent(t, function (t) {
                                    return s.handleCMenu(t)
                                })
                            }, mousewheel: function (t) {
                                return s.filterEvent(t, function (t) {
                                    return s.handleMouseWheel(t)
                                })
                            }, dragover: function (t) {
                                return s.filterEvent(t, function (t) {
                                    return s.handleMouseMove(t)
                                })
                            }
                        }, this.windowEvents = {
                            pointerdown: function (t) {
                                return s.filterEvent(t, function (t) {
                                    return s.handlePointerDown(t)
                                })
                            }, pointermove: function (t) {
                                return s.filterEvent(t, function (t) {
                                    return s.handlePointerMove(t)
                                })
                            }, pointerup: function (t) {
                                return s.filterEvent(t, function (t) {
                                    return s.handlePointerUp(t)
                                })
                            }, pointercancel: function (t) {
                                return s.filterEvent(t, function (t) {
                                    return s.handlePointerCancel(t)
                                })
                            }, pointerleave: function (t) {
                                return s.filterEvent(t, function (t) {
                                    return s.handlePointerLeave(t)
                                })
                            }
                        }) : "undefined" != typeof MSPointerEvent ? (this.container.style["-ms-touch-action"] = "none", this.containerEvents = {
                                MSPointerDown: function (t) {
                                    return s.filterEvent(t, function (t) {
                                        return s.handlePointerDown(t)
                                    })
                                }, contextmenu: function (t) {
                                    return s.filterEvent(t, function (t) {
                                        return s.handleCMenu(t)
                                    })
                                }, mousewheel: function (t) {
                                    return s.filterEvent(t, function (t) {
                                        return s.handleMouseWheel(t)
                                    })
                                }, dragover: function (t) {
                                    return s.filterEvent(t, function (t) {
                                        return s.handleMouseMove(t)
                                    })
                                }
                            }, this.windowEvents = {
                                MSPointerDown: function (t) {
                                    return s.filterEvent(t, function (t) {
                                        return s.handlePointerDown(t)
                                    })
                                }, MSPointerMove: function (t) {
                                    return s.filterEvent(t, function (t) {
                                        return s.handlePointerMove(t)
                                    })
                                }, MSPointerUp: function (t) {
                                    return s.filterEvent(t, function (t) {
                                        return s.handlePointerUp(t)
                                    })
                                }, MSPointerCancel: function (t) {
                                    return s.filterEvent(t, function (t) {
                                        return s.handlePointerCancel(t)
                                    })
                                }, MSPointerLeave: function (t) {
                                    return s.filterEvent(t, function (t) {
                                        return s.handlePointerLeave(t)
                                    })
                                }
                            }) : (this.containerEvents = {
                                mousedown: function (t) {
                                    return s.filterEvent(t, function (t) {
                                        return s.handleMouseDown(t)
                                    })
                                }, contextmenu: function (t) {
                                    return s.filterEvent(t, function (t) {
                                        return s.handleCMenu(t)
                                    })
                                }, mousewheel: function (t) {
                                    return s.filterEvent(t, function (t) {
                                        return s.handleMouseWheel(t)
                                    })
                                }, dragover: function (t) {
                                    return s.filterEvent(t, function (t) {
                                        return s.handleMouseMove(t)
                                    })
                                }, DOMMouseScroll: function (t) {
                                    return s.filterEvent(t, function (t) {
                                        return s.handleMouseWheel(t)
                                    })
                                }, touchstart: function (t) {
                                    return s.filterEvent(t, function (t) {
                                        return s.handleTouchStart(t)
                                    })
                                }
                            }, this.windowEvents = {
                                mousedown: function (t) {
                                    return s.filterEvent(t, function (t) {
                                        return s.handleMouseDown(t)
                                    })
                                }, mouseup: function (t) {
                                    return s.filterEvent(t, function (t) {
                                        return s.handleMouseUp(t)
                                    })
                                }, mousemove: function (t) {
                                    return s.filterEvent(t, function (t) {
                                        return s.handleMouseMove(t)
                                    })
                                }, touchstart: function (t) {
                                    return s.filterEvent(t, function (t) {
                                        return s.handleTouchStart(t)
                                    })
                                }, touchend: function (t) {
                                    return s.filterEvent(t, function (t) {
                                        return s.handleTouchEnd(t)
                                    })
                                }, touchcancel: function (t) {
                                    return s.filterEvent(t, function (t) {
                                        return s.handleTouchCancel(t)
                                    })
                                }, touchmove: function (t) {
                                    return s.filterEvent(t, function (t) {
                                        return s.handleTouchMove(t)
                                    })
                                }, mouseout: function (t) {
                                    return s.filterEvent(t, function (t) {
                                        return s.handleMouseOut(t)
                                    })
                                }
                            }), this.keyDownEvent = function (t) {
                        return s.handleKeyDown(t)
                    };
                    for (var o in this.windowEvents) {
                        var r = this.windowEvents[o];
                        t.Helpers.listen(window, o, r)
                    }
                    if (this.addContainer(e), n)for (var a = 0; a < n.length; a++)this.addContainer(n[a])
                }

                return n.prototype.addContainer = function (e) {
                    this.containerList.push(e);
                    var i, n;
                    for (i in this.containerEvents)n = this.containerEvents[i], t.Helpers.listen(e, i, n);
                    for (i in this.windowEvents)n = this.windowEvents[i], t.Helpers.listen(e, i, n);
                    t.Helpers.listen(e, "keydown", this.keyDownEvent)
                }, n.prototype.remove = function () {
                    for (var e in this.windowEvents) {
                        var i = this.windowEvents[e];
                        t.Helpers.unlisten(window, e, i)
                    }
                    for (var n = 0; n < this.containerList.length; n++) {
                        var s = this.containerList[n];
                        for (var e in this.containerEvents) {
                            var i = this.containerEvents[e];
                            t.Helpers.unlisten(s, e, i)
                        }
                        t.Helpers.unlisten(s, "keydown", this.keyDownEvent)
                    }
                }, n.prototype.listen = function (t, e) {
                    this.listeners[t] = e
                }, n.prototype.processConsumed = function (e, i) {
                    i.consumed && t.Helpers.stopPropagation(e)
                }, n.prototype.handleKeyDown = function (t) {
                    t.keyCode || (t.keyCode = t.which), this.fireEvent(n.EVENT_KEY, t), this.processConsumed(t, t)
                }, n.prototype.filterEvent = function (t, e) {
                    t !== this.lastEvent && (this.lastEvent = t, e(t))
                }, n.prototype.handlePointerDown = function (t) {
                    var e = this.buildEvent(t, t.pointerId.toString(), t.timeStamp, t.buttons > 0), i = "touch" === t.pointerType || 2 === t.pointerType;
                    this.downHappened(e, i), this.processConsumed(t, e)
                }, n.prototype.handlePointerMove = function (t) {
                    var e = this.buildEvent(t, t.pointerId.toString(), t.timeStamp, t.buttons > 0);
                    this.moveHappened(e), this.processConsumed(t, e)
                }, n.prototype.handlePointerUp = function (t) {
                    if (0 === t.buttons) {
                        var e = this.buildEvent(t, t.pointerId.toString(), t.timeStamp, !1);
                        e.isRightMB = 2 === t.button, this.upHappened(e), this.processConsumed(t, e)
                    }
                }, n.prototype.handlePointerCancel = function (t) {
                    var e = this.buildEvent(t, t.pointerId.toString(), t.timeStamp, !1);
                    this.cancelHappened(e)
                }, n.prototype.handlePointerLeave = function (t) {
                    var e = this.buildEvent(t, t.pointerId.toString(), t.timeStamp, !1);
                    this.moveHappened(e)
                }, n.prototype.handleMouseDown = function (t) {
                    var e = this.buildEvent(t, this.ID_MOUSE, t.timeStamp, !0);
                    e.isWithinDistance(this.lastTouchEvent, this.settings.doubleClickSensitivity, this.settings.longPressTimeout) || (this.downHappened(e, !1), this.processConsumed(t, e))
                }, n.prototype.handleCMenu = function (t) {
                    var e;
                    if (e = t.which ? 3 === t.which : 2 === t.button) {
                        var i = this.buildEvent(t, this.ID_MOUSE, t.timeStamp, !0);
                        for (var n in this.downPointers) {
                            var s = this.downPointers[n];
                            this.downPointers.hasOwnProperty(n) && (i = this.rebuildEvent(t, s, !1), this.cancelHappened(i))
                        }
                        this.rclickHappened(i), this.processConsumed(t, i)
                    }
                }, n.prototype.handleMouseWheel = function (t) {
                    if (this.isTargetOkay(t.target)) {
                        var e = this.buildEvent(t, this.ID_MOUSE, t.timeStamp, !0);
                        e.wheely = t.wheelDelta || -40 * t.detail, this.wheelHappened(e), this.processConsumed(t, e)
                    }
                }, n.prototype.handleMouseUp = function (t) {
                    if (t.shiftKey && t.ctrlKey)return this.ID_MOUSE = "mouse" + this.nextFakeMouseId, void(this.nextFakeMouseId += 1);
                    var e = this.buildEvent(t, this.ID_MOUSE, t.timeStamp, !1);
                    e.isRightMB = t.which ? 3 === t.which : 2 === t.button, this.upHappened(e), this.processConsumed(t, e), this.removeLostTouches(t, [], [])
                }, n.prototype.handleMouseMove = function (t) {
                    var e = this.buildEvent(t, this.ID_MOUSE, t.timeStamp, !1);
                    e.isWithinDistance(this.lastTouchEvent, this.settings.doubleClickSensitivity, this.settings.longPressTimeout) || (this.moveHappened(e), this.processConsumed(t, e))
                }, n.prototype.handleMouseOut = function (t) {
                    var e = this.buildEvent(t, this.ID_MOUSE, t.timeStamp, !1);
                    e.target = t.relatedTarget, this.moveHappened(e)
                }, n.prototype.handleTouchStart = function (t) {
                    this.removeLostTouches(t, t.touches, t.changedTouches);
                    for (var e, i = !1, n = t.changedTouches || t.touches, s = 0; s < n.length; s++) {
                        var o = n[s];
                        e = this.buildEvent(o, o.identifier, t.timeStamp, !0, n.length), this.lastTouchEvent = e, this.downHappened(e, !0), i = i || e.consumed
                    }
                    this.processConsumed(t, e)
                }, n.prototype.handleTouchEnd = function (t) {
                    for (var e, i = t.changedTouches || t.touches, n = !1, s = 0; s < i.length; s++) {
                        var o = i[s];
                        e = this.buildEvent(o, o.identifier, t.timeStamp, !1, i.length), this.lastTouchEvent = e, this.upHappened(e), this.pointerLeave(e), n = n || e.consumed, this.removeLostTouches(t, t.touches)
                    }
                    this.processConsumed(t, e)
                }, n.prototype.handleTouchCancel = function (t) {
                    for (var e = t.changedTouches || t.touches, i = 0; i < e.length; i++) {
                        var n = e[i], s = this.buildEvent(n, n.identifier, t.timeStamp, !1, e.length);
                        this.lastTouchEvent = s, this.cancelHappened(s)
                    }
                    this.removeLostTouches(t, t.touches)
                }, n.prototype.handleTouchMove = function (t) {
                    var e = !1;
                    this.removeLostTouches(t, t.touches);
                    for (var i, n = t.changedTouches || t.touches, s = 0; s < n.length; s++) {
                        var o = n[s];
                        i = this.buildEvent(o, o.identifier, t.timeStamp, !0, n.length), this.lastTouchEvent = i, this.moveHappened(i), e = e || i.consumed
                    }
                    this.processConsumed(t, i)
                }, n.prototype.removeLostTouches = function (t, e, i) {
                    void 0 === i && (i = null);
                    for (var n = [], s = 0; s < e.length; s++) {
                        var o = e[s];
                        n[o.identifier] = !0
                    }
                    for (var r in this.downPointers) {
                        var a = this.downPointers[r];
                        if (this.downPointers.hasOwnProperty(r) && !n[r]) {
                            var h = this.rebuildEvent(t, a, !1);
                            this.upHappened(h)
                        }
                    }
                    if (null !== i)for (var s = 0; s < i.length; s++) {
                        var o = i[s], a = this.downPointers[o.identifier];
                        if (a) {
                            var h = this.rebuildEvent(t, a, !1);
                            this.upHappened(h)
                        }
                    }
                }, n.prototype.rebuildEvent = function (t, i, n) {
                    var s = new e(i.x, i.y, t.timeStamp, i.identifier);
                    return s.pageX = i.pageX, s.pageY = i.pageY, s.pressed = n, s.shiftKey = t.shiftKey, s.altKey = t.altKey, s.ctrlKey = t.ctrlKey, s
                }, n.prototype.buildEvent = function (i, n, s, o, r) {
                    void 0 === r && (r = 1);
                    var a, h, l = i.pageX, u = i.pageY, c = (!i.currentTarget || i.currentTarget === this.container) && i.target === this.container;
                    if (c && void 0 !== i.offsetX) a = i.offsetX, h = i.offsetY; else if (c && void 0 !== i.layerX) a = i.layerX, h = i.layerY; else {
                        var p = t.Helpers.convertPointFromPageToNode(this.container, l, u, i.clientX, i.clientY);
                        a = p.x, h = p.y
                    }
                    var d = new e(Math.round(a * this.scaleX), Math.round(h * this.scaleY), s, "" + n);
                    return d.target = i.target || i.srcElement, d.pageX = l, d.pageY = u, d.shiftKey = i.shiftKey, d.altKey = i.altKey, d.ctrlKey = i.ctrlKey, d.pressed = o, d.changedPointerCount = r, d
                }, n.prototype.downHappened = function (t, e) {
                    if (t.pressed = !0, this.fireEvent(n.EVENT_GLOBAL_DOWN, t), this.isTargetOkay(t.target) && (this.container.focus(), !this.downPointers[t.identifier])) {
                        this.click_Hold();
                        var s = new i(t, this.settings);
                        this.downPointers[t.identifier] = s, s.touch = e, this.inPointers[t.identifier] = !0, this.fireEvent(n.EVENT_DOWN, t), this.startLongPress(t)
                    }
                }, n.prototype.upHappened = function (t) {
                    if (this.downPointers[t.identifier]) {
                        var e = this.downPointers[t.identifier];
                        this.cancelLongPress(), e.moveTo(t), e.getPosAndSpeed(t), delete this.downPointers[t.identifier];
                        var i = t.vx, s = t.vy;
                        Math.abs(i) > 2 * Math.abs(s) ? (t.swipeSpeed = Math.abs(i), i > 0 && (t.swipeLeft = !0), 0 > i && (t.swipeRight = !0)) : Math.abs(s) > 2 * Math.abs(i) && (t.swipeSpeed = Math.abs(s), 0 > s && (t.swipeUp = !0), s > 0 && (t.swipeDown = !0)), this.fireEvent(n.EVENT_UP, t), t.isWithinDistance(e, this.settings.clickSensitivity, this.settings.doubleClickTimeout) && (t.isRightMB || e.noClick || this.click_Next(t))
                    }
                }, n.prototype.cancelHappened = function (t) {
                    this.downPointers[t.identifier] && (this.cancelLongPress(), delete this.downPointers[t.identifier], this.fireEvent(n.EVENT_CANCEL, t))
                }, n.prototype.moveHappened = function (t) {
                    var e = this.downPointers[t.identifier];
                    t.pressed = void 0 !== e && null !== e, void 0 !== e && null !== e ? (this.cancelLongPress(t), e.scrolling = !0, e.moveTo(t), e.getPosAndSpeed(t), this.fireEvent(n.EVENT_DRAG, t), this.click_Cancel(t)) : this.click_OnMove(t) || (this.isTargetOkay(t.target) ? (this.inPointers[t.identifier] = !0, this.fireEvent(n.EVENT_MOVE, t)) : this.pointerLeave(t))
                }, n.prototype.wheelHappened = function (t) {
                    this.fireEvent(n.EVENT_WHEEL, t)
                }, n.prototype.rclickHappened = function (t) {
                    this.fireEvent(n.EVENT_RCLICK, t)
                }, n.prototype.pointerLeave = function (t) {
                    return this.inPointers.hasOwnProperty(t.identifier) ? (this.click_Cancel(t) || this.fireEvent(n.EVENT_LEAVE, t), delete this.inPointers[t.identifier]) : void 0
                }, n.prototype.click_Next = function (t) {
                    var e, i = this;
                    switch (this.clickCounter) {
                        case 1:
                            e = n.EVENT_CLICK;
                            break;
                        case 2:
                            e = n.EVENT_DBLCLICK;
                            break;
                        default:
                        case 3:
                            e = n.EVENT_TPLCLICK
                    }
                    var s = null !== this.clickEvent && this.clickEvent.timeStamp + this.settings.doubleClickTimeout >= t.timeStamp && this.clickEvent.distance(t) < this.settings.doubleClickSensitivity;
                    s && clearTimeout(this.doubleClickTimeout), (s || 1 === this.clickCounter) && (this.settings.noClickOnDoubleClick && (this.doubleClickTimeout = setTimeout(function () {
                        return i.fireClick(e)
                    }, this.settings.doubleClickTimeout)), this.settings.noClickOnDoubleClick || this.fireEvent(e, t), this.lastClickEvent = e), this.clickEvent = t, this.clickCounter++, this.settings.noClickOnDoubleClick || setTimeout(function () {
                        i.clickEvent = i.lastClickEvent = null, i.clickCounter = 1
                    }, this.settings.doubleClickTimeout)
                }, n.prototype.click_Cancel = function (t) {
                    return this.clickEvent && this.clickEvent.identifier === t.identifier ? (this.clickEvent._leaving = !0, !0) : !1
                }, n.prototype.click_Hold = function () {
                    void 0 !== this.doubleClickTimeout && null !== this.doubleClickTimeout && (clearTimeout(this.doubleClickTimeout), this.doubleClickTimeout = null)
                }, n.prototype.click_OnMove = function (t) {
                    return this.clickEvent && this.settings.noClickOnDoubleClick ? this.clickEvent.distance(t) < this.settings.doubleClickSensitivity ? !0 : (this.fireEvent(this.lastClickEvent, this.clickEvent), this.clickEvent = this.lastClickEvent = null, this.clickCounter = 1, !1) : !1
                }, n.prototype.fireClick = function (t) {
                    this.clickEvent && (this.fireEvent(t, this.clickEvent), this.clickEvent._leaving && this.fireEvent(n.EVENT_LEAVE, this.clickEvent), this.clickEvent = null, this.clickCounter = 1)
                }, n.prototype.startLongPress = function (t) {
                    var e = this, i = function () {
                        e.longPressTimeout = null, e.longPressInitiator = null, t.consumed = !1, e.fireEvent(n.EVENT_RCLICK, t), t.consumed && (e.downPointers[t.identifier].noClick = !0)
                    };
                    this.cancelLongPress(), this.longPressTimeout = setTimeout(i, this.settings.longPressTimeout), this.longPressInitiator = t
                }, n.prototype.cancelLongPress = function (t) {
                    if (null !== this.longPressTimeout) {
                        if (t && t.isWithinDistance(this.longPressInitiator, this.settings.longPressSensitivity))return;
                        clearTimeout(this.longPressTimeout), this.longPressTimeout = null, this.longPressInitiator = null
                    }
                }, n.prototype.fireEvent = function (t, e) {
                    this.listeners[t] && this.listeners[t].call(this, e)
                }, n.prototype.isTargetOkay = function (e) {
                    return -1 !== this.containerList.indexOf(e) || t.Helpers.isParentOf(this.container, e)
                }, n.EVENT_MOVE = "move", n.EVENT_DOWN = "down", n.EVENT_GLOBAL_DOWN = "gdown", n.EVENT_DRAG = "drag", n.EVENT_CANCEL = "cancel", n.EVENT_UP = "up", n.EVENT_LEAVE = "leave", n.EVENT_CLICK = "click", n.EVENT_RCLICK = "rclick", n.EVENT_DBLCLICK = "dblclick", n.EVENT_TPLCLICK = "tplclick", n.EVENT_WHEEL = "mwheel", n.EVENT_KEY = "key", n
            }();
            t.MouseEvents = n
        }(e = t.Base || (t.Base = {}))
    }(e = t.Internal || (t.Internal = {}))
}(ZoomCharts || (ZoomCharts = {}));
var ZoomCharts;
!function (t) {
    var e;
    !function (t) {
        var e;
        !function (t) {
            var e = function () {
                function t() {
                    this.timeStamp = 0, this.dtime = 0, this.animating = !1, this.isExport = !1, this.context = null, this.scaleX = 1, this.scaleY = 1, this.labelRenderer = null, this.changes = {}
                }

                return t
            }();
            t.UpdateEvent = e;
            var i = function () {
                function t() {
                    this.keyCode = null, this.capture = !1, this.consumed = !1, this.noDefault = !1, this.cursor = null, this.target = null
                }

                return t
            }();
            t.KeyEvent = i
        }(e = t.Base || (t.Base = {}))
    }(e = t.Internal || (t.Internal = {}))
}(ZoomCharts || (ZoomCharts = {}));
var ZoomCharts;
!function (t) {
    var e;
    !function (t) {
        var e;
        !function (t) {
            var e = function () {
                function t() {
                    this.animationOrder = 0, this.updateOrder = 0, this.paintOrder = 0
                }

                return t.prototype.remove = function () {
                }, t.prototype.onSceneChange = function () {
                }, t.prototype.getPanels = function () {
                    return []
                }, t.prototype.doAnimations = function () {
                }, t.prototype.paintScene = function () {
                }, t.prototype.onClick = function () {
                }, t.prototype.onRClick = function () {
                }, t.prototype.onDoubleClick = function () {
                }, t.prototype.onTripleClick = function () {
                }, t.prototype.onPointerDown = function () {
                }, t.prototype.onPointerUp = function () {
                }, t.prototype.onPointerDrag = function () {
                }, t.prototype.onPointerMove = function () {
                }, t.prototype.onPointerOut = function () {
                }, t.prototype.onPointerCancel = function () {
                }, t.prototype.onWheel = function () {
                }, t.prototype.onKeyDown = function () {
                }, t.prototype.previewWheel = function () {
                }, t.prototype.previewGlobalPointerDown = function () {
                }, t.prototype.previewPointerDown = function () {
                }, t.prototype.previewPointerUp = function () {
                }, t.prototype.previewPointerDrag = function () {
                }, t.prototype.previewPointerMove = function () {
                }, t.prototype.previewPointerOut = function () {
                }, t.prototype.containsCoordinate = function (t, e) {
                    var i = this.getPanels(!1);
                    if (!i || !i.length)return !1;
                    for (var n = 0; n < i.length; n++) {
                        var s = i[n];
                        if (s.left < t && s.right > t && s.top < e && s.bottom > e)return !0
                    }
                    return !1
                }, t
            }();
            t.ChartElement = e
        }(e = t.Base || (t.Base = {}))
    }(e = t.Internal || (t.Internal = {}))
}(ZoomCharts || (ZoomCharts = {}));
var ZoomCharts;
!function (t) {
    var e;
    !function (t) {
        var e;
        !function (t) {
            var e = function () {
                function t(t, e, i, n) {
                    this.side = "top", this.align = "fill", this.floating = !1, this.margin = 0, this.location = "outside", this.packingOrder = void 0, void 0 !== t && (this.side = t), void 0 !== e && (this.align = e), void 0 !== i && (this.margin = i), void 0 !== n && (this.packingOrder = n)
                }

                return t
            }();
            t.SettingsChartPanel = e;
            var i = function () {
                function t() {
                    this.packingOrder = 0, this.location = "outside", this.side = "top", this.align = "fill", this.floating = !1, this.desiredWidth = 0, this.desiredHeight = 0, this.margin = 0, this.left = 0, this.top = 0, this.right = 0, this.bottom = 0, this.visible = !1, this._tempData = null
                }

                return t.prototype.computeSize = function () {
                    return {width: this.desiredWidth, height: this.desiredHeight}
                }, t.prototype.placePanel = function (t, e, i, n) {
                    this.bottom = n, this.right = i, this.top = e, this.left = t
                }, t
            }();
            t.ChartPanel = i
        }(e = t.Base || (t.Base = {}))
    }(e = t.Internal || (t.Internal = {}))
}(ZoomCharts || (ZoomCharts = {}));
var ZoomCharts;
!function (t) {
    var e;
    !function (t) {
        var e;
        !function (t) {
            var e = function () {
                function e(t) {
                    this.framesCount = 0, this.shell = t, this.record = {}, this.recording = !1, this.playback = !1, this.eventPlays = !1, this.playbackCallack = null, this.playbackTimeDiff = 0, this.playbackIndex = 0, this.measureFpsIters = 0, this.measureFpsT0 = 0, this.measureFpsIter = 0, this.measureFpsCallback = null
                }

                return e.prototype.hasPendingRequests = function () {
                    return this.shell.chart.hasPendingRequests()
                }, e.prototype.measureFps = function (t, e) {
                    var i = this;
                    this.measureFpsCallback = e, this.measureFpsIters = t;
                    var n = this.shell.settings.advanced.useAnimationFrame;
                    if (n) {
                        this.shell.chart.updateSettings({advanced: {useAnimationFrame: !1}});
                        var s = this.measureFpsCallback;
                        this.measureFpsCallback = function (t, e, n) {
                            i.shell.chart.updateSettings({advanced: {useAnimationFrame: !0}}), s && s.call(window, t, e, n)
                        }
                    }
                    return this.measureFpsIter = 0, this.measureFpsT0 = (new Date).getTime(), this.shell.events.notifySceneChanges({animation: !0}), !0
                }, e.prototype.startRecording = function () {
                    return this.record = {
                        width: this.shell.scene.chartWidth,
                        height: this.shell.scene.chartHeight,
                        events: []
                    }, this.recording = !0, this.playback = !1, !0
                }, e.prototype.stopRecording = function () {
                    this.recording = !1;
                    var t = this.record;
                    return this.record = {}, t
                }, e.prototype.startPlayback = function (t, e) {
                    var i = this;
                    return this.playbackCallack = e, t.events && t.events.length > 0 ? (this.record = t, this.recording = !1, this.playback = !0, this.playbackIndex = 0, this.shell.setSize(this.record.width, this.record.height), this.playbackTimeDiff = (new Date).getTime() - t.events[0].event.timeStamp, setTimeout(function () {
                            return i.playNextEvent()
                        }, 100), !0) : void 0
                }, e.prototype.stopPlayback = function () {
                    this.playback = !1, this.record = {}
                }, e.prototype.playNextEvent = function () {
                    var e = this;
                    if (this.playback) {
                        var i = this.record.events[this.playbackIndex], n = t.Helpers.clone(i.event);
                        n.target = this.shell.container;
                        var s = i.type;
                        if (n.timeStamp += this.playbackTimeDiff, this.eventPlays = !0, "KeyDown" === s) this.shell.notifyKeyEvent(n); else {
                            for (var o = null, r = 0; r < t.ChartOuterShell.MouseEventConfig.length; r++) {
                                var a = t.ChartOuterShell.MouseEventConfig[r];
                                if (a.ev === s) {
                                    o = a;
                                    break
                                }
                            }
                            this.shell.notifyMouseEvent(n, o)
                        }
                        if (this.eventPlays = !1, this.playbackIndex += 1, this.playbackIndex < this.record.events.length) {
                            i = this.record.events[this.playbackIndex];
                            var h = i.event.timeStamp + this.playbackTimeDiff - (new Date).getTime();
                            return setTimeout(function () {
                                return e.playNextEvent()
                            }, Math.max(0, h))
                        }
                        return this.stopPlayback(), this.playbackCallack ? this.playbackCallack() : void 0
                    }
                }, e.prototype.mouseEvent = function (e, i) {
                    return this.playback && !this.eventPlays ? !0 : this.recording ? (e = t.Helpers.clone(e), delete e.target, this.record.events.push({
                                type: i.ev,
                                event: e
                            }), !1) : !1
                }, e.prototype.keyEvent = function (e, i) {
                    return this.playback && !this.eventPlays ? !0 : this.recording ? (e = t.Helpers.clone(e), delete e.target, this.record.events.push({
                                type: i,
                                event: e
                            }), !1) : !1
                }, e.prototype.paintDone = function () {
                    if (this.framesCount += 1, this.measureFpsIters) {
                        this.measureFpsIter += 1;
                        var t = (new Date).getTime() - this.measureFpsT0;
                        if (this.measureFpsIter >= this.measureFpsIters && t > 4e3 || t > 1e4 && this.measureFpsIter >= 5) {
                            var e = 1e3 * this.measureFpsIter / Math.max(1e-4, t);
                            this.measureFpsCallback(e, this.measureFpsIter, t), this.measureFpsCallback = null, this.measureFpsIters = 0
                        } else this.shell.events.notifySceneChanges({animation: !0})
                    }
                }, e
            }();
            t.Profiler = e
        }(e = t.Base || (t.Base = {}))
    }(e = t.Internal || (t.Internal = {}))
}(ZoomCharts || (ZoomCharts = {}));
var ZoomCharts;
!function (t) {
    var e;
    !function (t) {
        var e;
        !function (t) {
            var e = function () {
                function t() {
                    this.subchart = null, this.element = null
                }

                return t
            }(), i = function () {
                function i(e, i) {
                    this.sceneChanges = {}, this.pointerState = {}, this.animationOrder = [], this.updateOrder = [], this.paintOrder = [], this.subcharts = [], this.chartBounds = new t.Rect(0, 0, 1, 1), this.chartOuterBounds = new t.Rect(0, 0, 1, 1), this.chartBoundsIsOuter = !0, this.chart = e, this.shell = i, this.scene = e.scene
                }

                return i.prototype.addElement = function (t) {
                    if (!t)throw new Error("`element` must be defined.");
                    return this.paintOrder.push(t), this.updateOrder.push(t), this.animationOrder.push(t), this.animationOrder.sort(function (t, e) {
                        return t.animationOrder - e.animationOrder
                    }), this.paintOrder.sort(function (t, e) {
                        return t.paintOrder - e.paintOrder
                    }), this.updateOrder.sort(function (t, e) {
                        return t.updateOrder - e.updateOrder
                    }), t
                }, i.prototype.removeElement = function (e) {
                    t.Helpers.removeFromArray(this.paintOrder, e), t.Helpers.removeFromArray(this.animationOrder, e), t.Helpers.removeFromArray(this.updateOrder, e)
                }, i.prototype.addSubchart = function (t) {
                    this.subcharts.push(t)
                }, i.prototype.removeSubchart = function (e) {
                    t.Helpers.removeFromArray(this.subcharts, e);
                    for (var i in this.pointerState) {
                        var n = this.pointerState[i];
                        n.subchart === e && (n.subchart = null)
                    }
                }, i.prototype.notifySceneChanges = function (e) {
                    if (t.Helpers.hasProperties(e)) {
                        var i = e.settingsChanges;
                        void 0 !== i && i instanceof t.Settings ? (this.sceneChanges.settingsChanges = t.Helpers.extendCopy(this.sceneChanges.settingsChanges || {}, i, function (t, e) {
                                return "_" === t[0] ? !0 : e
                            }), delete e.settingsChanges, t.Helpers.extendDeep(this.sceneChanges, e), e.settingsChanges = i) : t.Helpers.extendDeep(this.sceneChanges, e), this.shell.requestPaint()
                    }
                }, i.prototype.requestPaint = function () {
                    this.shell.requestPaint()
                }, i.prototype.paintNow = function (t) {
                    void 0 === t && (t = !1), this.shell.paintNow(t = !1)
                }, i.prototype.clearSceneChanges = function (t) {
                    for (var e in t)delete this.sceneChanges[e]
                }, i.prototype.onMouseEvent = function (i, n) {
                    var s = n.name;
                    i.changes = {}, i.capture = !1;
                    var o, r, a = null, h = null, l = void 0, u = i.identifier, c = this.pointerState[u];
                    c || (c = new e, c.identifier = u, this.pointerState[u] = c);
                    for (var p = "preview" + s, d = 0; d < this.updateOrder.length; d++)r = this.updateOrder[d], r[p] && r[p].call(r, i);
                    if (c.subchart) {
                        var f = c.subchart.events;
                        f.onMouseEvent(i, n), i.consumed || i.hovered || i.capture ? (h = c.subchart, i.capture = !0, l = i.cursor) : f.onMouseEvent(i, {
                                ev: t.MouseEvents.EVENT_LEAVE,
                                name: "PointerOut"
                            })
                    }
                    if (p = "on" + s, o = r = c.element, r && r[p] && (r[p].call(r, i), (i.consumed || i.capture || n.captures && n.needsCapture) && !n.releasesCapture && (a = r, i.capture = !0, l = i.cursor)), !i.capture && !n.needsCapture)for (var m = this.subcharts.length - 1; m >= 0; m -= 1) {
                        var g = this.subcharts[m], f = g.events;
                        if (f.chartOuterBounds.containsPoint(i.x, i.y)) {
                            if (f.onMouseEvent(i, n), i.consumed || i.hovered || i.capture) {
                                h = g, i.capture = !0;
                                break
                            }
                            f.onMouseEvent(i, {
                                ev: t.MouseEvents.EVENT_LEAVE,
                                name: "PointerOut"
                            })
                        }
                    }
                    if (!i.capture && !n.needsCapture)for (var d = 0; d < this.updateOrder.length; d++)if (r = this.updateOrder[d], r[p] && r !== o && (r[p].call(r, i), i.consumed || i.capture)) {
                        l = i.cursor, a = r, i.capture = !0;
                        break
                    }
                    void 0 !== l && (i.cursor = l), i.consumed = i.consumed || i.noDefault, (n.releasesCapture || n.captures) && (c.element = n.captures ? a : null, c.subchart = n.captures ? h : null), this.notifySceneChanges(i.changes)
                }, i.prototype.onKeyEvent = function (t) {
                    t.changes = {}, t.consumed = !1, t.cursor = null;
                    for (var e = "on" + name, i = 0; i < this.updateOrder.length; i++) {
                        var n = this.updateOrder[i];
                        if (n[e] && (n[e].call(n, t), t.consumed))break
                    }
                    this.notifySceneChanges(t.changes)
                }, i.prototype.setNewSize = function (t, e) {
                    this.chartBounds.equals(t) && e === this.chartBoundsIsOuter || (this.chartBounds = t.clone(), this.chartBoundsIsOuter = e, this.notifySceneChanges({bounds: !0}))
                }, i.prototype.updateLayout = function (e) {
                    for (var i = this.scene, n = [], s = 0; s < this.paintOrder.length; s++) {
                        var o = this.paintOrder[s];
                        o.getPanels && (n = n.concat(o.getPanels(e.isExport)))
                    }
                    t.Helpers.sort(n, function (t, e) {
                        return t.packingOrder - e.packingOrder
                    });
                    var r, a, h;
                    if (this.chartBoundsIsOuter) {
                        r = this.chartBounds.clone();
                        for (var l = 0; l < n.length; l++) {
                            var u = n[l];
                            "external" === u.location && this._placePanel(u, r, !0, e)
                        }
                        a = this.chartBounds.clone(), h = this.chartBounds.clone();
                        for (var l = 0; l < n.length; l++) {
                            var u = n[l];
                            ("outside" === u.location || "outsideFill" === u.location) && this._placePanel(u, h, !1, e)
                        }
                    } else {
                        h = this.chartBounds.clone(), a = this.chartBounds.clone();
                        for (var l = 0; l < n.length; l++) {
                            var u = n[l];
                            ("outside" === u.location || "outsideFill" === u.location) && this._placePanel(u, a, !0, e)
                        }
                        r = a.clone();
                        for (var l = 0; l < n.length; l++) {
                            var u = n[l];
                            "external" === u.location && this._placePanel(u, r, !0, e)
                        }
                    }
                    this.chartOuterBounds = a, i.chartLeft = a.x0, i.chartTop = a.y0, i.chartHeight = a.h(), i.chartWidth = a.w();
                    for (var l = 0; l < n.length; l++) {
                        var u = n[l];
                        "inside" !== u.location && this._placePanelFinal(u, h)
                    }
                    (i.x0 !== h.x0 || i.y0 !== h.y0 || i.width !== h.w() || i.height !== h.h()) && this.chart.events.notifySceneChanges({bounds: !0}), i.x0 = h.x0, i.y0 = h.y0, i.width = h.w(), i.height = h.h(), i.leftMargin = h.x0 - a.x0, i.rightMargin = a.x1 - h.x1, i.topMargin = h.y0 - a.y0, i.bottomMargin = a.y1 - h.y1;
                    for (var l = 0; l < n.length; l++) {
                        var u = n[l];
                        "inside" === u.location && (this._placePanel(u, h, !1, e), this._placePanelFinal(u, h))
                    }
                    return r
                }, i.prototype._placePanel = function (t, e, i, n) {
                    var s = e.x0, o = e.y0, r = e.x1, a = e.y1, h = t.margin, l = t.computeSize(e.x1 - e.x0, e.y1 - e.y0, n.context, n.labelRenderer), u = l.width, c = l.height;
                    u += 2 * h, c += 2 * h, i ? "top" === t.side ? (a = o, o = a - c, t.floating || (e.y0 = o)) : "bottom" === t.side ? (o = a, a = o + c, t.floating || (e.y1 = a)) : "left" === t.side ? (r = s, s = r - u, t.floating || (e.x0 = s)) : "right" === t.side && (s = r, r = s + u, t.floating || (e.x1 = r)) : "top" === t.side ? (a = Math.min(a, o + c), t.floating || (e.y0 = a)) : "bottom" === t.side ? (o = Math.max(o, a - c), t.floating || (e.y1 = o)) : "left" === t.side ? (r = Math.min(r, s + u), t.floating || (e.x0 = r)) : "right" === t.side && (s = Math.max(s, r - u), t.floating || (e.x1 = s)), t._tempData = {
                        left: s,
                        right: r,
                        top: o,
                        bottom: a,
                        desiredWidth: u,
                        desiredHeight: c
                    }
                }, i.prototype._placePanelFinal = function (t, e) {
                    var i = t._tempData.left, n = t._tempData.right, s = t._tempData.top, o = t._tempData.bottom, r = t._tempData.desiredWidth, a = t._tempData.desiredHeight;
                    if ("outside" === t.location && ("top" === t.side || "bottom" === t.side ? (i = Math.max(i, e.x0), n = Math.min(n, e.x1)) : (s = Math.max(s, e.y0), o = Math.min(o, e.y1))), "left" === t.align) n = Math.min(n, i + r); else if ("right" === t.align) i = Math.max(i, n - r); else if ("top" === t.align) o = Math.min(o, s + a); else if ("bottom" === t.align) s = Math.max(s, o - a); else if ("center" === t.align) {
                        var h = Math.max(0, n - i - r) / 2, l = Math.max(0, o - s - a) / 2;
                        i += h, n -= h, s += l, o -= l
                    }
                    var u = t.margin;
                    t.placePanel(i + u, s + u, n - u, o - u)
                }, i.prototype.animateFrame = function (t) {
                    this.shell.prepareContext(t), t.changes = this.sceneChanges, this.sceneChanges = {};
                    for (var e = 0; e < this.updateOrder.length; e++) {
                        var i = this.updateOrder[e];
                        i.onSceneChange && i.onSceneChange(t)
                    }
                    t.changes.bounds && this.updateLayout(t);
                    for (var n = 0; n < this.animationOrder.length; n++) {
                        var s = this.animationOrder[n];
                        s.doAnimations && s.doAnimations(t)
                    }
                    for (var o = 0; o < this.paintOrder.length; o++) {
                        var r = this.paintOrder[o];
                        r.paintScene && r.paintScene(t)
                    }
                    t.changes.position && this.chart.notifyPositionChange(t), t.changes = null;
                    var a = [];
                    for (var h in this.pointerState) {
                        var l = this.pointerState[h];
                        l.subchart && a.push(l.subchart)
                    }
                    for (var u = 0; u < this.subcharts.length; u += 1) {
                        var c = this.subcharts[u];
                        if (!(a.indexOf(c) > -1)) {
                            var p = c.events;
                            (p.sceneChanges.bounds || p.chartOuterBounds.overlaps(this.chartOuterBounds)) && p.animateFrame(t)
                        }
                    }
                    for (var u = 0; u < a.length; u += 1) {
                        var c = a[u];
                        c.events.animateFrame(t)
                    }
                    this.shell.finalizeContext(t)
                }, i.prototype.doPaint = function (t) {
                    for (var e = 0; e < this.paintOrder.length; e++) {
                        var i = this.paintOrder[e];
                        i.paintScene && i.paintScene(t)
                    }
                    for (var n = 0; n < this.subcharts.length; n += 1) {
                        var s = this.subcharts[n], o = s.events;
                        o.chartOuterBounds.overlaps(this.chartOuterBounds) && o.doPaint(t)
                    }
                }, i
            }();
            t.ChartEvents = i
        }(e = t.Base || (t.Base = {}))
    }(e = t.Internal || (t.Internal = {}))
}(ZoomCharts || (ZoomCharts = {}));
var __extends = this && this.__extends || function (t, e) {
        function i() {
            this.constructor = t
        }

        for (var n in e)e.hasOwnProperty(n) && (t[n] = e[n]);
        i.prototype = e.prototype, t.prototype = new i
    }, ZoomCharts;
!function (t) {
    var e;
    !function (t) {
        var e;
        !function (t) {
            var e = function () {
                function t() {
                    this.enabled = !1, this.enabledOnExport = !1, this.url = "http://zoomcharts.com", this.image = "builtin://logo-supported-by", this.imageScaling = .5, this.location = "outside"
                }

                return t
            }();
            t.SettingsCredits = e;
            var i = function (e) {
                function i(i, n) {
                    var s = this;
                    e.call(this), this.animationOrder = 2e3, this.paintOrder = 60, this.updateOrder = 400, this.settings = n, this.chart = i, this.scene = this.chart.scene, (this.settings.enabledOnExport || this.settings.enabled) && (this.chart.assetsLoader.getAssetImage(this.settings.image, function (t) {
                        return s.imageLoaded(t)
                    }), this.settings.imageExport && this.settings.image !== this.settings.imageExport && this.chart.assetsLoader.getAssetImage(this.settings.imageExport, function (t) {
                        return s.imageLoaded(t)
                    })), this.panel = new t.ChartPanel, this.panel.packingOrder = 0, this.panel.side = "bottom", this.panel.align = "right", this.panel.visible = !1, this.panel.margin = 3
                }

                return __extends(i, e), i.prototype.onSceneChange = function (t) {
                    var e = t.changes;
                    e.settings && e.settingsChanges.credits && (e.bounds = !0)
                }, i.prototype.getPanels = function (t) {
                    var e = this, i = t ? this.settings.enabledOnExport : this.settings.enabled;
                    if (i) {
                        this.panel.location = "outside", "outside" === this.settings.location ? (this.panel.floating = !1, t && !this.settings.enabled && (this.panel.location = "external")) : this.panel.floating = !0;
                        var n = this.chart.assetsLoader.getAssetImage(this.settings.image, function (t) {
                            return e.imageLoaded(t)
                        });
                        if (n) {
                            this.panel.desiredWidth = n.width * this.settings.imageScaling, this.panel.desiredHeight = n.height * this.settings.imageScaling, this.panel.visible = !0;
                            var s = [this.panel];
                            return s
                        }
                    }
                    return this.panel.visible = !1, []
                }, i.prototype.paintScene = function (t) {
                    var e = this, i = this.panel;
                    if (i.visible) {
                        var n = this.chart.assetsLoader.getAssetImage(this.settings.image, function (t) {
                            return e.imageLoaded(t)
                        }), s = this.settings.imageExport ? this.chart.assetsLoader.getAssetImage(this.settings.imageExport, function (t) {
                                return e.imageLoaded(t)
                            }) : n;
                        t.isExport && (n = s), n ? t.context.drawImage(n, 0, 0, n.width, n.height, i.left, i.top, i.right - i.left, i.bottom - i.top) : t.animating = !0
                    }
                }, i.prototype.onPointerMove = function (t) {
                    var e = t.x, i = t.y, n = this.panel;
                    n.visible && e >= n.left && i >= n.top && e <= n.right && i <= n.bottom && this.settings.url && (t.cursor = "pointer")
                }, i.prototype.onClick = function (e) {
                    var i = e.x, n = e.y, s = this.panel;
                    s.visible && i >= s.left && n >= s.top && i <= s.right && n <= s.bottom && this.settings.url && (t.Helpers.openUrl(this.settings.url), e.consumed = !0)
                }, i.prototype.imageLoaded = function () {
                    this.chart.updateSize(!0), this.chart.events.notifySceneChanges({
                        settings: !0,
                        settingsChanges: {credits: !0}
                    })
                }, i
            }(t.ChartElement);
            t.Credits = i
        }(e = t.Base || (t.Base = {}))
    }(e = t.Internal || (t.Internal = {}))
}(ZoomCharts || (ZoomCharts = {}));
var ZoomCharts;
!function (t) {
    var e;
    !function (t) {
        var e;
        !function (t) {
            var e = function () {
                function t() {
                    this.enabled = !0, this.enabledOnExport = !0, this.align = "center", this.margin = 25, this.style = {
                        font: "20px Arial",
                        fillColor: "#000"
                    }, this.text = ""
                }

                return t
            }();
            t.SettingsTitle = e;
            var i = function (e) {
                function i(i) {
                    var n = this;
                    e.call(this), this.lineSpacing = 0, this.animationOrder = 2e3, this.paintOrder = 55, this.updateOrder = 500, this.chart = i, this.scene = i.scene, this.settings = this.scene.settings.title, this.panel = new t.ChartPanel, this.panel.packingOrder = 10, this.panel.side = "top", this.panel.align = "fill", this.panel.visible = !1, this.panel.computeSize = function (t, e, i) {
                        return n.computePanelSize(t, e, i)
                    }
                }

                return __extends(i, e), i.prototype.onSceneChange = function (t) {
                    var e = t.changes;
                    e.settings && e.settingsChanges.title && (e.bounds = !0)
                }, i.prototype.getPanels = function (t) {
                    if (this.panel.visible = t ? this.settings.enabledOnExport : this.settings.enabled, this.panel.visible = this.panel.visible && !!this.settings.text, this.panel.margin = this.settings.margin, this.panel.visible) {
                        this.panel.location = t && !this.settings.enabled ? "external" : "outsideFill";
                        var e = [this.panel];
                        return e
                    }
                    return []
                }, i.prototype.computePanelSize = function (e, i, n) {
                    this.lines = [];
                    var s = this.settings.text;
                    n.save(), t.Graphics.textStyle(n, this.settings.style);
                    var o = n.measureText(s).width, r = t.Graphics.getTextHeight(n, this.settings.style.font);
                    if (this.lineSpacing = 1.15 * r, o > e) {
                        for (var a = 0, h = s.split(" "), l = h[0], u = n.measureText(l).width, c = 1; c <= h.length - 1; c++) {
                            var p = l + " " + h[c], d = n.measureText(p).width;
                            e >= d ? (l = p, u = d) : (this.lines.push(l), o = Math.max(o, u), l = h[c], u = n.measureText(l).width)
                        }
                        this.lines.push(l), o = Math.max(a, u)
                    } else this.lines.push(s);
                    return n.restore(), r = (this.lines.length - 1) * this.lineSpacing + r, {
                        width: o,
                        height: r
                    }
                }, i.prototype.paintScene = function (e) {
                    if (this.panel.visible) {
                        var i = this.settings, n = e.context, s = this.panel.left, o = this.panel.right, r = this.panel.top;
                        t.Graphics.textStyle(n, i.style), n.textBaseline = "top";
                        var a;
                        "left" === i.align ? (n.textAlign = "start", a = s) : "right" === i.align ? (n.textAlign = "end", a = o) : (n.textAlign = "center", a = (s + o) / 2);
                        for (var h = 0; h < this.lines.length; h++) {
                            var l = this.lines[h];
                            n.fillText(l, a, r), r += this.lineSpacing
                        }
                    }
                }, i
            }(t.ChartElement);
            t.Title = i
        }(e = t.Base || (t.Base = {}))
    }(e = t.Internal || (t.Internal = {}))
}(ZoomCharts || (ZoomCharts = {}));
var ZoomCharts;
!function (t) {
    var e;
    !function (t) {
        var e;
        !function (t) {
            var e = function () {
                function e(e, i, n) {
                    void 0 === e && (e = null), void 0 === i && (i = t.SettingsMapping.BaseSettingsLabelStyle), this.aspectRatio = 3, this.maxWidth = null, this.lineSpacing = .2, this.align = "left", this.padding = 0, this.margin = 0, this.angle = 0, this.text = null, this.image = null, this.borderRadius = 0, this.backgroundStyle = null, this.textStyle = null, this.imageSlicing = null, this.onClick = null, this.onHover = null, this.url = null, this.visible = !0, this.shouldBeVisible = !0, this.userPlaced = !1, this.id = null, this.measureDone = !1, this.loadedImage = null, this.rows = null, this.lineHeight = 0, this.lineHeightM = 0, this.hwidth = 0, this.hheight = 0, this.currentBounds = null, this.x = null, this.originX = null, this.y = null, this.prop = null, this._textCache = null, t.SettingsHelper.updateRecursive(this, e, i, {}, n)
                }

                return e
            }();
            t.Label = e;
            var i = function () {
                function e(t, e, i) {
                    if (this.cache = {}, this.frameLabels = {}, this.numPaints = 0, this.numCachedPaints = 0, this.allowCache = !0, this.chartArea = 0, this.scaleX = 0, this.scaleY = 0, this.settings = t, this.assetsLoader = e, !i)throw new Error("chartContainer must be specified");
                    this.chartContainer = i
                }

                return e.prototype.startFrame = function (t, e, i, n) {
                    this.chartArea = t * e, this.scaleX = i, this.scaleY = n
                }, e.prototype.finishFrame = function () {
                    var e = t.Helpers.countProperties(this.frameLabels), i = t.Helpers.countProperties(this.cache);
                    if (i > 3 * e)for (var n in this.cache)this.frameLabels[n] || delete this.cache[n];
                    this.frameLabels = {}
                }, e.prototype.printStats = function () {
                    var e = t.Helpers.countProperties(this.frameLabels), i = t.Helpers.countProperties(this.cache);
                    t.Helpers.log("Paints: " + this.numPaints + ", cached: " + this.numCachedPaints + ", cache size: " + i + ", frame size: " + e), this.numPaints = 0, this.numCachedPaints = 0
                }, e.prototype.measure = function (t, e, i) {
                    if (void 0 === i && (i = e), null == i && (i = e), !e.measureDone) {
                        e.id = null;
                        var n = !0, s = i.padding, o = 0, r = 0;
                        if (e.text) {
                            var a = this.measureText(t, e, i), h = a.w, l = a.h;
                            r = Math.max(r, l), o += h
                        } else e.rows = {subLines: [], rowWidths: []};
                        if (e.image)if (e.imageSlicing) o += e.imageSlicing[2], r = Math.max(r, e.imageSlicing[3]); else {
                            var u = this.assetsLoader.getAssetImage(e.image, null);
                            u && u.width ? (o += u.width, r = Math.max(r, u.height)) : n = !1
                        }
                        if (0 === o && (o = 10, r = 10), o += 2 * s, r += 2 * s, e.borderRadius > 0 && e.text) {
                            var c = Math.min(e.borderRadius, r / 2);
                            o += .45 * c, e.image || (o += .45 * c)
                        }
                        e.hwidth = o / 2, e.hheight = r / 2, e.measureDone = n
                    }
                }, e.prototype.measureText = function (e, i, s) {
                    var o, r, a = s.aspectRatio, h = s.maxWidth, l = new n(e, s), u = s.padding;
                    if ((a > 0 || h > 0) && i.text.split(" ").length > 1) {
                        a || (a = 1e9), h || (h = 1e9);
                        var c = function (t) {
                            return {
                                x: 0,
                                y: 0,
                                dx: 0,
                                dy: 0,
                                width: Math.min(h, t * (a + .2))
                            }
                        };
                        l.fitLabelInRect(i, s.align, s.align, c, !1), o = 2 * i.hwidth, r = 2 * i.hheight
                    } else {
                        for (var p = l.styleTagParser(i.text), d = p.words, f = p.breaks, m = 0; m < f.length; m++)f[m] = f[m] - 1;
                        var g = l.stringsByFont(d, f);
                        i.lineHeight = r = t.Graphics.getTextHeight(e, s.textStyle.font), i.rows = g, t.Graphics.textStyleNoShadow(e, s.textStyle), o = g.rowWidths.reduce(function (t, e) {
                            return Math.max(t, e)
                        }), r = r * (1 + i.lineSpacing) * g.rowWidths.length + u
                    }
                    return {w: o, h: r}
                }, e.prototype.canCache = function (t, e, i) {
                    if (!this.allowCache || !this.settings.advanced.labelCache)return !1;
                    var n = 2 * t.hwidth * t.hheight * i * i;
                    if (this.chartArea / n < 10)return !1;
                    if (t.image) {
                        var s = this.assetsLoader.getAssetImage(t.image, null);
                        if (!s)return !1
                    }
                    return !0
                }, e.prototype.styleRequiresDocumentCanvas = function (t) {
                    return t && t.font && /[0-9]+em/.test(t.font) ? !0 : !1
                }, e.prototype.paint = function (t, e, i, n, s) {
                    this.paintWithStyle(t, e, i, n, s, s)
                }, e.prototype.realPaint = function (e, i, n, s, o) {
                    var r = s.hwidth, a = s.hheight, h = o.backgroundStyle, l = o.padding, u = Math.min(s.borderRadius, a);
                    if (h) {
                        var c = t.Graphics.beginStrokeAndFill(e, h);
                        if (u >= a) {
                            var p = i + r - a;
                            c.moveTo(p, n - a), c.arc(p, n, a, -Math.PI / 2, Math.PI / 2, !1), p = i - r + a, c.lineTo(p, n + a), c.arc(p, n, a, Math.PI / 2, -Math.PI / 2, !1), c.closePath()
                        } else u > 0 ? (c.moveTo(i - r + u, n - a), c.lineTo(i + r - u, n - a), c.arc(i + r - u, n - a + u, u, -Math.PI / 2, 0, !1), c.lineTo(i + r, n + a - u), c.arc(i + r - u, n + a - u, u, 0, +Math.PI / 2, !1), c.lineTo(i - r + u, n + a), c.arc(i - r + u, n + a - u, u, +Math.PI / 2, Math.PI, !1), c.lineTo(i - r, n - a + u), c.arc(i - r + u, n - a + u, u, Math.PI, Math.PI + Math.PI / 2, !1)) : (c.moveTo(i - r, n - a), c.lineTo(i + r, n - a), c.lineTo(i + r, n + a), c.lineTo(i - r, n + a), c.closePath());
                        t.Graphics.endStrokeAndFill(e, c, h)
                    }
                    var d = s.image;
                    r -= l, a -= l;
                    var f = i - r, m = i + r;
                    if (d) {
                        var g = this.assetsLoader.getAssetImage(d);
                        if (g) {
                            var y = s.imageSlicing;
                            y ? (e.drawImage(g, y[0], y[1], y[2], y[3], i - r, n - a, y[2], y[3]), f += y[2]) : (e.drawImage(g, i - r, n - a), f += d.width)
                        }
                    }
                    var v = s.rows.subLines, S = s.rows.rowWidths, C = S.length;
                    if (v.length > 0) {
                        var b, x = s.lineHeight * (1 + s.lineSpacing), _ = o.align;
                        e.textBaseline = "bottom";
                        var w = n - (C + 1) * x / 2 + .58 * s.lineHeight;
                        "left" === _ ? (b = f, d || (b += .45 * u), e.textAlign = "start") : "right" === _ ? (b = m - .45 * u, e.textAlign = "end") : (b = (f + m) / 2, e.textAlign = "center"), t.Graphics.textStyle(e, o.textStyle);
                        var L = -1, T = 0;
                        _ = e.textAlign;
                        for (var M, P = o.textStyle.font, k = 0; k < v.length; k++) {
                            var D = v[k], I = T;
                            if (T += D.width, L !== D.row) {
                                L = D.row, w += x, I = 0, T = D.width;
                                var A = S[L];
                                M = "center" === _ ? b - A / 2 : "start" === _ ? b : b - A
                            }
                            e.textAlign = "left";
                            var B = D.font;
                            P !== B && (P = B, e.font = B), I += M, e.fillText(D.text, I, w)
                        }
                    }
                }, e.prototype.paintWithStyle = function (e, i, n, s, o, r) {
                    o.measureDone || this.measure(e, o, r);
                    var a = (r.angle || 0) / 180 * Math.PI, h = this.scaleX, l = this.scaleY, u = h * s, c = l * s, p = this.canCache(o, r, s), d = 1 !== s || 1 !== h || 0 !== a, f = o.hwidth, m = o.hheight;
                    if (o.currentBounds = new t.Rect(i - f * u, n - m * c, i + f * u, n + m * c), d && e.save(), p) {
                        a = (r.angle || 0) / 180 * Math.PI;
                        var g = 0 === (r.angle || 0) ? 1 : 1.7;
                        if (!o.id) {
                            var y = t.Helpers.SeparatorChar, v = "" + o.text + y + "," + f + "," + m + "," + r.lineSpacing + ", " + r.align + "," + r.image + "," + r.borderRadius + "," + r.imageSlicing + "," + r.maxWidth + "," + r.aspectRatio;
                            if (r.backgroundStyle) {
                                var S = r.backgroundStyle;
                                v += "" + y + S.fillColor + "," + S.lineColor + "," + S.lineWidth + "," + S.shadowColor + "," + S.shadowOffsetX + "," + S.shadowOffsetY + "," + S.shadowBlur
                            }
                            if (r.textStyle) {
                                var C = r.textStyle;
                                v += "" + y + C.fillColor + "," + C.font
                            }
                            o.id = v
                        }
                        var b, x, _, w, L = o.id + u.toFixed(2) + "," + c.toFixed(2) + "," + g, T = this.cache[L] || null;
                        if (T) b = T.width, x = T.height, _ = b / 2, w = x / 2, this.numCachedPaints += 1; else {
                            var M = r.backgroundStyle, P = M && M.lineWidth ? M.lineWidth : 0;
                            b = Math.ceil(2 * f + P + 1) * u, x = Math.ceil(2 * m + P + 1) * c, T = document.createElement("canvas"), b *= g, x *= g, b = 2 * Math.ceil(b / 2), x = 2 * Math.ceil(x / 2), _ = b / 2, w = x / 2, T.width = b, T.height = x;
                            var k, D = this.styleRequiresDocumentCanvas(r.textStyle);
                            D && (k = this.chartContainer, k.ownerDocument || (t.Helpers.warn("chartContainer must be appended to the document in order to use `em` when specifying font size."), k = document.body), T.style.display = "none", k.appendChild(T));
                            var I = T.getContext("2d");
                            d ? I.transform(u * g, 0, 0, c * g, _, w) : I.transform(g, 0, 0, g, _, w), this.realPaint(I, 0, 0, o, r), D && k.removeChild(T), this.cache[L] = T, this.numPaints += 1
                        }
                        i = Math.round(i * h) / h, n = Math.round(n * l) / l;
                        var A = b / h / g, B = x / l / g, E = i - _ / h / g, O = n - w / l / g;
                        0 !== a && (e.translate(i, n), e.rotate(a), E = -A / 2, O = -B / 2), e.drawImage(T, 0, 0, b, x, E, O, A, B), this.frameLabels[L] = 1
                    } else d && (e.transform(s, 0, 0, s, i, n), 0 !== a && e.rotate(a), i = 0, n = 0), this.realPaint(e, i, n, o, r), this.numPaints += 1;
                    d && e.restore()
                }, e
            }();
            t.LabelRenderer = i;
            var n = function () {
                function e(e, i) {
                    this.g = e, this.textStyle = i.textStyle, this.angle = (i.angle || 0) / 180 * Math.PI, this.borderRadius = i.borderRadius || 0, this.margin = i.margin || 0, this.padding = i.padding || 0;
                    var n = t.Graphics.getTextHeight(e, this.textStyle.font), s = i.lineSpacing;
                    this.lineHeight = n, this.lineHeightM = n * (s + 1), this.lineHeightC = -n * s
                }

                return e.prototype.fitLabelInRect = function (t, e, i, n, s) {
                    void 0 === s && (s = !0), null == s && (s = !0);
                    var o = this.margin, r = this.padding, a = this.lineHeightC, h = this.lineHeightM;
                    t.measureDone && t._textCache || (t._textCache = this.styleTagParser(t.text));
                    for (var l, u, c = t._textCache.words, p = t._textCache.breaks, d = t._textCache.maxLines, f = -1 / 0, m = null, g = 0, y = 0, v = 0, S = 0, C = p.length; d >= C; C++) {
                        var b = a + h * C, x = n(b / 2 + o + r), _ = x.width;
                        _ -= 2 * (o + r);
                        var w = this.splitWordsToLines(c, p, C, function () {
                            return _
                        }), L = w.prop, T = w.actualWidthForLines, M = w.positions;
                        if (L > f) {
                            m = M, f = L, l = x.dx, u = x.dy, g = x.x, y = x.y, v = _, S = 0;
                            for (var P = 0; P < T.length; P++) {
                                var k = T[P];
                                S = Math.max(k, S)
                            }
                        }
                        if (L >= 1)break
                    }
                    if (m) {
                        if (!t.userPlaced) {
                            1 > f && (e = i);
                            var D;
                            D = "left" === e ? (S - v) / 2 : "right" === e ? (v - S) / 2 : 0, g += l * D, y += u * D
                        }
                        s && (t.x = g, t.y = y), t.rows = this.stringsByFont(c, m), t.hheight = (a + h * m.length) / 2 + r, t.lineHeight = this.lineHeight, t.lineHeightM = h, t.hwidth = S / 2 + r, t.align = e, t.measureDone = !0, t.visible = !0, t.padding = r, t.borderRadius = this.borderRadius, this.borderRadius > 0 && (t.hwidth += .45 * Math.min(this.borderRadius, t.hheight))
                    } else t.rows = {subLines: [], rowWidths: []}, t.visible = !1;
                    return f
                }, e.prototype.styleTagParser = function (i) {
                    var n = this.g;
                    t.Graphics.textStyleNoShadow(n, this.textStyle);
                    var s = n.font, o = e._spaceWidth;
                    o[s] || (o[s] = n.measureText(" ").width);
                    var r = s, a = 0, h = 0, l = !0;
                    i = null == i ? "" : "" + i;
                    var u = 0, c = 0, p = [], d = [];
                    p.push({word: "", width: 0, font: r, spaceWidth: 0});
                    var f = {word: "", width: 0, font: r, spaceWidth: 0};
                    p.push(f);
                    for (var m = i.length, g = 0 === m ? -1 : i.charCodeAt(0); m > u;)switch (g) {
                        case 32:
                            for (; 32 === g && ++u < m;)g = i.charCodeAt(u);
                            l || (f.spaceWidth = o[r], l = !0), c = u;
                            break;
                        case 60:
                            if (u + 4 > m) {
                                u++;
                                break
                            }
                            var y = i.charCodeAt(++u), v = 47 === y ? -1 : 1;
                            0 > v && (y = i.charCodeAt(++u));
                            var S = i.charCodeAt(++u), C = -1;
                            if (98 === y || 66 === y ? 82 === S || 114 === S ? (S = ++u === m ? -1 : i.charCodeAt(u), C = 2) : C = 0 : (73 === y || 105 === y) && (C = 1), C > -1 && 62 === S) {
                                g = ++u === m ? -1 : i.charCodeAt(u), c = u;
                                var b = !1;
                                if (2 === C) d.push(p.length), l = !0, b = !0; else {
                                    1 === C ? h = Math.max(0, h + v) : a = Math.max(0, a + v);
                                    var x = (h ? "italic " : "") + (a ? "bold " : "") + s;
                                    x !== r && (b = !0, r = x, o[r] || (n.font = r, o[r] = n.measureText(" ").width))
                                }
                                b && (f.width > 0 || f.spaceWidth > 0 ? (f = {
                                        word: "",
                                        width: 0,
                                        font: r,
                                        spaceWidth: 0
                                    }, p.push(f)) : f.font = r)
                            } else u = c + 1;
                            break;
                        default:
                            for (var _ = !1; 32 !== g && 60 !== g && ++u < m;)_ = _ || 38 === g, g = i.charCodeAt(u);
                            var w = i.substring(c, u);
                            _ && (w = t.Helpers.decodeEntities(w));
                            var L = n.measureText(w).width;
                            f.spaceWidth > 0 || f.font !== r ? (f = {
                                    word: w,
                                    width: L,
                                    font: r,
                                    spaceWidth: 0
                                }, p.push(f)) : (f.word += w, f.width += L), l = !1, c = u
                    }
                    var T = p.length;
                    d[d.length - 1] !== T && d.push(T);
                    var M = 0 === p[0].spaceWidth ? T - 1 : T;
                    return {breaks: d, maxLines: M, words: p}
                }, e.prototype.stringsByFont = function (t, e) {
                    for (var i = t[0].font, n = e.slice(0), s = [], o = [], r = 0, a = 0, h = "", l = 0, u = 0, c = 0; c <= t.length - 1; c++) {
                        var p = t[c];
                        u = p.spaceWidth;
                        var d = c === n[0];
                        p.font !== i && (a && s.push({
                            text: h,
                            width: a,
                            font: i,
                            row: l
                        }), i = p.font, h = "", a = 0), a += p.width, h += p.word, r += p.width + p.spaceWidth, d && (s.push({
                            text: h,
                            width: a,
                            font: i,
                            row: l
                        }), o.push(r - p.spaceWidth), h = "", l++, a = r = 0, n.shift()), d || p.spaceWidth && (a += p.spaceWidth, h += " ")
                    }
                    return h && (s.push({
                        text: h,
                        width: a,
                        font: i,
                        row: l
                    }), o.push(r - u)), {subLines: s, rowWidths: o}
                }, e.prototype.fitLabelInLines = function (t, e, i, n, s, o) {
                    var r = this.margin, a = this.padding, h = this.lineHeightC, l = this.lineHeightM;
                    t.measureDone && t._textCache || (t._textCache = this.styleTagParser(t.text));
                    var u = t._textCache.words, c = t._textCache.breaks, p = t._textCache.maxLines, d = -1 / 0, f = null, m = null, g = null, y = 0, v = [], S = [];
                    S.push(o(e, i));
                    for (var C = 1; C <= c.length - 1; C++) {
                        var b = h + l * C, x = void 0;
                        x = C % 2 === 1 ? v : S;
                        var _ = o(e, i - b / 2 - r);
                        x.unshift([_[0] - r, _[1] - r]), _ = o(e, i + b / 2 + r), x.push([_[0] - r, _[1] - r])
                    }
                    for (var C = c.length; p >= C; C++) {
                        var w, b = h + l * C;
                        w = C % 2 === 1 ? v : S;
                        var _ = o(e, i - b / 2 - r);
                        w.unshift([_[0] - r, _[1] - r]), _ = o(e, i + b / 2 + r), w.push([_[0] - r, _[1] - r]);
                        var L = function (t) {
                            return Math.min(w[t][0] + w[t][1], w[t + 1][0] + w[t + 1][1])
                        }, T = this.splitWordsToLines(u, c, C, L), M = T.prop, P = T.actualWidthForLines, k = T.positions;
                        if (M > d && (y = i - b / 2, f = k, d = M, m = P, g = w.slice(0), k.length + 1 > w.length))throw new Error("Internal error");
                        if (M >= 1)break
                    }
                    if (f) {
                        var D, I, A = 0, B = 0;
                        if ("left" === n) {
                            for (var E = 1e30, O = 0; O <= f.length; O++)E = Math.min(g[O][0]);
                            var F = -E;
                            D = F, I = F;
                            for (var O = 0; O <= f.length - 1; O++) {
                                var N = m[O], z = Math.min(g[O][1], g[O + 1][1]);
                                I = Math.max(F + N), B = Math.max(B, N - (z - F))
                            }
                        } else if ("right" === n) {
                            for (var z = 1e30, O = 0; O <= f.length; O++)z = Math.min(g[O][1]);
                            var R = z;
                            D = R, I = R;
                            for (var O = 0; O <= f.length - 1; O++) {
                                var N = m[O];
                                D = Math.min(R - N), A = Math.max(A, N - (z + R))
                            }
                        } else if ("center" === n) {
                            for (var E = 1e30, z = 1e30, O = 0; O <= f.length - 1; O++) {
                                var N = m[O] / 2;
                                E = Math.min(g[O][0] - N, Math.min(g[O + 1][0] - N, E)), z = Math.min(g[O][1] - N, Math.min(g[O + 1][1] - N, z))
                            }
                            var H;
                            H = E > 0 && z > 0 ? 0 : E > -z ? z : z > -E ? -E : (z - E) / 2, D = H, I = H;
                            for (var O = 0; O <= f.length - 1; O++) {
                                var N = m[O];
                                E = Math.min(g[O][0], g[O + 1][0]), z = Math.min(g[O][1], g[O + 1][1]), D = Math.min(D, H - N / 2), I = Math.max(I, H + N / 2), A = Math.max(A, N / 2 - E - H), B = Math.max(B, N / 2 - z + H)
                            }
                        }
                        if ("left" === s && A > 0) D += A, I += A; else if ("right" === s && B > 0) D -= B, I -= B; else if ("center" === s) {
                            var Z = (A - B) / 2;
                            D += Z, I += Z
                        }
                        t.rows = this.stringsByFont(u, f), t.hwidth = (I - D) / 2 + a, t.hheight = (h + l * f.length) / 2 + a, t.lineHeight = this.lineHeight, t.lineHeightM = l, t.visible = !0, t.align = n, t.measureDone = !0, t.padding = a, t.borderRadius = this.borderRadius, this.borderRadius > 0 && (t.hwidth += .45 * Math.min(this.borderRadius, t.hheight)), t.userPlaced || (t.x = e + (D + I) / 2, t.y = y + t.hheight)
                    } else t.rows = {subLines: [], rowWidths: []}, t.visible = !1;
                    return d
                }, e.prototype.splitWordsToLines = function (t, e, i, n) {
                    for (var s = 100, o = [], r = [], a = 0, h = e[a], l = i - e.length, u = t[0], c = 0, p = n(0), d = 0, f = 1; f <= t.length - 1; f++) {
                        var m = t[f], g = c + (u.spaceWidth + m.width);
                        h === f || u.spaceWidth > 0 && g > p && l > 0 ? (r.push(f - 1), o.push(c), s = Math.min(s, p / c), c = m.width, d += 1, p = n(d), h !== f ? l -= 1 : (a += 1, h = e[a])) : c = g, u = m
                    }
                    return r.push(t.length), o.push(c), s = Math.min(s, p / c), {
                        prop: s,
                        actualWidthForLines: o,
                        positions: r
                    }
                }, e.prototype.shrinkLabelWithEllipsis = function (e, i, n, s) {
                    var o = this.lineHeightC + this.lineHeightM, r = this.margin + this.padding;
                    t.Graphics.textStyleNoShadow(e, this.textStyle);
                    var a = s(o / 2 + r), h = a.width - 2 * r, l = this.getIncludingPart(e, i.text, "", h, 0), u = null, c = !1, p = e.measureText("").width, d = i.text;
                    if (0 === i.angle)for (var f = Math.floor(n / o) - 2, m = 0; f >= m;) {
                        if (l = this.getIncludingPart(e, d, "", h, 0).replace(/\s+$/g, ""), l === d) {
                            this.addLine(e, i, l, m, c);
                            break
                        }
                        if (c = !0, l.length <= 1) {
                            l = d.slice(0, 1), c = i.text !== l, this.addLine(e, i, l, m, c), u = i.rows.rowWidths[0];
                            break
                        }
                        if (m === f) l = this.getIncludingPart(e, d, "", h - p, 0); else {
                            var g = l.lastIndexOf(" ");
                            if (-1 === g) {
                                var y = d.split(" ")[0];
                                c = l !== y, c && (l = this.getIncludingPart(e, d, "", h - p, 0).replace(/\s+$/g, ""), y = d.split(" ")[0]), d = d.substr(l.length);
                                var v = d.indexOf(" ");
                                -1 === v && (d = ""), d = d.substr(v + 1)
                            } else l = l.substr(0, g), d = d.split(l)[1], c = !1
                        }
                        if (l.length <= 1) {
                            if (0 !== m)break;
                            l = i.text.slice(0, 1)
                        }
                        if (this.addLine(e, i, l, m, c), "" === d)break;
                        d = d.replace(/(^\s+|\s+$)/, ""), c = !1, m++
                    } else c = l !== d, c && (l = this.getIncludingPart(e, d, "", h - p, 0).replace(/\s+$/g, "")), this.addLine(e, i, l, 0, c);
                    var S = o * i.rows.subLines.length / 2 + r, C = 0;
                    if ("center" !== i.align) {
                        var b = Math.max.apply(Math, i.rows.rowWidths), x = (h - b) / 2;
                        C = "right" === i.align ? x : -x
                    }
                    0 !== i.angle && (u = Math.max.apply(Math, i.rows.rowWidths) + r);
                    var _ = s(S, u);
                    i.x = _.x + _.dx * C, i.y = _.y, i.hheight = o * i.rows.subLines.length / 2 + r, i.hwidth = Math.max.apply(Math, i.rows.rowWidths) / 2 + r, i.lineHeight = this.lineHeight, i.lineHeightM = this.lineHeightM, i.measureDone = !0, i.visible = !0, i.padding = this.padding, i.margin = this.margin, i.borderRadius = this.borderRadius, this.borderRadius > 0 && (i.hwidth += .45 * Math.min(this.borderRadius, i.hheight))
                }, e.prototype.addLine = function (t, e, i, n, s) {
                    s && (i = i.replace(/\s+$/g, "") + "");
                    var o = t.measureText(i).width;
                    null == e.rows && (e.rows = {
                        rowWidths: [],
                        subLines: []
                    }), e.rows.rowWidths.push(o), e.rows.subLines.push({
                        font: this.textStyle.font,
                        row: n,
                        text: i,
                        width: o
                    })
                }, e.prototype.getIncludingPart = function (t, e, i, n, s) {
                    if (e.length <= 1) {
                        var o = t.measureText(e).width;
                        return n >= s + o && (i += e), i
                    }
                    var r = e.slice(0, e.length / 2), a = t.measureText(r).width;
                    if (n >= s + a && (i += r), s + a === n)return i;
                    if (n > s + a) {
                        var h = e.slice(e.length / 2, e.length);
                        return s += a, this.getIncludingPart(t, h, i, n, s)
                    }
                    return this.getIncludingPart(t, r, i, n, s)
                }, e._spaceWidth = {}, e
            }();
            t.LabelLayoutBase = n
        }(e = t.Base || (t.Base = {}))
    }(e = t.Internal || (t.Internal = {}))
}(ZoomCharts || (ZoomCharts = {}));
var ZoomCharts;
!function (t) {
    var e;
    !function (t) {
        var e;
        !function (t) {
            var e = function () {
                function t() {
                    this.data = null, this.label = null, this.textColor = null
                }

                return t
            }();
            t.LegendEntry = e;
            var i = function () {
                function t() {
                    this.enabled = !1, this.width = null, this.height = null, this.numberOfRows = null, this.numberOfColumns = null, this.margin = 1, this.padding = 5, this.maxLineSymbols = 15, this.lineSpacing = .2, this.text = {
                        font: "12px Arial",
                        fillColor: "#000"
                    }, this.marker = new o, this.equalizeRowsColumns = !0, this.panel = new s("left", "fill", 1), this.advanced = new n
                }

                return t
            }();
            t.SettingsLegend = i;
            var n = function () {
                function t() {
                    this.selectedBackground = "rgba(208,233,255,0.3)", this.selectedBorder = "rgba(208,233,255,0.3)"
                }

                return t
            }();
            t.SettingsLegendAdvanced = n;
            var s = function (t) {
                function e(e, i, n, s, o) {
                    t.call(this, e, i, n, s), this.padding = 0, void 0 !== o && (this.padding = o)
                }

                return __extends(e, t), e
            }(t.SettingsChartPanel);
            t.SettingsLegendPanel = s;
            var o = function () {
                function t() {
                    this.size = 20, this.alignment = "left", this.lineColor = "#fff"
                }

                return t
            }();
            t.SettingsLegendMarker = o;
            var r = function (i) {
                function n(e) {
                    var n = this;
                    i.call(this), this.entries = [], this.hoverObject = null, this.selectedObjects = [], this.entryWidth = 0, this.textHeight = 0, this.columns = null, this.rows = null, this.contentWidth = 0, this.contentHeight = 0, this.baseTextColor = null, this.markerSize = 0, this.drawingEntries = 0, this.lastInsensitive = !1, this.animationOrder = 300, this.chart = e, this.scene = e.scene, this.settings = this.scene.settings.legend, this.panel = new t.ChartPanel, this.panel.packingOrder = 50, this.panel.location = "outside", this.panel.computeSize = function (t, e, i, s) {
                        return n.computePanelSize(t, e, i, s)
                    }, t.Helpers.extend(this.panel, this.settings.panel), this.orientation = "left" === this.settings.panel.side || "right" === this.settings.panel.side ? "vertical" : "horizontal"
                }

                return __extends(n, i), n.prototype.onSceneChange = function (e) {
                    var i = e.changes;
                    i.settings && i.settingsChanges.legend && (i.bounds = !0, this.settings.enabled || (this.entries = []), t.Helpers.extend(this.panel, this.settings.panel), this.labelStyle = {
                        textStyle: this.settings.text,
                        align: "left",
                        lineSpacing: this.settings.lineSpacing,
                        padding: 0
                    })
                }, n.prototype.setItems = function (i) {
                    if (this.settings.enabled) {
                        this.entries = [];
                        for (var n = 0; n < i.length; n++) {
                            var s = i[n], o = new e;
                            o.data = s.data;
                            var r = o.label = new t.Label;
                            r.text = s.label, r.align = "left", o.textColor = s.textColor, this.entries.push(o)
                        }
                    }
                }, n.prototype.getPanels = function () {
                    return this.settings.enabled ? [this.panel] : []
                }, n.prototype.computePanelSize = function (e, i, n, s) {
                    if (0 === this.entries.length)return {width: 0, height: 0};
                    t.Graphics.textStyleNoShadow(n, this.labelStyle.textStyle);
                    for (var o = this.labelStyle.maxWidth = n.measureText("M").width * this.settings.maxLineSymbols, r = 0, a = this.settings.numberOfRows, h = this.settings.numberOfColumns, l = 2 * (this.settings.margin + this.settings.padding), u = 2 * (this.settings.panel.margin + this.settings.panel.padding), c = 0; c < this.entries.length; c++) {
                        var p = this.entries[c];
                        s.measure(n, p.label, this.labelStyle), r = Math.max(r, 2 * p.label.hheight)
                    }
                    this.textHeight = this.entries[0].label.lineHeight, this.markerSize = this.settings.marker.size || this.textHeight, r = Math.max(r, this.markerSize), this.entryHeight = Math.max(r, this.markerSize) + l, this.entryWidth = o + this.markerSize + this.settings.padding + l;
                    var d, f, m = (this.settings.width > 0 ? Math.min(e, Math.max(this.settings.width, this.entryWidth) + u) : e) - u, g = (this.settings.height > 0 ? Math.min(i, Math.max(this.settings.height, this.entryHeight) + u) : i) - u;
                    if ("vertical" === this.orientation) {
                        this.rows = Math.floor(g / this.entryHeight);
                        var y = Math.min(Math.ceil(this.entries.length / this.rows), Math.floor(m / this.entryWidth));
                        this.columns = h > 0 ? Math.min(h, y) : y, this.drawingEntries = Math.min(Math.floor(g / this.entryHeight) * this.columns, this.entries.length), f = this.columns * this.entryWidth, this.drawingEntries > this.rows ? (this.settings.equalizeRowsColumns && (this.rows = Math.ceil(this.drawingEntries / this.columns)), d = this.rows * this.entryHeight) : d = this.drawingEntries * this.entryHeight
                    }
                    if ("horizontal" === this.orientation) {
                        this.columns = Math.floor(m / this.entryWidth);
                        var v = Math.min(Math.ceil(this.entries.length / this.columns), Math.floor(g / this.entryHeight));
                        this.rows = a > 0 ? Math.min(a, v) : v, this.drawingEntries = Math.min(Math.floor(m / this.entryWidth) * this.rows, this.entries.length), d = this.rows * this.entryHeight, this.drawingEntries > this.columns ? (this.settings.equalizeRowsColumns && (this.columns = Math.ceil(this.drawingEntries / this.rows)), f = this.columns * this.entryWidth) : f = this.drawingEntries * this.entryWidth
                    }
                    this.contentHeight = d, this.contentWidth = f;
                    var S = this.settings.panel.padding;
                    return {width: f + 2 * S, height: d + 2 * S}
                }, n.prototype.paintScene = function (e) {
                    if (this.settings.enabled && 0 !== this.entries.length && 0 !== this.drawingEntries) {
                        this.lastInsensitive = !1;
                        var i = e.context, n = e.labelRenderer, s = this.panel.top, o = this.panel.left, r = this.settings.margin, a = this.settings.padding, h = this.settings.panel.padding, l = 0, u = 0, c = 0;
                        for (t.Graphics.textStyleNoShadow(i, this.settings.text), l = 0; l < this.drawingEntries; l++) {
                            var p = h + r, d = o + p + u * this.entryWidth, f = s + p + c * this.entryHeight, m = this.entries[l];
                            m.label.lineSpacing = this.settings.lineSpacing;
                            var g = void 0, y = void 0;
                            "right" === this.settings.marker.alignment ? (g = d + a + m.label.hwidth, y = d + this.entryWidth - 2 * (r + a) - this.markerSize / 2) : (g = d + this.markerSize + 2 * a + m.label.hwidth, y = d + a + this.markerSize / 2);
                            var v = m.label.hheight > this.markerSize / 2 ? 0 : this.markerSize / 2 - this.textHeight / 2, S = f + a + this.markerSize / 2, C = f + v + a + m.label.hheight;
                            if (this.drawingEntries < this.entries.length && l + 1 === this.drawingEntries) {
                                this.lastInsensitive = !0, i.fillStyle = "#000", i.textAlign = "left", i.font = "bold 12px Arial", i.fillText(". . .", g - m.label.hwidth, C);
                                break
                            }
                            if ((m.data === this.hoverObject || this.selectedObjects.indexOf(m.data) > -1) && this.rect(i, d, f, this.settings.advanced.selectedBorder, this.settings.advanced.selectedBackground, this.entryWidth - 2 * r, this.entryHeight - 2 * r), this.labelStyle.textStyle.fillColor = m.textColor, n.paintWithStyle(i, g, C, 1, m.label, this.labelStyle), this.paintMarker(e, y, S, this.markerSize / 2, m), "vertical" === this.orientation) {
                                if (c += 1, c === this.rows && (c = 0, u += 1), u === this.columns)break
                            } else if (u += 1, u === this.columns && (u = 0, c += 1), c === this.rows)break
                        }
                    }
                }, n.prototype.findItemAt = function (t, e) {
                    if (0 === this.entries.length)return null;
                    var i = this.panel.top + this.settings.panel.padding, n = this.panel.left + this.settings.panel.padding, s = n > t || t > n + this.contentWidth || i > e || e > i + this.contentHeight;
                    if (s)return null;
                    var o, r, a = Math.abs("vertical" === this.orientation ? this.contentHeight / this.entryHeight : this.contentWidth / this.entryWidth);
                    "vertical" === this.orientation ? (o = Math.floor((t - n) / this.entryWidth), r = Math.floor((e - i) / this.entryHeight)) : (o = Math.floor((e - i) / this.entryHeight), r = Math.floor((t - n) / this.entryWidth));
                    var h = Math.floor(a * o + r);
                    return h > this.drawingEntries - 1 ? null : this.lastInsensitive && h === this.drawingEntries - 1 ? null : this.entries[h].data
                }, n.prototype.rect = function (t, e, i, n, s, o, r) {
                    t.beginPath(), t.rect(e, i, o, r), t.fillStyle = s, t.fill(), t.lineWidth = 0, t.strokeStyle = n, t.stroke()
                }, n.prototype.paintMarker = function () {
                    throw new Error("Not implemented in derived class")
                }, n.prototype.shape = function (t, e, i, n, s, o) {
                    void 0 === o && (o = "black"), t.lineWidth = 1, t.beginPath(), t.rect(e, i, n, s), t.strokeStyle = o, t.stroke()
                }, n
            }(t.ChartElement);
            t.Legend = r
        }(e = t.Base || (t.Base = {}))
    }(e = t.Internal || (t.Internal = {}))
}(ZoomCharts || (ZoomCharts = {}));
var ZoomCharts;
!function (t) {
    var e;
    !function (t) {
        var e;
        !function (t) {
            var e;
            !function (e) {
                var i = function () {
                    function t(t) {
                        this.chart = t, this.domElement = null
                    }

                    return t.prototype.updateSettings = function () {
                    }, t.prototype.remove = function () {
                    }, t.prototype.onSceneChange = function () {
                    }, t.prototype.doAnimations = function () {
                    }, t
                }();
                e.Item = i;
                var n = function (e) {
                    function i(t) {
                        var i = this;
                        e.call(this, t), this.onClickProxy = function (t) {
                            return i.onClick(t)
                        }
                    }

                    return __extends(i, e), i.prototype.createButton = function (e) {
                        this.options = e, this.li = t.Helpers.createDom("li", null, null, null), this.a = t.Helpers.createDom("a", null, null, this.li), this.p = t.Helpers.createDom("p", null, null, this.a), this.domElement = this.li, t.Helpers.listen(this.a, "click", this.onClickProxy), this.updateSettings()
                    }, i.prototype.updateSettings = function () {
                        var t = this.options.title || this.options.label || "";
                        this.a.title = t;
                        var e = "DVSL-bar-btn " + (this.options.cssClass ? this.options.cssClass : this.options.image ? "DVSL-bar-btn-image" : "DVSL-bar-btn-none");
                        this.a.className = e, this.p.innerHTML = this.options.showLabels !== !1 ? this.options.label || "" : "", this.p.style.backgroundImage = this.options.image ? "url('" + this.options.image + "')" : null
                    }, i.prototype.remove = function () {
                        t.Helpers.unlisten(this.a, "click", this.onClickProxy)
                    }, i.prototype.onClick = function () {
                    }, i
                }(i);
                e.Button = n
            }(e = t.Bar || (t.Bar = {}))
        }(e = t.Base || (t.Base = {}))
    }(e = t.Internal || (t.Internal = {}))
}(ZoomCharts || (ZoomCharts = {}));
var ZoomCharts;
!function (t) {
    var e;
    !function (t) {
        var e;
        !function (t) {
            var e;
            !function (e) {
                var i = function (e) {
                    function i(t, i) {
                        e.call(this, t), this.options = i, this.createButton(i)
                    }

                    return __extends(i, e), i.prototype.onClick = function (e) {
                        this.options.onClick && this.options.onClick(e, this.chart.api), t.Helpers.stopPropagation(e)
                    }, i
                }(e.Button);
                e.UserButton = i
            }(e = t.Bar || (t.Bar = {}))
        }(e = t.Base || (t.Base = {}))
    }(e = t.Internal || (t.Internal = {}))
}(ZoomCharts || (ZoomCharts = {}));
var ZoomCharts;
!function (t) {
    var e;
    !function (t) {
        var e;
        !function (t) {
            var e;
            !function (e) {
                var i = function (e) {
                    function i(i, n) {
                        e.call(this, i), this.options = n, this.createButton(n), t.Helpers.createDom("span", null, null, this.a), t.Helpers.addClass(this.a, "DVSL-bar-show-more")
                    }

                    return __extends(i, e), i.prototype.buildDropdownList = function () {
                        return []
                    }, i.prototype.onHideDropdown = function () {
                    }, i.prototype.onClick = function (e) {
                        this.dropdown ? this.hideDropdown() : this.showDropdown(), t.Helpers.stopPropagation(e)
                    }, i.prototype.showDropdown = function () {
                        this.dropdown = t.Helpers.createDom("div", "DVSL-bar-dropdown", null, this.li), this.dropdown.style.display = "block";
                        for (var e = t.Helpers.createDom("ul", null, null, this.dropdown), i = 0, n = this.buildDropdownList(); i < n.length; i++) {
                            var s = n[i];
                            e.appendChild(s)
                        }
                    }, i.prototype.hideDropdown = function () {
                        this.onHideDropdown(), this.dropdown.parentNode.removeChild(this.dropdown), this.dropdown = null
                    }, i.prototype.previewPointerDown = function (e) {
                        var i = t.Helpers.isParentOf(this.li, e.target);
                        if (this.dropdown && !i) {
                            var n = t.Helpers.elementPos(this.chart.shell.interactiveContainer), s = n.left, o = n.top;
                            n = t.Helpers.elementPos(this.dropdown);
                            var r = n.left, a = n.top;
                            r -= s, a -= o;
                            var h = r + this.dropdown.offsetWidth, l = a + this.dropdown.offsetHeight;
                            (r > e.x || a > e.y || l < e.y || h < e.x) && this.hideDropdown()
                        }
                    }, i
                }(e.Button);
                e.DropdownBase = i
            }(e = t.Bar || (t.Bar = {}))
        }(e = t.Base || (t.Base = {}))
    }(e = t.Internal || (t.Internal = {}))
}(ZoomCharts || (ZoomCharts = {}));
var ZoomCharts;
!function (t) {
    var e;
    !function (t) {
        var e;
        !function (t) {
            var e;
            !function (e) {
                var i = function (e) {
                    function i(t, i) {
                        e.call(this, t, i), this.options = i, this.items = [], this.listeners = []
                    }

                    return __extends(i, e), i.prototype.buildDropdownList = function () {
                        var e = this;
                        this.items = [], this.listeners = [];
                        for (var i = 0; i < this.options.items.length; i++) {
                            var n = this.options.items[i];
                            t.Helpers.listen(n.domElement, "click", function () {
                                return e.hideDropdown()
                            }), this.items.push(n.domElement)
                        }
                        return this.items
                    }, i.prototype.onHideDropdown = function () {
                        for (var e = this, i = 0; i < this.items.length; i++) {
                            var n = this.items[i];
                            n.parentNode.removeChild(n), t.Helpers.unlisten(n, "click", function () {
                                return e.hideDropdown()
                            })
                        }
                        return this.items = [], this.listeners = []
                    }, i
                }(e.DropdownBase);
                e.Dropdown = i
            }(e = t.Bar || (t.Bar = {}))
        }(e = t.Base || (t.Base = {}))
    }(e = t.Internal || (t.Internal = {}))
}(ZoomCharts || (ZoomCharts = {}));
var ZoomCharts;
!function (t) {
    var e;
    !function (t) {
        var e;
        !function (t) {
            var e;
            !function (e) {
                var i = function (e) {
                    function i(t, i) {
                        this.options = i, e.call(this, t, i)
                    }

                    return __extends(i, e), i.prototype.onSelectionChange = function (t) {
                        return t
                    }, i.prototype.getItems = function () {
                        return []
                    }, i.prototype.buildDropdownList = function () {
                        for (var e = this, i = [], n = 0, s = this.getItems(); n < s.length; n++) {
                            var o = s[n], r = t.Helpers.createDom("li", null, null, null), a = t.Helpers.createDom("a", null, o.name, r);
                            o.selected && (a.className = "DVSL-bar-dropdown-active"), o.disabled ? a.className = "DVSL-bar-dropdown-disabled" : !function (i, n) {
                                    return t.Helpers.listen(i, "click", function () {
                                        return e.userSelected(n)
                                    })
                                }(a, o), i.push(r)
                        }
                        return i
                    }, i.prototype.userSelected = function (t) {
                        this.hideDropdown(), this.setSelectedItem(t), this.onSelectionChange(t)
                    }, i.prototype.setSelectedItem = function (t) {
                        this.options.showLabels !== !1 && (this.p.innerHTML = t.name || "")
                    }, i
                }(e.DropdownBase);
                e.Combobox = i
            }(e = t.Bar || (t.Bar = {}))
        }(e = t.Base || (t.Base = {}))
    }(e = t.Internal || (t.Internal = {}))
}(ZoomCharts || (ZoomCharts = {}));
var ZoomCharts;
!function (t) {
    var e;
    !function (t) {
        var e;
        !function (t) {
            var e;
            !function (e) {
                var i = function (e) {
                    function i(t, i) {
                        e.call(this, t), this.options = i, this.createButton(i), this.curState = !1
                    }

                    return __extends(i, e), i.prototype.onSceneChange = function (t) {
                        void 0 === t && (t = null);
                        var e = this.options.getChartState();
                        return e !== this.curState && (this.curState = e, this.a.className = this.curState && this.options.cssClassEnabled ? this.options.cssClassEnabled : this.options.cssClass, this.options.showLabels !== !1) ? this.p.innerHTML = this.curState && this.options.labelEnabled ? this.options.labelEnabled : this.options.label : void 0
                    }, i.prototype.onClick = function (e) {
                        this.curState ? this.options.onDisable() : this.options.onEnable(), this.onSceneChange(), t.Helpers.stopPropagation(e)
                    }, i
                }(e.Button);
                e.ToggleButton = i
            }(e = t.Bar || (t.Bar = {}))
        }(e = t.Base || (t.Base = {}))
    }(e = t.Internal || (t.Internal = {}))
}(ZoomCharts || (ZoomCharts = {}));
var ZoomCharts;
!function (t) {
    var e;
    !function (t) {
        var e;
        !function (t) {
            var e;
            !function (t) {
                t.ToolbarItemNames = {}
            }(e = t.Bar || (t.Bar = {}))
        }(e = t.Base || (t.Base = {}))
    }(e = t.Internal || (t.Internal = {}))
}(ZoomCharts || (ZoomCharts = {}));
var ZoomCharts;
!function (t) {
    var e;
    !function (t) {
        var e;
        !function (t) {
            var e = function () {
                function t(t, e, i, n, s) {
                    void 0 === t && (t = !1), void 0 === e && (e = []), this.enabled = !1, this.location = "inside", this.side = "top", this.align = "right", this.showLabels = !0, this.cssClass = "DVSL-bar-infobar", this.items = [], this.extraItems = [], this.back = !0, this["export"] = !0, this.zoomOut = !1, this.enabled = t, this.items = e, void 0 !== i && (this.side = i), void 0 !== n && (this.align = n), void 0 !== s && (this.showLabels = s)
                }

                return t
            }();
            t.SettingsToolbar = e;
            var i = function () {
                function t(t, e, i) {
                    this.location = void 0, this.side = void 0, this.align = void 0, this.showLabel = void 0, this.item = null, this.itemConstructor = null, this.label = null, this.title = null, this.image = null, this.onClick = null, this.cssClass = null, this.item = t, void 0 !== e && (this.align = e), void 0 !== i && (this.side = i)
                }

                return t
            }();
            t.SettingsToolbarItem = i;
            var n = function (e) {
                function i(t, i) {
                    e.call(this), this.panels = {}, this.panelList = [], this.animationOrder = 2e3, this.options = i, this.chart = t, this.scene = this.chart.scene, this.items = [], this.itemBuilders = {}, this.addItems(), this.chart.events.addElement(this), this.chart.events.notifySceneChanges({bounds: !0})
                }

                return __extends(i, e), i.prototype.rebuildItems = function () {
                    this.removeItems(), this.addItems()
                }, i.prototype.addItems = function () {
                    if (this.options.enabled) {
                        for (var t = 0; t < this.options.items.length; t++) {
                            var e = this.options.items[t];
                            this.addItem(e)
                        }
                        for (var t = 0; t < this.options.extraItems.length; t++) {
                            var e = this.options.extraItems[t];
                            this.addItem(e)
                        }
                    }
                }, i.prototype.removeItems = function () {
                    for (var t = 0; t < this.items.length; t++) {
                        var e = this.items[t];
                        e.remove()
                    }
                    for (var i = 0; i < this.panelList.length; i++) {
                        var n = this.panelList[i];
                        n.clear()
                    }
                    this.items = []
                }, i.prototype.remove = function () {
                    this.removeItems();
                    for (var t = 0; t < this.panelList.length; t++) {
                        var e = this.panelList[t];
                        e.remove()
                    }
                    this.chart.events.removeElement(this)
                }, i.prototype.addItem = function (e) {
                    var i, n, o = e.location || this.options.location, r = e.side || this.options.side, a = e.align || this.options.align, h = o + r;
                    if (this.panels.hasOwnProperty(h) ? i = this.panels[h] : (i = new s(this, o, r, this.chart), this.panelList.push(i), this.panels[h] = i), e = t.Helpers.isString(e) ? {item: e} : t.Helpers.clone(e), e.showLabels = (void 0 !== e.showLabels ? e.showLabels : this.options.showLabels) && !i.hideLabels, t.Helpers.isString(e.item)) {
                        var l = e.item || e;
                        if (this.options.hasOwnProperty(l) && this.options[l] === !1)return;
                        if (!t.Bar.ToolbarItemNames.hasOwnProperty(l))return void this.chart.error("Toolbar item name '" + l + "' not recognized.");
                        n = t.Bar.ToolbarItemNames[l](this.chart, e)
                    } else n = e.itemConstructor ? new e.itemConstructor(this.chart, e) : new t.Bar.UserButton(this.chart, e);
                    i.addItem(n, a), this.items.push(n)
                }, i.prototype.getPanels = function () {
                    return this.panelList
                }, i.prototype.onSceneChange = function (t) {
                    for (var e = 0; e < this.items.length; e++) {
                        var i = this.items[e];
                        i.onSceneChange(t.changes)
                    }
                }, i.prototype.doAnimations = function (t) {
                    for (var e = 0; e < this.items.length; e++) {
                        var i = this.items[e];
                        i.doAnimations(t)
                    }
                }, i.prototype.previewGlobalPointerDown = function (t) {
                    for (var e = 0; e < this.items.length; e++) {
                        var i = this.items[e];
                        i.previewPointerDown && i.previewPointerDown(t)
                    }
                }, i
            }(t.ChartElement);
            t.Toolbar = n;
            var s = function (e) {
                function i(i, n, s, o) {
                    e.call(this), this.chart = o, this.side = s, this.location = n, this.toolbar = i, this.packingOrder = "inside" === n ? 1e3 : 15, this.container = this.toolbar.chart.shell.menuContainer, this.floating = !1, this.align = "fill", "top" === this.side ? (this.vertical = !1, this.leftPanel = t.Helpers.createDom("ul", "DVSL-bar-left DVSL-bar-top DVSL-bar-horizontal", null, this.container), this.rightPanel = t.Helpers.createDom("ul", "DVSL-bar-right DVSL-bar-top DVSL-bar-horizontal", null, this.container)) : "bottom" === this.side ? (this.vertical = !1, this.leftPanel = t.Helpers.createDom("ul", "DVSL-bar-left DVSL-bar-bottom DVSL-bar-horizontal", null, this.container), this.rightPanel = t.Helpers.createDom("ul", "DVSL-bar-right DVSL-bar-bottom DVSL-bar-horizontal", null, this.container)) : "left" === this.side ? (this.vertical = !0, this.leftPanel = t.Helpers.createDom("ul", "DVSL-bar-left DVSL-bar-top DVSL-bar-vertical", null, this.container), this.rightPanel = t.Helpers.createDom("ul", "DVSL-bar-left DVSL-bar-bottom DVSL-bar-vertical", null, this.container)) : "right" === this.side ? (this.vertical = !0, this.leftPanel = t.Helpers.createDom("ul", "DVSL-bar-right DVSL-bar-top DVSL-bar-vertical", null, this.container), this.rightPanel = t.Helpers.createDom("ul", "DVSL-bar-right DVSL-bar-bottom DVSL-bar-vertical", null, this.container)) : this.chart.error("Unrecognized side: '" + this.side + "'"), this.leftPanel.style.visibility = "hidden", this.rightPanel.style.visibility = "hidden"
                }

                return __extends(i, e), i.prototype.addItem = function (t, e) {
                    "left" === e || "top" === e ? this.leftPanel.appendChild(t.domElement) : "right" === e || "bottom" === e ? this.rightPanel.appendChild(t.domElement) : this.chart.error("Unrecognized align: '" + e + "'")
                }, i.prototype.clear = function () {
                    this.leftPanel.innerHTML = "", this.rightPanel.innerHTML = ""
                }, i.prototype.computeSize = function (t) {
                    if (!this.vertical) {
                        this.hideLabels || (this.contentWidthWithLabels = this.leftPanel.offsetWidth + this.rightPanel.offsetWidth);
                        var e = this.contentWidthWithLabels > t;
                        e !== this.hideLabels && (this.hideLabels = e, this.toolbar.rebuildItems())
                    }
                    return this.vertical ? {
                            width: Math.max(this.leftPanel.offsetWidth, this.rightPanel.offsetWidth),
                            height: 0
                        } : {
                            width: 0,
                            height: Math.max(this.leftPanel.offsetHeight, this.rightPanel.offsetHeight)
                        }
                }, i.prototype.placePanel = function (t, e, i, n) {
                    this.vertical ? (this.leftPanel.style.width = i - t + "px", this.rightPanel.style.width = i - t + "px", this.leftPanel.style.top = e + "px", this.rightPanel.style.bottom = this.toolbar.scene.chartHeight - n + "px", "left" === this.side ? (this.leftPanel.style.left = t + "px", this.rightPanel.style.left = t + "px") : (this.leftPanel.style.right = this.toolbar.scene.chartWidth - i + "px", this.rightPanel.style.right = this.toolbar.scene.chartWidth - i + "px")) : (this.leftPanel.style.left = t + "px", this.leftPanel.style.height = n - e + "px", this.rightPanel.style.right = this.toolbar.scene.chartWidth - i + "px", this.rightPanel.style.height = n - e + "px", "top" === this.side ? (this.leftPanel.style.top = e + "px", this.rightPanel.style.top = e + "px") : (this.leftPanel.style.bottom = this.toolbar.scene.chartHeight - n + "px", this.rightPanel.style.bottom = this.toolbar.scene.chartHeight - n + "px")), this.leftPanel.style.visibility = "visible", this.rightPanel.style.visibility = "visible"
                }, i.prototype.remove = function () {
                    return this.container.removeChild(this.leftPanel), this.container.removeChild(this.rightPanel)
                }, i
            }(t.ChartPanel);
            t.ToolbarPanel = s
        }(e = t.Base || (t.Base = {}))
    }(e = t.Internal || (t.Internal = {}))
}(ZoomCharts || (ZoomCharts = {}));
var ZoomCharts;
!function (t) {
    var e;
    !function (t) {
        var e;
        !function (t) {
            var e = function () {
                function t() {
                    this.enabled = !0, this.fixedAspect = !1, this.visibilityDistance = 45, this.grabDistance = 10
                }

                return t
            }();
            t.SettingsResizer = e;
            var i = function (e) {
                function i(i) {
                    e.call(this), this.animationOrder = 2e3, this.paintOrder = 65, this.updateOrder = 300, this.oh = 0, this.sy = 0, this.barVisible = !1, this.resizing = !1, this.aspect = null, this.chart = i, this.scene = this.chart.scene, this.options = this.scene.settings.interaction.resizing, this.resizerBar = t.Helpers.createDom("div", "DVSL-resizer", null, this.chart.shell.interactiveContainer)
                }

                return __extends(i, e), i.prototype.onSceneChange = function () {
                    this.options.enabled || this.hideUI()
                }, i.prototype.doAnimations = function (t) {
                    t.changes.bounds && this.resizerBar && (this.resizerBar.style.width = this.scene.width + "px", this.resizerBar.style.left = this.scene.x0 + "px")
                }, i.prototype.onPointerOut = function () {
                    this.options.enabled && this.hideUI()
                }, i.prototype.onPointerMove = function (t) {
                    if (this.options.enabled) {
                        var e = this.scene.chartHeight - t.y;
                        e < this.options.visibilityDistance ? (this.barVisible || this.showUI(), e < this.options.grabDistance && (t.consumed = !0, t.cursor = "ns-resize")) : this.barVisible && this.hideUI()
                    }
                }, i.prototype.onPointerDown = function (t) {
                    if (this.options.enabled) {
                        this.sy = t.y;
                        var e = this.scene.chartHeight - t.y;
                        return this.resizing = e < this.options.grabDistance && t.y <= this.scene.chartHeight, this.resizing ? (this.aspect = this.options.fixedAspect ? Math.max(1, this.chart.scene.chartWidth) / Math.max(1, this.chart.scene.chartHeight) : 0, this.oh = this.scene.chartHeight, this.showUI(), t.cursor = "ns-resize", t.consumed = !0) : void 0
                    }
                }, i.prototype.onDoubleClick = function () {
                    return this.resizing ? this.chart.setFullscreen(!this.chart.isFullscreen()) : void 0
                }, i.prototype.onPointerDrag = function (t) {
                    if (this.options.enabled)if (this.chart.isFullscreen()) this.chart.setFullscreen(!1), this.hideUI(), t.consumed = !0; else if (this.resizing) {
                        var e = this.scene.settings.area;
                        t.consumed = !0, this.wasMaximized = !1, e.height = Math.min(e.maxHeight, Math.max(e.minHeight, this.oh + (t.y - this.sy))), this.aspect && (e.width = e.height * this.aspect), this.chart.updateSize(!0)
                    }
                }, i.prototype.showUI = function () {
                    this.barVisible || (this.barVisible = !0, t.Helpers.fadeIn(this.resizerBar))
                }, i.prototype.hideUI = function () {
                    this.barVisible && (this.barVisible = !1, this.resizing = !1, t.Helpers.fadeOut(this.resizerBar))
                }, i
            }(t.ChartElement);
            t.Resizer = i
        }(e = t.Base || (t.Base = {}))
    }(e = t.Internal || (t.Internal = {}))
}(ZoomCharts || (ZoomCharts = {}));
var ZoomCharts;
!function (t) {
    var e;
    !function (t) {
        var e;
        !function (e) {
            var i = function () {
                function e() {
                }

                return e.BaseIDataErrorResponse = {error: {type: 0}}, e.BaseSettings = {
                    advanced: {
                        type: 5,
                        update: 0,
                        contents: function () {
                            return e.BaseSettingsAdvanced
                        },
                        ctor: function () {
                            return t.Base.SettingsAdvanced
                        }
                    },
                    area: {
                        type: 5, update: 0, contents: function () {
                            return e.BaseSettingsArea
                        }, ctor: function () {
                            return t.Base.SettingsArea
                        }
                    },
                    assetsUrlBase: {type: 0},
                    container: {type: 3},
                    credits: {
                        type: 5, update: 0, contents: function () {
                            return e.BaseSettingsCredits
                        }, ctor: function () {
                            return t.Base.SettingsCredits
                        }
                    },
                    data: {
                        type: 6,
                        update: 4,
                        baseTypes: [{
                            type: 5, update: 0, contents: function () {
                                return e.BaseSettingsData
                            }, ctor: function () {
                                return t.Base.SettingsData
                            }
                        }]
                    },
                    events: {
                        type: 5, update: 0, contents: function () {
                            return e.BaseSettingsEvents
                        }, ctor: function () {
                            return t.Base.SettingsEvents
                        }
                    },
                    interaction: {
                        type: 5, update: 0, contents: function () {
                            return e.BaseSettingsInteraction
                        }, ctor: function () {
                            return t.Base.SettingsInteraction
                        }
                    },
                    legend: {
                        type: 5, update: 0, contents: function () {
                            return e.BaseSettingsLegend
                        }, ctor: function () {
                            return t.Base.SettingsLegend
                        }
                    },
                    localization: {
                        type: 5, update: 0, contents: function () {
                            return e.BaseSettingsLocalization
                        }, ctor: function () {
                            return t.Base.SettingsLocalization
                        }
                    },
                    parentChart: {type: 5},
                    theme: {
                        type: 5, contents: function () {
                            return e.BaseSettings
                        }, ctor: function () {
                            return t.Base.Settings
                        }, ctorIgnore: !0
                    },
                    title: {
                        type: 5, update: 0, contents: function () {
                            return e.BaseSettingsTitle
                        }, ctor: function () {
                            return t.Base.SettingsTitle
                        }
                    },
                    toolbar: {
                        type: 5, update: 0, contents: function () {
                            return e.BaseSettingsToolbar
                        }, ctor: function () {
                            return t.Base.SettingsToolbar
                        }
                    }
                }, e.BaseSettingsAdvanced = {
                    assets: {
                        type: 6,
                        update: 3,
                        baseTypes: [{type: 0, details: 5}]
                    },
                    exportProxyURL: {type: 0, details: 5},
                    highDPI: {type: 9},
                    labelCache: {type: 9},
                    logging: {type: 9},
                    maxCanvasHeight: {type: 1},
                    maxCanvasWidth: {type: 1},
                    pdfExportAssets: {
                        type: 6,
                        update: 0,
                        baseTypes: [{type: 0, details: 5}]
                    },
                    pointer: {
                        type: 5, update: 0, contents: function () {
                            return e.BaseSettingsAdvancedPointer
                        }, ctor: function () {
                            return t.Base.SettingsAdvancedPointer
                        }
                    },
                    showFPS: {type: 9},
                    showTimestamp: {type: 9},
                    showTouches: {type: 9},
                    style: {
                        type: 5, update: 0, contents: function () {
                            return e.BaseSettingsAdvancedStyle
                        }, ctor: function () {
                            return t.Base.SettingsAdvancedStyle
                        }
                    },
                    themeCSSClass: {type: 0},
                    useAnimationFrame: {type: 9}
                }, e.BaseSettingsAdvancedPointer = {
                    clickSensitivity: {type: 1},
                    doubleClickSensitivity: {type: 1},
                    doubleClickTimeout: {type: 1, details: 0},
                    longPressSensitivity: {type: 1, details: 0},
                    longPressTimeout: {type: 1, details: 0},
                    noClickOnDoubleClick: {type: 9},
                    speedAveragingPeriod: {type: 1, details: 0}
                }, e.BaseSettingsAdvancedStyle = {
                    loadingArcStyle: {
                        type: 5,
                        update: 0,
                        contents: function () {
                            return {
                                lineColor: {type: 0},
                                lineWidth: {type: 1},
                                location: {type: 0, details: 6},
                                r: {type: 1}
                            }
                        }
                    }, messageTextStyle: {
                        type: 5, update: 0, contents: function () {
                            return {fillColor: {type: 0}, font: {type: 0}}
                        }
                    }
                }, e.BaseSettingsArea = {
                    height: {type: 1},
                    left: {type: 1},
                    maxHeight: {type: 1},
                    maxWidth: {type: 1},
                    minHeight: {type: 1},
                    minWidth: {type: 1},
                    style: {
                        type: 5, update: 0, contents: function () {
                            return e.BaseSettingsAreaStyle
                        }, ctor: function () {
                            return t.Base.SettingsAreaStyle
                        }
                    },
                    top: {type: 1},
                    width: {type: 1}
                }, e.BaseSettingsAreaStyle = {
                    fillColor: {type: 0, details: 3},
                    image: {type: 0, details: 4},
                    overlayColor: {type: 0, details: 3}
                }, e.BaseSettingsBackgroundStyle = {
                    fillColor: {
                        type: 7,
                        baseTypes: [{type: 0}, {type: 14}]
                    },
                    lineColor: {type: 0},
                    lineDash: {type: 6, update: 0, baseTypes: [{type: 1}]},
                    lineWidth: {type: 1},
                    shadowBlur: {type: 1},
                    shadowColor: {type: 0},
                    shadowOffsetX: {type: 1},
                    shadowOffsetY: {type: 1}
                }, e.BaseSettingsCredits = {
                    enabled: {type: 9},
                    enabledOnExport: {type: 9},
                    image: {type: 0, details: 4},
                    imageScaling: {type: 1},
                    location: {type: 0, details: 6},
                    url: {type: 0, details: 5}
                }, e.BaseSettingsData = {
                    format: {type: 0, details: 6},
                    id: {type: 0},
                    numberOfParallelRequests: {type: 1, details: 0},
                    postprocessorFunction: {type: 4},
                    preloaded: {
                        type: 7,
                        baseTypes: [{type: 0}, {
                            type: 5, contents: function () {
                                return e.BaseIDataErrorResponse
                            }
                        }]
                    },
                    requestTimeout: {type: 1, details: 0},
                    url: {type: 0, details: 5},
                    urlParameters: {
                        type: 6,
                        update: 0,
                        baseTypes: [{
                            type: 5, update: 0, contents: function () {
                                return {name: {type: 0}, value: {type: 0}}
                            }
                        }]
                    }
                }, e.BaseSettingsEvents = {
                    chartUpdateDelay: {type: 1, details: 0},
                    onChartUpdate: {type: 4},
                    onClick: {type: 4},
                    onDoubleClick: {type: 4},
                    onError: {type: 4},
                    onHoverChange: {type: 4},
                    onPositionChange: {type: 4},
                    onRightClick: {type: 4},
                    onSelectionChange: {type: 4},
                    onSettingsChange: {type: 4},
                    onTripleClick: {type: 4}
                }, e.BaseSettingsInteraction = {
                    resizing: {
                        type: 5,
                        update: 0,
                        contents: function () {
                            return e.BaseSettingsResizer
                        },
                        ctor: function () {
                            return t.Base.SettingsResizer
                        }
                    }
                }, e.BaseSettingsLabelStyle = {
                    align: {type: 0, details: 6},
                    angle: {type: 1, details: 0},
                    aspectRatio: {type: 1},
                    backgroundStyle: {
                        type: 5, update: 0, contents: function () {
                            return e.BaseSettingsBackgroundStyle
                        }
                    },
                    borderRadius: {type: 1},
                    image: {type: 0, details: 4},
                    imageSlicing: {
                        type: 12,
                        baseTypes: [{type: 1}, {type: 1}, {type: 1}, {type: 1}]
                    },
                    lineSpacing: {type: 1},
                    margin: {type: 1},
                    maxWidth: {type: 1},
                    padding: {type: 1},
                    text: {type: 0},
                    textStyle: {
                        type: 5, update: 0, contents: function () {
                            return e.BaseSettingsTextStyle
                        }
                    }
                }, e.BaseSettingsLegend = {
                    advanced: {
                        type: 5,
                        update: 0,
                        contents: function () {
                            return e.BaseSettingsLegendAdvanced
                        },
                        ctor: function () {
                            return t.Base.SettingsLegendAdvanced
                        }
                    },
                    enabled: {type: 9},
                    equalizeRowsColumns: {type: 9},
                    height: {type: 1},
                    lineSpacing: {type: 1},
                    margin: {type: 1},
                    marker: {
                        type: 5, update: 0, contents: function () {
                            return e.BaseSettingsLegendMarker
                        }, ctor: function () {
                            return t.Base.SettingsLegendMarker
                        }
                    },
                    maxLineSymbols: {type: 1, details: 0},
                    numberOfColumns: {type: 1, details: 0},
                    numberOfRows: {type: 1, details: 0},
                    padding: {type: 1},
                    panel: {
                        type: 5, update: 0, contents: function () {
                            return e.BaseSettingsLegendPanel
                        }, ctor: function () {
                            return t.Base.SettingsLegendPanel
                        }
                    },
                    text: {
                        type: 5, update: 0, contents: function () {
                            return {fillColor: {type: 0}, font: {type: 0}}
                        }
                    },
                    width: {type: 1}
                }, e.BaseSettingsLegendAdvanced = {
                    selectedBackground: {
                        type: 0,
                        details: 3
                    }, selectedBorder: {type: 0, details: 3}
                }, e.BaseSettingsLegendMarker = {
                    alignment: {type: 0, details: 6},
                    lineColor: {type: 0, details: 3},
                    size: {type: 1}
                }, e.BaseSettingsLegendPanel = {
                    align: {type: 0, details: 6},
                    floating: {type: 9},
                    location: {type: 0, details: 6},
                    margin: {type: 1},
                    padding: {type: 1},
                    side: {type: 0, details: 6}
                }, e.BaseSettingsLineStyle = {
                    lineColor: {type: 0},
                    lineDash: {type: 6, update: 0, baseTypes: [{type: 1}]},
                    lineWidth: {type: 1}
                }, e.BaseSettingsLocalization = {
                    closeButton: {type: 0},
                    dataRequestFailed: {type: 0},
                    loadingLabel: {type: 0},
                    toolbar: {
                        type: 5, update: 0, contents: function () {
                            return e.BaseSettingsLocalizationToolbar
                        }, ctor: function () {
                            return t.Base.SettingsLocalizationToolbar
                        }
                    }
                }, e.BaseSettingsLocalizationToolbar = {
                    backButton: {type: 0},
                    backTitle: {type: 0},
                    exportButton: {type: 0},
                    exportCSV: {type: 0},
                    exportJpeg: {type: 0},
                    exportPDF: {type: 0},
                    exportPNG: {type: 0},
                    exportTitle: {type: 0},
                    exportXLS: {type: 0},
                    fullscreenButton: {type: 0},
                    fullscreenTitle: {type: 0},
                    zoomoutButton: {type: 0},
                    zoomoutTitle: {type: 0}
                }, e.BaseSettingsResizer = {
                    enabled: {type: 9},
                    fixedAspect: {type: 9},
                    grabDistance: {type: 1},
                    visibilityDistance: {type: 1}
                }, e.BaseSettingsTextStyle = {
                    fillColor: {type: 0},
                    font: {type: 0},
                    shadowBlur: {type: 1},
                    shadowColor: {type: 0},
                    shadowOffsetX: {type: 1},
                    shadowOffsetY: {type: 1}
                }, e.BaseSettingsTitle = {
                    align: {type: 0, details: 6},
                    enabled: {type: 9},
                    enabledOnExport: {type: 9},
                    margin: {type: 1},
                    style: {
                        type: 5, update: 0, contents: function () {
                            return {fillColor: {type: 0}, font: {type: 0}}
                        }
                    },
                    text: {type: 0}
                }, e.BaseSettingsToolbar = {
                    align: {type: 0, details: 6},
                    back: {type: 9},
                    cssClass: {type: 0},
                    enabled: {type: 9},
                    "export": {type: 9},
                    extraItems: {
                        type: 6,
                        update: 0,
                        baseTypes: [{
                            type: 7,
                            update: 0,
                            baseTypes: [{type: 0}, {
                                type: 5,
                                update: 0,
                                contents: function () {
                                    return e.BaseSettingsToolbarItem
                                },
                                ctor: function () {
                                    return t.Base.SettingsToolbarItem
                                }
                            }]
                        }]
                    },
                    items: {
                        type: 6,
                        update: 0,
                        baseTypes: [{
                            type: 7,
                            update: 0,
                            baseTypes: [{type: 0}, {
                                type: 5,
                                update: 0,
                                contents: function () {
                                    return e.BaseSettingsToolbarItem
                                },
                                ctor: function () {
                                    return t.Base.SettingsToolbarItem
                                }
                            }]
                        }]
                    },
                    location: {type: 0, details: 6},
                    showLabels: {type: 9},
                    side: {type: 0, details: 6},
                    zoomOut: {type: 9}
                }, e.BaseSettingsToolbarItem = {
                    align: {type: 0, details: 6},
                    cssClass: {type: 0},
                    image: {type: 0, details: 4},
                    item: {type: 0, details: 6},
                    itemConstructor: {type: 10},
                    label: {type: 0},
                    location: {type: 0, details: 6},
                    onClick: {type: 4},
                    showLabel: {type: 9},
                    side: {type: 0, details: 6},
                    title: {type: 0}
                }, e.FacetChartSettings = {
                    advanced: {
                        type: 5,
                        update: 0,
                        contents: function () {
                            return e.BaseSettingsAdvanced
                        },
                        ctor: function () {
                            return t.Base.SettingsAdvanced
                        }
                    },
                    area: {
                        type: 5, update: 0, contents: function () {
                            return e.LinearChartSettingsArea
                        }, ctor: function () {
                            return t.LinearChart.SettingsArea
                        }
                    },
                    assetsUrlBase: {type: 0},
                    chartTypes: {
                        type: 5, update: 0, contents: function () {
                            return {
                                columns: {
                                    type: 5, update: 0, contents: function () {
                                        return e.FacetChartSettingsSeriesColumns
                                    }, ctor: function () {
                                        return t.FacetChart.SettingsSeriesColumns
                                    }, ctorIgnore: !0
                                }, line: {
                                    type: 5, update: 0, contents: function () {
                                        return e.FacetChartSettingsSeriesLines
                                    }, ctor: function () {
                                        return t.FacetChart.SettingsSeriesLines
                                    }, ctorIgnore: !0
                                }
                            }
                        }
                    },
                    container: {type: 3},
                    credits: {
                        type: 5, update: 0, contents: function () {
                            return e.BaseSettingsCredits
                        }, ctor: function () {
                            return t.Base.SettingsCredits
                        }
                    },
                    data: {
                        type: 6,
                        update: 4,
                        baseTypes: [{
                            type: 5, update: 0, contents: function () {
                                return e.PieChartSettingsData
                            }, ctor: function () {
                                return t.PieChart.SettingsData
                            }
                        }]
                    },
                    events: {
                        type: 5, update: 0, contents: function () {
                            return e.LinearChartSettingsEvents
                        }, ctor: function () {
                            return t.LinearChart.SettingsEvents
                        }
                    },
                    facetAxis: {
                        type: 5, update: 0, contents: function () {
                            return e.FacetChartSettingsFacetAxis
                        }, ctor: function () {
                            return t.FacetChart.SettingsFacetAxis
                        }
                    },
                    filters: {
                        type: 5, update: 0, contents: function () {
                            return {sliceFilter: {type: 4}}
                        }
                    },
                    info: {
                        type: 5, update: 0, contents: function () {
                            return e.LinearChartSettingsInfoPopup
                        }, ctor: function () {
                            return t.LinearChart.SettingsInfoPopup
                        }
                    },
                    interaction: {
                        type: 5, update: 0, contents: function () {
                            return e.FacetChartSettingsInteraction
                        }, ctor: function () {
                            return t.FacetChart.SettingsInteraction
                        }
                    },
                    items: {
                        type: 5, update: 0, contents: function () {
                            return {
                                style: {
                                    type: 5, update: 0, contents: function () {
                                        return {expandable: {type: 9}, label: {type: 0}}
                                    }
                                }, styleFunction: {type: 4}
                            }
                        }
                    },
                    legend: {
                        type: 5, update: 0, contents: function () {
                            return e.LinearChartSettingsLegend
                        }, ctor: function () {
                            return t.LinearChart.SettingsLegend
                        }
                    },
                    localization: {
                        type: 5, update: 0, contents: function () {
                            return e.LinearChartSettingsLocalization
                        }, ctor: function () {
                            return t.LinearChart.SettingsLocalization
                        }
                    },
                    navigation: {
                        type: 5, update: 0, contents: function () {
                            return {
                                initialDrilldown: {
                                    type: 6,
                                    update: 0,
                                    baseTypes: [{type: 0}]
                                }, initialOffset: {type: 1, details: 0}
                            }
                        }
                    },
                    parentChart: {type: 5},
                    scrollButtons: {
                        type: 5, update: 0, contents: function () {
                            return e.FacetChartSettingsScrollButtons
                        }, ctor: function () {
                            return t.FacetChart.SettingsScrollButtons
                        }
                    },
                    series: {
                        type: 6,
                        update: 4,
                        baseTypes: [{
                            type: 5, update: 0, contents: function () {
                                return e.FacetChartSettingsSeries
                            }, ctor: function () {
                                return t.FacetChart.SettingsSeries
                            }, ctorIgnore: !0
                        }]
                    },
                    seriesDefault: {
                        type: 5, update: 0, contents: function () {
                            return e.LinearChartSettingsSeries
                        }, ctor: function () {
                            return t.LinearChart.SettingsSeries
                        }, ctorIgnore: !0
                    },
                    stacks: {
                        type: 8,
                        update: 0,
                        baseTypes: [{
                            type: 5, update: 0, contents: function () {
                                return e.LinearChartSettingsStack
                            }, ctor: function () {
                                return t.LinearChart.SettingsStack
                            }
                        }]
                    },
                    style: {
                        type: 5, update: 0, contents: function () {
                            return {
                                columnColors: {
                                    type: 6,
                                    update: 0,
                                    baseTypes: [{type: 0}]
                                },
                                lineColors: {type: 6, update: 0, baseTypes: [{type: 0}]}
                            }
                        }
                    },
                    theme: {
                        type: 5, contents: function () {
                            return e.BaseSettings
                        }, ctor: function () {
                            return t.Base.Settings
                        }, ctorIgnore: !0
                    },
                    title: {
                        type: 5, update: 0, contents: function () {
                            return e.BaseSettingsTitle
                        }, ctor: function () {
                            return t.Base.SettingsTitle
                        }
                    },
                    toolbar: {
                        type: 5, update: 0, contents: function () {
                            return e.BaseSettingsToolbar
                        }, ctor: function () {
                            return t.Base.SettingsToolbar
                        }
                    },
                    valueAxis: {
                        type: 8,
                        update: 0,
                        baseTypes: [{
                            type: 5, update: 0, contents: function () {
                                return e.LinearChartSettingsValueAxis
                            }, ctor: function () {
                                return t.LinearChart.SettingsValueAxis
                            }
                        }]
                    },
                    valueAxisDefault: {
                        type: 5, update: 0, contents: function () {
                            return e.LinearChartSettingsValueAxis
                        }, ctor: function () {
                            return t.LinearChart.SettingsValueAxis
                        }
                    }
                }, e.FacetChartSettingsFacetAxis = {
                    defaultUnitWidth: {type: 1},
                    enabled: {type: 9},
                    labels: {
                        type: 5, update: 0, contents: function () {
                            return e.FacetChartSettingsFacetAxisLabels
                        }
                    },
                    maxUnitWidth: {type: 1},
                    size: {type: 1}
                }, e.FacetChartSettingsFacetAxisLabels = {
                    align: {type: 0, details: 6},
                    angle: {type: 1, details: 0},
                    aspectRatio: {type: 1},
                    backgroundStyle: {
                        type: 5, update: 0, contents: function () {
                            return e.BaseSettingsBackgroundStyle
                        }
                    },
                    borderRadius: {type: 1},
                    enabled: {type: 9},
                    image: {type: 0, details: 4},
                    imageSlicing: {
                        type: 12,
                        baseTypes: [{type: 1}, {type: 1}, {type: 1}, {type: 1}]
                    },
                    interLabelSpacing: {type: 1},
                    lineSpacing: {type: 1},
                    margin: {type: 1},
                    maxWidth: {type: 1},
                    padding: {type: 1},
                    text: {type: 0},
                    textStyle: {
                        type: 5, update: 0, contents: function () {
                            return e.BaseSettingsTextStyle
                        }
                    }
                }, e.FacetChartSettingsInteraction = {
                    animation: {
                        type: 5,
                        update: 0,
                        contents: function () {
                            return {scrollDuration: {type: 1, details: 0}}
                        }
                    },
                    resizing: {
                        type: 5, update: 0, contents: function () {
                            return e.BaseSettingsResizer
                        }, ctor: function () {
                            return t.Base.SettingsResizer
                        }
                    },
                    scrolling: {
                        type: 5, update: 0, contents: function () {
                            return e.LinearChartSettingsInteractionScrolling
                        }, ctor: function () {
                            return t.LinearChart.SettingsInteractionScrolling
                        }
                    },
                    selection: {
                        type: 5, update: 0, contents: function () {
                            return e.FacetChartSettingsInteractionSelection
                        }, ctor: function () {
                            return t.FacetChart.SettingsInteractionSelection
                        }
                    },
                    swipeSensitivity: {type: 1},
                    zooming: {
                        type: 5, update: 0, contents: function () {
                            return {
                                enabled: {type: 9},
                                fingers: {type: 9},
                                fingersMaxZoom: {type: 1},
                                keyboardFactor: {type: 1},
                                sensitivity: {type: 1},
                                swipe: {type: 9},
                                upDownTreshold: {type: 1},
                                wheel: {type: 9},
                                zoomHighlightThreshold: {type: 1}
                            }
                        }
                    }
                }, e.FacetChartSettingsInteractionSelection = {
                    enabled: {type: 9},
                    tolerance: {type: 1}
                }, e.FacetChartSettingsScrollButtons = {
                    enabled: {type: 9},
                    enabledOnExport: {type: 9},
                    size: {type: 1},
                    style: {
                        type: 5, update: 0, contents: function () {
                            return {
                                fillColor: {type: 0},
                                hoverFillColor: {type: 0},
                                hoverLineColor: {type: 0},
                                lineColor: {type: 0}
                            }
                        }
                    }
                }, e.FacetChartSettingsSeries = {
                    cluster: {type: 0},
                    data: {
                        type: 5, update: 0, contents: function () {
                            return e.FacetChartSettingsSeriesData
                        }, ctor: function () {
                            return t.FacetChart.SettingsSeriesData
                        }
                    },
                    enabled: {type: 9},
                    id: {type: 0},
                    name: {type: 0},
                    nameLegend: {type: 0},
                    showInLegend: {type: 9},
                    stack: {type: 0},
                    style: {
                        type: 5, update: 0, contents: function () {
                            return e.LinearChartSettingsSeriesStyle
                        }, ctor: function () {
                            return t.LinearChart.SettingsSeriesStyle
                        }
                    },
                    type: {type: 0, details: 6},
                    valueAxis: {type: 0}
                }, e.FacetChartSettingsSeriesColumns = {
                    cluster: {type: 0},
                    data: {
                        type: 5, update: 0, contents: function () {
                            return e.FacetChartSettingsSeriesData
                        }, ctor: function () {
                            return t.FacetChart.SettingsSeriesData
                        }
                    },
                    enabled: {type: 9},
                    id: {type: 0},
                    name: {type: 0},
                    nameLegend: {type: 0},
                    showInLegend: {type: 9},
                    stack: {type: 0},
                    style: {
                        type: 5, update: 0, contents: function () {
                            return e.FacetChartSettingsSeriesColumnsStyle
                        }, ctor: function () {
                            return t.FacetChart.SettingsSeriesColumnsStyle
                        }
                    },
                    type: {type: 0, details: 6},
                    valueAxis: {type: 0}
                }, e.FacetChartSettingsSeriesColumnsStyle = {
                    depth: {type: 1},
                    depthBrightness: {type: 1},
                    fillColor: {type: 0, details: 3},
                    fillGradient: {type: 11},
                    gradient: {type: 1},
                    lineColor: {type: 0, details: 3},
                    lineDash: {type: 6, update: 0, baseTypes: [{type: 1}]},
                    lineWidth: {type: 1, details: 0},
                    minHeight: {type: 1, details: 0},
                    padding: {
                        type: 12,
                        baseTypes: [{type: 1, details: 0}, {type: 1, details: 0}]
                    },
                    previewContents: {type: 9},
                    previewLineColor: {type: 0},
                    shadowBlur: {type: 1, details: 0},
                    shadowColor: {type: 0, details: 3},
                    shadowOffsetX: {type: 1, details: 0},
                    shadowOffsetY: {type: 1, details: 0}
                }, e.FacetChartSettingsSeriesData = {
                    aggregatedValueFunction: {type: 4},
                    aggregation: {type: 0, details: 6},
                    field: {type: 0},
                    noDataPolicy: {type: 0, details: 6},
                    source: {type: 0, details: 6},
                    valueFunction: {type: 4}
                }, e.FacetChartSettingsSeriesLines = {
                    cluster: {type: 0},
                    data: {
                        type: 5, update: 0, contents: function () {
                            return e.FacetChartSettingsSeriesData
                        }, ctor: function () {
                            return t.FacetChart.SettingsSeriesData
                        }
                    },
                    enabled: {type: 9},
                    id: {type: 0},
                    name: {type: 0},
                    nameLegend: {type: 0},
                    showInLegend: {type: 9},
                    stack: {type: 0},
                    style: {
                        type: 5, update: 0, contents: function () {
                            return {
                                depth: {type: 1},
                                fillColor: {type: 0, details: 3},
                                fillGradient: {type: 11},
                                lineColor: {type: 0},
                                lineDash: {type: 6, update: 0, baseTypes: [{type: 1}]},
                                lineWidth: {type: 1},
                                marker: {
                                    type: 5, update: 0, contents: function () {
                                        return {
                                            fillColor: {type: 0, details: 3},
                                            shape: {type: 0, details: 6},
                                            width: {type: 1, details: 0}
                                        }
                                    }
                                },
                                shadowBlur: {type: 1, details: 0},
                                shadowColor: {type: 0, details: 3},
                                shadowOffsetX: {type: 1, details: 0},
                                shadowOffsetY: {type: 1, details: 0},
                                smoothing: {type: 9},
                                steps: {type: 9}
                            }
                        }
                    },
                    type: {type: 0, details: 6},
                    valueAxis: {type: 0}
                }, e.GeoChartIAggregationDataObjectNode = {
                    aggregate: {type: 10},
                    aggregatedNodes: {
                        type: 6,
                        update: 0,
                        baseTypes: [{
                            type: 5, update: 0, contents: function () {
                                return e.GeoChartIDataObjectNode
                            }
                        }]
                    },
                    aggregatedWeight: {type: 1},
                    className: {type: 0},
                    coordinates: {
                        type: 7,
                        update: 0,
                        baseTypes: [{
                            type: 6,
                            update: 0,
                            baseTypes: [{type: 6, update: 0, baseTypes: [{type: 1}]}]
                        }, {type: 12, baseTypes: [{type: 1}, {type: 1}]}]
                    },
                    count: {type: 1},
                    id: {type: 0},
                    loaded: {type: 9},
                    style: {
                        type: 5, update: 0, contents: function () {
                            return e.ItemsChartSettingsNodeStyle
                        }
                    }
                }, e.GeoChartIDataObject = {
                    east: {type: 1},
                    error: {type: 0},
                    links: {
                        type: 6,
                        update: 0,
                        baseTypes: [{
                            type: 5, update: 0, contents: function () {
                                return e.GeoChartIDataObjectLink
                            }
                        }]
                    },
                    nodes: {
                        type: 6,
                        update: 0,
                        baseTypes: [{
                            type: 5, update: 0, contents: function () {
                                return e.GeoChartIDataObjectNode
                            }
                        }]
                    },
                    north: {type: 1},
                    south: {type: 1},
                    west: {type: 1}
                }, e.GeoChartIDataObjectLink = {
                    className: {type: 0},
                    from: {type: 0},
                    id: {type: 0},
                    style: {
                        type: 5, update: 0, contents: function () {
                            return e.ItemsChartSettingsLinkStyle
                        }
                    },
                    to: {type: 0},
                    value: {type: 1}
                }, e.GeoChartIDataObjectNode = {
                    aggregate: {type: 10},
                    className: {type: 0},
                    coordinates: {
                        type: 7,
                        update: 0,
                        baseTypes: [{
                            type: 6,
                            update: 0,
                            baseTypes: [{type: 6, update: 0, baseTypes: [{type: 1}]}]
                        }, {type: 12, baseTypes: [{type: 1}, {type: 1}]}]
                    },
                    count: {type: 1},
                    id: {type: 0},
                    loaded: {type: 9},
                    style: {
                        type: 5, update: 0, contents: function () {
                            return e.ItemsChartSettingsNodeStyle
                        }
                    }
                }, e.GeoChartSettings = {
                    advanced: {
                        type: 5, update: 0, contents: function () {
                            return e.ItemsChartSettingsAdvanced
                        }, ctor: function () {
                            return t.ItemsChart.SettingsAdvanced
                        }
                    },
                    area: {
                        type: 5, update: 0, contents: function () {
                            return e.GeoChartSettingsArea
                        }, ctor: function () {
                            return t.GeoChart.SettingsArea
                        }
                    },
                    assetsUrlBase: {type: 0},
                    background: {
                        type: 5, update: 0, contents: function () {
                            return e.GeoChartSettingsBackground
                        }, ctor: function () {
                            return t.GeoChart.SettingsBackground
                        }
                    },
                    container: {type: 3},
                    credits: {
                        type: 5, update: 0, contents: function () {
                            return e.BaseSettingsCredits
                        }, ctor: function () {
                            return t.Base.SettingsCredits
                        }
                    },
                    data: {
                        type: 6,
                        update: 4,
                        baseTypes: [{
                            type: 5, update: 0, contents: function () {
                                return e.GeoChartSettingsData
                            }, ctor: function () {
                                return t.GeoChart.SettingsData
                            }
                        }]
                    },
                    events: {
                        type: 5, update: 0, contents: function () {
                            return e.BaseSettingsEvents
                        }, ctor: function () {
                            return t.Base.SettingsEvents
                        }
                    },
                    filters: {
                        type: 5, update: 0, contents: function () {
                            return {nodeFilter: {type: 4}}
                        }
                    },
                    info: {
                        type: 5, update: 0, contents: function () {
                            return {
                                enabled: {type: 9},
                                linkContentsFunction: {type: 4},
                                nodeContentsFunction: {type: 4}
                            }
                        }
                    },
                    interaction: {
                        type: 5, update: 0, contents: function () {
                            return e.GeoChartSettingsInteraction
                        }, ctor: function () {
                            return t.GeoChart.SettingsInteraction
                        }
                    },
                    layerTypes: {
                        type: 5, update: 0, contents: function () {
                            return {
                                aggregateOnShapes: {
                                    type: 5,
                                    update: 0,
                                    contents: function () {
                                        return e.GeoChartSettingsLayerAggregated
                                    },
                                    ctor: function () {
                                        return t.GeoChart.SettingsLayerAggregated
                                    },
                                    ctorIgnore: !0
                                }, charts: {
                                    type: 5, update: 0, contents: function () {
                                        return e.GeoChartSettingsLayerCharts
                                    }, ctor: function () {
                                        return t.GeoChart.SettingsLayerCharts
                                    }, ctorIgnore: !0
                                }, items: {
                                    type: 5, update: 0, contents: function () {
                                        return e.GeoChartSettingsLayerItems
                                    }, ctor: function () {
                                        return t.GeoChart.SettingsLayerItems
                                    }, ctorIgnore: !0
                                }, shapes: {
                                    type: 5, update: 0, contents: function () {
                                        return e.GeoChartSettingsLayerShapes
                                    }, ctor: function () {
                                        return t.GeoChart.SettingsLayerShapes
                                    }, ctorIgnore: !0
                                }
                            }
                        }
                    },
                    layers: {
                        type: 6,
                        update: 4,
                        baseTypes: [{
                            type: 5, update: 0, contents: function () {
                                return e.GeoChartSettingsLayerBase
                            }, ctor: function () {
                                return t.GeoChart.SettingsLayerBase
                            }, ctorIgnore: !0
                        }]
                    },
                    layersDefault: {type: 10},
                    legend: {
                        type: 5, update: 0, contents: function () {
                            return e.BaseSettingsLegend
                        }, ctor: function () {
                            return t.Base.SettingsLegend
                        }
                    },
                    linkMenu: {
                        type: 5, update: 0, contents: function () {
                            return e.ItemsChartSettingsLinkMenu
                        }, ctor: function () {
                            return t.ItemsChart.SettingsLinkMenu
                        }
                    },
                    localization: {
                        type: 5, update: 0, contents: function () {
                            return e.BaseSettingsLocalization
                        }, ctor: function () {
                            return t.Base.SettingsLocalization
                        }
                    },
                    navigation: {
                        type: 5, update: 0, contents: function () {
                            return {
                                drilldownLayer: {type: 0},
                                initialDrilldown: {
                                    type: 6,
                                    update: 0,
                                    baseTypes: [{type: 0}]
                                },
                                initialLat: {type: 1},
                                initialLng: {type: 1},
                                initialZoom: {type: 1},
                                maxBounds: {
                                    type: 5, update: 0, contents: function () {
                                        return {
                                            east: {type: 1},
                                            north: {type: 1},
                                            south: {type: 1},
                                            west: {type: 1}
                                        }
                                    }
                                },
                                maxZoom: {type: 1},
                                minZoom: {type: 1}
                            }
                        }
                    },
                    nodeMenu: {
                        type: 5, update: 0, contents: function () {
                            return e.ItemsChartSettingsNodeMenu
                        }, ctor: function () {
                            return t.ItemsChart.SettingsNodeMenu
                        }
                    },
                    parentChart: {type: 5},
                    style: {
                        type: 5, update: 0, contents: function () {
                            return {
                                fadeTime: {type: 1},
                                selection: {
                                    type: 5, update: 0, contents: function () {
                                        return {
                                            fillColor: {type: 0},
                                            sizeConstant: {type: 1},
                                            sizeProportional: {type: 1}
                                        }
                                    }
                                }
                            }
                        }
                    },
                    theme: {
                        type: 5, contents: function () {
                            return e.GeoChartSettings
                        }, ctor: function () {
                            return t.GeoChart.Settings
                        }, ctorIgnore: !0
                    },
                    title: {
                        type: 5, update: 0, contents: function () {
                            return e.BaseSettingsTitle
                        }, ctor: function () {
                            return t.Base.SettingsTitle
                        }
                    },
                    toolbar: {
                        type: 5, update: 0, contents: function () {
                            return e.BaseSettingsToolbar
                        }, ctor: function () {
                            return t.Base.SettingsToolbar
                        }
                    }
                }, e.GeoChartSettingsAggregation = {
                    distance: {type: 1, details: 0},
                    enabled: {type: 9},
                    maxZoom: {type: 1, details: 0},
                    postProcessAggregatedNodes: {type: 4},
                    weightFunction: {type: 4}
                }, e.GeoChartSettingsArea = {
                    height: {type: 1},
                    left: {type: 1},
                    maxHeight: {type: 1},
                    maxWidth: {type: 1},
                    minHeight: {type: 1},
                    minWidth: {type: 1},
                    style: {
                        type: 5, update: 0, contents: function () {
                            return e.GeoChartSettingsAreaStyle
                        }, ctor: function () {
                            return t.GeoChart.SettingsAreaStyle
                        }
                    },
                    top: {type: 1},
                    width: {type: 1}
                }, e.GeoChartSettingsAreaStyle = {
                    fillColor: {type: 0, details: 3},
                    overlayColor: {type: 0, details: 3}
                }, e.GeoChartSettingsBackground = {
                    enabled: {type: 9},
                    params: {
                        type: 5, update: 0, contents: function () {
                            return {
                                attribution: {type: 0},
                                subdomains: {type: 6, update: 0, baseTypes: [{type: 0}]}
                            }
                        }
                    },
                    type: {type: 0},
                    url: {type: 0}
                }, e.GeoChartSettingsData = {
                    aggregationGridSize: {type: 1},
                    aggregationMinCount: {type: 1},
                    bounds: {
                        type: 12,
                        baseTypes: [{type: 1}, {type: 1}, {type: 1}, {type: 1}]
                    },
                    cacheSize: {type: 1, details: 0},
                    dataFunction: {type: 4},
                    format: {type: 0, details: 6},
                    id: {type: 0},
                    maxRequestRect: {type: 12, baseTypes: [{type: 1}, {type: 1}]},
                    numberOfParallelRequests: {type: 1, details: 0},
                    perBoundsData: {type: 9},
                    perDrilldownData: {type: 9},
                    perZoomData: {type: 9},
                    postprocessorFunction: {type: 4},
                    prefetchRatio: {type: 1},
                    preloadNodeLinks: {type: 9},
                    preloaded: {
                        type: 7,
                        baseTypes: [{type: 0}, {
                            type: 5, contents: function () {
                                return e.GeoChartIDataObject
                            }
                        }]
                    },
                    random: {type: 0, details: 6},
                    randomGridLinkProbability: {type: 1},
                    randomLinks: {type: 1, details: 0},
                    randomNodes: {type: 1, details: 0},
                    randomTreeDensity: {type: 1},
                    requestMaxUnits: {type: 1, details: 0},
                    requestTimeout: {type: 1, details: 0},
                    url: {type: 0, details: 5},
                    urlParameters: {
                        type: 6,
                        update: 0,
                        baseTypes: [{
                            type: 5, update: 0, contents: function () {
                                return {name: {type: 0}, value: {type: 0}}
                            }
                        }]
                    },
                    wrapLng: {type: 9}
                }, e.GeoChartSettingsInteraction = {
                    mode: {type: 0, details: 6},
                    nodesMovable: {type: 9},
                    panning: {
                        type: 5, update: 0, contents: function () {
                            return {enabled: {type: 9}}
                        }
                    },
                    resizing: {
                        type: 5, update: 0, contents: function () {
                            return e.BaseSettingsResizer
                        }, ctor: function () {
                            return t.Base.SettingsResizer
                        }
                    },
                    selection: {
                        type: 5, update: 0, contents: function () {
                            return e.ItemsChartSettingsInteractionSelection
                        }, ctor: function () {
                            return t.ItemsChart.SettingsInteractionSelection
                        }
                    },
                    zooming: {
                        type: 5, update: 0, contents: function () {
                            return e.ItemsChartSettingsInteractionZooming
                        }, ctor: function () {
                            return t.ItemsChart.SettingsInteractionZooming
                        }
                    }
                }, e.GeoChartSettingsLayerAggregated = {
                    aggregation: {
                        type: 0,
                        details: 6
                    },
                    aggregationField: {type: 0},
                    aggregationFunction: {type: 4},
                    data: {
                        type: 5, update: 0, contents: function () {
                            return {id: {type: 0}}
                        }
                    },
                    enabled: {type: 9},
                    id: {type: 0},
                    maxZoom: {type: 1, details: 0},
                    minZoom: {type: 1, details: 0},
                    name: {type: 0},
                    perZoomStyle: {type: 9},
                    shapesLayer: {type: 0},
                    styleFunction: {type: 4},
                    type: {type: 0, details: 6}
                }, e.GeoChartSettingsLayerBase = {
                    data: {
                        type: 5,
                        update: 0,
                        contents: function () {
                            return {id: {type: 0}}
                        }
                    },
                    enabled: {type: 9},
                    id: {type: 0},
                    maxZoom: {type: 1, details: 0},
                    minZoom: {type: 1, details: 0},
                    name: {type: 0},
                    perZoomStyle: {type: 9},
                    type: {type: 0, details: 6}
                }, e.GeoChartSettingsLayerCharts = {
                    chartType: {type: 0, details: 6},
                    data: {
                        type: 5, update: 0, contents: function () {
                            return {id: {type: 0}}
                        }
                    },
                    enabled: {type: 9},
                    id: {type: 0},
                    maxZoom: {type: 1, details: 0},
                    minZoom: {type: 1, details: 0},
                    name: {type: 0},
                    perZoomStyle: {type: 9},
                    settings: {
                        type: 7, baseTypes: [{
                            type: 5, contents: function () {
                                return e.TimeChartSettings
                            }, ctor: function () {
                                return t.TimeChart.Settings
                            }, ctorIgnore: !0
                        }, {
                            type: 5, contents: function () {
                                return e.PieChartSettings
                            }, ctor: function () {
                                return t.PieChart.Settings
                            }, ctorIgnore: !0
                        }, {
                            type: 5, contents: function () {
                                return e.FacetChartSettings
                            }, ctor: function () {
                                return t.FacetChart.Settings
                            }, ctorIgnore: !0
                        }]
                    },
                    settingsFunction: {type: 4},
                    shapesLayer: {type: 0},
                    type: {type: 0, details: 6}
                }, e.GeoChartSettingsLayerItems = {
                    aggregation: {
                        type: 5,
                        update: 0,
                        contents: function () {
                            return e.GeoChartSettingsAggregation
                        },
                        ctor: function () {
                            return t.GeoChart.SettingsAggregation
                        }
                    },
                    data: {
                        type: 5, update: 0, contents: function () {
                            return {id: {type: 0}}
                        }
                    },
                    enabled: {type: 9},
                    id: {type: 0},
                    layout: {
                        type: 5, update: 0, contents: function () {
                            return e.GeoChartSettingsNodesLayout
                        }, ctor: function () {
                            return t.GeoChart.SettingsNodesLayout
                        }
                    },
                    maxZoom: {type: 1, details: 0},
                    minZoom: {type: 1, details: 0},
                    name: {type: 0},
                    perZoomStyle: {type: 9},
                    style: {
                        type: 5, update: 0, contents: function () {
                            return e.GeoChartSettingsNodesLayerStyle
                        }, ctor: function () {
                            return t.GeoChart.SettingsNodesLayerStyle
                        }
                    },
                    type: {type: 0, details: 6}
                }, e.GeoChartSettingsLayerShapes = {
                    data: {
                        type: 5,
                        update: 0,
                        contents: function () {
                            return {id: {type: 0}}
                        }
                    },
                    enabled: {type: 9},
                    id: {type: 0},
                    maxZoom: {type: 1, details: 0},
                    minZoom: {type: 1, details: 0},
                    name: {type: 0},
                    perZoomStyle: {type: 9},
                    style: {
                        type: 5, update: 0, contents: function () {
                            return e.GeoChartSettingsShapesLayerStyle
                        }, ctor: function () {
                            return t.GeoChart.SettingsShapesLayerStyle
                        }
                    },
                    type: {type: 0, details: 6}
                }, e.GeoChartSettingsNodesLayerStyle = {
                    aggregatedShape: {
                        type: 5,
                        update: 0,
                        contents: function () {
                            return e.BaseSettingsBackgroundStyle
                        }
                    },
                    allObjectsStyleFunction: {type: 4},
                    fadeTime: {type: 1, details: 0},
                    hiddenLinks: {
                        type: 5, update: 0, contents: function () {
                            return {
                                lineColor: {type: 0},
                                lineWidth: {type: 1},
                                size: {type: 1}
                            }
                        }
                    },
                    item: {
                        type: 5, update: 0, contents: function () {
                            return e.ItemsChartSettingsItemsLayerLabelStyle
                        }
                    },
                    link: {
                        type: 5, update: 0, contents: function () {
                            return e.ItemsChartSettingsLinkStyle
                        }
                    },
                    linkAutoScaling: {type: 0, details: 6},
                    linkClasses: {
                        type: 6,
                        update: 0,
                        baseTypes: [{
                            type: 5, update: 0, contents: function () {
                                return {
                                    className: {type: 0},
                                    style: {
                                        type: 5, update: 0, contents: function () {
                                            return e.ItemsChartSettingsLinkStyle
                                        }
                                    }
                                }
                            }
                        }]
                    },
                    linkDecorationMinSize: {type: 1},
                    linkDecorationScale: {type: 1},
                    linkDetailMinSize: {type: 1},
                    linkDetailMinZoom: {type: 1},
                    linkHovered: {
                        type: 5, update: 0, contents: function () {
                            return e.ItemsChartSettingsLinkStyle
                        }
                    },
                    linkLabel: {
                        type: 5, update: 0, contents: function () {
                            return e.ItemsChartSettingsItemsLayerLinkLabelStyle
                        }
                    },
                    linkLabelScaleBase: {type: 1},
                    linkLengthAutoScaling: {type: 0, details: 6},
                    linkLengthExtent: {type: 12, baseTypes: [{type: 1}, {type: 1}]},
                    linkRadiusExtent: {type: 12, baseTypes: [{type: 1}, {type: 1}]},
                    linkRules: {type: 8, update: 0, baseTypes: [{type: 4}]},
                    linkSelected: {
                        type: 5, update: 0, contents: function () {
                            return e.ItemsChartSettingsLinkStyle
                        }
                    },
                    linkStrengthAutoScaling: {type: 0, details: 6},
                    linkStrengthExtent: {type: 12, baseTypes: [{type: 1}, {type: 1}]},
                    linkStyleFunction: {type: 4},
                    multilinkSpacing: {type: 1},
                    node: {
                        type: 5, update: 0, contents: function () {
                            return e.ItemsChartSettingsNodeStyle
                        }
                    },
                    nodeAnchor: {
                        type: 5, update: 0, contents: function () {
                            return e.ItemsChartSettingsNodeAnchorStyle
                        }
                    },
                    nodeAutoScaling: {type: 0, details: 6},
                    nodeBackground: {
                        type: 5, update: 0, contents: function () {
                            return e.ItemsChartSettingsNodeStyle
                        }
                    },
                    nodeClasses: {
                        type: 6,
                        update: 0,
                        baseTypes: [{
                            type: 5, update: 0, contents: function () {
                                return {
                                    className: {type: 0},
                                    style: {
                                        type: 5, update: 0, contents: function () {
                                            return e.ItemsChartSettingsNodeStyle
                                        }
                                    }
                                }
                            }
                        }]
                    },
                    nodeDetailMinSize: {type: 1},
                    nodeDetailMinZoom: {type: 1},
                    nodeExpanded: {
                        type: 5, update: 0, contents: function () {
                            return e.ItemsChartSettingsNodeStyle
                        }
                    },
                    nodeFocused: {
                        type: 5, update: 0, contents: function () {
                            return e.ItemsChartSettingsNodeStyle
                        }
                    },
                    nodeHovered: {
                        type: 5, update: 0, contents: function () {
                            return e.ItemsChartSettingsNodeStyle
                        }
                    },
                    nodeLabel: {
                        type: 5, update: 0, contents: function () {
                            return e.ItemsChartSettingsItemsLayerLabelStyle
                        }
                    },
                    nodeLabelScaleBase: {type: 1},
                    nodeLocked: {
                        type: 5, update: 0, contents: function () {
                            return e.ItemsChartSettingsNodeStyle
                        }
                    },
                    nodeNotLoaded: {
                        type: 5, update: 0, contents: function () {
                            return e.ItemsChartSettingsNodeStyle
                        }
                    },
                    nodeRadiusExtent: {
                        type: 12,
                        baseTypes: [{type: 1, details: 0}, {type: 1, details: 0}]
                    },
                    nodeRules: {type: 8, update: 0, baseTypes: [{type: 4}]},
                    nodeSelected: {
                        type: 5, update: 0, contents: function () {
                            return e.ItemsChartSettingsNodeStyle
                        }
                    },
                    nodeStyleFunction: {type: 4},
                    removedColor: {type: 0, details: 3},
                    scaleLinksWithZoom: {type: 9},
                    scaleObjectsWithZoom: {type: 9},
                    selection: {
                        type: 5, update: 0, contents: function () {
                            return {
                                fillColor: {type: 0},
                                lineColor: {type: 0},
                                shadowBlur: {type: 1},
                                shadowColor: {type: 0},
                                shadowOffsetX: {type: 1},
                                shadowOffsetY: {type: 1},
                                sizeConstant: {type: 1},
                                sizeProportional: {type: 1}
                            }
                        }
                    }
                }, e.GeoChartSettingsNodesLayout = {
                    anchorStrength: {type: 1},
                    mode: {type: 0, details: 6},
                    nodeSpacing: {type: 1, details: 0}
                }, e.GeoChartSettingsShapesLayerNodeStyle = {
                    anchorMode: {
                        type: 2,
                        "enum": function () {
                            return t.ItemsChart.NodeAnchorMode
                        }
                    },
                    anchorStyle: {
                        type: 5, update: 0, contents: function () {
                            return e.ItemsChartSettingsNodeAnchorStyle
                        }
                    },
                    anchorX: {type: 1},
                    anchorY: {type: 1},
                    coordinates: {
                        type: 7,
                        update: 0,
                        baseTypes: [{
                            type: 6,
                            update: 0,
                            baseTypes: [{type: 1}]
                        }, {
                            type: 6,
                            update: 0,
                            baseTypes: [{type: 6, update: 0, baseTypes: [{type: 1}]}]
                        }]
                    },
                    cursor: {type: 0, details: 7},
                    customShape: {
                        type: 5, update: 0, contents: function () {
                            return e.ItemsChartSettingsCustomShape
                        }
                    },
                    display: {type: 0},
                    expandable: {type: 9},
                    fillColor: {type: 0},
                    image: {type: 0},
                    imageCropping: {type: 7, baseTypes: [{type: 0}, {type: 9}]},
                    invisible: {type: 9},
                    items: {
                        type: 6,
                        update: 0,
                        baseTypes: [{
                            type: 5, update: 0, contents: function () {
                                return e.ItemsChartSettingsNodeItem
                            }
                        }]
                    },
                    label: {type: 0},
                    labelStyle: {
                        type: 5, update: 0, contents: function () {
                            return e.ItemsChartSettingsItemsLayerLabelStyle
                        }
                    },
                    lineColor: {type: 0},
                    lineDash: {type: 6, update: 0, baseTypes: [{type: 1}]},
                    lineWidth: {type: 1},
                    opacity: {type: 1},
                    radius: {type: 1},
                    shadowBlur: {type: 1},
                    shadowColor: {type: 0},
                    shadowOffsetX: {type: 1},
                    shadowOffsetY: {type: 1}
                }, e.GeoChartSettingsShapesLayerStyle = {
                    aggregatedShape: {
                        type: 5,
                        update: 0,
                        contents: function () {
                            return e.BaseSettingsBackgroundStyle
                        }
                    },
                    allObjectsStyleFunction: {type: 4},
                    fadeTime: {type: 1, details: 0},
                    hiddenLinks: {
                        type: 5, update: 0, contents: function () {
                            return {
                                lineColor: {type: 0},
                                lineWidth: {type: 1},
                                size: {type: 1}
                            }
                        }
                    },
                    item: {
                        type: 5, update: 0, contents: function () {
                            return e.ItemsChartSettingsItemsLayerLabelStyle
                        }
                    },
                    link: {
                        type: 5, update: 0, contents: function () {
                            return e.ItemsChartSettingsLinkStyle
                        }
                    },
                    linkAutoScaling: {type: 0, details: 6},
                    linkClasses: {
                        type: 6,
                        update: 0,
                        baseTypes: [{
                            type: 5, update: 0, contents: function () {
                                return {
                                    className: {type: 0},
                                    style: {
                                        type: 5, update: 0, contents: function () {
                                            return e.ItemsChartSettingsLinkStyle
                                        }
                                    }
                                }
                            }
                        }]
                    },
                    linkDecorationMinSize: {type: 1},
                    linkDecorationScale: {type: 1},
                    linkDetailMinSize: {type: 1},
                    linkDetailMinZoom: {type: 1},
                    linkHovered: {
                        type: 5, update: 0, contents: function () {
                            return e.ItemsChartSettingsLinkStyle
                        }
                    },
                    linkLabel: {
                        type: 5, update: 0, contents: function () {
                            return e.ItemsChartSettingsItemsLayerLinkLabelStyle
                        }
                    },
                    linkLabelScaleBase: {type: 1},
                    linkLengthAutoScaling: {type: 0, details: 6},
                    linkLengthExtent: {type: 12, baseTypes: [{type: 1}, {type: 1}]},
                    linkRadiusExtent: {type: 12, baseTypes: [{type: 1}, {type: 1}]},
                    linkRules: {type: 8, update: 0, baseTypes: [{type: 4}]},
                    linkSelected: {
                        type: 5, update: 0, contents: function () {
                            return e.ItemsChartSettingsLinkStyle
                        }
                    },
                    linkStrengthAutoScaling: {type: 0, details: 6},
                    linkStrengthExtent: {type: 12, baseTypes: [{type: 1}, {type: 1}]},
                    linkStyleFunction: {type: 4},
                    multilinkSpacing: {type: 1},
                    node: {
                        type: 5, update: 0, contents: function () {
                            return e.GeoChartSettingsShapesLayerNodeStyle
                        }
                    },
                    nodeAnchor: {
                        type: 5, update: 0, contents: function () {
                            return e.ItemsChartSettingsNodeAnchorStyle
                        }
                    },
                    nodeAutoScaling: {type: 0, details: 6},
                    nodeBackground: {
                        type: 5, update: 0, contents: function () {
                            return e.ItemsChartSettingsNodeStyle
                        }
                    },
                    nodeClasses: {
                        type: 6,
                        update: 0,
                        baseTypes: [{
                            type: 5, update: 0, contents: function () {
                                return {
                                    className: {type: 0},
                                    style: {
                                        type: 5, update: 0, contents: function () {
                                            return e.ItemsChartSettingsNodeStyle
                                        }
                                    }
                                }
                            }
                        }]
                    },
                    nodeDetailMinSize: {type: 1},
                    nodeDetailMinZoom: {type: 1},
                    nodeExpanded: {
                        type: 5, update: 0, contents: function () {
                            return e.ItemsChartSettingsNodeStyle
                        }
                    },
                    nodeFocused: {
                        type: 5, update: 0, contents: function () {
                            return e.ItemsChartSettingsNodeStyle
                        }
                    },
                    nodeHovered: {
                        type: 5, update: 0, contents: function () {
                            return e.ItemsChartSettingsNodeStyle
                        }
                    },
                    nodeLabel: {
                        type: 5, update: 0, contents: function () {
                            return e.ItemsChartSettingsItemsLayerLabelStyle
                        }
                    },
                    nodeLabelScaleBase: {type: 1},
                    nodeLocked: {
                        type: 5, update: 0, contents: function () {
                            return e.ItemsChartSettingsNodeStyle
                        }
                    },
                    nodeNotLoaded: {
                        type: 5, update: 0, contents: function () {
                            return e.ItemsChartSettingsNodeStyle
                        }
                    },
                    nodeRadiusExtent: {
                        type: 12,
                        baseTypes: [{type: 1, details: 0}, {type: 1, details: 0}]
                    },
                    nodeRules: {type: 8, update: 0, baseTypes: [{type: 4}]},
                    nodeSelected: {
                        type: 5, update: 0, contents: function () {
                            return e.ItemsChartSettingsNodeStyle
                        }
                    },
                    nodeStyleFunction: {type: 4},
                    removedColor: {type: 0, details: 3},
                    scaleLinksWithZoom: {type: 9},
                    scaleObjectsWithZoom: {type: 9},
                    selection: {
                        type: 5, update: 0, contents: function () {
                            return {
                                fillColor: {type: 0},
                                lineColor: {type: 0},
                                shadowBlur: {type: 1},
                                shadowColor: {type: 0},
                                shadowOffsetX: {type: 1},
                                shadowOffsetY: {type: 1},
                                sizeConstant: {type: 1},
                                sizeProportional: {type: 1}
                            }
                        }
                    }
                }, e.ItemsChartIDataObjectLink = {
                    className: {type: 0},
                    from: {type: 0},
                    id: {type: 0},
                    style: {
                        type: 5, update: 0, contents: function () {
                            return e.ItemsChartSettingsLinkStyle
                        }
                    },
                    to: {type: 0},
                    value: {type: 1}
                }, e.ItemsChartIDataObjectNode = {
                    className: {type: 0},
                    id: {type: 0},
                    loaded: {type: 9},
                    style: {
                        type: 5, update: 0, contents: function () {
                            return e.ItemsChartSettingsNodeStyle
                        }
                    }
                }, e.ItemsChartSettingsAdvanced = {
                    assets: {
                        type: 6,
                        update: 3,
                        baseTypes: [{type: 0, details: 5}]
                    },
                    exportProxyURL: {type: 0, details: 5},
                    highDPI: {type: 9},
                    labelCache: {type: 9},
                    logging: {type: 9},
                    maxCanvasHeight: {type: 1},
                    maxCanvasWidth: {type: 1},
                    pdfExportAssets: {
                        type: 6,
                        update: 0,
                        baseTypes: [{type: 0, details: 5}]
                    },
                    perNodeLoadingIndicator: {type: 9},
                    pointer: {
                        type: 5, update: 0, contents: function () {
                            return e.BaseSettingsAdvancedPointer
                        }, ctor: function () {
                            return t.Base.SettingsAdvancedPointer
                        }
                    },
                    showFPS: {type: 9},
                    showTimestamp: {type: 9},
                    showTouches: {type: 9},
                    style: {
                        type: 5, update: 0, contents: function () {
                            return e.BaseSettingsAdvancedStyle
                        }, ctor: function () {
                            return t.Base.SettingsAdvancedStyle
                        }
                    },
                    themeCSSClass: {type: 0},
                    useAnimationFrame: {type: 9}
                }, e.ItemsChartSettingsCustomShape = {
                    distanceToEdge: {type: 4},
                    getBounds: {type: 4},
                    hitTest: {type: 4},
                    onUpdate: {type: 4},
                    paint: {type: 4},
                    paintSelection: {type: 4}
                }, e.ItemsChartSettingsInteractionSelection = {
                    allowMoveNodesOffscreen: {type: 9},
                    enabled: {type: 9},
                    linksSelectable: {type: 9},
                    lockNodesOnMove: {type: 9},
                    nodesSelectable: {type: 9},
                    tolerance: {type: 1}
                }, e.ItemsChartSettingsInteractionZooming = {
                    autoZoomAfterClick: {type: 9},
                    doubleClickZoom: {type: 1},
                    fingers: {type: 9},
                    sensitivity: {type: 1},
                    wheel: {type: 9},
                    zoomInOnDoubleClick: {type: 9}
                }, e.ItemsChartSettingsItemsLayerLabelStyle = {
                    align: {
                        type: 0,
                        details: 6
                    },
                    angle: {type: 1, details: 0},
                    aspectRatio: {type: 1},
                    backgroundStyle: {
                        type: 5, update: 0, contents: function () {
                            return e.BaseSettingsBackgroundStyle
                        }
                    },
                    borderRadius: {type: 1},
                    image: {type: 0, details: 4},
                    imageSlicing: {
                        type: 12,
                        baseTypes: [{type: 1}, {type: 1}, {type: 1}, {type: 1}]
                    },
                    lineSpacing: {type: 1},
                    margin: {type: 1},
                    maxWidth: {type: 1},
                    padding: {type: 1},
                    scaleWithSize: {type: 9},
                    scaleWithZoom: {type: 9},
                    text: {type: 0},
                    textStyle: {
                        type: 5, update: 0, contents: function () {
                            return e.BaseSettingsTextStyle
                        }
                    }
                }, e.ItemsChartSettingsItemsLayerLinkLabelStyle = {
                    align: {
                        type: 0,
                        details: 6
                    },
                    angle: {type: 1, details: 0},
                    aspectRatio: {type: 1},
                    backgroundStyle: {
                        type: 5, update: 0, contents: function () {
                            return e.BaseSettingsBackgroundStyle
                        }
                    },
                    borderRadius: {type: 1},
                    image: {type: 0, details: 4},
                    imageSlicing: {
                        type: 12,
                        baseTypes: [{type: 1}, {type: 1}, {type: 1}, {type: 1}]
                    },
                    lineSpacing: {type: 1},
                    margin: {type: 1},
                    maxWidth: {type: 1},
                    padding: {type: 1},
                    rotateWithLink: {type: 9},
                    scaleWithSize: {type: 9},
                    scaleWithZoom: {type: 9},
                    text: {type: 0},
                    textStyle: {
                        type: 5, update: 0, contents: function () {
                            return e.BaseSettingsTextStyle
                        }
                    }
                }, e.ItemsChartSettingsLinkItem = {
                    align: {type: 0, details: 6},
                    angle: {type: 1, details: 0},
                    aspectRatio: {type: 1},
                    backgroundStyle: {
                        type: 5, update: 0, contents: function () {
                            return e.BaseSettingsBackgroundStyle
                        }
                    },
                    borderRadius: {type: 1},
                    image: {type: 0, details: 4},
                    imageSlicing: {
                        type: 12,
                        baseTypes: [{type: 1}, {type: 1}, {type: 1}, {type: 1}]
                    },
                    lineSpacing: {type: 1},
                    lx: {type: 1},
                    ly: {type: 1},
                    margin: {type: 1},
                    maxWidth: {type: 1},
                    padding: {type: 1},
                    px: {type: 1},
                    py: {type: 1},
                    rotateWithLink: {type: 9},
                    scaleWithSize: {type: 9},
                    scaleWithZoom: {type: 9},
                    text: {type: 0},
                    textStyle: {
                        type: 5, update: 0, contents: function () {
                            return e.BaseSettingsTextStyle
                        }
                    },
                    x: {type: 1},
                    y: {type: 1}
                }, e.ItemsChartSettingsLinkMenu = {
                    contentsFunction: {type: 4},
                    enabled: {type: 9},
                    showData: {type: 9}
                }, e.ItemsChartSettingsLinkStyle = {
                    cursor: {type: 0},
                    direction: {type: 0},
                    fillColor: {type: 0},
                    fromDecoration: {type: 0, details: 6},
                    invisible: {type: 9},
                    items: {
                        type: 6,
                        update: 0,
                        baseTypes: [{
                            type: 5, update: 0, contents: function () {
                                return e.ItemsChartSettingsLinkItem
                            }
                        }]
                    },
                    label: {type: 0},
                    length: {type: 1},
                    lineDash: {type: 6, update: 0, baseTypes: [{type: 1}]},
                    radius: {type: 1},
                    shadowBlur: {type: 1},
                    shadowColor: {type: 0},
                    shadowOffsetX: {type: 1},
                    shadowOffsetY: {type: 1},
                    strength: {type: 1},
                    toDecoration: {type: 0, details: 6}
                }, e.ItemsChartSettingsNodeAnchorStyle = {
                    lineColor: {type: 0},
                    lineDash: {type: 6, update: 0, baseTypes: [{type: 1}]},
                    lineWidth: {type: 1},
                    shadowBlur: {type: 1},
                    shadowColor: {type: 0},
                    shadowOffsetX: {type: 1},
                    shadowOffsetY: {type: 1}
                }, e.ItemsChartSettingsNodeItem = {
                    align: {type: 0, details: 6},
                    angle: {type: 1, details: 0},
                    aspectRatio: {type: 1},
                    backgroundStyle: {
                        type: 5, update: 0, contents: function () {
                            return e.BaseSettingsBackgroundStyle
                        }
                    },
                    borderRadius: {type: 1},
                    image: {type: 0, details: 4},
                    imageSlicing: {
                        type: 12,
                        baseTypes: [{type: 1}, {type: 1}, {type: 1}, {type: 1}]
                    },
                    lineSpacing: {type: 1},
                    margin: {type: 1},
                    maxWidth: {type: 1},
                    padding: {type: 1},
                    px: {type: 1},
                    py: {type: 1},
                    scaleWithSize: {type: 9},
                    scaleWithZoom: {type: 9},
                    text: {type: 0},
                    textStyle: {
                        type: 5, update: 0, contents: function () {
                            return e.BaseSettingsTextStyle
                        }
                    },
                    x: {type: 1},
                    y: {type: 1}
                }, e.ItemsChartSettingsNodeMenu = {
                    buttons: {
                        type: 6,
                        update: 0,
                        baseTypes: [{type: 0}]
                    },
                    contentsFunction: {type: 4},
                    enabled: {type: 9},
                    showData: {type: 9}
                }, e.ItemsChartSettingsNodeStyle = {
                    anchorMode: {
                        type: 2,
                        "enum": function () {
                            return t.ItemsChart.NodeAnchorMode
                        }
                    },
                    anchorStyle: {
                        type: 5, update: 0, contents: function () {
                            return e.ItemsChartSettingsNodeAnchorStyle
                        }
                    },
                    anchorX: {type: 1},
                    anchorY: {type: 1},
                    coordinates: {
                        type: 7,
                        update: 0,
                        baseTypes: [{
                            type: 6,
                            update: 0,
                            baseTypes: [{type: 1}]
                        }, {
                            type: 6,
                            update: 0,
                            baseTypes: [{type: 6, update: 0, baseTypes: [{type: 1}]}]
                        }]
                    },
                    cursor: {type: 0, details: 7},
                    customShape: {
                        type: 5, update: 0, contents: function () {
                            return e.ItemsChartSettingsCustomShape
                        }
                    },
                    display: {type: 0},
                    fillColor: {type: 0},
                    image: {type: 0},
                    imageCropping: {type: 7, baseTypes: [{type: 0}, {type: 9}]},
                    invisible: {type: 9},
                    items: {
                        type: 6,
                        update: 0,
                        baseTypes: [{
                            type: 5, update: 0, contents: function () {
                                return e.ItemsChartSettingsNodeItem
                            }
                        }]
                    },
                    label: {type: 0},
                    labelStyle: {
                        type: 5, update: 0, contents: function () {
                            return e.ItemsChartSettingsItemsLayerLabelStyle
                        }
                    },
                    lineColor: {type: 0},
                    lineDash: {type: 6, update: 0, baseTypes: [{type: 1}]},
                    lineWidth: {type: 1},
                    opacity: {type: 1},
                    radius: {type: 1},
                    shadowBlur: {type: 1},
                    shadowColor: {type: 0},
                    shadowOffsetX: {type: 1},
                    shadowOffsetY: {type: 1}
                }, e.ItemsChartSettingsNodesLayerStyle = {
                    allObjectsStyleFunction: {type: 4},
                    fadeTime: {type: 1, details: 0},
                    hiddenLinks: {
                        type: 5, update: 0, contents: function () {
                            return {
                                lineColor: {type: 0},
                                lineWidth: {type: 1},
                                size: {type: 1}
                            }
                        }
                    },
                    item: {
                        type: 5, update: 0, contents: function () {
                            return e.ItemsChartSettingsItemsLayerLabelStyle
                        }
                    },
                    link: {
                        type: 5, update: 0, contents: function () {
                            return e.ItemsChartSettingsLinkStyle
                        }
                    },
                    linkAutoScaling: {type: 0, details: 6},
                    linkClasses: {
                        type: 6,
                        update: 0,
                        baseTypes: [{
                            type: 5, update: 0, contents: function () {
                                return {
                                    className: {type: 0},
                                    style: {
                                        type: 5, update: 0, contents: function () {
                                            return e.ItemsChartSettingsLinkStyle
                                        }
                                    }
                                }
                            }
                        }]
                    },
                    linkDecorationMinSize: {type: 1},
                    linkDecorationScale: {type: 1},
                    linkDetailMinSize: {type: 1},
                    linkDetailMinZoom: {type: 1},
                    linkHovered: {
                        type: 5, update: 0, contents: function () {
                            return e.ItemsChartSettingsLinkStyle
                        }
                    },
                    linkLabel: {
                        type: 5, update: 0, contents: function () {
                            return e.ItemsChartSettingsItemsLayerLinkLabelStyle
                        }
                    },
                    linkLabelScaleBase: {type: 1},
                    linkLengthAutoScaling: {type: 0, details: 6},
                    linkLengthExtent: {type: 12, baseTypes: [{type: 1}, {type: 1}]},
                    linkRadiusExtent: {type: 12, baseTypes: [{type: 1}, {type: 1}]},
                    linkRules: {type: 8, update: 0, baseTypes: [{type: 4}]},
                    linkSelected: {
                        type: 5, update: 0, contents: function () {
                            return e.ItemsChartSettingsLinkStyle
                        }
                    },
                    linkStrengthAutoScaling: {type: 0, details: 6},
                    linkStrengthExtent: {type: 12, baseTypes: [{type: 1}, {type: 1}]},
                    linkStyleFunction: {type: 4},
                    multilinkSpacing: {type: 1},
                    node: {
                        type: 5, update: 0, contents: function () {
                            return e.ItemsChartSettingsNodeStyle
                        }
                    },
                    nodeAnchor: {
                        type: 5, update: 0, contents: function () {
                            return e.ItemsChartSettingsNodeAnchorStyle
                        }
                    },
                    nodeAutoScaling: {type: 0, details: 6},
                    nodeBackground: {
                        type: 5, update: 0, contents: function () {
                            return e.ItemsChartSettingsNodeStyle
                        }
                    },
                    nodeClasses: {
                        type: 6,
                        update: 0,
                        baseTypes: [{
                            type: 5, update: 0, contents: function () {
                                return {
                                    className: {type: 0},
                                    style: {
                                        type: 5, update: 0, contents: function () {
                                            return e.ItemsChartSettingsNodeStyle
                                        }
                                    }
                                }
                            }
                        }]
                    },
                    nodeDetailMinSize: {type: 1},
                    nodeDetailMinZoom: {type: 1},
                    nodeExpanded: {
                        type: 5, update: 0, contents: function () {
                            return e.ItemsChartSettingsNodeStyle
                        }
                    },
                    nodeFocused: {
                        type: 5, update: 0, contents: function () {
                            return e.ItemsChartSettingsNodeStyle
                        }
                    },
                    nodeHovered: {
                        type: 5, update: 0, contents: function () {
                            return e.ItemsChartSettingsNodeStyle
                        }
                    },
                    nodeLabel: {
                        type: 5, update: 0, contents: function () {
                            return e.ItemsChartSettingsItemsLayerLabelStyle
                        }
                    },
                    nodeLabelScaleBase: {type: 1},
                    nodeLocked: {
                        type: 5, update: 0, contents: function () {
                            return e.ItemsChartSettingsNodeStyle
                        }
                    },
                    nodeNotLoaded: {
                        type: 5, update: 0, contents: function () {
                            return e.ItemsChartSettingsNodeStyle
                        }
                    },
                    nodeRadiusExtent: {
                        type: 12,
                        baseTypes: [{type: 1, details: 0}, {type: 1, details: 0}]
                    },
                    nodeRules: {type: 8, update: 0, baseTypes: [{type: 4}]},
                    nodeSelected: {
                        type: 5, update: 0, contents: function () {
                            return e.ItemsChartSettingsNodeStyle
                        }
                    },
                    nodeStyleFunction: {type: 4},
                    removedColor: {type: 0, details: 3},
                    scaleLinksWithZoom: {type: 9},
                    scaleObjectsWithZoom: {type: 9},
                    selection: {
                        type: 5, update: 0, contents: function () {
                            return {
                                fillColor: {type: 0},
                                lineColor: {type: 0},
                                shadowBlur: {type: 1},
                                shadowColor: {type: 0},
                                shadowOffsetX: {type: 1},
                                shadowOffsetY: {type: 1},
                                sizeConstant: {type: 1},
                                sizeProportional: {type: 1}
                            }
                        }
                    }
                }, e.ItemsOverlaySettings = {
                    advanced: {
                        type: 5,
                        update: 0,
                        contents: function () {
                            return e.BaseSettingsAdvanced
                        },
                        ctor: function () {
                            return t.Base.SettingsAdvanced
                        }
                    },
                    area: {
                        type: 5, update: 0, contents: function () {
                            return e.BaseSettingsArea
                        }, ctor: function () {
                            return t.Base.SettingsArea
                        }
                    },
                    assetsUrlBase: {type: 0},
                    container: {type: 3},
                    credits: {
                        type: 5, update: 0, contents: function () {
                            return e.BaseSettingsCredits
                        }, ctor: function () {
                            return t.Base.SettingsCredits
                        }
                    },
                    data: {
                        type: 6,
                        update: 4,
                        baseTypes: [{
                            type: 5, update: 0, contents: function () {
                                return e.BaseSettingsData
                            }, ctor: function () {
                                return t.Base.SettingsData
                            }
                        }]
                    },
                    events: {
                        type: 5, update: 0, contents: function () {
                            return e.BaseSettingsEvents
                        }, ctor: function () {
                            return t.Base.SettingsEvents
                        }
                    },
                    info: {
                        type: 5, update: 0, contents: function () {
                            return {arrowContentsFunction: {type: 10}, enabled: {type: 9}}
                        }
                    },
                    interaction: {
                        type: 5, update: 0, contents: function () {
                            return e.BaseSettingsInteraction
                        }, ctor: function () {
                            return t.Base.SettingsInteraction
                        }
                    },
                    legend: {
                        type: 5, update: 0, contents: function () {
                            return e.BaseSettingsLegend
                        }, ctor: function () {
                            return t.Base.SettingsLegend
                        }
                    },
                    localization: {
                        type: 5, update: 0, contents: function () {
                            return e.BaseSettingsLocalization
                        }, ctor: function () {
                            return t.Base.SettingsLocalization
                        }
                    },
                    parentChart: {type: 5},
                    style: {
                        type: 5, update: 0, contents: function () {
                            return {
                                arrow: {
                                    type: 5, update: 0, contents: function () {
                                        return {
                                            arrowLength: {type: 1},
                                            arrowWidth: {type: 1},
                                            baseWidth: {type: 1},
                                            depth: {type: 1},
                                            fillGradient: {type: 11},
                                            height: {type: 1},
                                            topWidth: {type: 1}
                                        }
                                    }
                                }, arrowShadow: {
                                    type: 5, update: 0, contents: function () {
                                        return {
                                            arrowLength: {type: 1},
                                            arrowWidth: {type: 1},
                                            baseWidth: {type: 1},
                                            fillGradient: {type: 11},
                                            height: {type: 1},
                                            shadowBlur: {type: 1},
                                            shadowColor: {type: 0},
                                            shadowOffsetX: {type: 1},
                                            shadowOffsetY: {type: 1},
                                            topWidth: {type: 1}
                                        }
                                    }
                                }
                            }
                        }
                    },
                    theme: {
                        type: 5, contents: function () {
                            return e.BaseSettings
                        }, ctor: function () {
                            return t.Base.Settings
                        }, ctorIgnore: !0
                    },
                    title: {
                        type: 5, update: 0, contents: function () {
                            return e.BaseSettingsTitle
                        }, ctor: function () {
                            return t.Base.SettingsTitle
                        }
                    },
                    toolbar: {
                        type: 5, update: 0, contents: function () {
                            return e.BaseSettingsToolbar
                        }, ctor: function () {
                            return t.Base.SettingsToolbar
                        }
                    }
                }, e.LinearChartSettingsArea = {
                    height: {type: 1},
                    left: {type: 1},
                    maxHeight: {type: 1},
                    maxWidth: {type: 1},
                    minHeight: {type: 1},
                    minWidth: {type: 1},
                    style: {
                        type: 5, update: 0, contents: function () {
                            return e.LinearChartSettingsAreaStyle
                        }, ctor: function () {
                            return t.LinearChart.SettingsAreaStyle
                        }
                    },
                    top: {type: 1},
                    width: {type: 1}
                }, e.LinearChartSettingsAreaStyle = {
                    fillColor: {type: 0, details: 3},
                    image: {type: 0, details: 4},
                    noData: {
                        type: 5, update: 0, contents: function () {
                            return {fillColor: {type: 0}, image: {type: 0, details: 5}}
                        }
                    },
                    overlayColor: {type: 0, details: 3},
                    zoomHighlight: {
                        type: 5, update: 0, contents: function () {
                            return e.LinearChartSettingsHighlightStyle
                        }
                    },
                    zoomHighlightInactive: {
                        type: 5, update: 0, contents: function () {
                            return {fillColor: {type: 0}}
                        }
                    }
                }, e.LinearChartSettingsCandleStickMotionStyle = {
                    bar: {
                        type: 5,
                        update: 0,
                        contents: function () {
                            return {
                                lineColor: {type: 0},
                                lineDash: {type: 6, update: 0, baseTypes: [{type: 1}]},
                                lineWidth: {type: 1},
                                shadowBlur: {type: 1},
                                shadowColor: {type: 0},
                                shadowOffsetX: {type: 1},
                                shadowOffsetY: {type: 1}
                            }
                        }
                    }, candlestick: {
                        type: 5, update: 0, contents: function () {
                            return {
                                fillColor: {type: 0},
                                lineColor: {type: 0, details: 3},
                                lineDash: {type: 6, update: 0, baseTypes: [{type: 1}]},
                                lineWidth: {type: 1},
                                shadowBlur: {type: 1},
                                shadowColor: {type: 0},
                                shadowOffsetX: {type: 1},
                                shadowOffsetY: {type: 1}
                            }
                        }
                    }
                }, e.LinearChartSettingsEvents = {
                    chartUpdateDelay: {type: 1, details: 0},
                    onAnimationDone: {type: 4},
                    onChartUpdate: {type: 4},
                    onClick: {type: 4},
                    onDoubleClick: {type: 4},
                    onError: {type: 4},
                    onHoverChange: {type: 4},
                    onPositionChange: {type: 4},
                    onRightClick: {type: 4},
                    onSelectionChange: {type: 4},
                    onSettingsChange: {type: 4},
                    onTripleClick: {type: 4}
                }, e.LinearChartSettingsHighlightStyle = {
                    fadeIn: {type: 1, details: 0},
                    fadeOut: {type: 1, details: 0},
                    fillColor: {type: 0}
                }, e.LinearChartSettingsInfoPopup = {
                    advanced: {
                        type: 5,
                        update: 0,
                        contents: function () {
                            return {
                                contentsFunction: {type: 4},
                                scope: {type: 0, details: 6},
                                showHeader: {type: 9},
                                showOnlyHoveredSeries: {type: 9}
                            }
                        }
                    },
                    aggregations: {
                        type: 6,
                        update: 0,
                        baseTypes: [{type: 0, details: 6}]
                    },
                    enabled: {type: 9},
                    showNoData: {type: 9},
                    style: {
                        type: 5, update: 0, contents: function () {
                            return {
                                highlight: {
                                    type: 5, update: 0, contents: function () {
                                        return e.LinearChartSettingsHighlightStyle
                                    }
                                }
                            }
                        }
                    },
                    valueFormatterFunction: {type: 4}
                }, e.LinearChartSettingsInteractionScrolling = {
                    enabled: {type: 9},
                    keyboardScrollingFactor: {type: 1},
                    kineticFriction: {type: 1},
                    swipePageFlipping: {type: 9}
                }, e.LinearChartSettingsLegend = {
                    advanced: {
                        type: 5,
                        update: 0,
                        contents: function () {
                            return e.LinearChartSettingsLegendAdvanced
                        },
                        ctor: function () {
                            return t.LinearChart.SettingsLegendAdvanced
                        }
                    },
                    enabled: {type: 9},
                    equalizeRowsColumns: {type: 9},
                    height: {type: 1},
                    lineSpacing: {type: 1},
                    margin: {type: 1},
                    marker: {
                        type: 5, update: 0, contents: function () {
                            return e.BaseSettingsLegendMarker
                        }, ctor: function () {
                            return t.Base.SettingsLegendMarker
                        }
                    },
                    maxLineSymbols: {type: 1, details: 0},
                    numberOfColumns: {type: 1, details: 0},
                    numberOfRows: {type: 1, details: 0},
                    padding: {type: 1},
                    panel: {
                        type: 5, update: 0, contents: function () {
                            return e.BaseSettingsLegendPanel
                        }, ctor: function () {
                            return t.Base.SettingsLegendPanel
                        }
                    },
                    text: {
                        type: 5, update: 0, contents: function () {
                            return {fillColor: {type: 0}, font: {type: 0}}
                        }
                    },
                    width: {type: 1}
                }, e.LinearChartSettingsLegendAdvanced = {
                    disabledSeries: {
                        type: 5,
                        update: 0,
                        contents: function () {
                            return {
                                fillColor: {type: 0},
                                lineColor: {type: 0},
                                textColor: {type: 0}
                            }
                        }
                    },
                    selectedBackground: {type: 0, details: 3},
                    selectedBorder: {type: 0, details: 3}
                }, e.LinearChartSettingsLocalization = {
                    closeButton: {type: 0},
                    dataRequestFailed: {type: 0},
                    loadingLabel: {type: 0},
                    noDataLabel: {type: 0},
                    toolbar: {
                        type: 5, update: 0, contents: function () {
                            return e.LinearChartSettingsLocalizationToolbar
                        }, ctor: function () {
                            return t.LinearChart.SettingsLocalizationToolbar
                        }
                    },
                    unnamedSeries: {type: 0},
                    valueUnits: {type: 8, update: 0, baseTypes: [{type: 1, details: 0}]}
                }, e.LinearChartSettingsLocalizationToolbar = {
                    backButton: {type: 0},
                    backTitle: {type: 0},
                    exportButton: {type: 0},
                    exportCSV: {type: 0},
                    exportJpeg: {type: 0},
                    exportPDF: {type: 0},
                    exportPNG: {type: 0},
                    exportTitle: {type: 0},
                    exportXLS: {type: 0},
                    fullscreenButton: {type: 0},
                    fullscreenTitle: {type: 0},
                    linButton: {type: 0},
                    linLogTitle: {type: 0},
                    logButton: {type: 0},
                    zoomoutButton: {type: 0},
                    zoomoutTitle: {type: 0}
                }, e.LinearChartSettingsSeries = {
                    cluster: {type: 0},
                    data: {
                        type: 5, update: 0, contents: function () {
                            return e.LinearChartSettingsSeriesData
                        }, ctor: function () {
                            return t.LinearChart.SettingsSeriesData
                        }
                    },
                    enabled: {type: 9},
                    id: {type: 0},
                    name: {type: 0},
                    nameLegend: {type: 0},
                    showInLegend: {type: 9},
                    stack: {type: 0},
                    style: {
                        type: 5, update: 0, contents: function () {
                            return e.LinearChartSettingsSeriesStyle
                        }, ctor: function () {
                            return t.LinearChart.SettingsSeriesStyle
                        }
                    },
                    type: {type: 0, details: 6},
                    valueAxis: {type: 0}
                }, e.LinearChartSettingsSeriesCandleStick = {
                    cluster: {type: 0},
                    data: {
                        type: 5, update: 0, contents: function () {
                            return e.LinearChartSettingsSeriesData
                        }, ctor: function () {
                            return t.LinearChart.SettingsSeriesData
                        }
                    },
                    enabled: {type: 9},
                    id: {type: 0},
                    localization: {
                        type: 5, update: 0, contents: function () {
                            return {
                                close: {type: 0},
                                high: {type: 0},
                                low: {type: 0},
                                open: {type: 0}
                            }
                        }
                    },
                    name: {type: 0},
                    nameLegend: {type: 0},
                    showInLegend: {type: 9},
                    stack: {type: 0},
                    style: {
                        type: 5, update: 0, contents: function () {
                            return {
                                decrease: {
                                    type: 5, update: 0, contents: function () {
                                        return e.LinearChartSettingsCandleStickMotionStyle
                                    }
                                },
                                increase: {
                                    type: 5, update: 0, contents: function () {
                                        return e.LinearChartSettingsCandleStickMotionStyle
                                    }
                                },
                                padding: {
                                    type: 12,
                                    baseTypes: [{type: 1, details: 0}, {
                                        type: 1,
                                        details: 0
                                    }]
                                },
                                pattern: {type: 0, details: 6}
                            }
                        }
                    },
                    type: {type: 0, details: 6},
                    valueAxis: {type: 0}
                }, e.LinearChartSettingsSeriesColumns = {
                    cluster: {type: 0},
                    data: {
                        type: 5, update: 0, contents: function () {
                            return e.LinearChartSettingsSeriesData
                        }, ctor: function () {
                            return t.LinearChart.SettingsSeriesData
                        }
                    },
                    enabled: {type: 9},
                    id: {type: 0},
                    name: {type: 0},
                    nameLegend: {type: 0},
                    showInLegend: {type: 9},
                    stack: {type: 0},
                    style: {
                        type: 5, update: 0, contents: function () {
                            return e.LinearChartSettingsSeriesColumnsStyle
                        }, ctor: function () {
                            return t.LinearChart.SettingsSeriesColumnsStyle
                        }
                    },
                    type: {type: 0, details: 6},
                    valueAxis: {type: 0}
                }, e.LinearChartSettingsSeriesColumnsStyle = {
                    depth: {type: 1},
                    depthBrightness: {type: 1},
                    fillColor: {type: 0, details: 3},
                    fillGradient: {type: 11},
                    gradient: {type: 1},
                    lineColor: {type: 0, details: 3},
                    lineDash: {type: 6, update: 0, baseTypes: [{type: 1}]},
                    lineWidth: {type: 1, details: 0},
                    minHeight: {type: 1, details: 0},
                    padding: {
                        type: 12,
                        baseTypes: [{type: 1, details: 0}, {type: 1, details: 0}]
                    },
                    shadowBlur: {type: 1, details: 0},
                    shadowColor: {type: 0, details: 3},
                    shadowOffsetX: {type: 1, details: 0},
                    shadowOffsetY: {type: 1, details: 0}
                }, e.LinearChartSettingsSeriesData = {
                    aggregatedValueFunction: {type: 4},
                    aggregation: {type: 0, details: 6},
                    noDataPolicy: {type: 0, details: 6},
                    source: {type: 0, details: 6},
                    valueFunction: {type: 4}
                }, e.LinearChartSettingsSeriesLines = {
                    cluster: {type: 0},
                    data: {
                        type: 5, update: 0, contents: function () {
                            return e.LinearChartSettingsSeriesData
                        }, ctor: function () {
                            return t.LinearChart.SettingsSeriesData
                        }
                    },
                    enabled: {type: 9},
                    id: {type: 0},
                    name: {type: 0},
                    nameLegend: {type: 0},
                    showInLegend: {type: 9},
                    stack: {type: 0},
                    style: {
                        type: 5, update: 0, contents: function () {
                            return {
                                depth: {type: 1},
                                fillColor: {type: 0, details: 3},
                                fillGradient: {type: 11},
                                lineColor: {type: 0},
                                lineDash: {type: 6, update: 0, baseTypes: [{type: 1}]},
                                lineWidth: {type: 1},
                                marker: {
                                    type: 5, update: 0, contents: function () {
                                        return {
                                            fillColor: {type: 0, details: 3},
                                            shape: {type: 0, details: 6},
                                            width: {type: 1, details: 0}
                                        }
                                    }
                                },
                                shadowBlur: {type: 1, details: 0},
                                shadowColor: {type: 0, details: 3},
                                shadowOffsetX: {type: 1, details: 0},
                                shadowOffsetY: {type: 1, details: 0},
                                smoothing: {type: 9},
                                steps: {type: 9}
                            }
                        }
                    },
                    type: {type: 0, details: 6},
                    valueAxis: {type: 0}
                }, e.LinearChartSettingsSeriesStyle = {
                    fillColor: {type: 0},
                    lineColor: {type: 0}
                }, e.LinearChartSettingsStack = {
                    name: {type: 0},
                    separateNegativeValues: {type: 9},
                    type: {type: 0, details: 6}
                }, e.LinearChartSettingsValueAxis = {
                    axisLine: {type: 9},
                    enabled: {type: 9},
                    hgrid: {type: 9},
                    logScale: {type: 9},
                    maxValue: {type: 1},
                    minValue: {type: 1},
                    position: {type: 0, details: 6},
                    scaleAdjustmentAnimation: {type: 0, details: 6},
                    scaleAdjustmentAnimationDelay: {type: 1, details: 0},
                    scaleAdjustmentTolerance: {type: 1},
                    scaleMinStep: {type: 1},
                    scaleStep: {type: 1},
                    side: {type: 0, details: 6},
                    size: {type: 1, details: 0},
                    style: {
                        type: 5, update: 0, contents: function () {
                            return {
                                axisLine: {
                                    type: 5, update: 0, contents: function () {
                                        return e.BaseSettingsLineStyle
                                    }
                                },
                                baseLine: {
                                    type: 5, update: 0, contents: function () {
                                        return e.LinearChartSettingsValueAxisBaseLineStyle
                                    }
                                },
                                hgrid: {
                                    type: 5, update: 0, contents: function () {
                                        return e.BaseSettingsLineStyle
                                    }
                                },
                                labelSpacing: {type: 1},
                                tick: {
                                    type: 5, update: 0, contents: function () {
                                        return e.BaseSettingsLineStyle
                                    }
                                },
                                title: {
                                    type: 5, update: 0, contents: function () {
                                        return e.LinearChartSettingsValueAxisTitleStyle
                                    }
                                },
                                valueLabel: {
                                    type: 5, update: 0, contents: function () {
                                        return e.LinearChartSettingsValueAxisValueLabelStyle
                                    }
                                }
                            }
                        }
                    },
                    thresholds: {
                        type: 6,
                        update: 0,
                        baseTypes: [{
                            type: 5, update: 0, contents: function () {
                                return e.LinearChartSettingsValueAxisThreshold
                            }, ctor: function () {
                                return t.LinearChart.SettingsValueAxisThreshold
                            }
                        }]
                    },
                    title: {type: 0},
                    valueFormatterFunction: {type: 4},
                    zeroLine: {type: 0, details: 6}
                }, e.LinearChartSettingsValueAxisBaseLineStyle = {
                    depthColor: {
                        type: 0,
                        details: 3
                    },
                    lineColor: {type: 0},
                    lineDash: {type: 6, update: 0, baseTypes: [{type: 1}]},
                    lineDepth: {type: 1, details: 0},
                    lineWidth: {type: 1}
                }, e.LinearChartSettingsValueAxisThreshold = {
                    from: {type: 1},
                    position: {type: 0, details: 6},
                    style: {
                        type: 5, update: 0, contents: function () {
                            return {
                                fillColor: {type: 0, details: 3},
                                lineColor: {type: 0, details: 3},
                                lineDash: {type: 6, update: 0, baseTypes: [{type: 1}]},
                                lineWidth: {type: 1}
                            }
                        }
                    },
                    to: {type: 1}
                }, e.LinearChartSettingsValueAxisTitleStyle = {
                    align: {
                        type: 0,
                        details: 6
                    },
                    alignment: {type: 0},
                    angle: {type: 1, details: 0},
                    aspectRatio: {type: 1},
                    backgroundStyle: {
                        type: 5, update: 0, contents: function () {
                            return e.BaseSettingsBackgroundStyle
                        }
                    },
                    borderRadius: {type: 1},
                    fillColor: {type: 0},
                    font: {type: 0},
                    image: {type: 0, details: 4},
                    imageSlicing: {
                        type: 12,
                        baseTypes: [{type: 1}, {type: 1}, {type: 1}, {type: 1}]
                    },
                    lineSpacing: {type: 1},
                    margin: {type: 1},
                    maxWidth: {type: 1},
                    padding: {type: 1},
                    reverseDirection: {type: 9},
                    shadowBlur: {type: 1},
                    shadowColor: {type: 0},
                    shadowOffsetX: {type: 1},
                    shadowOffsetY: {type: 1},
                    text: {type: 0},
                    textStyle: {
                        type: 5, update: 0, contents: function () {
                            return e.BaseSettingsTextStyle
                        }
                    }
                }, e.LinearChartSettingsValueAxisValueLabelStyle = {
                    align: {
                        type: 0,
                        details: 6
                    },
                    angle: {type: 1, details: 0},
                    aspectRatio: {type: 1},
                    backgroundStyle: {
                        type: 5, update: 0, contents: function () {
                            return e.BaseSettingsBackgroundStyle
                        }
                    },
                    borderRadius: {type: 1},
                    fillColor: {type: 0},
                    font: {type: 0},
                    image: {type: 0, details: 4},
                    imageSlicing: {
                        type: 12,
                        baseTypes: [{type: 1}, {type: 1}, {type: 1}, {type: 1}]
                    },
                    lineSpacing: {type: 1},
                    margin: {type: 1},
                    maxWidth: {type: 1},
                    padding: {type: 1},
                    shadowBlur: {type: 1},
                    shadowColor: {type: 0},
                    shadowOffsetX: {type: 1},
                    shadowOffsetY: {type: 1},
                    text: {type: 0},
                    textStyle: {
                        type: 5, update: 0, contents: function () {
                            return e.BaseSettingsTextStyle
                        }
                    }
                }, e.NetChartBarSettingsLocalizationToolbar = {
                    backButton: {type: 0},
                    backTitle: {type: 0},
                    exportButton: {type: 0},
                    exportCSV: {type: 0},
                    exportJpeg: {type: 0},
                    exportPDF: {type: 0},
                    exportPNG: {type: 0},
                    exportTitle: {type: 0},
                    exportXLS: {type: 0},
                    fitButton: {type: 0},
                    fitTitle: {type: 0},
                    freezeButton: {type: 0},
                    freezeTitle: {type: 0},
                    fullscreenButton: {type: 0},
                    fullscreenTitle: {type: 0},
                    rearrangeButton: {type: 0},
                    rearrangeTitle: {type: 0},
                    unfreezeTitle: {type: 0},
                    zoomoutButton: {type: 0},
                    zoomoutTitle: {type: 0}
                }, e.NetChartBarSettingsToolbar = {
                    align: {type: 0, details: 6},
                    back: {type: 9},
                    cssClass: {type: 0},
                    enabled: {type: 9},
                    "export": {type: 9},
                    extraItems: {
                        type: 6,
                        update: 0,
                        baseTypes: [{
                            type: 7,
                            update: 0,
                            baseTypes: [{type: 0}, {
                                type: 5,
                                update: 0,
                                contents: function () {
                                    return e.BaseSettingsToolbarItem
                                },
                                ctor: function () {
                                    return t.Base.SettingsToolbarItem
                                }
                            }]
                        }]
                    },
                    items: {
                        type: 6,
                        update: 0,
                        baseTypes: [{
                            type: 7,
                            update: 0,
                            baseTypes: [{type: 0}, {
                                type: 5,
                                update: 0,
                                contents: function () {
                                    return e.BaseSettingsToolbarItem
                                },
                                ctor: function () {
                                    return t.Base.SettingsToolbarItem
                                }
                            }]
                        }]
                    },
                    location: {type: 0, details: 6},
                    showLabels: {type: 9},
                    side: {type: 0, details: 6},
                    zoomOut: {type: 9}
                }, e.NetChartIDataObject = {
                    error: {type: 0},
                    links: {
                        type: 6,
                        update: 0,
                        baseTypes: [{
                            type: 5, update: 0, contents: function () {
                                return e.NetChartIDataObjectLink
                            }
                        }]
                    },
                    nodes: {
                        type: 6,
                        update: 0,
                        baseTypes: [{
                            type: 5, update: 0, contents: function () {
                                return e.NetChartIDataObjectNode
                            }
                        }]
                    }
                }, e.NetChartIDataObjectLink = {
                    className: {type: 0},
                    from: {type: 0},
                    id: {type: 0},
                    style: {
                        type: 5, update: 0, contents: function () {
                            return e.ItemsChartSettingsLinkStyle
                        }
                    },
                    to: {type: 0},
                    value: {type: 1}
                },e.NetChartIDataObjectNode = {
                    className: {type: 0},
                    error: {type: 0},
                    id: {type: 0},
                    loaded: {type: 9},
                    style: {
                        type: 5, update: 0, contents: function () {
                            return e.ItemsChartSettingsNodeStyle
                        }
                    },
                    value: {type: 1},
                    x: {type: 1},
                    y: {type: 1}
                },e.NetChartSettings = {
                    advanced: {
                        type: 5,
                        update: 0,
                        contents: function () {
                            return e.ItemsChartSettingsAdvanced
                        },
                        ctor: function () {
                            return t.ItemsChart.SettingsAdvanced
                        }
                    },
                    area: {
                        type: 5, update: 0, contents: function () {
                            return e.NetChartSettingsArea
                        }, ctor: function () {
                            return t.NetChart.SettingsArea
                        }
                    },
                    assetsUrlBase: {type: 0},
                    container: {type: 3},
                    credits: {
                        type: 5, update: 0, contents: function () {
                            return e.BaseSettingsCredits
                        }, ctor: function () {
                            return t.Base.SettingsCredits
                        }
                    },
                    data: {
                        type: 6,
                        update: 4,
                        baseTypes: [{
                            type: 5, update: 0, contents: function () {
                                return e.NetChartSettingsData
                            }, ctor: function () {
                                return t.NetChart.SettingsData
                            }
                        }]
                    },
                    events: {
                        type: 5, update: 0, contents: function () {
                            return e.BaseSettingsEvents
                        }, ctor: function () {
                            return t.Base.SettingsEvents
                        }
                    },
                    filters: {
                        type: 5, update: 0, contents: function () {
                            return {
                                linkFilter: {type: 4},
                                multilinkProcessor: {type: 4},
                                nodeFilter: {type: 4},
                                nodeLinksProcessor: {type: 4}
                            }
                        }
                    },
                    info: {
                        type: 5, update: 0, contents: function () {
                            return {
                                enabled: {type: 9},
                                linkContentsFunction: {type: 4},
                                nodeContentsFunction: {type: 4}
                            }
                        }
                    },
                    interaction: {
                        type: 5, update: 0, contents: function () {
                            return e.NetChartSettingsInteraction
                        }, ctor: function () {
                            return t.NetChart.SettingsInteraction
                        }
                    },
                    layout: {
                        type: 5, update: 0, contents: function () {
                            return e.NetChartSettingsLayout
                        }, ctor: function () {
                            return t.NetChart.SettingsLayout
                        }
                    },
                    legend: {
                        type: 5, update: 0, contents: function () {
                            return e.NetChartSettingsLegend
                        }, ctor: function () {
                            return t.NetChart.SettingsLegend
                        }
                    },
                    linkMenu: {
                        type: 5, update: 0, contents: function () {
                            return e.ItemsChartSettingsLinkMenu
                        }, ctor: function () {
                            return t.ItemsChart.SettingsLinkMenu
                        }
                    },
                    localization: {
                        type: 5, update: 0, contents: function () {
                            return e.NetChartSettingsLocalization
                        }, ctor: function () {
                            return t.NetChart.SettingsLocalization
                        }
                    },
                    navigation: {
                        type: 5, update: 0, contents: function () {
                            return e.NetChartSettingsNavigation
                        }, ctor: function () {
                            return t.NetChart.SettingsNavigation
                        }
                    },
                    nodeMenu: {
                        type: 5, update: 0, contents: function () {
                            return e.ItemsChartSettingsNodeMenu
                        }, ctor: function () {
                            return t.ItemsChart.SettingsNodeMenu
                        }
                    },
                    parentChart: {type: 5},
                    style: {
                        type: 5, update: 0, contents: function () {
                            return e.ItemsChartSettingsNodesLayerStyle
                        }, ctor: function () {
                            return t.ItemsChart.SettingsNodesLayerStyle
                        }
                    },
                    theme: {
                        type: 5, contents: function () {
                            return e.NetChartSettings
                        }, ctor: function () {
                            return t.NetChart.Settings
                        }, ctorIgnore: !0
                    },
                    title: {
                        type: 5, update: 0, contents: function () {
                            return e.BaseSettingsTitle
                        }, ctor: function () {
                            return t.Base.SettingsTitle
                        }
                    },
                    toolbar: {
                        type: 5, update: 0, contents: function () {
                            return e.NetChartBarSettingsToolbar
                        }, ctor: function () {
                            return t.NetChart.Bar.SettingsToolbar
                        }
                    }
                },e.NetChartSettingsArea = {
                    centerX: {type: 1},
                    centerY: {type: 1},
                    height: {type: 1},
                    left: {type: 1},
                    maxHeight: {type: 1},
                    maxWidth: {type: 1},
                    minHeight: {type: 1},
                    minWidth: {type: 1},
                    paddingBottom: {type: 1},
                    paddingLeft: {type: 1},
                    paddingRight: {type: 1},
                    paddingTop: {type: 1},
                    style: {
                        type: 5, update: 0, contents: function () {
                            return e.BaseSettingsAreaStyle
                        }, ctor: function () {
                            return t.Base.SettingsAreaStyle
                        }
                    },
                    top: {type: 1},
                    width: {type: 1}
                },e.NetChartSettingsData = {
                    cacheSize: {type: 1, details: 0},
                    dataFunction: {type: 4},
                    format: {type: 0, details: 6},
                    id: {type: 0},
                    numberOfParallelRequests: {type: 1, details: 0},
                    postprocessorFunction: {type: 4},
                    preloadNodeLinks: {type: 9},
                    preloaded: {
                        type: 7,
                        baseTypes: [{type: 0}, {
                            type: 5, contents: function () {
                                return e.NetChartIDataObject
                            }
                        }]
                    },
                    random: {type: 0, details: 6},
                    randomGridLinkProbability: {type: 1},
                    randomLinks: {type: 1, details: 0},
                    randomNodes: {type: 1, details: 0},
                    randomTreeDensity: {type: 1},
                    requestMaxUnits: {type: 1, details: 0},
                    requestTimeout: {type: 1, details: 0},
                    url: {type: 0, details: 5},
                    urlParameters: {
                        type: 6,
                        update: 0,
                        baseTypes: [{
                            type: 5, update: 0, contents: function () {
                                return {name: {type: 0}, value: {type: 0}}
                            }
                        }]
                    }
                },e.NetChartSettingsInteraction = {
                    nodesMovable: {type: 9},
                    panning: {
                        type: 5, update: 0, contents: function () {
                            return {enabled: {type: 9}}
                        }
                    },
                    resizing: {
                        type: 5, update: 0, contents: function () {
                            return e.BaseSettingsResizer
                        }, ctor: function () {
                            return t.Base.SettingsResizer
                        }
                    },
                    rotation: {
                        type: 5, update: 0, contents: function () {
                            return {fingers: {type: 9}}
                        }
                    },
                    selection: {
                        type: 5, update: 0, contents: function () {
                            return e.NetChartSettingsInteractionSelection
                        }, ctor: function () {
                            return t.NetChart.SettingsInteractionSelection
                        }
                    },
                    zooming: {
                        type: 5, update: 0, contents: function () {
                            return e.NetChartSettingsInteractionZooming
                        }, ctor: function () {
                            return t.NetChart.SettingsInteractionZooming
                        }
                    }
                },e.NetChartSettingsInteractionSelection = {
                    allowMoveNodesOffscreen: {type: 9},
                    enabled: {type: 9},
                    linksSelectable: {type: 9},
                    lockNodesOnMove: {type: 9},
                    nodesSelectable: {type: 9},
                    tolerance: {type: 1}
                },e.NetChartSettingsInteractionZooming = {
                    autoZoomAfterClick: {type: 9},
                    autoZoomExtent: {type: 12, baseTypes: [{type: 1}, {type: 1}]},
                    autoZoomPositionEllasticity: {type: 1},
                    autoZoomSize: {type: 1},
                    doubleClickZoom: {type: 1},
                    fingers: {type: 9},
                    initialAutoZoom: {type: 0, details: 6},
                    sensitivity: {type: 1},
                    wheel: {type: 9},
                    zoomExtent: {type: 12, baseTypes: [{type: 1}, {type: 1}]},
                    zoomInOnDoubleClick: {type: 9}
                },e.NetChartSettingsLayout = {
                    advanced: {
                        type: 5,
                        update: 0,
                        contents: function () {
                            return {adaptiveFreezeTreshold: {type: 1}}
                        }
                    },
                    aspectRatio: {type: 9},
                    globalLayoutOnChanges: {type: 9},
                    incrementalLayoutMaxTime: {type: 1, details: 0},
                    initialLayoutMaxTime: {type: 1, details: 0},
                    layoutFreezeMinTimeout: {type: 1, details: 0},
                    layoutFreezeTimeout: {type: 1, details: 0},
                    mode: {type: 0, details: 6},
                    nodeSpacing: {type: 1, details: 0},
                    rowSpacing: {type: 1, details: 0}
                },e.NetChartSettingsLegend = {
                    advanced: {
                        type: 5,
                        update: 0,
                        contents: function () {
                            return e.BaseSettingsLegendAdvanced
                        },
                        ctor: function () {
                            return t.Base.SettingsLegendAdvanced
                        }
                    },
                    enabled: {type: 9},
                    equalizeRowsColumns: {type: 9},
                    height: {type: 1},
                    lineSpacing: {type: 1},
                    margin: {type: 1},
                    marker: {
                        type: 5, update: 0, contents: function () {
                            return e.BaseSettingsLegendMarker
                        }, ctor: function () {
                            return t.Base.SettingsLegendMarker
                        }
                    },
                    maxLineSymbols: {type: 1, details: 0},
                    numberOfColumns: {type: 1, details: 0},
                    numberOfRows: {type: 1, details: 0},
                    padding: {type: 1},
                    panel: {
                        type: 5, update: 0, contents: function () {
                            return e.BaseSettingsLegendPanel
                        }, ctor: function () {
                            return t.Base.SettingsLegendPanel
                        }
                    },
                    text: {
                        type: 5, update: 0, contents: function () {
                            return {fillColor: {type: 0}, font: {type: 0}}
                        }
                    },
                    width: {type: 1}
                },e.NetChartSettingsLocalization = {
                    closeButton: {type: 0},
                    dataRequestFailed: {type: 0},
                    loadingLabel: {type: 0},
                    menu: {
                        type: 5, update: 0, contents: function () {
                            return {
                                collapse: {type: 0},
                                dynaminc: {type: 0},
                                expand: {type: 0},
                                fixed: {type: 0},
                                focus: {type: 0},
                                hide: {type: 0},
                                unfocus: {type: 0}
                            }
                        }
                    },
                    toolbar: {
                        type: 5, update: 0, contents: function () {
                            return e.NetChartBarSettingsLocalizationToolbar
                        }, ctor: function () {
                            return t.NetChart.Bar.SettingsLocalizationToolbar
                        }
                    }
                },e.NetChartSettingsNavigation = {
                    autoZoomOnFocus: {type: 9},
                    expandDelay: {type: 1, details: 0},
                    expandOnClick: {type: 9},
                    focusAutoFadeout: {type: 9},
                    focusNodeExpansionRadius: {type: 1, details: 0},
                    focusNodeTailExpansionRadius: {type: 1},
                    initialNodes: {type: 6, update: 0, baseTypes: [{type: 0}]},
                    minNumberOfFocusNodes: {type: 1, details: 0},
                    mode: {type: 0, details: 6},
                    numberOfFocusNodes: {type: 1, details: 0}
                },e.PieChartIDataObject = {
                    afterSum: {type: 1},
                    beforeSum: {type: 1},
                    id: {type: 0},
                    limit: {type: 1},
                    name: {type: 0},
                    offset: {type: 1},
                    style: {
                        type: 5, update: 0, contents: function () {
                            return e.PieChartSettingsSliceStyle
                        }
                    },
                    subvalues: {
                        type: 6,
                        update: 0,
                        baseTypes: [{
                            type: 5, update: 0, contents: function () {
                                return e.PieChartIDataObject
                            }
                        }]
                    },
                    sum: {type: 1},
                    total: {type: 1},
                    value: {type: 1}
                },e.PieChartIDataObjectRoot = {
                    afterSum: {type: 1},
                    beforeSum: {type: 1},
                    error: {type: 0},
                    id: {type: 0},
                    limit: {type: 1},
                    name: {type: 0},
                    offset: {type: 1},
                    subvalues: {
                        type: 6,
                        update: 0,
                        baseTypes: [{
                            type: 5, update: 0, contents: function () {
                                return e.PieChartIDataObject
                            }
                        }]
                    },
                    sum: {type: 1},
                    total: {type: 1}
                },e.PieChartSettings = {
                    advanced: {
                        type: 5,
                        update: 0,
                        contents: function () {
                            return e.PieChartSettingsAdvanced
                        },
                        ctor: function () {
                            return t.PieChart.SettingsAdvanced
                        }
                    },
                    area: {
                        type: 5, update: 0, contents: function () {
                            return e.BaseSettingsArea
                        }, ctor: function () {
                            return t.Base.SettingsArea
                        }
                    },
                    assetsUrlBase: {type: 0},
                    container: {type: 3},
                    credits: {
                        type: 5, update: 0, contents: function () {
                            return e.BaseSettingsCredits
                        }, ctor: function () {
                            return t.Base.SettingsCredits
                        }
                    },
                    data: {
                        type: 6,
                        update: 4,
                        baseTypes: [{
                            type: 5, update: 0, contents: function () {
                                return e.PieChartSettingsData
                            }, ctor: function () {
                                return t.PieChart.SettingsData
                            }
                        }]
                    },
                    events: {
                        type: 5, update: 0, contents: function () {
                            return e.PieChartSettingsEvents
                        }, ctor: function () {
                            return t.PieChart.SettingsEvents
                        }
                    },
                    filters: {
                        type: 5, update: 0, contents: function () {
                            return {sliceFilter: {type: 4}}
                        }
                    },
                    icons: {
                        type: 5, update: 0, contents: function () {
                            return {
                                autohideWhenTooSmall: {type: 9},
                                placement: {type: 0, details: 6},
                                sizeExtent: {type: 12, baseTypes: [{type: 1}, {type: 1}]}
                            }
                        }
                    },
                    info: {
                        type: 5, update: 0, contents: function () {
                            return {contentsFunction: {type: 4}, enabled: {type: 9}}
                        }
                    },
                    interaction: {
                        type: 5, update: 0, contents: function () {
                            return e.PieChartSettingsInteraction
                        }, ctor: function () {
                            return t.PieChart.SettingsInteraction
                        }
                    },
                    labels: {
                        type: 5, update: 0, contents: function () {
                            return e.PieChartSettingsLabels
                        }, ctor: function () {
                            return t.PieChart.SettingsLabels
                        }
                    },
                    legend: {
                        type: 5, update: 0, contents: function () {
                            return e.PieChartSettingsLegend
                        }, ctor: function () {
                            return t.PieChart.SettingsLegend
                        }
                    },
                    localization: {
                        type: 5, update: 0, contents: function () {
                            return e.PieChartSettingsLocalization
                        }, ctor: function () {
                            return t.PieChart.SettingsLocalization
                        }
                    },
                    navigation: {
                        type: 5, update: 0, contents: function () {
                            return {
                                initialDrilldown: {
                                    type: 6,
                                    update: 0,
                                    baseTypes: [{type: 0}]
                                }, initialOffset: {type: 1, details: 0}
                            }
                        }
                    },
                    parentChart: {type: 5},
                    pie: {
                        type: 5, update: 0, contents: function () {
                            return {
                                adaptiveRadius: {type: 9},
                                backgroundHoveredStyle: {
                                    type: 5,
                                    update: 0,
                                    contents: function () {
                                        return e.PieChartSettingsPieStyle
                                    }
                                },
                                backgroundStyle: {
                                    type: 5, update: 0, contents: function () {
                                        return e.PieChartSettingsPieStyle
                                    }
                                },
                                centerMargin: {type: 1, details: 0},
                                depth: {type: 1, details: 0},
                                endAngle: {type: 1},
                                innerRadius: {type: 1},
                                innerRadiusWhenDrilldown: {type: 1},
                                margin: {type: 1},
                                noDataStyle: {
                                    type: 5, update: 0, contents: function () {
                                        return e.PieChartSettingsPieStyle
                                    }
                                },
                                outerMargin: {type: 1},
                                radius: {type: 1},
                                showInnerPies: {type: 9},
                                showInnerPiesExport: {type: 9},
                                startAngle: {type: 1},
                                style: {
                                    type: 5, update: 0, contents: function () {
                                        return e.PieChartSettingsPieStyle
                                    }
                                },
                                styleFunction: {type: 4},
                                theme: {type: 0, details: 6},
                                x: {type: 1},
                                y: {type: 1}
                            }
                        }
                    },
                    slice: {
                        type: 5, update: 0, contents: function () {
                            return {
                                backgroundActiveStyle: {
                                    type: 5,
                                    update: 0,
                                    contents: function () {
                                        return {brightness: {type: 1}}
                                    }
                                },
                                backgroundStyle: {
                                    type: 5, update: 0, contents: function () {
                                        return {
                                            fillColor: {type: 0},
                                            fillColor2: {type: 0, details: 3}
                                        }
                                    }
                                },
                                connectorStyle: {
                                    type: 5, update: 0, contents: function () {
                                        return e.BaseSettingsLineStyle
                                    }
                                },
                                expandableMarkStyle: {
                                    type: 5,
                                    update: 0,
                                    contents: function () {
                                        return {
                                            distance: {type: 1},
                                            lineColor: {type: 0},
                                            lineDash: {
                                                type: 6,
                                                update: 0,
                                                baseTypes: [{type: 1}]
                                            },
                                            lineWidth: {type: 1}
                                        }
                                    }
                                },
                                hoverStyle: {
                                    type: 5, update: 0, contents: function () {
                                        return e.PieChartSettingsSliceStyle
                                    }
                                },
                                margin: {type: 1},
                                minFraction: {type: 1},
                                othersStyle: {
                                    type: 5, update: 0, contents: function () {
                                        return {
                                            fillColor: {type: 0},
                                            lineDecoration: {type: 0, details: 6}
                                        }
                                    }
                                },
                                previousStyle: {
                                    type: 5, update: 0, contents: function () {
                                        return {
                                            fillColor: {type: 0},
                                            lineDecoration: {type: 0, details: 6}
                                        }
                                    }
                                },
                                selectedStyle: {
                                    type: 5, update: 0, contents: function () {
                                        return e.PieChartSettingsSliceStyle
                                    }
                                },
                                style: {
                                    type: 5, update: 0, contents: function () {
                                        return e.PieChartSettingsSliceStyle
                                    }
                                },
                                styleFunction: {type: 4}
                            }
                        }
                    },
                    theme: {
                        type: 5, contents: function () {
                            return e.PieChartSettings
                        }, ctor: function () {
                            return t.PieChart.Settings
                        }, ctorIgnore: !0
                    },
                    title: {
                        type: 5, update: 0, contents: function () {
                            return e.BaseSettingsTitle
                        }, ctor: function () {
                            return t.Base.SettingsTitle
                        }
                    },
                    toolbar: {
                        type: 5, update: 0, contents: function () {
                            return e.BaseSettingsToolbar
                        }, ctor: function () {
                            return t.Base.SettingsToolbar
                        }
                    }
                },e.PieChartSettingsAdvanced = {
                    assets: {
                        type: 6,
                        update: 3,
                        baseTypes: [{type: 0, details: 5}]
                    },
                    backAlwaysVisible: {type: 9},
                    backImage: {type: 0, details: 4},
                    exportProxyURL: {type: 0, details: 5},
                    highDPI: {type: 9},
                    iconMinSize: {type: 1},
                    initialAnimation: {type: 9},
                    labelCache: {type: 9},
                    labelInsideTreshold: {type: 1, details: 0},
                    logging: {type: 9},
                    maxCanvasHeight: {type: 1},
                    maxCanvasWidth: {type: 1},
                    pdfExportAssets: {
                        type: 6,
                        update: 0,
                        baseTypes: [{type: 0, details: 5}]
                    },
                    pointer: {
                        type: 5, update: 0, contents: function () {
                            return e.BaseSettingsAdvancedPointer
                        }, ctor: function () {
                            return t.Base.SettingsAdvancedPointer
                        }
                    },
                    renderQuality: {type: 1, details: 0},
                    showFPS: {type: 9},
                    showTimestamp: {type: 9},
                    showTouches: {type: 9},
                    style: {
                        type: 5, update: 0, contents: function () {
                            return e.BaseSettingsAdvancedStyle
                        }, ctor: function () {
                            return t.Base.SettingsAdvancedStyle
                        }
                    },
                    themeCSSClass: {type: 0},
                    useAnimationFrame: {type: 9}
                },e.PieChartSettingsData = {
                    autoCategories: {
                        type: 6,
                        update: 0,
                        baseTypes: [{type: 7, baseTypes: [{type: 0}, {type: 4}]}]
                    },
                    dataFunction: {type: 4},
                    format: {type: 0, details: 6},
                    id: {type: 0},
                    itemsToLoad: {type: 1, details: 0},
                    numberOfParallelRequests: {type: 1, details: 0},
                    partialLoad: {type: 9},
                    postprocessorFunction: {type: 4},
                    preloaded: {
                        type: 7,
                        baseTypes: [{type: 0}, {
                            type: 5, contents: function () {
                                return e.PieChartIDataObject
                            }
                        }]
                    },
                    requestTimeout: {type: 1, details: 0},
                    sortField: {type: 0},
                    url: {type: 0, details: 5},
                    urlParameters: {
                        type: 6,
                        update: 0,
                        baseTypes: [{
                            type: 5, update: 0, contents: function () {
                                return {name: {type: 0}, value: {type: 0}}
                            }
                        }]
                    }
                },e.PieChartSettingsEvents = {
                    chartUpdateDelay: {type: 1, details: 0},
                    onChartUpdate: {type: 4},
                    onClick: {type: 4},
                    onDoubleClick: {type: 4},
                    onError: {type: 4},
                    onHoverChange: {type: 4},
                    onPieChange: {type: 4},
                    onPieReadyStateChanged: {type: 4},
                    onPositionChange: {type: 4},
                    onRightClick: {type: 4},
                    onSelectionChange: {type: 4},
                    onSettingsChange: {type: 4},
                    onTripleClick: {type: 4}
                },e.PieChartSettingsInteraction = {
                    animation: {
                        type: 5,
                        update: 0,
                        contents: function () {
                            return {
                                hoverDuration: {type: 1, details: 0},
                                scrollDuration: {type: 1, details: 0}
                            }
                        }
                    },
                    coverCenter: {type: 9},
                    mode: {type: 0, details: 6},
                    others: {
                        type: 5, update: 0, contents: function () {
                            return {
                                centerGoesToPrevious: {type: 9},
                                enabled: {type: 9},
                                maxOthersFraction: {type: 1},
                                maxSlicesVisible: {type: 1, details: 0},
                                minSliceFraction: {type: 1},
                                navigationFraction: {type: 1}
                            }
                        }
                    },
                    resizing: {
                        type: 5, update: 0, contents: function () {
                            return e.BaseSettingsResizer
                        }, ctor: function () {
                            return t.Base.SettingsResizer
                        }
                    },
                    scrolling: {
                        type: 5, update: 0, contents: function () {
                            return {enabled: {type: 9}}
                        }
                    },
                    selection: {
                        type: 5, update: 0, contents: function () {
                            return {
                                enabled: {type: 9},
                                maxSwipeDistance: {type: 1},
                                partialSwipe: {type: 9},
                                swipe: {type: 9},
                                swipeSensitivity: {type: 1},
                                tolerance: {type: 1}
                            }
                        }
                    }
                },e.PieChartSettingsLabels = {
                    angle: {type: 1, details: 0},
                    connectorLength: {type: 1, details: 0},
                    connectors: {type: 9},
                    enabled: {type: 9},
                    insideLabel: {type: 0, details: 6},
                    insideLabelVisibilityFraction: {type: 1},
                    interLabelSpacing: {type: 1},
                    placement: {type: 0, details: 6}
                },e.PieChartSettingsLegend = {
                    advanced: {
                        type: 5,
                        update: 0,
                        contents: function () {
                            return e.BaseSettingsLegendAdvanced
                        },
                        ctor: function () {
                            return t.Base.SettingsLegendAdvanced
                        }
                    },
                    enabled: {type: 9},
                    equalizeRowsColumns: {type: 9},
                    height: {type: 1},
                    lineSpacing: {type: 1},
                    margin: {type: 1},
                    marker: {
                        type: 5, update: 0, contents: function () {
                            return e.PieChartSettingsLegendMarker
                        }, ctor: function () {
                            return t.PieChart.SettingsLegendMarker
                        }
                    },
                    maxLineSymbols: {type: 1, details: 0},
                    numberOfColumns: {type: 1, details: 0},
                    numberOfRows: {type: 1, details: 0},
                    padding: {type: 1},
                    panel: {
                        type: 5, update: 0, contents: function () {
                            return e.BaseSettingsLegendPanel
                        }, ctor: function () {
                            return t.Base.SettingsLegendPanel
                        }
                    },
                    text: {
                        type: 5, update: 0, contents: function () {
                            return {fillColor: {type: 0}, font: {type: 0}}
                        }
                    },
                    width: {type: 1}
                },e.PieChartSettingsLegendMarker = {
                    alignment: {type: 0, details: 6},
                    lineColor: {type: 0, details: 3},
                    shape: {type: 0, details: 6},
                    size: {type: 1}
                },e.PieChartSettingsLocalization = {
                    closeButton: {type: 0},
                    dataRequestFailed: {type: 0},
                    loadingLabel: {type: 0},
                    othersLabel: {type: 0},
                    previousLabel: {type: 0},
                    toolbar: {
                        type: 5, update: 0, contents: function () {
                            return e.BaseSettingsLocalizationToolbar
                        }, ctor: function () {
                            return t.Base.SettingsLocalizationToolbar
                        }
                    }
                },e.PieChartSettingsPieStyle = {
                    background: {type: 9},
                    brightness: {type: 1},
                    colorDistribution: {type: 0, details: 6},
                    fillColor: {type: 0, details: 3},
                    sliceColors: {type: 6, update: 0, baseTypes: [{type: 0, details: 3}]}
                },e.PieChartSettingsSliceStyle = {
                    brightness: {type: 1},
                    cutoutDistance: {type: 1},
                    fillColor: {type: 0, details: 3},
                    icon: {type: 0, details: 4},
                    insideLabel: {
                        type: 5, update: 0, contents: function () {
                            return e.BaseSettingsLabelStyle
                        }
                    },
                    label: {
                        type: 5, update: 0, contents: function () {
                            return e.BaseSettingsLabelStyle
                        }
                    },
                    lineBrightness: {type: 1, details: 0},
                    lineColor: {type: 0, details: 3},
                    lineDash: {type: 6, update: 0, baseTypes: [{type: 1}]},
                    lineWidth: {type: 1, details: 0},
                    url: {type: 0, details: 5}
                },e.TimeChartIDataObject = {
                    data: {
                        type: 6,
                        update: 0,
                        baseTypes: [{type: 6, update: 0, baseTypes: [{type: 1}]}]
                    },
                    dataLimitFrom: {type: 1},
                    dataLimitTo: {type: 1},
                    error: {type: 0},
                    from: {type: 1},
                    to: {type: 1},
                    unit: {type: 0},
                    values: {
                        type: 6,
                        update: 0,
                        baseTypes: [{type: 6, update: 0, baseTypes: [{type: 1}]}]
                    }
                },e.TimeChartSettings = {
                    advanced: {
                        type: 5,
                        update: 0,
                        contents: function () {
                            return e.TimeChartSettingsAdvanced
                        },
                        ctor: function () {
                            return t.TimeChart.SettingsAdvanced
                        }
                    },
                    area: {
                        type: 5, update: 0, contents: function () {
                            return e.TimeChartSettingsArea
                        }, ctor: function () {
                            return t.TimeChart.SettingsArea
                        }
                    },
                    assetsUrlBase: {type: 0},
                    chartTypes: {
                        type: 5, update: 0, contents: function () {
                            return {
                                candlestick: {
                                    type: 5, update: 0, contents: function () {
                                        return e.TimeChartSettingsSeriesCandleStick
                                    }, ctor: function () {
                                        return t.TimeChart.SettingsSeriesCandleStick
                                    }, ctorIgnore: !0
                                }, columns: {
                                    type: 5, update: 0, contents: function () {
                                        return e.TimeChartSettingsSeriesColumns
                                    }, ctor: function () {
                                        return t.TimeChart.SettingsSeriesColumns
                                    }, ctorIgnore: !0
                                }, line: {
                                    type: 5, update: 0, contents: function () {
                                        return e.TimeChartSettingsSeriesLines
                                    }, ctor: function () {
                                        return t.TimeChart.SettingsSeriesLines
                                    }, ctorIgnore: !0
                                }
                            }
                        }
                    },
                    container: {type: 3},
                    credits: {
                        type: 5, update: 0, contents: function () {
                            return e.BaseSettingsCredits
                        }, ctor: function () {
                            return t.Base.SettingsCredits
                        }
                    },
                    currentTime: {
                        type: 5, update: 0, contents: function () {
                            return e.TimeChartSettingsCurrentTime
                        }, ctor: function () {
                            return t.TimeChart.SettingsCurrentTime
                        }
                    },
                    data: {
                        type: 6,
                        update: 4,
                        baseTypes: [{
                            type: 5, update: 0, contents: function () {
                                return e.TimeChartSettingsData
                            }, ctor: function () {
                                return t.TimeChart.SettingsData
                            }
                        }]
                    },
                    events: {
                        type: 5, update: 0, contents: function () {
                            return e.TimeChartSettingsEvents
                        }, ctor: function () {
                            return t.TimeChart.SettingsEvents
                        }
                    },
                    info: {
                        type: 5, update: 0, contents: function () {
                            return e.LinearChartSettingsInfoPopup
                        }, ctor: function () {
                            return t.LinearChart.SettingsInfoPopup
                        }
                    },
                    interaction: {
                        type: 5, update: 0, contents: function () {
                            return e.TimeChartSettingsInteraction
                        }, ctor: function () {
                            return t.TimeChart.SettingsInteraction
                        }
                    },
                    legend: {
                        type: 5, update: 0, contents: function () {
                            return e.LinearChartSettingsLegend
                        }, ctor: function () {
                            return t.LinearChart.SettingsLegend
                        }
                    },
                    localization: {
                        type: 5, update: 0, contents: function () {
                            return e.TimeChartSettingsLocalization
                        }, ctor: function () {
                            return t.TimeChart.SettingsLocalization
                        }
                    },
                    navigation: {
                        type: 5, update: 0, contents: function () {
                            return {
                                followAnchor: {type: 9},
                                initialDisplayAnchor: {type: 0, details: 6},
                                initialDisplayPeriod: {type: 0, details: 6},
                                initialDisplayUnit: {type: 0, details: 6}
                            }
                        }
                    },
                    parentChart: {type: 5},
                    series: {
                        type: 6,
                        update: 4,
                        baseTypes: [{
                            type: 5, update: 0, contents: function () {
                                return e.TimeChartSettingsSeries
                            }, ctor: function () {
                                return t.TimeChart.SettingsSeries
                            }, ctorIgnore: !0
                        }]
                    },
                    seriesDefault: {
                        type: 5, update: 0, contents: function () {
                            return e.LinearChartSettingsSeries
                        }, ctor: function () {
                            return t.LinearChart.SettingsSeries
                        }, ctorIgnore: !0
                    },
                    stacks: {
                        type: 8,
                        update: 0,
                        baseTypes: [{
                            type: 5, update: 0, contents: function () {
                                return e.LinearChartSettingsStack
                            }, ctor: function () {
                                return t.LinearChart.SettingsStack
                            }
                        }]
                    },
                    style: {
                        type: 5, update: 0, contents: function () {
                            return {
                                columnColors: {
                                    type: 6,
                                    update: 0,
                                    baseTypes: [{type: 0}]
                                },
                                lineColors: {type: 6, update: 0, baseTypes: [{type: 0}]}
                            }
                        }
                    },
                    theme: {
                        type: 5, contents: function () {
                            return e.TimeChartSettings
                        }, ctor: function () {
                            return t.TimeChart.Settings
                        }, ctorIgnore: !0
                    },
                    timeAxis: {
                        type: 5, update: 0, contents: function () {
                            return e.TimeChartSettingsTimeAxis
                        }, ctor: function () {
                            return t.TimeChart.SettingsTimeAxis
                        }
                    },
                    title: {
                        type: 5, update: 0, contents: function () {
                            return e.BaseSettingsTitle
                        }, ctor: function () {
                            return t.Base.SettingsTitle
                        }
                    },
                    toolbar: {
                        type: 5, update: 0, contents: function () {
                            return e.TimeChartSettingsToolbar
                        }, ctor: function () {
                            return t.TimeChart.SettingsToolbar
                        }
                    },
                    valueAxis: {
                        type: 8,
                        update: 0,
                        baseTypes: [{
                            type: 5, update: 0, contents: function () {
                                return e.LinearChartSettingsValueAxis
                            }, ctor: function () {
                                return t.LinearChart.SettingsValueAxis
                            }
                        }]
                    },
                    valueAxisDefault: {
                        type: 5, update: 0, contents: function () {
                            return e.LinearChartSettingsValueAxis
                        }, ctor: function () {
                            return t.LinearChart.SettingsValueAxis
                        }
                    }
                },e.TimeChartSettingsAdvanced = {
                    assets: {
                        type: 6,
                        update: 3,
                        baseTypes: [{type: 0, details: 5}]
                    },
                    dataUpdateInterval: {type: 1, details: 0},
                    exportProxyURL: {type: 0, details: 5},
                    highDPI: {type: 9},
                    labelCache: {type: 9},
                    logging: {type: 9},
                    maxCanvasHeight: {type: 1},
                    maxCanvasWidth: {type: 1},
                    maxUnitsToDisplay: {type: 1, details: 0},
                    pdfExportAssets: {
                        type: 6,
                        update: 0,
                        baseTypes: [{type: 0, details: 5}]
                    },
                    pointer: {
                        type: 5, update: 0, contents: function () {
                            return e.BaseSettingsAdvancedPointer
                        }, ctor: function () {
                            return t.Base.SettingsAdvancedPointer
                        }
                    },
                    showFPS: {type: 9},
                    showTimestamp: {type: 9},
                    showTouches: {type: 9},
                    style: {
                        type: 5, update: 0, contents: function () {
                            return e.BaseSettingsAdvancedStyle
                        }, ctor: function () {
                            return t.Base.SettingsAdvancedStyle
                        }
                    },
                    themeCSSClass: {type: 0},
                    timeUpdateInterval: {type: 1, details: 0},
                    useAnimationFrame: {type: 9}
                },e.TimeChartSettingsArea = {
                    displayPeriods: {
                        type: 6,
                        update: 0,
                        baseTypes: [{
                            type: 5, update: 0, contents: function () {
                                return {unit: {type: 0}}
                            }
                        }]
                    },
                    displayUnits: {
                        type: 6,
                        update: 0,
                        baseTypes: [{
                            type: 5, update: 0, contents: function () {
                                return {unit: {type: 0}, name: {type: 0}}
                            }
                        }]
                    },
                    height: {type: 1},
                    left: {type: 1},
                    maxHeight: {type: 1},
                    maxWidth: {type: 1},
                    minHeight: {type: 1},
                    minWidth: {type: 1},
                    style: {
                        type: 5, update: 0, contents: function () {
                            return e.TimeChartSettingsAreaStyle
                        }, ctor: function () {
                            return t.TimeChart.SettingsAreaStyle
                        }
                    },
                    top: {type: 1},
                    width: {type: 1}
                },e.TimeChartSettingsAreaDisplayPeriod = {
                    displayAnchor: {type: 0},
                    displayPeriod: {type: 0},
                    displayUnit: {type: 0, details: 6},
                    name: {type: 0}
                },e.TimeChartSettingsAreaStyle = {
                    fillColor: {type: 0, details: 3},
                    image: {type: 0, details: 4},
                    loadingData: {
                        type: 5, update: 0, contents: function () {
                            return {fillColor: {type: 0}}
                        }
                    },
                    markerText: {
                        type: 5, update: 0, contents: function () {
                            return e.BaseSettingsTextStyle
                        }
                    },
                    noData: {
                        type: 5, update: 0, contents: function () {
                            return {fillColor: {type: 0}, image: {type: 0, details: 5}}
                        }
                    },
                    overlayColor: {type: 0, details: 3},
                    selection: {
                        type: 5, update: 0, contents: function () {
                            return {
                                fillColor: {type: 0},
                                lineColor: {type: 0},
                                lineWidth: {type: 1}
                            }
                        }
                    },
                    selectionLabel: {
                        type: 5, update: 0, contents: function () {
                            return e.BaseSettingsTextStyle
                        }
                    },
                    zoomHighlight: {
                        type: 5, update: 0, contents: function () {
                            return e.LinearChartSettingsHighlightStyle
                        }
                    },
                    zoomHighlightInactive: {
                        type: 5, update: 0, contents: function () {
                            return {fillColor: {type: 0}}
                        }
                    }
                },e.TimeChartSettingsCurrentTime = {
                    enabled: {type: 9},
                    label: {type: 0},
                    overrideCurTime: {type: 1, details: 0},
                    overridesLimits: {type: 9},
                    style: {
                        type: 5, update: 0, contents: function () {
                            return e.BaseSettingsBackgroundStyle
                        }
                    },
                    textStyle: {
                        type: 5, update: 0, contents: function () {
                            return e.BaseSettingsTextStyle
                        }
                    }
                },e.TimeChartSettingsData = {
                    cacheSize: {type: 1, details: 0},
                    dataFunction: {type: 4},
                    format: {type: 0, details: 6},
                    id: {type: 0},
                    minimizeRequests: {type: 9},
                    numberOfParallelRequests: {type: 1, details: 0},
                    postprocessorFunction: {type: 4},
                    prefetchRatio: {type: 1},
                    preloaded: {
                        type: 5, contents: function () {
                            return e.TimeChartIDataObject
                        }
                    },
                    requestMaxUnits: {type: 1, details: 0},
                    requestTimeout: {type: 1, details: 0},
                    timeZoneOffset: {type: 7, baseTypes: [{type: 0}, {type: 1}]},
                    timestampInSeconds: {type: 9},
                    units: {type: 6, update: 0, baseTypes: [{type: 0}]},
                    url: {type: 0, details: 5},
                    urlByUnit: {
                        type: 5, update: 0, contents: function () {
                            return {
                                M: {type: 0},
                                d: {type: 0},
                                h: {type: 0},
                                m: {type: 0},
                                ms: {type: 0},
                                s: {type: 0},
                                y: {type: 0}
                            }
                        }
                    },
                    urlParameters: {
                        type: 6,
                        update: 0,
                        baseTypes: [{
                            type: 5, update: 0, contents: function () {
                                return {name: {type: 0}, value: {type: 0}}
                            }
                        }]
                    }
                },e.TimeChartSettingsEvents = {
                    chartUpdateDelay: {type: 1, details: 0},
                    onAnimationDone: {type: 4},
                    onChartUpdate: {type: 4},
                    onClick: {type: 4},
                    onDoubleClick: {type: 4},
                    onError: {type: 4},
                    onHoverChange: {type: 4},
                    onPositionChange: {type: 4},
                    onRightClick: {type: 4},
                    onSelectionChange: {type: 4},
                    onSettingsChange: {type: 4},
                    onTimeChange: {type: 4},
                    onTripleClick: {type: 4}
                },e.TimeChartSettingsInteraction = {
                    resizing: {
                        type: 5,
                        update: 0,
                        contents: function () {
                            return e.BaseSettingsResizer
                        },
                        ctor: function () {
                            return t.Base.SettingsResizer
                        }
                    },
                    scrolling: {
                        type: 5, update: 0, contents: function () {
                            return e.TimeChartSettingsInteractionScrolling
                        }, ctor: function () {
                            return t.TimeChart.SettingsInteractionScrolling
                        }
                    },
                    selection: {
                        type: 5, update: 0, contents: function () {
                            return e.TimeChartSettingsInteractionSelection
                        }, ctor: function () {
                            return t.TimeChart.SettingsInteractionSelection
                        }
                    },
                    snapMode: {type: 0, details: 6},
                    swipeSensitivity: {type: 1},
                    zooming: {
                        type: 5, update: 0, contents: function () {
                            return {
                                enabled: {type: 9},
                                fingers: {type: 9},
                                fingersMaxZoom: {type: 1},
                                keyboardFactor: {type: 1},
                                sensitivity: {type: 1},
                                swipe: {type: 9},
                                upDownTreshold: {type: 1},
                                wheel: {type: 9},
                                zoomHighlightThreshold: {type: 1}
                            }
                        }
                    }
                },e.TimeChartSettingsInteractionScrolling = {
                    enabled: {type: 9},
                    keyboardScrollingFactor: {type: 1},
                    kineticFriction: {type: 1},
                    limitFrom: {type: 7, baseTypes: [{type: 0}, {type: 1}]},
                    limitMode: {type: 0, details: 6},
                    limitTo: {type: 7, baseTypes: [{type: 0}, {type: 1}]},
                    overscrollProportion: {type: 1},
                    swipePageFlipping: {type: 9}
                },e.TimeChartSettingsInteractionSelection = {
                    enabled: {type: 9},
                    tolerance: {type: 1}
                },e.TimeChartSettingsLocalization = {
                    calendar: {
                        type: 5,
                        update: 0,
                        contents: function () {
                            return {
                                months: {type: 6, update: 0, baseTypes: [{type: 0}]},
                                monthsShort: {type: 6, update: 0, baseTypes: [{type: 0}]},
                                week: {
                                    type: 5, update: 0, contents: function () {
                                        return {dow: {type: 1}, doy: {type: 1}}
                                    }
                                },
                                weekdays: {type: 6, update: 0, baseTypes: [{type: 0}]},
                                weekdaysMin: {type: 6, update: 0, baseTypes: [{type: 0}]},
                                weekdaysShort: {
                                    type: 6,
                                    update: 0,
                                    baseTypes: [{type: 0}]
                                }
                            }
                        }
                    },
                    closeButton: {type: 0},
                    dataRequestFailed: {type: 0},
                    determiningDataBounds: {type: 0},
                    holidayWeekdays: {
                        type: 6,
                        update: 0,
                        baseTypes: [{type: 1, details: 0}]
                    },
                    infoDates: {
                        type: 5, update: 0, contents: function () {
                            return {
                                fullTimeFormats: {
                                    type: 5,
                                    update: 0,
                                    contents: function () {
                                        return e.TimeChartSettingsLocalizationTimeUnits
                                    }
                                }, majorTimeFormats: {
                                    type: 5, update: 0, contents: function () {
                                        return e.TimeChartSettingsLocalizationTimeUnits
                                    }
                                }, minorTimeFormats: {
                                    type: 5, update: 0, contents: function () {
                                        return e.TimeChartSettingsLocalizationTimeUnits
                                    }
                                }
                            }
                        }
                    },
                    loadingLabel: {type: 0},
                    markerDates: {
                        type: 5, update: 0, contents: function () {
                            return {
                                timeFormats: {
                                    type: 5, update: 0, contents: function () {
                                        return e.TimeChartSettingsLocalizationTimeUnits
                                    }
                                }
                            }
                        }
                    },
                    noDataLabel: {type: 0},
                    timeAxisDates: {
                        type: 5, update: 0, contents: function () {
                            return {
                                majorLabelFullTimeFormats: {
                                    type: 5,
                                    update: 0,
                                    contents: function () {
                                        return e.TimeChartSettingsLocalizationTimeUnits
                                    }
                                },
                                majorLabelTimeFormats: {
                                    type: 5,
                                    update: 0,
                                    contents: function () {
                                        return e.TimeChartSettingsLocalizationTimeUnits
                                    }
                                },
                                minorLabelTimeFormats: {
                                    type: 5,
                                    update: 0,
                                    contents: function () {
                                        return e.TimeChartSettingsLocalizationTimeUnits
                                    }
                                }
                            }
                        }
                    },
                    timeUnitsNames: {
                        type: 5, update: 0, contents: function () {
                            return e.TimeChartSettingsLocalizationTimeUnits
                        }
                    },
                    timeUnitsNamesPlural: {
                        type: 5, update: 0, contents: function () {
                            return e.TimeChartSettingsLocalizationTimeUnits
                        }
                    },
                    toolbar: {
                        type: 5, update: 0, contents: function () {
                            return e.TimeChartSettingsLocalizationToolbar
                        }, ctor: function () {
                            return t.TimeChart.SettingsLocalizationToolbar
                        }
                    },
                    unnamedSeries: {type: 0},
                    valueUnits: {type: 8, update: 0, baseTypes: [{type: 1, details: 0}]}
                },e.TimeChartSettingsLocalizationTimeUnits = {
                    M: {type: 0},
                    d: {type: 0},
                    h: {type: 0},
                    m: {type: 0},
                    ms: {type: 0},
                    s: {type: 0},
                    w: {type: 0},
                    y: {type: 0}
                },e.TimeChartSettingsLocalizationToolbar = {
                    backButton: {type: 0},
                    backTitle: {type: 0},
                    customPeriod: {type: 0},
                    exportButton: {type: 0},
                    exportCSV: {type: 0},
                    exportJpeg: {type: 0},
                    exportPDF: {type: 0},
                    exportPNG: {type: 0},
                    exportTitle: {type: 0},
                    exportXLS: {type: 0},
                    fullscreenButton: {type: 0},
                    fullscreenTitle: {type: 0},
                    linButton: {type: 0},
                    linLogTitle: {type: 0},
                    logButton: {type: 0},
                    periodDropdownTitle: {type: 0},
                    unitDropdownTitle: {type: 0},
                    zoomoutButton: {type: 0},
                    zoomoutTitle: {type: 0}
                },e.TimeChartSettingsSeries = {
                    cluster: {type: 0},
                    data: {
                        type: 5, update: 0, contents: function () {
                            return e.TimeChartSettingsSeriesData
                        }, ctor: function () {
                            return t.TimeChart.SettingsSeriesData
                        }
                    },
                    enabled: {type: 9},
                    id: {type: 0},
                    name: {type: 0},
                    nameLegend: {type: 0},
                    showInLegend: {type: 9},
                    stack: {type: 0},
                    style: {
                        type: 5, update: 0, contents: function () {
                            return e.LinearChartSettingsSeriesStyle
                        }, ctor: function () {
                            return t.LinearChart.SettingsSeriesStyle
                        }
                    },
                    type: {type: 0, details: 6},
                    valueAxis: {type: 0}
                },e.TimeChartSettingsSeriesCandleStick = {
                    cluster: {type: 0},
                    data: {
                        type: 5, update: 0, contents: function () {
                            return e.TimeChartSettingsSeriesCandleStickData
                        }, ctor: function () {
                            return t.TimeChart.SettingsSeriesCandleStickData
                        }
                    },
                    enabled: {type: 9},
                    id: {type: 0},
                    localization: {
                        type: 5, update: 0, contents: function () {
                            return {
                                close: {type: 0},
                                high: {type: 0},
                                low: {type: 0},
                                open: {type: 0}
                            }
                        }
                    },
                    name: {type: 0},
                    nameLegend: {type: 0},
                    showInLegend: {type: 9},
                    stack: {type: 0},
                    style: {
                        type: 5, update: 0, contents: function () {
                            return {
                                decrease: {
                                    type: 5, update: 0, contents: function () {
                                        return e.LinearChartSettingsCandleStickMotionStyle
                                    }
                                },
                                increase: {
                                    type: 5, update: 0, contents: function () {
                                        return e.LinearChartSettingsCandleStickMotionStyle
                                    }
                                },
                                padding: {
                                    type: 12,
                                    baseTypes: [{type: 1, details: 0}, {
                                        type: 1,
                                        details: 0
                                    }]
                                },
                                pattern: {type: 0, details: 6}
                            }
                        }
                    },
                    type: {type: 0, details: 6},
                    valueAxis: {type: 0}
                },e.TimeChartSettingsSeriesCandleStickData = {
                    aggregatedValueFunction: {type: 4},
                    aggregation: {type: 0, details: 6},
                    close: {type: 1},
                    countIndex: {type: 1},
                    high: {type: 1},
                    index: {type: 1, details: 0},
                    low: {type: 1},
                    noDataPolicy: {type: 0, details: 6},
                    open: {type: 1},
                    source: {type: 0, details: 6},
                    valueFunction: {type: 4}
                },e.TimeChartSettingsSeriesColumns = {
                    cluster: {type: 0},
                    data: {
                        type: 5, update: 0, contents: function () {
                            return e.TimeChartSettingsSeriesData
                        }, ctor: function () {
                            return t.TimeChart.SettingsSeriesData
                        }
                    },
                    enabled: {type: 9},
                    id: {type: 0},
                    name: {type: 0},
                    nameLegend: {type: 0},
                    showInLegend: {type: 9},
                    stack: {type: 0},
                    style: {
                        type: 5, update: 0, contents: function () {
                            return e.LinearChartSettingsSeriesColumnsStyle
                        }, ctor: function () {
                            return t.LinearChart.SettingsSeriesColumnsStyle
                        }
                    },
                    type: {type: 0, details: 6},
                    valueAxis: {type: 0}
                },e.TimeChartSettingsSeriesData = {
                    aggregatedValueFunction: {type: 4},
                    aggregation: {type: 0, details: 6},
                    countIndex: {type: 1},
                    index: {type: 1, details: 0},
                    noDataPolicy: {type: 0, details: 6},
                    source: {type: 0, details: 6},
                    valueFunction: {type: 4}
                },e.TimeChartSettingsSeriesLines = {
                    cluster: {type: 0},
                    data: {
                        type: 5, update: 0, contents: function () {
                            return e.TimeChartSettingsSeriesData
                        }, ctor: function () {
                            return t.TimeChart.SettingsSeriesData
                        }
                    },
                    enabled: {type: 9},
                    id: {type: 0},
                    name: {type: 0},
                    nameLegend: {type: 0},
                    showInLegend: {type: 9},
                    stack: {type: 0},
                    style: {
                        type: 5, update: 0, contents: function () {
                            return {
                                depth: {type: 1},
                                fillColor: {type: 0, details: 3},
                                fillGradient: {type: 11},
                                lineColor: {type: 0},
                                lineDash: {type: 6, update: 0, baseTypes: [{type: 1}]},
                                lineWidth: {type: 1},
                                marker: {
                                    type: 5, update: 0, contents: function () {
                                        return {
                                            fillColor: {type: 0, details: 3},
                                            shape: {type: 0, details: 6},
                                            width: {type: 1, details: 0}
                                        }
                                    }
                                },
                                shadowBlur: {type: 1, details: 0},
                                shadowColor: {type: 0, details: 3},
                                shadowOffsetX: {type: 1, details: 0},
                                shadowOffsetY: {type: 1, details: 0},
                                smoothing: {type: 9},
                                steps: {type: 9}
                            }
                        }
                    },
                    type: {type: 0, details: 6},
                    valueAxis: {type: 0}
                },e.TimeChartSettingsTimeAxis = {
                    enabled: {type: 9},
                    maxUnitWidth: {type: 1},
                    minUnitWidth: {type: 1},
                    miniTimeRuler: {type: 9},
                    showHolidays: {type: 9},
                    style: {
                        type: 5, update: 0, contents: function () {
                            return {
                                dateHolidays: {
                                    type: 5, update: 0, contents: function () {
                                        return {fillColor: {type: 0}}
                                    }
                                },
                                dateLighten: {
                                    type: 5, update: 0, contents: function () {
                                        return {fillColor: {type: 0}}
                                    }
                                },
                                majorTimeBalloonStyle: {
                                    type: 5,
                                    update: 0,
                                    contents: function () {
                                        return e.BaseSettingsBackgroundStyle
                                    }
                                },
                                majorTimeLabel: {
                                    type: 5, update: 0, contents: function () {
                                        return e.BaseSettingsTextStyle
                                    }
                                },
                                minorTimeBalloonStyle: {
                                    type: 5,
                                    update: 0,
                                    contents: function () {
                                        return e.BaseSettingsBackgroundStyle
                                    }
                                },
                                minorTimeLabel: {
                                    type: 5, update: 0, contents: function () {
                                        return e.BaseSettingsTextStyle
                                    }
                                },
                                minorTimeRuler: {
                                    type: 5, update: 0, contents: function () {
                                        return e.BaseSettingsLineStyle
                                    }
                                },
                                showMajorTimeBalloons: {type: 9},
                                showMinorTimeBalloons: {type: 9},
                                vgrid: {
                                    type: 5, update: 0, contents: function () {
                                        return e.BaseSettingsLineStyle
                                    }
                                }
                            }
                        }
                    },
                    timeZoneOffset: {type: 7, baseTypes: [{type: 0}, {type: 1}]},
                    unitSizePolicy: {type: 0, details: 6},
                    vgrid: {type: 9}
                },e.TimeChartSettingsToolbar = {
                    align: {type: 0, details: 6},
                    back: {type: 9},
                    cssClass: {type: 0},
                    displayPeriod: {type: 9},
                    displayUnit: {type: 9},
                    enabled: {type: 9},
                    "export": {type: 9},
                    extraItems: {
                        type: 6,
                        update: 0,
                        baseTypes: [{
                            type: 7,
                            update: 0,
                            baseTypes: [{type: 0}, {
                                type: 5,
                                update: 0,
                                contents: function () {
                                    return e.BaseSettingsToolbarItem
                                },
                                ctor: function () {
                                    return t.Base.SettingsToolbarItem
                                }
                            }]
                        }]
                    },
                    items: {
                        type: 6,
                        update: 0,
                        baseTypes: [{
                            type: 5, update: 0, contents: function () {
                                return e.BaseSettingsToolbarItem
                            }, ctor: function () {
                                return t.Base.SettingsToolbarItem
                            }
                        }]
                    },
                    location: {type: 0, details: 6},
                    logScale: {type: 9},
                    periods: {
                        type: 6,
                        update: 0,
                        baseTypes: [{
                            type: 5, update: 0, contents: function () {
                                return e.TimeChartSettingsAreaDisplayPeriod
                            }, ctor: function () {
                                return t.TimeChart.SettingsAreaDisplayPeriod
                            }
                        }]
                    },
                    showLabels: {type: 9},
                    side: {type: 0, details: 6},
                    zoomOut: {type: 9}
                },e
            }();
            e.SettingsMapping = i
        }(e = t.Base || (t.Base = {}))
    }(e = t.Internal || (t.Internal = {}))
}(ZoomCharts || (ZoomCharts = {}));
var ZoomCharts;
!function (t) {
    var e;
    !function (t) {
        var e;
        !function (t) {
            var e = function () {
                function e() {
                }

                return e.createEmptySettings = function (t) {
                    var i = e.createEmptySettingsInner(t);
                    return i.__cleanup = !0, i
                }, e.createEmptySettingsInner = function (t) {
                    var i = {};
                    for (var n in t)if (t.hasOwnProperty(n)) {
                        var s = t[n];
                        5 === s.type && 0 === s.update && s.contents && (i[n] = e.createEmptySettingsInner(s.contents()))
                    }
                    return i
                }, e.cleanupEmptySettings = function (t) {
                    t && t.__cleanup && (delete t.__cleanup, e.cleanupEmptySettingsInner(t))
                }, e.cleanupEmptySettingsInner = function (i) {
                    for (var n in i)if (i.hasOwnProperty(n)) {
                        var s = i[n];
                        s && t.Helpers.isObjectOrArray(s) && !t.Helpers.isArray(s) && (t.Helpers.hasProperties(s) ? e.cleanupEmptySettingsInner(s) : delete i[n])
                    }
                }, e.mergeDefaultValues = function (i, n, s, o, r, a) {
                    var h = n ? n.type : null;
                    if (!i || 0 === i.length) {
                        if (!h)return [];
                        i = [{type: h}]
                    }
                    for (var l = [], u = 0; u < i.length; u++) {
                        var c = i[u], p = a + "[" + u + "]";
                        if (t.Helpers.isObjectOrArray(c)) {
                            var d = c.type || h;
                            if (!d)throw new Error("`type` property must be specified in the settings for value: " + p);
                            var f = o(c, d), m = s[d];
                            n && (delete n.type, e.updateRecursive(f, n, r(f, n), {}, p), n.type = h), m && e.updateRecursive(f, m, r(f, m), {}, p), e.updateRecursive(f, c, r(f, c), {}, p), l.push(f)
                        }
                    }
                    return l
                }, e.updateRecursive = function (t, e, i, n, s) {
                    if (void 0 === s && (s = ""), !t)throw new Error("Cannot update settings path '" + s + "' because the target object is not defined.");
                    if (e)for (var o in e)if (e.hasOwnProperty(o)) {
                        var r = e[o], a = (s.length ? s + "." : "") + o, h = this.findPropertyConfiguration(o, i, a);
                        null !== h && void 0 !== r && this.copyValue(t, o, r, h, n, a)
                    }
                }, e.copyValueMergeByID = function (e, i, n, s, o, r) {
                    if (null != n) {
                        if (6 !== s.type)throw new Error("Property '" + r + "' is set to use merge-by-ID update mode which is only supported on arrays.");
                        var a = e[i];
                        null == a && (e[i] = a = []);
                        for (var h = {}, l = 0; l < a.length; l++)h[a[l].id] = a[l];
                        for (var u = 0; u < n.length; u++) {
                            var c = n[u];
                            if (null != c) {
                                c.id || (c.id = t.Helpers.getIdentifierStr());
                                var p = h[c.id];
                                o[i] || (o[i] = {}), this.copyValue(h, c.id, c, s.baseTypes[0], o[i], r + "[" + c.id + "]"), p || a.push(h[c.id])
                            }
                        }
                    }
                }, e.retrieveOwnMethod = function (t, e) {
                    if (!t)return null;
                    var i = t[e], n = t.__baseType;
                    return n && n[e] === i ? null : i
                }, e.copyValueRecursive = function (t, e, i, n, s, o) {
                    if (null != i) {
                        var r = t[e];
                        if (n.contents) {
                            var a = n.ctor ? n.ctor() : null, h = this.retrieveOwnMethod(a, "getMapping"), l = h ? h(r, i) : n.contents();
                            if (null == r) {
                                if (!a || n.ctorIgnore || this._ignoringCtor) r = {}; else {
                                    var u = this.retrieveOwnMethod(a, "createInstance");
                                    r = u ? u(i) : new a
                                }
                                t[e] = r
                            }
                            if (n.ctorIgnore)try {
                                this._ignoringCtor++, this.updateRecursive(r, i, l, s[e] = {}, o)
                            } finally {
                                this._ignoringCtor--
                            } else this.updateRecursive(r, i, l, s[e] = {}, o)
                        } else if (6 === n.type) t[e] = r = [], this.copyArray(r, i, n.baseTypes[0], s[e] = [], o); else {
                            if (8 !== n.type)throw new Error("Property '" + o + "' is set to use recursive update but does not define target object mapping.");
                            null == r && (t[e] = r = {}), this.copyObject(r, i, n.baseTypes[0], s[e] = {}, o)
                        }
                    }
                }, e.copyValue = function (t, e, i, n, s, o) {
                    if (void 0 === i)return delete t[e], void(s[e] = !0);
                    var r = this.ensurePropertyType(i, n, o);
                    if (r) {
                        i = r.value, n = r.configuration || n;
                        var a = t[e];
                        if (1 === n.update || void 0 === n.update) a !== i && (s[e] = i, t[e] = i); else if (2 === n.update) i = JSON.parse(JSON.stringify(i)), s[e] = i, t[e] = i; else if (4 === n.update) this.copyValueMergeByID(t, e, i, n, s, o); else if (3 === n.update) {
                            if (null != i) {
                                if (6 !== n.type)throw new Error("Property '" + o + "' is set to use concat update which is only supported for arrays.");
                                a || (t[e] = a = []), this.copyArray(a, i, n.baseTypes[0], s[e] = [], o)
                            }
                        } else {
                            if (0 !== n.update)throw new Error("Property '" + o + "' does not have an update mode defined in the settings mapping or it is not implemented.");
                            this.copyValueRecursive(t, e, i, n, s, o)
                        }
                    }
                }, e.copyObject = function (e, i, n, s, o) {
                    for (var r in i)if (i.hasOwnProperty(r)) {
                        var a = {};
                        this.copyValue(e, r, i[r], n, a, o + "." + r), t.Helpers.hasProperties(a) && (s[r] = a)
                    }
                }, e.copyArray = function (t, e, i, n, s) {
                    for (var o = 0; o < e.length; o++)this.copyValue(t, t.length, e[o], i, n, s + "[" + o + "]")
                }, e.ensurePropertyType = function (e, i, n, s) {
                    if (void 0 === s && (s = !1), null == e)return {value: e};
                    var o = null, r = null, a = void 0, h = null;
                    switch (i.type) {
                        case 0:
                            t.Helpers.isString(e) || (o = "String");
                            break;
                        case 1:
                            if (0 === i.details) {
                                a = parseFloat(e);
                                var l = Math.round(a);
                                if (isNaN(a)) o = "Integer"; else if (l !== a) {
                                    var u = Math.abs(l - a);
                                    s || t.Helpers.warn("Settings value '" + n + "' expected to be an Integer but contains a decimal point: " + a + "."), 1e-8 > u && (a = l)
                                }
                            } else a = parseFloat(e), isNaN(a) && (o = "Float");
                            break;
                        case 3:
                            t.Helpers.isString(e) ? (a = document.getElementById(e), a || (r = "the property expects either a reference to a DOM element or a string containing the ID of the element. There is no element with the given ID '" + e + "'.")) : t.Helpers.isDomObject(e) || (r = "the property expects either a reference to a DOM element or a string containing the ID of the element.");
                            break;
                        case 4:
                            t.Helpers.isFunction(e) || (o = "Function");
                            break;
                        case 6:
                            t.Helpers.isArray(e) || (s || t.Helpers.warn("Settings value '" + n + "' expected to be an array but found " + typeof e + ". The value will be wrapped in an array."), a = [e]);
                            break;
                        case 11:
                            if (t.Helpers.isArray(e))for (var c = 0; c < e.length; c++) {
                                var p = e[c];
                                if (!t.Helpers.isArray(p) || 2 !== p.length || !t.Helpers.isNumber(p[0]) || !t.Helpers.isString(p[1])) {
                                    r = "the property at index " + c + " has to be an array with two elements - a number and a string.";
                                    break
                                }
                            } else r = "the property has to be an array where each item is an array with two elements - a number and a string.";
                            break;
                        case 14:
                            e instanceof CanvasGradient || (o = "CanvasGradient");
                            break;
                        case 12:
                            if (t.Helpers.isArray(e) && e.length === i.baseTypes.length)for (var d = 0; d < e.length; d++) {
                                var f = this.ensurePropertyType(e[d], i.baseTypes[d], n + "[" + d + "]", s);
                                if (!f)return null;
                                e[d] = f.value
                            } else r = "the property expects an array with exactly " + i.baseTypes.length + " elements.";
                            break;
                        case 7:
                            for (var m = !1, g = 0; g < i.baseTypes.length; g++) {
                                var y = this.ensurePropertyType(e, i.baseTypes[g], n, !0);
                                if (y) {
                                    a = y.value, h = y.configuration || i.baseTypes[g], m = !0;
                                    break
                                }
                            }
                            m || (r = "the the given value does not match any constituent of the union type. Please review the documentation on the correct type.");
                            break;
                        case 5:
                        case 8:
                            t.Helpers.isObjectOrArray(e) || (o = "Object");
                            break;
                        case 9:
                            null !== e && e !== !0 && e !== !1 && (o = "Boolean");
                            break;
                        case 10:
                            break;
                        default:
                            throw new Error("Unsupported data type: " + i.type)
                    }
                    return null !== o && null === r && (r = "the given value '" + e + "' is not of type '" + o + "'."), null !== r ? (s || t.Helpers.error("Cannot update settings value '" + n + "' because " + r, e), null) : (void 0 !== a && (e = a), {
                            value: e,
                            configuration: h
                        })
                }, e.findPropertyConfiguration = function (e, i, n) {
                    var s = i[e];
                    return void 0 !== s ? s : (t.Helpers.warn("Cannot update settings value '" + n + "' because such property does not exist.", null, !0), null)
                }, e._ignoringCtor = 0, e
            }();
            t.SettingsHelper = e
        }(e = t.Base || (t.Base = {}))
    }(e = t.Internal || (t.Internal = {}))
}(ZoomCharts || (ZoomCharts = {}));
var ZoomCharts;
!function (t) {
    var e;
    !function (t) {
        var e;
        !function (e) {
            var i = function () {
                function t(t) {
                    this._mapping = null, this._computedDataMap = {}, this._initializing = !0, this.container = null, this.theme = null, this.assetsUrlBase = "", this.area = new r, this.data = [], this.advanced = new l, this.events = new n, this.interaction = new h, this.localization = new s, this.toolbar = new e.SettingsToolbar, this.title = new e.SettingsTitle, this.credits = new e.SettingsCredits, this.legend = new e.SettingsLegend, this._mapping = t
                }

                return t.prototype.applyGlobalCustomizations = function () {
                    if (null !== t.perBrowserCustomizations) {
                        var i = e.Helpers.detectBrowser(), n = t.perBrowserCustomizations[i];
                        n && e.SettingsHelper.updateRecursive(this, n, this._mapping, {})
                    }
                    this.theme && e.SettingsHelper.updateRecursive(this, this.theme, this._mapping, {})
                }, t.prototype.applyCompatibility = function (t, i, n) {
                    n = null == n ? "" : n + ".";
                    for (var s = 0; s < i.length; s++) {
                        var o = i[s], r = o.from, a = e.Helpers.getProp(t, r, !!o.to && !o.filter);
                        if (void 0 !== a && (!o.filter || o.filter(a)))if (o.to) o.transform && (a = o.transform(a)), e.Helpers.extendDeep(t, e.Helpers.wrapValue(a, o.to)), e.Helpers.warn("Setting `" + n + r + "` is being deprecated. Compatibility layer moved the value automatically to `" + n + o.to + "`. Please update the configuration to avoid using the obsolete property.", null, !0); else {
                            var h = o.alternativeAsWarning, l = "Setting `" + n + r + "` " + (h ? "is being deprecated" : "is no longer supported") + ". Consider using `" + o.alternative + "` instead.";
                            h ? e.Helpers.warn(l, null, !0) : e.Helpers.error(l)
                        }
                    }
                }, t.prototype.apply = function (t) {
                    this.applyCompatibility(t, [{
                        from: "width",
                        to: "area.width"
                    }, {from: "height", to: "area.height"}, {
                        from: "minHeight",
                        to: "area.minHeight"
                    }, {from: "maxHeight", to: "area.maxHeight"}, {
                        from: "minWidth",
                        to: "area.minWidth"
                    }, {from: "maxWidth", to: "area.maxWidth"}]);
                    var i = {};
                    if (this._initializing) this.applyGlobalCustomizations(), t || (t = {}), t.data || (t.data = [{}]); else if (!t)return i;
                    if (t.data) {
                        e.Helpers.isArray(t.data) || (t.data = [t.data]);
                        for (var n = 0; n < t.data.length; n++) {
                            var s = t.data[n];
                            s.id || (s.name ? (e.Helpers.warn("The property `name` in the data object configuration is deprecated in favor of `id` property. Please update the configuration to avoid using the obsolete property.", null, !0), s.id = s.name, delete s.name) : s.id = 0 === n ? "default" : "default-" + n.toString(10))
                        }
                    }
                    if (e.SettingsHelper.updateRecursive(this, t.theme, this._mapping, i), e.SettingsHelper.updateRecursive(this, t, this._mapping, i), i.data || this._initializing) {
                        this._computedDataMap = {};
                        for (var n = 0; n < this.data.length; n++) {
                            var o = this.data[n];
                            this._computedDataMap[o.id] = o
                        }
                    }
                    return i
                }, t.perBrowserCustomizations = null, t
            }();
            e.Settings = i;
            var n = function () {
                function t() {
                    this.onError = null, this.onSettingsChange = null, this.onClick = null, this.onDoubleClick = null, this.onTripleClick = null, this.onRightClick = null, this.onHoverChange = null, this.onSelectionChange = null, this.onChartUpdate = null, this.onPositionChange = null, this.chartUpdateDelay = 0
                }

                return t
            }();
            e.SettingsEvents = n;
            var s = function () {
                function t() {
                    this.toolbar = new o, this.loadingLabel = "Loading...", this.closeButton = "Close", this.dataRequestFailed = "Data request failed"
                }

                return t
            }();
            e.SettingsLocalization = s;
            var o = function () {
                function t() {
                    this.backButton = "Back", this.backTitle = "Move one step back in navigation", this.fullscreenButton = "Fullscreen", this.fullscreenTitle = "Toggle fullscreen mode", this.zoomoutButton = "Zoom-out", this.zoomoutTitle = "Zoom out", this.exportButton = "Export", this.exportTitle = "Export Data", this.exportJpeg = "For Office and Web (jpeg)", this.exportPNG = "For Photoshop (png)", this.exportPDF = "For Printer (pdf)", this.exportCSV = "Spreadsheet (csv)", this.exportXLS = "Spreadsheet (xls)"
                }

                return t
            }();
            e.SettingsLocalizationToolbar = o;
            var r = function () {
                function t() {
                    this.defaultHeight = 300, this.width = null, this.height = null, this.top = null, this.left = null, this.minHeight = 165, this.maxHeight = 2e4, this.minWidth = 100, this.maxWidth = 2e4, this.style = new a
                }

                return t
            }();
            e.SettingsArea = r;
            var a = function () {
                function t() {
                    this.fillColor = "transparent", this.image = null, this.overlayColor = null
                }

                return t
            }();
            e.SettingsAreaStyle = a;
            var h = function () {
                function t() {
                    this.resizing = new e.SettingsResizer
                }

                return t
            }();
            e.SettingsInteraction = h;
            var l = function () {
                function e() {
                    this.labelCache = !0, this.highDPI = !0, this.pointer = new u, this.useAnimationFrame = !0, this.showTouches = !1, this.showFPS = !1, this.showTimestamp = !1, this.logging = !1, this.style = new c, this.maxCanvasWidth = 2047, this.maxCanvasHeight = 2047, this.themeCSSClass = "DVSL-round", this.assets = ["assets://zc.css"], this.builtinAssets = {
                        "logo-supported-by": t.Resources.LicenseBannerSupportedBy,
                        "logo-development": t.Resources.LicenseBannerDevelopment
                    }, this.pdfExportAssets = ["assets://jspdf/jspdf.complete.js"], this.exportProxyURL = "https://zoomcharts.com/developers/export"
                }

                return e
            }();
            e.SettingsAdvanced = l;
            var u = function () {
                function t() {
                    this.noClickOnDoubleClick = !0, this.clickSensitivity = 10, this.doubleClickSensitivity = 20, this.doubleClickTimeout = 300, this.longPressTimeout = 500, this.longPressSensitivity = 10, this.speedAveragingPeriod = 200
                }

                return t
            }();
            e.SettingsAdvancedPointer = u;
            var c = function () {
                function t() {
                    this.messageTextStyle = {
                        fillColor: "#000",
                        font: "15px Arial"
                    }, this.loadingArcStyle = {
                        r: 10,
                        lineColor: "#444",
                        lineWidth: 1,
                        location: "center"
                    }
                }

                return t
            }();
            e.SettingsAdvancedStyle = c
        }(e = t.Base || (t.Base = {}))
    }(e = t.Internal || (t.Internal = {}))
}(ZoomCharts || (ZoomCharts = {}));
var ZoomCharts;
!function (t) {
    var e;
    !function (t) {
        var e;
        !function (t) {
            var e = function () {
                function e(t, e, i, n) {
                    1 / 0 !== t && t > i ? (this.x1 = t, this.x0 = i) : (this.x1 = i, this.x0 = t), 1 / 0 !== e && e > n ? (this.y1 = e, this.y0 = n) : (this.y1 = n, this.y0 = e)
                }

                return e.createEmpty = function () {
                    return new e(1 / 0, 1 / 0, -1 / 0, -1 / 0)
                }, e.prototype.isEmpty = function () {
                    return this.x0 >= this.x1 || this.y0 >= this.y1
                }, e.prototype.clone = function () {
                    return new e(this.x0, this.y0, this.x1, this.y1)
                }, e.prototype.w = function () {
                    return this.x1 - this.x0
                }, e.prototype.h = function () {
                    return this.y1 - this.y0
                }, e.prototype.equals = function (t) {
                    return this.x0 === t.x0 && this.x1 === t.x1 && this.y0 === t.y0 && this.y1 === t.y1
                }, e.prototype.inflate = function (t) {
                    var e = (this.x0 + this.x1) / 2, i = (this.y0 + this.y1) / 2;
                    return this.x0 = (this.x0 - e) * t + e, this.x1 = (this.x1 - e) * t + e, this.y0 = (this.y0 - i) * t + i, this.y1 = (this.y1 - i) * t + i, this
                }, e.prototype.clip = function (t) {
                    return this.x0 = Math.max(this.x0, t.x0), this.x1 = Math.min(this.x1, t.x1), this.y0 = Math.max(this.y0, t.y0), this.y1 = Math.min(this.y1, t.y1), this
                }, e.prototype.isInside = function (t) {
                    return this.x0 >= t.x0 && this.x1 <= t.x1 && this.y0 >= t.y0 && this.y1 <= t.y1
                }, e.prototype.isOutside = function (t) {
                    return this.x0 > t.x1 || this.x1 < t.x0 || this.y0 > t.y1 || this.y1 < t.y0
                }, e.prototype.overlapsRect = function (t, e, i, n) {
                    return t < this.x1 && i > this.x0 && e < this.y1 && n > this.y0
                }, e.prototype.intersectsSegment = function (e, i, n, s) {
                    return null != t.Geometry.clipSegmentToRect(e, i, n - e, s - i, this.x0, this.y0, this.x1, this.y1)
                }, e.prototype.area = function () {
                    return (this.x1 - this.x0) * (this.y1 - this.y0)
                }, e.prototype.toString = function () {
                    return this.x0 + "," + this.y0 + ", " + this.x1 + ", " + this.y1
                }, e.prototype.addPoint = function (t, e) {
                    return this.x0 = Math.min(this.x0, t), this.x1 = Math.max(this.x1, t), this.y0 = Math.min(this.y0, e), this.y1 = Math.max(this.y1, e), this
                }, e.prototype.addBounds = function (t, e, i, n) {
                    return this.x0 = Math.min(this.x0, t), this.x1 = Math.max(this.x1, i), this.y0 = Math.min(this.y0, e), this.y1 = Math.max(this.y1, n), this
                }, e.prototype.addRect = function (t) {
                    return this.x0 = Math.min(this.x0, t.x0), this.x1 = Math.max(this.x1, t.x1), this.y0 = Math.min(this.y0, t.y0), this.y1 = Math.max(this.y1, t.y1), this
                }, e.prototype.moveBy = function (t, e) {
                    return this.x0 += t, this.x1 += t, this.y0 += e, this.y1 += e, this
                }, e.prototype.containsPoint = function (t, e) {
                    return t >= this.x0 && t < this.x1 && e >= this.y0 && e < this.y1
                }, e.prototype.addLine = function (t) {
                    for (var e = 0; e <= t.length - 2; e += 2)this.addPoint(t[e], t[e + 1]);
                    return this
                }, e.prototype.translate = function (t, e, i, n) {
                    return this.x0 = this.x0 * t + e, this.x1 = this.x1 * t + e, this.y0 = this.y0 * i + n, this.y1 = this.y1 * i + n, this
                }, e.prototype.overlaps = function (t) {
                    return this.x0 < t.x1 && this.x1 > t.x0 && this.y0 < t.y1 && this.y1 > t.y0
                }, e
            }();
            t.Rect = e
        }(e = t.Base || (t.Base = {}))
    }(e = t.Internal || (t.Internal = {}))
}(ZoomCharts || (ZoomCharts = {}));
var ZoomCharts;
!function (t) {
    var e;
    !function (t) {
        var e;
        !function (t) {
            var e = function () {
                function t(t, e) {
                    this.msg = t, this.pri = e
                }

                return t
            }(), i = function () {
                function t() {
                    this.settings = null, this.assetsLoader = null, this.isActive = !0, this.mainData = null, this.chartLeft = 0, this.chartTop = 0, this.chartWidth = 1, this.chartHeight = 1, this.x0 = 0, this.y0 = 0, this.height = 0, this.width = 0, this.leftMargin = 0, this.rightMargin = 0, this.topMargin = 0, this.bottomMargin = 0, this.loading = !0, this.messages = {}, this.selection = [], this.backStack = []
                }

                return t.prototype.setMessage = function (t, i, n) {
                    void 0 === n && (n = 0);
                    var s;
                    return i ? (s = !this.messages[t] || this.messages[t].msg !== i || this.messages[t].pri !== n, this.messages[t] = new e(i, n)) : (s = this.messages.hasOwnProperty(t), delete this.messages[t]), s
                }, t.prototype.getMessage = function () {
                    var t = null, e = 0;
                    for (var i in this.messages) {
                        var n = this.messages[i];
                        n.pri > e && (t = n.msg, e = n.pri)
                    }
                    return t
                }, t.prototype.pushBack = function (t) {
                    this.backStack.push(t), this.backStack.length > 1e3 && (this.backStack = this.backStack.slice(200))
                }, t
            }();
            t.Scene = i
        }(e = t.Base || (t.Base = {}))
    }(e = t.Internal || (t.Internal = {}))
}(ZoomCharts || (ZoomCharts = {}));
var ZoomCharts;
!function (t) {
    var e;
    !function (t) {
        var e;
        !function (t) {
            var e = 2 * Math.PI, i = function () {
                function i() {
                }

                return i.distanceToSegmentSq = function (t, e, i, n, s, o) {
                    var r = s - t, a = o - e, h = i - t, l = n - e, u = r * h + a * l, c = h * h + l * l, p = -1;
                    0 !== c && (p = u / c);
                    var d, f;
                    0 > p ? (d = t, f = e) : p > 1 ? (d = i, f = n) : (d = t + p * h, f = e + p * l);
                    var m = s - d, g = o - f;
                    return m * m + g * g
                }, i.rayIntersectsSegment = function (t, e, i, n, s, o, r, a) {
                    var h = 1 / 0, l = r - s, u = a - o, c = i * u - n * l;
                    if (0 !== c) {
                        var p, d = (e * l - t * u + s * u - o * l) / c;
                        p = Math.abs(l) > Math.abs(u) ? (t + i * d - s) / l : (e + n * d - o) / u, p >= 0 && 1 >= p && d >= 0 && (h = d)
                    }
                    return h
                }, i.lineIntersectsSegment = function (t, e, i, n, s, o, r, a) {
                    var h = 1 / 0, l = r - s, u = a - o, c = i * u - n * l;
                    if (0 !== c) {
                        var p, d = (e * l - t * u + s * u - o * l) / c;
                        p = Math.abs(l) > Math.abs(u) ? (t + i * d - s) / l : (e + n * d - o) / u, p >= 0 && 1 >= p && (h = d)
                    }
                    return h
                }, i.lineIntersectsLine = function (t, e, i, n, s, o, r, a) {
                    var h = 1 / 0, l = i - t, u = n - e, c = r - s, p = a - o, d = l * p - u * c;
                    if (0 !== d) {
                        var f, m = (e * c - t * p + s * p - o * c) / d;
                        f = Math.abs(c) > Math.abs(p) ? (t + l * m - s) / c : (e + u * m - o) / p, h = m
                    }
                    return h
                }, i.rayIntersectsCircle = function (t, e, i, n, s) {
                    var o = i * i + n * n, r = t * i + e * n, a = t * t + e * e - s * s, h = r * r - o * a, l = 1 / 0;
                    if (h > 0) {
                        h = Math.sqrt(h);
                        var u = (-r - h) / o, c = (-r + h) / o;
                        u >= 0 && (l = u), c >= 0 && (l = Math.min(l, c))
                    }
                    return l
                }, i.clipSegmentToRect = function (t, e, i, n, s, o, r, a) {
                    var h = 0, l = 1;
                    if (0 !== n) {
                        var u = 1 / n, c = (o - e) * u, p = (a - e) * u;
                        if (h = Math.min(c, p), l = Math.max(c, p), h > 1 || 0 > l)return null
                    } else if (o > e || e > a)return null;
                    if (0 !== i) {
                        var d = 1 / i, f = (s - t) * d, m = (r - t) * d, g = Math.min(f, m), y = Math.max(f, m);
                        if (h = Math.max(h, g), l = Math.min(l, y), h > 1 || 0 > l || h > l)return null
                    } else if (s > t || t > r)return null;
                    return [h, l]
                }, i.rayIntersectsCircleOuter = function (t, e, i, n, s) {
                    var o = i * i + n * n, r = t * i + e * n, a = t * t + e * e - s * s, h = r * r - o * a;
                    return h = Math.sqrt(h), Math.max((-r + h) / o, (-r - h) / o)
                }, i.lineTouchingCircle = function (t, e, i, n, s) {
                    var o = Math.sqrt(t * t + e * e);
                    if (!(o > s))return null;
                    var r = Math.sqrt(o * o - s * s), a = s * r / o, h = s * s / o, l = t / o, u = e / o, c = t * n - e * i;
                    return 0 > c && (a = -a), {x: l * h - u * a, y: u * h + l * a}
                }, i.distanceToPolygonSq = function (t, e, n) {
                    if (i.isInsidePolygon(t, e, n))return 0;
                    for (var s = 1 / 0, o = 0; o < n.length; o++)for (var r = n[o], a = r.length, h = r[a - 2], l = r[a - 1], u = 0; a - 2 >= u; u += 2) {
                        var c = r[u], p = r[u + 1];
                        s = Math.min(s, i.distanceToSegmentSq(h, l, c, p, t, e)), h = c, l = p
                    }
                    return s
                }, i.distanceToLinesSq = function (t, e, n) {
                    for (var s = 1 / 0, o = 0; o < n.length; o++) {
                        var r = n[o], a = r.length;
                        if (2 === a) s = Math.min(s, (t - r[0]) * (t - r[0]) + (e - r[1]) * (e - r[1])); else if (a > 2)for (var h = r[0], l = r[1], u = 2; a - 2 >= u; u += 2) {
                            var c = r[u], p = r[u + 1];
                            s = Math.min(s, i.distanceToSegmentSq(h, l, c, p, t, e)), h = c, l = p
                        }
                    }
                    return s
                }, i.isInsidePolygon = function (t, e, i) {
                    for (var n = !1, s = 0; s < i.length; s++)for (var o = i[s], r = o.length, a = o[r - 2], h = o[r - 1], l = 0; r - 2 >= l; l += 2) {
                        var u = o[l], c = o[l + 1];
                        c > e != h > e && (u - a) * (e - h) / (c - h) + a > t && (n = !n), a = u, h = c
                    }
                    return n
                }, i.distanceToBalloon = function (e, n, s, o) {
                    var r;
                    if (e >= n) r = e; else if (0 === o) r = n; else {
                        var a = t.Helpers.sign(o);
                        r = e / o * a, Math.abs(s * r) > n - e && (r = i.rayIntersectsCircleOuter(-(n - e), 0, Math.abs(s), o, e))
                    }
                    return r
                }, i.distanceToRect = function (e, i, n, s, o, r, a) {
                    void 0 === a && (a = !1);
                    var h, l;
                    n instanceof t.Rect ? (a = s, h = n.x0, l = n.y0, o = n.x1, r = n.y1) : (h = n, l = s);
                    var u, c;
                    return u = h > e ? h - e : e > o ? e - o : 0, c = l > i ? l - i : i > r ? i - r : 0, a ? u * u + c * c : Math.sqrt(u * u + c * c)
                }, i.clipSegmentToBounds = function (t, e, n, s, o, r, a, h, l, u) {
                    var c = Math.max(o, r), p = n - t, d = s - e, f = i.clipSegmentToRect(t, e, p, d, a - c, h - c, l + c, u + c);
                    if (null === f)return null;
                    var m = Math.max(0, f[0]), g = Math.min(1, f[1]);
                    return [t + p * m, e + d * m, t + p * g, e + d * g]
                }, i.computeBoundsSize = function (t) {
                    for (var e = 1 / 0, i = -1 / 0, n = 1 / 0, s = -1 / 0, o = t.length, r = 0; o > r; r += 2) {
                        var a = t[r], h = t[r + 1];
                        e = Math.min(a, e), i = Math.max(a, i), n = Math.min(h, n), s = Math.max(h, s)
                    }
                    return Math.max(i - e, s - n)
                }, i.simplify = function (t, e) {
                    if (!e || !t.length)return t;
                    var n = e * e;
                    return t = i.reducePoints(t, n), t = i.simplifyDP(t, n)
                }, i.simplifyDP = function (t, e) {
                    var n, s = t.length;
                    n = "undefined" != typeof Uint8Array ? new Uint8Array(s) : new Array(s), n[0] = n[s - 2] = 1, i.simplifyDPStep(t, n, e, 0, s - 2);
                    for (var o = [], r = 0; s > r; r += 2)n[r] && (o.push(t[r]), o.push(t[r + 1]));
                    return o
                }, i.simplifyDPStep = function (t, e, n, s, o) {
                    for (var r = 0, a = 0, h = t[s], l = t[s + 1], u = t[o], c = t[o + 1], p = s + 2; o - 2 >= p; p += 2) {
                        var d = i.distanceToSegmentSq(h, l, u, c, t[p], t[p + 1]);
                        d > r && (a = p, r = d)
                    }
                    r > n && (e[a] = 1, i.simplifyDPStep(t, e, n, s, a), i.simplifyDPStep(t, e, n, a, o))
                }, i.reducePoints = function (t, e) {
                    for (var i, n, s = t[0], o = t[1], r = [s, o], a = t.length, h = 2; a > h; h += 2)i = t[h], n = t[h + 1], (s - i) * (s - i) + (o - n) * (o - n) > e && (r.push(i), r.push(n), s = i, o = n);
                    return s !== i && o !== n && r.push(i, n), r
                }, i.transformPolyline = function (t, e, i, n, s) {
                    for (var o = [], r = 0; r < t.length; r += 2)o.push(t[r] * e + i, t[r + 1] * n + s);
                    return o
                }, i.outlinePolylineByVectors = function (e, i, n) {
                    for (var s = [], o = [], r = e.length - 2, a = 0; r > a; a += 2) {
                        var h = i[a] * n, l = i[a + 1] * n, u = e[a] + h, c = e[a + 1] + l, p = e[a + 2] + h, d = e[a + 3] + l;
                        s.push(u, c, p, d)
                    }
                    o = s.slice(0, 2), r = s.length - 4;
                    for (var a = 0; r > a; a += 4) {
                        var f = t.Geometry.lineIntersectsLine(s[a], s[a + 1], s[a + 2], s[a + 3], s[a + 4], s[a + 5], s[a + 6], s[a + 7]);
                        1 / 0 === f ? o.push(s[a + 2], s[a + 3]) : o.push(s[a] + (s[a + 2] - s[a]) * f, s[a + 1] + (s[a + 3] - s[a + 1]) * f)
                    }
                    return o.push.apply(o, s.slice(-2)), o
                }, i.calculatePolyArea = function (t) {
                    for (var e = 0, i = t, n = t.length - 2, s = 0; n > s; s += 2)e += i[s] * i[s + 3] - i[s + 2] * i[s + 1];
                    return e / 2
                }, i.calculatePolyCentroid = function (t, e) {
                    var i, n = 0, s = 0, o = t.length - 2;
                    e *= 6;
                    for (var r = 0; o > r; r += 2)i = t[r] * t[r + 3] - t[r + 2] * t[r + 1], n += (t[r] + t[r + 2]) * i, s += (t[r + 1] + t[r + 3]) * i;
                    return {x: n / e, y: s / e}
                }, i.normalizeAngle = function (t) {
                    return 0 > t ? (t %= e, t += e) : t >= e && (t %= e), t
                }, i.sectorBetweenAngles = function (t, i) {
                    for (; t > i;)i += e;
                    return i - t
                }, i.subtractAngle = function (t, i) {
                    var n = t - i;
                    return n > Math.PI ? n -= e : n < -Math.PI && (n += e), n
                }, i.rotateVector = function (t, e, i, n) {
                    return {x: t * n - e * i, y: t * i + e * n}
                }, i
            }();
            t.Geometry = i
        }(e = t.Base || (t.Base = {}))
    }(e = t.Internal || (t.Internal = {}))
}(ZoomCharts || (ZoomCharts = {}));
var ZoomCharts;
!function (t) {
    var e;
    !function (t) {
        var e;
        !function (e) {
            var i = function (i) {
                function n() {
                    i.call(this), this.centerX = 0, this.centerY = 0, this.zoom = 1, this.hoverNode = null, this.hoverLink = null, this.hoverItem = null, this.lastClickedNode = null, this.autoZoomMode = !1, this.layoutActive = !1
                }

                return __extends(n, i), n.prototype.xyInChart = function (t, e) {
                    return t >= this.x0 && t < this.x0 + this.width && e >= this.y0 && e < this.y0 + this.height
                }, n.prototype.toDisplay = function (t, e) {
                    return {
                        x: (t - this.centerX) * this.zoom + this.x0 + .5 * this.width,
                        y: (e - this.centerY) * this.zoom + this.y0 + .5 * this.height
                    }
                }, n.prototype.fromDisplay = function (t, e) {
                    return {
                        x: (t - this.x0 - .5 * this.width) / this.zoom + this.centerX,
                        y: (e - this.y0 - .5 * this.height) / this.zoom + this.centerY
                    }
                }, n.prototype.toDisplayTransform = function () {
                    return {
                        xm: this.zoom,
                        xa: this.x0 + .5 * this.width - this.centerX * this.zoom,
                        ym: this.zoom,
                        ya: this.y0 + .5 * this.height - this.centerY * this.zoom
                    }
                }, n.prototype.objectRemoved = function (e) {
                    t.Base.Helpers.removeFromArray(this.selection, e) && (e.selected = !1), (this.hoverNode === e || this.hoverLink === e) && this.setActiveObject(null, null)
                }, n.prototype.addToSelection = function (t) {
                    return this.selection.indexOf(t) < 0 ? (this.selection.push(t), t.layer.touchNodeOrLink(t), t.selected = !0, !0) : !1
                }, n.prototype.removeFromSelection = function (e) {
                    return t.Base.Helpers.removeFromArray(this.selection, e) ? (e.selected = !1, e.layer.touchNodeOrLink(e), !0) : !1
                }, n.prototype.setSelection = function (t) {
                    for (var e = 0, i = !1, n = 0; n < t.length; n++) {
                        for (var s = t[n]; e < this.selection.length && this.selection[e] !== s;) {
                            var o = this.selection[e];
                            o.selected = !1, o.layer.touchNodeOrLink(o), i = !0, e += 1
                        }
                        e < this.selection.length ? e += 1 : (s.selected = !0, s.layer.touchNodeOrLink(s), i = !0)
                    }
                    for (; e < this.selection.length;) {
                        var o = this.selection[e];
                        o.selected = !1, o.layer.touchNodeOrLink(o), i = !0, e += 1
                    }
                    return this.selection = t, i
                }, n.prototype.setActiveObject = function (t, i) {
                    if (this.hoverNode) {
                        this.hoverNode.layer.touchNode(this.hoverNode);
                        for (var n = 0; n < this.hoverNode.links.length; n++) {
                            var s = this.hoverNode.links[n];
                            s.layer.touchLink(s)
                        }
                        this.hoverNode.hovered = !1
                    }
                    if (this.hoverLink && (this.hoverLink.layer.touchLink(this.hoverLink), this.hoverLink.from.layer.touchNode(this.hoverLink.from), this.hoverLink.to.layer.touchNode(this.hoverLink.to), this.hoverLink.hovered = !1), this.hoverNode = null, this.hoverLink = null, this.hoverItem = i, t instanceof e.Node) {
                        this.hoverNode = t, t.hovered = !0, this.hoverNode.layer.touchNode(this.hoverNode);
                        for (var n = 0; n < this.hoverNode.links.length; n++) {
                            var s = this.hoverNode.links[n];
                            s.layer.touchLink(s)
                        }
                    } else if (t instanceof e.Link) this.hoverLink = t, t.hovered = !0, this.hoverLink.layer.touchLink(this.hoverLink), this.hoverLink.from.layer.touchNode(this.hoverLink.from), this.hoverLink.to.layer.touchNode(this.hoverLink.to); else if (null !== t)throw"scene.setActiveObject invalid active object type " + t
                }, n.prototype.getVisibleBounds = function () {
                    var e = this.fromDisplay(this.x0, this.y0), i = e.x, n = e.y;
                    e = this.fromDisplay(this.x0 + this.width, this.y0 + this.height);
                    var s = e.x, o = e.y;
                    return new t.Base.Rect(i, n, s, o)
                }, n
            }(t.Base.Scene);
            e.Scene = i
        }(e = t.ItemsChart || (t.ItemsChart = {}))
    }(e = t.Internal || (t.Internal = {}))
}(ZoomCharts || (ZoomCharts = {}));
var ZoomCharts;
!function (t) {
    var e;
    !function (t) {
        var e;
        !function (t) {
            var e = function () {
                function e(t) {
                    this.scene = t, this.bounds = null
                }

                return e.prototype.setBounds = function (e, i, n, s) {
                    this.bounds = new t.Rect(e, i, n, s)
                }, e.prototype.paint = function () {
                }, e.prototype.findObjectAt = function () {
                    return null
                }, e.prototype.remove = function () {
                }, e
            }();
            t.Layer = e
        }(e = t.Base || (t.Base = {}))
    }(e = t.Internal || (t.Internal = {}))
}(ZoomCharts || (ZoomCharts = {}));
var ZoomCharts;
!function (t) {
    var e;
    !function (t) {
        var e;
        !function (e) {
            var i = 2 * Math.PI, n = function () {
                function e(t, e) {
                    this.node = t, this.nodesLayer = e
                }

                return e.prototype.postProcess = function (e, i, n) {
                    var s = this.node;
                    s.targetHWidth = s.targetHHeight, s.bounds = new t.Base.Rect(-s.targetHHeight, -s.targetHHeight, s.targetHHeight, s.targetHHeight), this.sizeScale = s.targetHHeight / e.nodeLabelScaleBase, this.postProcessLabel(i, n)
                }, e.prototype.postProcessLabel = function (e, i) {
                    var n, s, o, r = this.node;
                    if (null != r.label) {
                        var a = r.label.toString();
                        if (0 === a.length) this.currentLabel = null; else {
                            var h = new t.Base.Label(r.labelStyle, t.Base.SettingsMapping.ItemsChartSettingsItemsLayerLabelStyle);
                            h.text = a, i.measure(e, h), o = h.scaleWithSize ? this.sizeScale : (h.scaleWithZoom, 1), n = 0, s = r.targetHHeight + h.hheight * o * .8, r.outerBounds.addBounds(n - h.hwidth * o, s - h.hheight * o, n + h.hwidth * o, s + h.hheight * o), this.currentLabel = h
                        }
                    }
                }, e.prototype.getAnchor = function () {
                    return {x: 0, y: 0}
                }, e.prototype.adaptToViewport = function (t, e, i, n, s) {
                    var o = this.node;
                    this.x = o.x * t + e, this.y = o.y * i + n, this.r = o.hHeight * s, this.w = o.hWidth * s, this.zoom = s
                }, e.prototype.isInViewport = function (t, e, i, n, s) {
                    var o = this.node.outerBounds;
                    return this.x + o.x0 * s < e && this.x + o.x1 * s > t && this.y + o.y0 * s < n && this.y + o.y1 * s > i
                }, e.prototype.paintSelection = function (t, e, i) {
                    var n = this.r * (1 + e) + i;
                    t.moveTo(this.x, this.y), t.arc(this.x, this.y, n, 0, 2 * Math.PI), t.closePath()
                }, e.prototype.paint = function (t, e, i) {
                    this.paintBasicShape(t), i && (this.image = this.nodesLayer.getNodeImage(this.node), this.paintDetails(t, e))
                }, e.prototype.paintBasicShape = function (e) {
                    var n = t.Base.Graphics.beginStrokeAndFill(e, this.node);
                    if (this.r !== this.w) {
                        var s = this.x + this.w - this.r;
                        n.moveTo(s, this.y - this.r), n.arc(s, this.y, this.r, -Math.PI / 2, Math.PI / 2, !1), s = this.x - this.w + this.r, n.lineTo(s, this.y + this.r), n.arc(s, this.y, this.r, .5 * Math.PI, 1.5 * Math.PI, !1), n.closePath()
                    } else n.moveTo(this.x + this.r, this.y), n.arc(this.x, this.y, this.r, 0, i, !1);
                    t.Base.Graphics.endStrokeAndFill(e, n, this.node)
                }, e.prototype.paintDetails = function (t, e) {
                    this.image && this.basicPaintImage(t), this.paintLabel(t, e)
                }, e.prototype.basicPaintImage = function (e, i) {
                    if (void 0 === i && (i = 1), this.image) {
                        var n, s, o = 0, r = 0;
                        if (this.node.imageSlicing) {
                            var a = this.node.imageSlicing;
                            o = a[0], r = a[1], n = a[2], s = a[3]
                        } else n = this.image.width, s = this.image.height;
                        t.Base.Graphics.drawImageInSquare(e, this.image, o, r, n, s, this.x - this.w + this.r, this.y, this.r * i)
                    }
                }, e.prototype.paintLabel = function (e, i) {
                    var n = this.nodesLayer.style.nodeLabelScaleBase;
                    if (this.node.hovered && (n = t.Base.Helpers.toleranceMin(n, this.r, .9)), this.currentLabel) {
                        var s = this.r / n, o = this.currentLabel, r = 1;
                        if (this.node.labelStyle.scaleWithSize ? r = s : this.node.labelStyle.scaleWithZoom && (r = this.zoom), i.measure(e, o), o.hheight > 1.5) {
                            var a = this.getLabelPosition(o, r);
                            i.paint(e, a.x, a.y, r, o)
                        }
                    }
                }, e.prototype.getLabelPosition = function (t, e) {
                    return {x: this.x, y: this.y + this.r + t.hheight * e * .8}
                }, e.prototype.distanceToEdge = function (t) {
                    return t
                }, e.prototype.hitTest = function (e, i, n, s) {
                    var o, r = this.node, a = r.renderHheight * n, h = r.renderHwidth * n, l = r.x, u = r.y;
                    if (h > a) {
                        var c = h - a;
                        o = t.Base.Geometry.distanceToSegmentSq(l - c, u, l + c, u, e, i)
                    } else o = (e - l) * (e - l) + (i - u) * (i - u);
                    var p = (a + s) * (a + s);
                    if (p > o) {
                        var d = a * a;
                        return d > o ? 0 : Math.sqrt(o) - a
                    }
                    return s
                }, e
            }();
            e.Shape = n
        }(e = t.ItemsChart || (t.ItemsChart = {}))
    }(e = t.Internal || (t.Internal = {}))
}(ZoomCharts || (ZoomCharts = {}));
var ZoomCharts;
!function (t) {
    var e;
    !function (t) {
        var e;
        !function (e) {
            var i = function (e) {
                function i(t, i) {
                    e.call(this, t, i), this.validate()
                }

                return __extends(i, e), i.prototype.postProcess = function (e, i) {
                    var n = this.node.customShape.onUpdate.call(this.node, i, this.node.radius), s = new t.Base.Rect(n.bounds[0], n.bounds[1], n.bounds[2], n.bounds[3]);
                    this.node.targetHWidth = n.HWidth, this.node.targetHHeight = n.HHeight, this.node.bounds = s, this.node.outerBounds = s.clone(), n.anchor && (this.node.shapeAnchorX = n.anchor[0], this.node.shapeAnchorY = n.anchor[1])
                }, i.prototype.paint = function (t, e, i) {
                    var n = this.nodesLayer.getNodeImage(this.node);
                    this.node.customShape.paint.call(this.node, t, this.x, this.y, this.r, this.w, n, i)
                }, i.prototype.paintSelection = function (t, i, n) {
                    this.node.customShape.paintSelection ? this.node.customShape.paintSelection.call(this.node, t, this.x, this.y, this.r, this.w) : e.prototype.paintSelection.call(this, t, i, n)
                }, i.prototype.distanceToEdge = function (t, i, n, s) {
                    return "function" == typeof this.node.customShape.distanceToEdge ? this.node.customShape.distanceToEdge.call(this.node, t, i, n, s) : e.prototype.distanceToEdge.call(this, t, i, n, s)
                }, i.prototype.hitTest = function (t, i, n, s) {
                    return "function" == typeof this.node.customShape.hitTest ? this.node.customShape.hitTest.call(this.node, t, i, n, s) : e.prototype.hitTest.call(this, t, i, n, s)
                }, i.prototype.validate = function () {
                    var t = this.node;
                    "object" != typeof t.customShape ? console.error('If the display of an object is "customShape", it\'s mandatory to supply the rendering methods for the custom shape') : ("function" != typeof t.customShape.onUpdate && console.error("onUpdate function was not supplied for the custom shape"), "function" != typeof t.customShape.paint && console.error("paint function was not supplied for the custom shape"))
                }, i
            }(e.Shape);
            e.CustomShape = i
        }(e = t.ItemsChart || (t.ItemsChart = {}))
    }(e = t.Internal || (t.Internal = {}))
}(ZoomCharts || (ZoomCharts = {}));
var ZoomCharts;
!function (t) {
    var e;
    !function (t) {
        var e;
        !function (e) {
            !function (t) {
                t[t.Floating = 0] = "Floating", t[t.Scene = 1] = "Scene", t[t.Fixed = 2] = "Fixed"
            }(e.NodeAnchorMode || (e.NodeAnchorMode = {}));
            var i = e.NodeAnchorMode, n = function () {
                function t() {
                    this.id = null, this.data = null, this.added = !1, this.removed = !1, this.visibility = 1, this.selected = !1, this.hovered = !1, this.cursor = null, this.invisible = !1, this.items = [], this.currentItems = null
                }

                return t
            }();
            e.ItemsLayerObject = n;
            var s = function (e) {
                function n(t, n, s) {
                    void 0 === s && (s = !1), e.call(this), this.parentNode = null, this.links = [], this.dataLinks = [], this.dataLinksFiltered = [], this.isNode = !0, this.isLink = !1, this.x = null, this.y = null, this.anchorX = null, this.anchorY = null, this.shapeAnchorX = 0, this.shapeAnchorY = 0, this.targetHHeight = null, this.targetHWidth = null, this.hHeight = 0, this.hWidth = 0, this.renderHheight = 0, this.renderHwidth = 0, this.anchorMode = i.Floating, this.coordinates = null, this.coordinatesCache = null, this.coordinatesCachePrecision = 1 / 0, this.expanded = !1, this.focused = !1, this.background = !1, this.selected = !1, this.hovered = !1, this.loading = !1, this.userLock = !1, this.relevance = 1, this.display = "image", this.fillColor = null, this.lineColor = null, this.lineWidth = 1, this.image = null, this.imageCropping = null, this.imageSlicing = null, this.tintImage = !1, this.label = null, this._labelStyle = null, this._anchorStyle = null, this.zindex = 0, this.opacity = 1, this.locks = 0, this.locked = null, this.layer = n, this.id = t
                }

                return __extends(n, e), Object.defineProperty(n.prototype, "labelStyle", {
                    get: function () {
                        return this._labelStyle
                    }, set: function (e) {
                        null !== this._labelStyle ? (t.Base.Helpers.warn("For performance reasons it is not recommended to set `labelStyle` to a custom object. Instead modify properties on the existing object."), t.Base.SettingsHelper.updateRecursive(this._labelStyle, e, t.Base.SettingsMapping.ItemsChartSettingsItemsLayerLabelStyle, {})) : this._labelStyle = e
                    }, enumerable: !0, configurable: !0
                }), Object.defineProperty(n.prototype, "anchorStyle", {
                    get: function () {
                        return this._anchorStyle
                    }, set: function (e) {
                        null !== this._anchorStyle ? (t.Base.Helpers.warn("For performance reasons it is not recommended to set `anchorStyle` to a custom object. Instead modify properties on the existing object."), t.Base.SettingsHelper.updateRecursive(this._anchorStyle, e, t.Base.SettingsMapping.ItemsChartSettingsNodeAnchorStyle, {})) : this._anchorStyle = e
                    }, enumerable: !0, configurable: !0
                }), n
            }(n);
            e.Node = s;
            var o = function (e) {
                function i(t, i) {
                    e.call(this), this.from = null, this.to = null, this.isNode = !1, this.isLink = !0, this.multiId = null, this.radius = 1, this.fillColor = null, this.lineColor = null, this.length = 1, this.strength = 1, this.label = null, this._labelStyle = null, this.dashed = !1, this.currentRadius = 0, this.background = null, this._angle = null, this.targetRadius = null, this.targetStrength = null, this.targetLength = null, this.direction = null, this.fromDecoration = null, this.toDecoration = null, this.relevance = 1, this.toPieValue = 0, this.toPieColor = null, this.toPie0 = null, this.toPie1 = null, this.currentCenterOffset = 0, this.layer = i, this.id = t
                }

                return __extends(i, e), Object.defineProperty(i.prototype, "labelStyle", {
                    get: function () {
                        return this._labelStyle
                    }, set: function (e) {
                        null !== this._labelStyle ? (t.Base.Helpers.warn("For performance reasons it is not recommended to set `labelStyle` to a custom object. Instead modify properties on the existing object."), t.Base.SettingsHelper.updateRecursive(this._labelStyle, e, t.Base.SettingsMapping.ItemsChartSettingsItemsLayerLabelStyle, {})) : this._labelStyle = e
                    }, enumerable: !0, configurable: !0
                }), i.prototype.otherEnd = function (t) {
                    return t === this.from ? this.to : t === this.to ? this.from : null
                }, i.prototype.commonNode = function (t) {
                    return this.from === t.from || this.from === t.to ? this.from : this.to === t.from || this.to === t.to ? this.to : null
                }, i
            }(n);
            e.Link = o;
            var r = function (e) {
                function i(t, i) {
                    e.call(this, t), this.parentId = null, this.scaleNodesWithZoom = !0, this.scaleLinksWithZoom = !0, this._nodes = [], this._links = [], this._nodesDel = null, this._linksDel = null, this.idToNode = {}, this.idToLink = {}, this.lastClickedNode = null, this.newNodes = {}, this.newLinks = {}, this.modifiedNodes = {}, this.modifiedLinks = {}, this.deletedNodes = {}, this.deletedLinks = {}, this.drilldownId = null, this.layerSettings = i, this.scene = t, this.clearModified(), this.styleUpdater = this.createStyleUpdater(this.layerSettings.style)
                }

                return __extends(i, e), i.prototype.onSettingsChanged = function (t) {
                    if (t.style) {
                        this.styleUpdater = this.createStyleUpdater(this.layerSettings.style);
                        for (var e = 0, i = this.nodes(); e < i.length; e++) {
                            var n = i[e];
                            this.touchNode(n)
                        }
                        for (var s = 0, o = this.links(); s < o.length; s++) {
                            var r = o[s];
                            this.touchLink(r)
                        }
                    }
                }, i.prototype.updateStyle = function (t) {
                    this.styleUpdater.updateLayer(t, !0)
                }, i.prototype.postprocessStyle = function (t) {
                    this.styleUpdater.postprocessLayer(t)
                }, i.prototype.createStyleUpdater = function () {
                    return null
                }, i.prototype.paintPrepare = function () {
                }, i.prototype.paintSelection = function () {
                }, i.prototype.paintLinks = function () {
                }, i.prototype.paintNodes = function () {
                }, i.prototype.findObjectAt = function () {
                    return null
                }, i.prototype.getLegendItems = function () {
                    return []
                }, i.prototype.findObjectById = function (t) {
                    return this.idToNode.hasOwnProperty(t) ? this.idToNode[t] : this.idToLink.hasOwnProperty(t) ? this.idToLink[t] : null
                }, i.prototype.paint = function (t) {
                    this.paintPrepare(t), this.clearModified();
                    var e = this.scene.selection;
                    if (e.length > 0) {
                        for (var i = [], n = [], s = 0; s < e.length; s++) {
                            var o = e[s];
                            o.layer === this && o.isNode && i.push(o), o.layer === this && o.isLink && n.push(o)
                        }
                        (i.length > 0 || n.length > 0) && this.paintSelection(t, i, n)
                    }
                    var r = this.links(), a = this._makeHoveredLast(r, this.scene.hoverLink);
                    this.paintLinks(t, r), this._restoreHovered(r, a);
                    var h = this.nodes(), l = this._makeHoveredLast(h, this.scene.hoverNode);
                    this.paintNodes(t, h), this._restoreHovered(h, l)
                }, i.prototype.clearObjects = function () {
                    for (var t = 0, e = this.nodes(); t < e.length; t++) {
                        var i = e[t];
                        this.removeNode(i)
                    }
                    for (var n = 0, s = this.links(); n < s.length; n++) {
                        var o = s[n];
                        this.removeLink(o)
                    }
                }, i.prototype.nodes = function () {
                    if (null === this._nodesDel)return this._nodes;
                    for (var t = [], e = 0; e < this._nodes.length; e++) {
                        var i = this._nodes[e];
                        this._nodesDel[i.id] || t.push(i)
                    }
                    return this._nodes = t, this._nodesDel = null, t
                }, i.prototype.links = function () {
                    if (null === this._linksDel)return this._links;
                    for (var t = [], e = 0; e < this._links.length; e++) {
                        var i = this._links[e];
                        this._linksDel[i.id] || t.push(i)
                    }
                    return this._links = t, this._linksDel = null, t
                }, i.prototype.addNode = function (t) {
                    this.nodes();
                    var e;
                    return this.idToNode.hasOwnProperty(t) ? (e = this.idToNode[t], e.removed = !1, e.added || (e.added = !0)) : this.deletedNodes.hasOwnProperty(t) ? (e = this.deletedNodes[t], e.removed = !1, e.added || (e.added = !0), this.idToNode[t] = e, this._nodes.push(e), delete this.deletedNodes[t]) : (e = new s(t, this), e.added = !0, this.idToNode[t] = e, this._nodes.push(e), this.newNodes[t] = e), this.modifiedNodes[t] = e, e
                }, i.prototype.touchNodeOrLink = function (t) {
                    t.isNode ? this.modifiedNodes[t.id] = t : this.modifiedLinks[t.id] = t
                }, i.prototype.touchNode = function (t) {
                    this.modifiedNodes[t.id] = t
                }, i.prototype.removeNode = function (t) {
                    var e = t.id;
                    this.idToNode.hasOwnProperty(e) && (t === this.lastClickedNode && (this.lastClickedNode = null), this.scene.objectRemoved(t), this.newNodes.hasOwnProperty(t.id) ? this.deleteNode(t) : (t.removed || (t.removed = !0), t.added = !1, this.modifiedNodes[e] = t))
                }, i.prototype.deleteNode = function (t) {
                    null === this._nodesDel && (this._nodesDel = {}), this._nodesDel[t.id] = !0, this.scene.objectRemoved(t), delete this.newNodes[t.id], delete this.modifiedNodes[t.id], delete this.idToNode[t.id], this.deletedNodes[t.id] = t
                }, i.prototype.addLink = function (e, i, n) {
                    var s = this.idToNode[i], r = this.idToNode[n];
                    if (!s || !r)throw new Error("Cannot add link - missing nodes");
                    var a = null;
                    return this.links(), this.idToLink.hasOwnProperty(e) ? (a = this.idToLink[e], a.removed = !1, a.added || (a.added = !0)) : this.deletedLinks.hasOwnProperty(e) ? (a = this.deletedLinks[e], delete this.deletedLinks[e], this.idToLink[e] = a, this._links.push(a), a.removed = !1, a.added || (a.added = !0)) : (a = new o(e, this), a.added = !0, this._links.push(a), this.idToLink[e] = a, this.newLinks[e] = a), a.from && a.from !== s && (t.Base.Helpers.removeFromArray(a.from.links, a), a.from = null), a.from || (a.from = s, a.from.links.push(a), this.touchNode(a.from)), a.to && a.to !== r && (t.Base.Helpers.removeFromArray(a.to.links, a), a.to = null), a.to || (a.to = r, a.to.links.push(a), this.touchNode(a.to)), a.multiId = n > i ? i + t.Base.Helpers.SeparatorChar + n : n + t.Base.Helpers.SeparatorChar + i, this.modifiedLinks[e] = a, a
                }, i.prototype.removeLink = function (t) {
                    var e = t.id;
                    this.idToLink.hasOwnProperty(e) && (this.scene.objectRemoved(t), this.newLinks.hasOwnProperty(e) ? this.deleteLink(t) : (t.added = !1, t.removed || (t.removed = !0), this.modifiedLinks[e] = t))
                }, i.prototype.deleteLink = function (t) {
                    null === this._linksDel && (this._linksDel = {}), this._linksDel[t.id] = !0, this.scene.objectRemoved(t), this.newLinks.hasOwnProperty(t.id) ? delete this.newLinks[t.id] : this.deletedLinks[t.id] = t, delete this.modifiedLinks[t.id], delete this.idToLink[t.id]
                }, i.prototype.touchLink = function (t) {
                    this.modifiedLinks[t.id] = t
                }, i.prototype.getModified = function () {
                    return {
                        this_newNodes: this.newNodes,
                        this_newLinks: this.newLinks,
                        this_modifiedNodes: this.modifiedNodes,
                        this_modifiedLinks: this.modifiedLinks,
                        this_deletedNodes: this.deletedNodes,
                        this_deletedLinks: this.deletedLinks
                    }
                }, i.prototype.hasTopologyChanges = function () {
                    return t.Base.Helpers.hasProperties(this.newNodes) || t.Base.Helpers.hasProperties(this.newLinks) || t.Base.Helpers.hasProperties(this.deletedNodes) || t.Base.Helpers.hasProperties(this.deletedLinks)
                }, i.prototype.hasStyleChanges = function () {
                    return this.hasTopologyChanges() || t.Base.Helpers.hasProperties(this.modifiedLinks) || t.Base.Helpers.hasProperties(this.modifiedNodes)
                }, i.prototype.clearModified = function () {
                    this.newNodes = {}, this.newLinks = {}, this.modifiedNodes = {}, this.modifiedLinks = {}, this.deletedNodes = {}, this.deletedLinks = {}
                }, i.prototype.paintNodeDetails = function (t, e, i, n, s, o, r, a) {
                    var h, l = a.labelRenderer, u = a.context, c = s / r;
                    if (t.currentItems)for (var p = 0; p < t.currentItems.length; p++) {
                        var d = t.currentItems[p], f = d.x || 0, m = d.y || 0, g = d.px || 0, y = d.py || 0, v = e + n * g + f, S = i + s * y + m;
                        h = d.scaleWithSize ? c : d.scaleWithZoom ? o : 1, l.measure(u, d, d), d.hheight > 1.5 && l.paint(u, v, S, h, d)
                    }
                }, i.prototype.getNodesSceneZoom = function () {
                    return this.scaleNodesWithZoom ? 1 : 1 / this.scene.zoom
                }, i.prototype.getGeometry = function () {
                    var t = this.scene.toDisplayTransform(), e = t.xm, i = t.xa, n = t.ym, s = t.ya, o = this.bounds.x0, r = this.bounds.x1, a = this.bounds.y0, h = this.bounds.y1, l = (o - i) / e, u = (r - i) / e, c = (a - s) / n, p = (h - s) / n, d = this.scaleNodesWithZoom ? this.scene.zoom : 1, f = this.scaleLinksWithZoom ? this.scene.zoom : 1;
                    return {
                        txm: e,
                        txa: i,
                        tym: n,
                        tya: s,
                        zoom: d,
                        linkZoom: f,
                        x0s: o,
                        x1s: r,
                        y0s: a,
                        y1s: h,
                        x0w: l,
                        y0w: c,
                        x1w: u,
                        y1w: p
                    }
                }, i.prototype._makeHoveredLast = function (t, e) {
                    var i = t.length;
                    if (2 > i || !e || e === t[i - 1])return i - 1;
                    for (var n = 0; n < t.length; n++) {
                        var s = t[n];
                        if (s === e) {
                            var o = t[i - 1];
                            return t[i - 1] = e, t[n] = o, n
                        }
                    }
                    return i - 1
                }, i.prototype._restoreHovered = function (t, e) {
                    var i = t.length;
                    if (e !== i - 1) {
                        var n = t[e];
                        t[e] = t[i - 1], t[i - 1] = n
                    }
                }, i
            }(t.Base.Layer);
            e.ItemsLayer = r
        }(e = t.ItemsChart || (t.ItemsChart = {}))
    }(e = t.Internal || (t.Internal = {}))
}(ZoomCharts || (ZoomCharts = {}));
var ZoomCharts;
!function (t) {
    var e;
    !function (t) {
        var e;
        !function (e) {
            var i = function () {
                function t() {
                    this.allObjectsStyleFunction = null, this.linkStyleFunction = null, this.nodeStyleFunction = null, this.nodeRules = {}, this.linkRules = {}, this.nodeClasses = [], this.linkClasses = [], this.node = {
                        fillColor: "#c7dae0",
                        lineColor: null,
                        lineWidth: null,
                        radius: 30,
                        shadowColor: null,
                        lineDash: null
                    }, this.nodeAnchor = {
                        lineColor: "blue",
                        lineWidth: 1
                    }, this.link = {
                        fillColor: "#333",
                        shadowColor: null,
                        fromDecoration: null,
                        toDecoration: null,
                        label: null,
                        radius: 1,
                        length: 1,
                        strength: 1,
                        lineDash: null,
                        toPieValue: 0,
                        toPieColor: null
                    }, this.item = {
                        align: "center",
                        aspectRatio: 4,
                        borderRadius: 1e3,
                        textStyle: {fillColor: "black", font: "12px Arial"},
                        backgroundStyle: {fillColor: "rgba(255,255,255,0.7)"}
                    }, this.linkLabel = {
                        padding: .6,
                        margin: 0,
                        align: "center",
                        aspectRatio: 4,
                        borderRadius: 1e3,
                        textStyle: {fillColor: "black", font: "12px Arial"},
                        backgroundStyle: {fillColor: "#FFF", lineColor: "gray"},
                        scaleWithZoom: !0,
                        scaleWithSize: !1,
                        rotateWithLink: !1
                    }, this.nodeLabel = {
                        padding: 0,
                        margin: 0,
                        align: "center",
                        aspectRatio: 4,
                        borderRadius: 1e3,
                        textStyle: {fillColor: "black", font: "12px Arial"},
                        backgroundStyle: {fillColor: "rgba(255,255,255,0.7)"},
                        scaleWithZoom: !1,
                        scaleWithSize: !0
                    }, this.nodeLocked = {}, this.nodeExpanded = {}, this.nodeFocused = {fillColor: "#09c"}, this.nodeNotLoaded = {fillColor: "#fff"}, this.nodeHovered = {
                        shadowOffsetX: 0,
                        shadowOffsetY: 2,
                        shadowBlur: 6,
                        shadowColor: "rgba(0,0,0,.6)"
                    }, this.linkHovered = {
                        shadowOffsetX: 0,
                        shadowOffsetY: 0,
                        shadowBlur: 12,
                        shadowColor: "blue"
                    }, this.nodeSelected = {}, this.linkSelected = {}, this.selection = {
                        fillColor: "rgba(173, 216, 230, 1)",
                        lineColor: "rgba(255,255,255,0.01)",
                        sizeConstant: 0,
                        sizeProportional: 0,
                        shadowBlur: 8,
                        shadowOffsetX: 0,
                        shadowOffsetY: 3,
                        shadowColor: "rgba(0,0,0,0.8)"
                    }, this.removedColor = "#EEE", this.nodeBackground = {}, this.nodeDetailMinZoom = .2, this.nodeDetailMinSize = 5, this.linkDetailMinZoom = .5, this.linkDetailMinSize = 12, this.linkDecorationScale = 4, this.linkDecorationMinSize = 4, this.nodeLabelScaleBase = 30, this.linkLabelScaleBase = 1, this.scaleObjectsWithZoom = !0, this.scaleLinksWithZoom = null
                }

                return t
            }();
            e.SettingsItemsLayerStyle = i;
            var n = function () {
                function i(e, i) {
                    this.layer = i, this.styleSettings = e, this.nodeClasses = t.Base.Helpers.arrayToMap(this.styleSettings.nodeClasses, "className"), this.linkClasses = t.Base.Helpers.arrayToMap(this.styleSettings.linkClasses, "className"), this.nodeRules = this.sortRules(this.styleSettings.nodeRules), this.styleSettings.nodeStyleFunction && this.nodeRules.unshift(this.styleSettings.nodeStyleFunction), this.linkRules = this.sortRules(this.styleSettings.linkRules), this.styleSettings.linkStyleFunction && this.linkRules.unshift(this.styleSettings.linkStyleFunction)
                }

                return i.prototype.updateLayer = function (t, e) {
                    void 0 === e && (e = !1), null == e && (e = !1), this.isIncremental = e;
                    var i = this.styleSettings, n = t.changes.style || t.changes.zoom && !(!this.nodeRules.length && !this.linkRules.length);
                    if (n) {
                        this.isIncremental = !1;
                        for (var s = 0, o = this.layer.nodes(); s < o.length; s++)this.layer.touchNode(o[s]);
                        for (var r = 0, a = this.layer.links(); r < a.length; r++)this.layer.touchLink(a[r])
                    }
                    var h = this.layer.modifiedNodes;
                    for (var l in h) {
                        var u = h[l];
                        if (this.updateNode(u), e)for (var r = 0; r < u.links.length; r++)this.layer.touchLink(u.links[r])
                    }
                    var c = this.layer.modifiedLinks;
                    for (var l in c) {
                        var p = c[l];
                        this.updateLink(p)
                    }
                    if (i.allObjectsStyleFunction && (t.changes.zoom || this.layer.hasStyleChanges())) {
                        var d = this.layer.nodes(), f = this.layer.links(), m = i.allObjectsStyleFunction(d, f), g = f, y = d;
                        m && (g = m.modifiedLinks, y = m.modifiedNodes);
                        for (var v = 0; v < y.length; v += 1)this.layer.touchNode(y[v]);
                        for (var v = 0; v < g.length; v += 1)this.layer.touchLink(g[v])
                    }
                    if (this.nodeRules.length > 0) {
                        h = this.layer.modifiedNodes;
                        for (var l in h) {
                            var u = h[l];
                            this.applyStyleRules(u, this.nodeRules)
                        }
                    }
                    if (this.linkRules.length > 0) {
                        c = this.layer.modifiedLinks;
                        for (var l in c) {
                            var p = c[l];
                            this.applyStyleRules(p, this.linkRules)
                        }
                    }
                }, i.prototype.postprocessLayer = function () {
                    var t = this.layer.modifiedNodes;
                    for (var e in t) {
                        var i = t[e];
                        this.postprocessNode(i)
                    }
                    var n = this.layer.modifiedLinks;
                    for (var e in n) {
                        var s = n[e];
                        this.postprocessLink(s)
                    }
                }, i.prototype.postprocessItems = function (i) {
                    for (var n = i.currentItems, s = i instanceof e.Node ? t.Base.SettingsMapping.ItemsChartSettingsNodeItem : t.Base.SettingsMapping.ItemsChartSettingsLinkItem, o = this.styleSettings.item, r = 0; r < i.items.length; r++) {
                        var a = i.items[r], h = new t.Base.Label(o, s);
                        t.Base.SettingsHelper.updateRecursive(h, a, s, {}, "items[" + r + "]"), n.push(h)
                    }
                }, i.prototype.sortRules = function (t) {
                    var e = [];
                    for (var i in t)e.push(i);
                    e.sort();
                    for (var n = [], s = 0; s < e.length; s++) {
                        var o = e[s];
                        n.push(t[o])
                    }
                    return n
                }, i.prototype.updateNode = function (e) {
                    var i = this.styleSettings, n = e.hovered;
                    if (e.radius || (e.radius = 10), e.label = null, t.Base.Helpers.extendStyle(e, i.node), e._labelStyle = t.Base.Helpers.extendCopy({}, i.nodeLabel), e._anchorStyle = t.Base.Helpers.extendCopy({}, i.nodeAnchor), e.userLock && t.Base.Helpers.extendStyle(e, i.nodeLocked), e.expanded && t.Base.Helpers.extendStyle(e, i.nodeExpanded), e.focused && t.Base.Helpers.extendStyle(e, i.nodeFocused), e.background && t.Base.Helpers.extendStyle(e, i.nodeBackground), e.data.loaded || t.Base.Helpers.extendStyle(e, i.nodeNotLoaded), e.data && (e.data.error && (e.label = e.data.error, e.fillColor = "red"), e.data.style && t.Base.Helpers.extendStyle(e, e.data.style), e.data.className))for (var s = this.getClassSequence(e.data.className, this.nodeClasses), o = 0; o < s.length; o++) {
                        var r = s[o];
                        t.Base.Helpers.extendStyle(e, this.styleSettings.nodeClasses[r].style)
                    }
                    e.removed && (e.fillColor = i.removedColor), e.selected && t.Base.Helpers.extendStyle(e, i.nodeSelected), n && t.Base.Helpers.extendStyle(e, i.nodeHovered)
                }, i.prototype.postprocessNode = function () {
                }, i.prototype.updateLink = function (e) {
                    var i = this.styleSettings;
                    e.label = null, e._labelStyle = t.Base.Helpers.extendCopy({}, i.linkLabel), e.radius = 1, t.Base.Helpers.extendStyle(e, i.link);
                    var n = e.hovered || e.from.hovered || e.to.hovered;
                    if (e.data.style && t.Base.Helpers.extendStyle(e, e.data.style), e.data.className)for (var s = this.getClassSequence(e.data.className, this.linkClasses), o = 0; o < s.length; o++) {
                        var r = s[o];
                        t.Base.Helpers.extendStyle(e, i.linkClasses[r].style)
                    }
                    e.selected && t.Base.Helpers.extendStyle(e, i.linkSelected), n && (t.Base.Helpers.extendStyle(e, i.linkHovered), e.from.hovered && (e.toPieColor = e.fillColor)), e.removed && (e.fillColor = i.removedColor)
                }, i.prototype.postprocessLink = function () {
                }, i.prototype.applyStyleRules = function (t, e) {
                    for (var i = 0; i < e.length; i++) {
                        var n = e[i];
                        n(t)
                    }
                }, i.prototype.getClassSequence = function (e, i) {
                    for (var n = e.replace(/^\s+|\s+$/g, "").split(/\s+/g), s = [], o = 0; o < n.length; o++) {
                        var r = n[o], a = i[r];
                        a ? s.push(a.index) : t.Base.Helpers.error("Unable to apply item style: class `" + r + "` undefined")
                    }
                    return s.sort(function (t, e) {
                        return t - e
                    })
                }, i
            }();
            e.ItemsStyle = n
        }(e = t.ItemsChart || (t.ItemsChart = {}))
    }(e = t.Internal || (t.Internal = {}))
}(ZoomCharts || (ZoomCharts = {}));
var ZoomCharts;
!function (t) {
    var e;
    !function (t) {
        var e;
        !function (e) {
            var i = function (t) {
                function e() {
                    t.apply(this, arguments), this.data = [], this.info = {
                        enabled: !1,
                        nodeContentsFunction: null,
                        linkContentsFunction: null
                    }, this.interaction = new r, this.nodeMenu = new o([]), this.linkMenu = new s, this.advanced = new l
                }

                return __extends(e, t), e.prototype.apply = function (e) {
                    return this.applyCompatibility(e, [{
                        from: "style.makeImagesCircular",
                        to: "style.node.imageCropping"
                    }, {
                        from: "style.nodeDecorationMinSize",
                        alternative: "style.nodeDetailMinSize"
                    }, {
                        from: "style.nodeLabelMinSize",
                        to: "style.nodeDetailMinSize"
                    }, {
                        from: "style.nodeRules",
                        alternative: "style.nodeStyleFunction",
                        alternativeAsWarning: !0
                    }, {
                        from: "style.linkRules",
                        alternative: "style.linkStyleFunction",
                        alternativeAsWarning: !0
                    }]), t.prototype.apply.call(this, e)
                }, e
            }(t.Base.Settings);
            e.Settings = i;
            var n = function (t) {
                function e() {
                    t.apply(this, arguments), this.cacheSize = 1e4, this.random = null, this.randomGridLinkProbability = .6, this.randomNodes = 0, this.randomLinks = 0, this.randomTreeDensity = 3, this.requestMaxUnits = 2, this.preloadNodeLinks = !1
                }

                return __extends(e, t), e
            }(t.Base.SettingsData);
            e.SettingsData = n;
            var s = function () {
                function t() {
                    this.enabled = !0, this.showData = !1, this.contentsFunction = null
                }

                return t
            }();
            e.SettingsLinkMenu = s;
            var o = function () {
                function t(t) {
                    this.enabled = !0, this.showData = !1, this.contentsFunction = null, this.buttons = [], this.buttons = t
                }

                return t
            }();
            e.SettingsNodeMenu = o;
            var r = function (t) {
                function e() {
                    t.apply(this, arguments), this.nodesMovable = !0, this.zooming = new h, this.panning = {enabled: !0}, this.selection = new a
                }

                return __extends(e, t), e
            }(t.Base.SettingsInteraction);
            e.SettingsInteraction = r;
            var a = function () {
                function t() {
                    this.enabled = !0, this.nodesSelectable = !0, this.linksSelectable = !0, this.lockNodesOnMove = !0, this.allowMoveNodesOffscreen = !0, this.tolerance = 10
                }

                return t
            }();
            e.SettingsInteractionSelection = a;
            var h = function () {
                function t() {
                    this.zoomInOnDoubleClick = !0, this.autoZoomAfterClick = !1, this.doubleClickZoom = 1.5, this.sensitivity = 1, this.wheel = !0, this.fingers = !0
                }

                return t
            }();
            e.SettingsInteractionZooming = h;
            var l = function (t) {
                function e() {
                    t.apply(this, arguments), this.perNodeLoadingIndicator = !0
                }

                return __extends(e, t), e
            }(t.Base.SettingsAdvanced);
            e.SettingsAdvanced = l
        }(e = t.ItemsChart || (t.ItemsChart = {}))
    }(e = t.Internal || (t.Internal = {}))
}(ZoomCharts || (ZoomCharts = {}));
var ZoomCharts;
!function (t) {
    var e;
    !function (t) {
        var e;
        !function (t) {
            var e = function (t) {
                function e() {
                    t.apply(this, arguments)
                }

                return __extends(e, t), e
            }(t.Shape);
            t.ImageShape = e
        }(e = t.ItemsChart || (t.ItemsChart = {}))
    }(e = t.Internal || (t.Internal = {}))
}(ZoomCharts || (ZoomCharts = {}));
var ZoomCharts;
!function (t) {
    var e;
    !function (t) {
        var e;
        !function (e) {
            var i = function (e) {
                function i() {
                    e.apply(this, arguments), this.leftOffset = 0
                }

                return __extends(i, e), i.prototype.postProcessLabel = function (e, i) {
                    var n = this.node.targetHHeight, s = new t.Base.Label(this.node.labelStyle);
                    s.text = this.node.label.toString(), s.backgroundStyle = null, s.image = null, i.measure(e, s);
                    var o = s.hwidth, r = s.hheight, a = o / r * n;
                    this.node.image && (a += n), this.node.targetHWidth = Math.max(a, n), this.node.bounds.x0 = -this.node.targetHWidth, this.node.bounds.x1 = this.node.targetHWidth, this.currentLabel = s
                }, i.prototype.distanceToEdge = function (e, i, n, s) {
                    return t.Base.Geometry.distanceToBalloon(e, i, n, s)
                }, i.prototype.paintSelection = function (t, e, i) {
                    var n = this.node.renderHheight * (1 + e) + i, s = this.node.renderHwidth - this.node.renderHheight + n, o = this.x, r = this.y, a = o + s - n;
                    t.moveTo(a, r - n), t.arc(a, r, n, -Math.PI / 2, Math.PI / 2, !1), a = o - s + n, t.lineTo(a, r + n), t.arc(a, r, n, Math.PI / 2, -Math.PI / 2, !1), t.closePath()
                }, i.prototype.paintDetails = function (e, i) {
                    var n = this.currentLabel;
                    if (n) {
                        if (this.r > 2) {
                            if (i.measure(e, n), this._computeScale(), this.image) {
                                var s = this.image, o = this.x - this.w, r = this.y - this.imSize / 2;
                                if (this.node.imageSlicing) {
                                    var a = this.node.imageSlicing;
                                    e.drawImage(s, a[0], a[1], a[2], a[3], o, r, this.imSize, this.imSize)
                                } else e.drawImage(s, 0, 0, s.width, s.height, o, r, this.imSize, this.imSize)
                            }
                            i.paintWithStyle(e, this.x + this.leftOffset, this.y, this.scale, n, n), t.Base.Graphics.clearShadow(e)
                        }
                    } else this.basicPaintImage(e)
                }, i.prototype._computeScale = function () {
                    this.scale = this.r / this.currentLabel.hheight, this.image && (this.leftOffset = this.r, this.imSize = 2 * this.r)
                }, i
            }(e.Shape);
            e.TextShape = i
        }(e = t.ItemsChart || (t.ItemsChart = {}))
    }(e = t.Internal || (t.Internal = {}))
}(ZoomCharts || (ZoomCharts = {}));
var ZoomCharts;
!function (t) {
    var e;
    !function (t) {
        var e;
        !function (e) {
            var i = function (i) {
                function n() {
                    i.apply(this, arguments)
                }

                return __extends(n, i), n.prototype.postProcessLabel = function () {
                    var e, i = this.node.labelStyle;
                    i.backgroundStyle.fillColor = "transparent", e = new t.Base.Label(i), e.text = this.node.label.toString(), e.aspectRatio = 1, e.image = null, this.currentLabel = e
                }, n.prototype.distanceToEdge = function (t, i, n, s) {
                    return e.Shape.prototype.distanceToEdge.call(this, t, i, n, s)
                }, n.prototype._computeScale = function () {
                    var t = Math.sqrt(this.currentLabel.hwidth * this.currentLabel.hwidth + this.currentLabel.hheight * this.currentLabel.hheight);
                    if (this.image) {
                        var e = this.currentLabel.lineHeight + 2 * this.currentLabel.hwidth, i = (e * e + this.currentLabel.hheight * this.currentLabel.hheight) / 2 / e;
                        i > t && (this.leftOffset = i - t, t = i)
                    }
                    this.scale = this.r / t, this.image && (this.imSize = this.currentLabel.lineHeight * this.scale)
                }, n
            }(e.TextShape);
            e.RoundTextShape = i
        }(e = t.ItemsChart || (t.ItemsChart = {}))
    }(e = t.Internal || (t.Internal = {}))
}(ZoomCharts || (ZoomCharts = {}));
var ZoomCharts;
!function (t) {
    var e;
    !function (t) {
        var e;
        !function (e) {
            var i = {
                a0x: 0,
                a0y: -1,
                a1x: .556548642145067,
                a1y: -1,
                a2x: 1,
                a2y: -.5534547954623581,
                b0x: 1,
                b0y: 0,
                b1x: 1,
                b1y: .808869027157099,
                b2x: 0,
                b2y: 1.2870402200068753,
                apexX: 0,
                apexY: 1.878652526641458,
                imageRadius: .6170212765957447
            }, n = [i.a0x, i.a0y, i.a1x, i.a1y, i.a2x, i.a2y, i.b0x, i.b0y, i.b1x, i.b1y, i.b2x, i.b2y, i.apexX, i.apexY], s = t.Base.Helpers.reversePolyline(t.Base.Geometry.transformPolyline(n, -1, 0, 1, 0)), o = [0, -1, .7095605708093294, -.7046444467621514, 1, 0, 1, 0, .4313896533498214, .9021657092700437, 1, 0], r = t.Base.Helpers.reversePolyline(t.Base.Geometry.transformPolyline(o, -1, 0, 1, 0)), a = function (e) {
                function a() {
                    e.apply(this, arguments)
                }

                return __extends(a, e), a.prototype.postProcess = function (t, n, s) {
                    e.prototype.postProcess.call(this, t, n, s), this.node.bounds.addBounds(0, 0, 0, this.node.targetHHeight * i.apexY), this.node.shapeAnchorX = 0, this.node.shapeAnchorY = this.node.radius * i.apexY
                }, a.prototype.getAnchor = function () {
                    return {x: 0, y: this.r * i.apexY}
                }, a.prototype.adaptToViewport = function (i, o, r, a, h) {
                    e.prototype.adaptToViewport.call(this, i, o, r, a, h), this.controlPoints = t.Base.Geometry.transformPolyline(n, this.r, this.x, this.w, this.y), this.reverseControlPoints = t.Base.Geometry.transformPolyline(s, this.r, this.x, this.w, this.y)
                }, a.prototype.paintSelection = function (e, i, n) {
                    var s = this.r * i + n, a = t.Base.Geometry.outlinePolylineByVectors(this.controlPoints, o, s), h = t.Base.Geometry.outlinePolylineByVectors(this.reverseControlPoints, r, s);
                    e.moveTo.apply(e, a.slice(0, 2)), e.bezierCurveTo.apply(e, a.slice(2, 8)), e.bezierCurveTo.apply(e, a.slice(8, 14)), e.arc(this.controlPoints[12], this.controlPoints[13], s, 0, Math.PI, !1), e.bezierCurveTo.apply(e, h.slice(2, 8)), e.bezierCurveTo.apply(e, h.slice(8, 14)), e.closePath()
                }, a.prototype.paintBasicShape = function (e) {
                    var i = t.Base.Graphics.beginStrokeAndFill(e, this.node);
                    i.beginPath(), i.moveTo.apply(i, this.controlPoints.slice(0, 2)), i.bezierCurveTo.apply(i, this.controlPoints.slice(2, 8)), i.bezierCurveTo.apply(i, this.controlPoints.slice(8, 14)), i.bezierCurveTo.apply(i, this.reverseControlPoints.slice(2, 8)), i.bezierCurveTo.apply(i, this.reverseControlPoints.slice(8, 14)), i.closePath(), t.Base.Graphics.endStrokeAndFill(e, i, this.node)
                }, a.prototype.paintDetails = function (t, e) {
                    this.image && this.basicPaintImage(t, i.imageRadius), this.paintLabel(t, e)
                }, a.prototype.getLabelPosition = function (t, e) {
                    return {x: this.x, y: this.y - this.r - t.hheight * e * 1.1}
                }, a.prototype.distanceToEdge = function (e, n, s, o) {
                    var r = n, a = e * i.apexY, h = t.Base.Geometry.rayIntersectsSegment(0, 0, s, o, 0, a, r, 0), l = t.Base.Geometry.rayIntersectsSegment(0, 0, s, o, -r, 0, 0, a), u = Math.min(h, l);
                    return 1 / 0 > u ? u : e
                }, a
            }(e.Shape);
            e.DropletShape = a
        }(e = t.ItemsChart || (t.ItemsChart = {}))
    }(e = t.Internal || (t.Internal = {}))
}(ZoomCharts || (ZoomCharts = {}));
var ZoomCharts;
!function (t) {
    var e;
    !function (t) {
        var e;
        !function (e) {
            var i = function (t) {
                function e() {
                    t.apply(this, arguments), this.multilinkSpacing = 10, this.nodeRadiusExtent = [10, 150], this.linkRadiusExtent = [.6, 30], this.linkStrengthExtent = [.1, 1], this.linkLengthExtent = [.3, 150], this.nodeAutoScaling = null, this.linkAutoScaling = null, this.linkStrengthAutoScaling = null, this.linkLengthAutoScaling = null, this.hiddenLinks = {
                        lineColor: "rgba(100,100,100,0.3)",
                        lineWidth: 1,
                        size: 7
                    }, this.fadeTime = 600
                }

                return __extends(e, t), e
            }(e.SettingsItemsLayerStyle);
            e.SettingsNodesLayerStyle = i;
            var n = function (i) {
                function n(t, e, n) {
                    i.call(this, t, e), this.g = null, this.fadeout = n, this.styleSettings = t
                }

                return __extends(n, i), n.prototype.updateLayer = function (e, n) {
                    void 0 === n && (n = !1), this.nodeRadiusChanged = t.Base.Helpers.hasProperties(this.layer.newNodes) || t.Base.Helpers.hasProperties(this.layer.deletedNodes) || this.styleSettings.allObjectsStyleFunction && this.layer.hasStyleChanges() || this.nodeRules.length > 0, this.linkRadiusChanged = t.Base.Helpers.hasProperties(this.layer.newLinks) || t.Base.Helpers.hasProperties(this.layer.deletedLinks) || this.styleSettings.allObjectsStyleFunction && this.layer.hasStyleChanges() || this.linkRules.length > 0, i.prototype.updateLayer.call(this, e, n)
                }, n.prototype.postprocessLayer = function (e) {
                    this.g = e.context;
                    var i = this.layer, n = this.styleSettings.removedColor;
                    this.itemRenderer = e.labelRenderer;
                    for (var s in i.modifiedLinks) {
                        var o = i.modifiedLinks[s];
                        this.fadeout && o.relevance < 1 && (o.fillColor && (o.fillColor = t.Base.Graphics.blendColors(n, o.fillColor, o.relevance)), o.lineColor && (o.lineColor = t.Base.Graphics.blendColors(n, o.lineColor, o.relevance)), o.length = .2 + (o.length - .2) * o.relevance), this.postprocessLink(o)
                    }
                    for (var r in i.modifiedNodes) {
                        var a = i.modifiedNodes[r];
                        this.fadeout && a.relevance < 1 && (a.fillColor && (a.fillColor = t.Base.Graphics.blendColors(n, a.fillColor, a.relevance)), a.lineColor && (a.lineColor = t.Base.Graphics.blendColors(n, a.lineColor, a.relevance)))
                    }
                    var h = this.layer.nodes();
                    if (this.nodeRadiusChanged || this.fadeout && e.changes.navigation) {
                        this.computeNodeSize(h, this.styleSettings.nodeAutoScaling, this.styleSettings.nodeRadiusExtent);
                        for (var l = 0; l < h.length; l++) {
                            var u = h[l];
                            this.postprocessNode(u)
                        }
                    } else for (var c in i.modifiedNodes) {
                        var p = i.modifiedNodes[c];
                        this.postprocessNode(p)
                    }
                    if (this.linkRadiusChanged || e.changes.navigation) {
                        var d = i.links();
                        this.computeRadii(d, this.styleSettings.linkAutoScaling, this.styleSettings.linkRadiusExtent), this.computeStrengths(d, this.styleSettings.linkStrengthAutoScaling, this.styleSettings.linkStrengthExtent), this.computeLengths(d, this.styleSettings.linkLengthAutoScaling, this.styleSettings.linkLengthExtent), t.Base.Helpers.sort(d, function (t, e) {
                            return t.targetRadius === e.targetRadius ? 0 : t.targetRadius > e.targetRadius ? 1 : -1
                        })
                    }
                    t.Base.Helpers.sort(h, function (t, e) {
                        return t.zindex - e.zindex
                    })
                }, n.prototype.updateLink = function (t) {
                    var e = t.radius;
                    i.prototype.updateLink.call(this, t), e !== t.radius && (this.linkRadiusChanged = !0)
                }, n.prototype.updateNode = function (t) {
                    var e = t.radius;
                    i.prototype.updateNode.call(this, t), e !== t.radius && (this.nodeRadiusChanged = !0), null == t.label && t.data && (t.label = t.data.id)
                }, n.prototype.computeNodeSize = function (e, i, n) {
                    var s = n[0], o = n[1];
                    if ("linear" === i || "logarithmic" === i || "square" === i) {
                        for (var r = 1 / 0, a = -1 / 0, h = 0; h < e.length; h++) {
                            var l = e[h];
                            if (!l.removed) {
                                var u = l.radius;
                                t.Base.Helpers.isNumber(u) ? (r = Math.min(r, u), a = Math.max(a, u)) : l.targetHHeight = s
                            }
                        }
                        if (r >= a)for (var h = 0; h < e.length; h++) {
                            var l = e[h];
                            l.removed || (l.targetHHeight = s)
                        } else if ("linear" === i)for (var c = o / a, h = 0; h < e.length; h++) {
                            var l = e[h];
                            if (!l.removed) {
                                var u = l.radius;
                                t.Base.Helpers.isNumber(u) && (l.targetHHeight = Math.max(s, u * c))
                            }
                        } else if ("square" === i)for (var c = o / Math.sqrt(a), h = 0; h < e.length; h++) {
                            var l = e[h];
                            if (!l.removed) {
                                var u = l.radius;
                                t.Base.Helpers.isNumber(u) && (l.targetHHeight = Math.max(s, Math.sqrt(u) * c))
                            }
                        } else {
                            r = Math.max(1e-4, r), a = Math.max(r + 1e-4, a);
                            for (var c = o / Math.log(a), h = 0; h < e.length; h++) {
                                var l = e[h];
                                !l.removed && t.Base.Helpers.isNumber(l.radius) && (l.targetHHeight = Math.max(s, Math.log(Math.max(1e-4, l.radius)) * c))
                            }
                        }
                    } else for (var h = 0; h < e.length; h++) {
                        var l = e[h];
                        l.removed || (l.targetHHeight = t.Base.Helpers.isNumber(l.radius) ? Math.min(Math.max(1e-6, l.radius), 1e30) : s)
                    }
                    if (this.fadeout)for (var h = 0; h < e.length; h++) {
                        var l = e[h];
                        l.relevance < 1 && (l.targetHHeight = l.targetHHeight * l.relevance)
                    }
                }, n.prototype.computeRadii = function (e, i, n) {
                    var s = n[0], o = n[1];
                    if ("linear" === i || "logarithmic" === i || "square" === i) {
                        for (var r = 1 / 0, a = -1 / 0, h = 0; h < e.length; h++) {
                            var l = e[h];
                            if (!l.removed) {
                                var u = l.radius;
                                t.Base.Helpers.isNumber(u) ? (r = Math.min(r, u), a = Math.max(a, u)) : l.targetRadius = s
                            }
                        }
                        if (r >= a)for (var h = 0; h < e.length; h++) {
                            var l = e[h];
                            l.removed || (l.targetRadius = s)
                        } else if ("linear" === i)for (var c = o / a, h = 0; h < e.length; h++) {
                            var l = e[h];
                            if (!l.removed) {
                                var u = l.radius;
                                t.Base.Helpers.isNumber(u) && (l.targetRadius = Math.max(s, u * c))
                            }
                        } else if ("square" === i)for (var c = o / Math.sqrt(a), h = 0; h < e.length; h++) {
                            var l = e[h];
                            if (!l.removed) {
                                var u = l.radius;
                                t.Base.Helpers.isNumber(u) && (l.targetRadius = Math.max(s, Math.sqrt(u) * c))
                            }
                        } else {
                            r = Math.max(1e-4, r), a = Math.max(r + 1e-4, a);
                            for (var c = o / Math.log(a), h = 0; h < e.length; h++) {
                                var l = e[h];
                                !l.removed && t.Base.Helpers.isNumber(l.radius) && (l.targetRadius = Math.max(s, Math.log(Math.max(1e-4, l.radius)) * c))
                            }
                        }
                    } else for (var h = 0; h < e.length; h++) {
                        var l = e[h];
                        l.removed || (l.targetRadius = t.Base.Helpers.isNumber(l.radius) ? Math.min(Math.max(1e-6, l.radius), 1e30) : s)
                    }
                    if (this.fadeout)for (var h = 0; h < e.length; h++) {
                        var l = e[h];
                        l.relevance < 1 && (l.targetRadius = l.targetRadius * l.relevance)
                    }
                }, n.prototype.computeStrengths = function (e, i, n) {
                    var s = n[0], o = n[1];
                    if ("linear" === i || "logarithmic" === i || "square" === i) {
                        for (var r = 1 / 0, a = -1 / 0, h = 0; h < e.length; h++) {
                            var l = e[h];
                            l.removed || (r = Math.min(r, l.strength), a = Math.max(a, l.strength))
                        }
                        if (r >= a)for (var h = 0; h < e.length; h++) {
                            var l = e[h];
                            l.removed || (l.targetStrength = s)
                        } else if ("linear" === i)for (var u = o / a, h = 0; h < e.length; h++) {
                            var l = e[h];
                            l.removed || (l.targetStrength = Math.min(s, l.strength * u))
                        } else if ("square" === i)for (var u = o / Math.sqrt(a), h = 0; h < e.length; h++) {
                            var l = e[h];
                            if (!l.removed) {
                                var c = l.strength;
                                t.Base.Helpers.isNumber(c) && (l.targetStrength = Math.max(s, Math.sqrt(c) * u))
                            }
                        } else {
                            r = Math.max(1e-4, r), a = Math.max(r + 1e-4, a);
                            for (var u = o / Math.log(a), h = 0; h < e.length; h++) {
                                var l = e[h];
                                l.removed || (l.targetStrength = Math.max(s, Math.log(Math.max(1e-4, l.strength)) * u))
                            }
                        }
                    } else for (var h = 0; h < e.length; h++) {
                        var l = e[h];
                        l.removed || (l.targetStrength = Math.min(Math.max(s, l.strength), o))
                    }
                }, n.prototype.computeLengths = function (e, i, n) {
                    var s = n[0], o = n[1];
                    if ("linear" === i || "logarithmic" === i || "square" === i) {
                        for (var r = 1 / 0, a = -1 / 0, h = 0; h < e.length; h++) {
                            var l = e[h];
                            l.removed || (r = Math.min(r, l.length), a = Math.max(a, l.length))
                        }
                        if (r >= a)for (var h = 0; h < e.length; h++) {
                            var l = e[h];
                            l.removed || (l.targetLength = s)
                        } else if ("linear" === i)for (var u = (o - s) / (a - r), c = o - a * u, h = 0; h < e.length; h++) {
                            var l = e[h];
                            l.removed || (l.targetLength = l.length * u + c)
                        } else if ("square" === i)for (var u = o / Math.sqrt(a), h = 0; h < e.length; h++) {
                            var l = e[h];
                            if (!l.removed) {
                                var p = l.length;
                                t.Base.Helpers.isNumber(p) && (l.targetLength = Math.max(s, Math.sqrt(p) * u))
                            }
                        } else {
                            r = Math.max(1e-4, r), a = Math.max(r + 1e-4, a);
                            for (var u = (o - s) / Math.log(a / r), c = o - u * Math.log(a), h = 0; h < e.length; h++) {
                                var l = e[h];
                                l.removed || (l.targetLength = Math.log(Math.max(1e-4, l.length)) * u + c)
                            }
                        }
                    } else for (var h = 0; h < e.length; h++) {
                        var l = e[h];
                        l.removed || (l.targetLength = Math.min(Math.max(s, l.length), o))
                    }
                }, n.prototype.postprocessNode = function (n) {
                    i.prototype.postprocessNode.call(this, n);
                    var s;
                    switch (n.display) {
                        case"customShape":
                            s = e.CustomShape;
                            break;
                        case"roundtext":
                            s = e.RoundTextShape;
                            break;
                        case"text":
                            s = e.TextShape;
                            break;
                        case"droplet":
                            s = e.DropletShape;
                            break;
                        default:
                            s = e.ImageShape
                    }
                    n.shape instanceof s || (n.shape && (n.shape.node = null), n.shape = new s(n, this.layer));
                    var o = n.outerBounds = t.Base.Rect.createEmpty();
                    n.shape.postProcess(this.styleSettings, this.g, this.itemRenderer), o.addRect(n.bounds), n.currentItems = [], this.postprocessItems(n);
                    for (var r = n.targetHWidth, a = n.targetHHeight, h = 0; h < n.currentItems.length; h++) {
                        var l = n.currentItems[h];
                        this.measureCustomItem(r, a, n.shape.sizeScale, l, o)
                    }
                }, n.prototype.measureCustomItem = function (t, e, i, n, s) {
                    this.itemRenderer.measure(this.g, n);
                    var o = 1;
                    n.scaleWithSize && (o = i);
                    var r = n.x || 0, a = n.y || 0, h = n.px || 0, l = n.py || 0, u = t * h + r, c = e * l + a;
                    s.addBounds(u - n.hwidth * o, c - n.hheight * o, u + n.hwidth * o, c + n.hheight * o)
                }, n.prototype.postprocessLink = function (e) {
                    i.prototype.postprocessLink.call(this, e);
                    var n = [];
                    if (e.label) {
                        var s = new t.Base.Label(e.labelStyle, t.Base.SettingsMapping.ItemsChartSettingsLinkItem);
                        s.text = e.label.toString(), s.px = 0, s.py = 0, n.push(s)
                    }
                    e.currentItems = n, this.postprocessItems(e)
                }, n
            }(e.ItemsStyle);
            e.NodesStyle = n
        }(e = t.ItemsChart || (t.ItemsChart = {}))
    }(e = t.Internal || (t.Internal = {}))
}(ZoomCharts || (ZoomCharts = {}));
var ZoomCharts;
!function (t) {
    var e;
    !function (t) {
        var e;
        !function (e) {
            var i = function (e) {
                function i() {
                    e.call(this), this.panel = new t.Base.SettingsLegendPanel("bottom", "left"), this.marker.size = 30, this.padding = 15
                }

                return __extends(i, e), i
            }(t.Base.SettingsLegend);
            e.SettingsLegend = i;
            var n = function (e) {
                function i(t) {
                    e.call(this, t), this.paintOrder = 51, this.updateOrder = 100, this.chart = t, this.classes = [], this.renderer = t.renderer
                }

                return __extends(i, e), i.prototype.onSceneChange = function (t) {
                    e.prototype.onSceneChange.call(this, t);
                    var i = t.changes;
                    return i.settings && (this.updateSettings(i.settingsChanges), i.settingsChanges.legend) ? (this.rebuildItems(), i.bounds = !0) : void 0
                }, i.prototype.updateSettings = function (e) {
                    if (t.Base.Helpers.hasProp(e, "style.nodeClasses") || t.Base.Helpers.hasProp(e, "style.linkClasses")) {
                        for (var i = this.scene.settings.style, n = t.Base.Helpers.extendStyle({}, i.node), s = t.Base.Helpers.extendStyle({}, i.link), o = 0; o < i.nodeClasses.length; o++) {
                            var r = i.nodeClasses[o], a = t.Base.Helpers.clone(n);
                            this.classes.push({
                                className: r.className,
                                itemType: "node",
                                style: t.Base.Helpers.extendStyle(a, r.style)
                            })
                        }
                        for (var h = 0; h < i.linkClasses.length; h++) {
                            var l = i.linkClasses[h], a = t.Base.Helpers.clone(s);
                            this.classes.push({
                                className: l.className,
                                itemType: "link",
                                style: t.Base.Helpers.extendStyle(a, l.style)
                            })
                        }
                    }
                    t.Base.Helpers.hasProp(e, "legend.text.fillColor") && (this.baseTextColor = this.settings.text.fillColor)
                }, i.prototype.doAnimations = function () {
                    return 1
                }, i.prototype.paintMarker = function (e, i, n, s, o) {
                    if (o.data instanceof t.ItemsChart.Node) {
                        var r = {geometry: this.getGeometry(i, n, .6), paintDetails: !1};
                        this.renderer.paintNodes(e, [o.data], r, 0)
                    } else if (o.data instanceof t.ItemsChart.Link) {
                        var r = {geometry: this.getGeometry(i, n, 1), paintDetails: !0};
                        this.renderer.paintLinks(e, [o.data], {id: o}, r)
                    }
                }, i.prototype.rebuildItems = function () {
                    var e = [], i = this.settings.marker.size / 2;
                    for (var n in this.classes)if (this.classes.hasOwnProperty(n)) {
                        var s = this.classes[n], o = void 0;
                        "node" === s.itemType ? (o = new t.ItemsChart.Node(null, null), o.data = {}, o.hHeight = i, o.hWidth = i, o.renderHheight = i, o.renderHwidth = i, this.chart.layer.styleUpdater.postprocessNode(o)) : (o = new t.ItemsChart.Link(null, null), o.from = {
                                x: 2 * -i,
                                y: 0,
                                renderHheight: i,
                                renderHwidth: i,
                                shape: {
                                    distanceToEdge: function () {
                                        return i
                                    }
                                }
                            }, o.to = {
                                x: i + i / 2,
                                y: 0,
                                renderHheight: i,
                                renderHwidth: i,
                                shape: {
                                    distanceToEdge: function () {
                                        return i
                                    }
                                }
                            }), o = t.Base.Helpers.extendStyle(o, s.style), e.push({
                            textColor: this.baseTextColor,
                            label: s.className,
                            data: o
                        })
                    }
                    return this.setItems(e)
                }, i.prototype.getGeometry = function (t, e, i) {
                    var n = this.settings.marker.size, s = -n, o = n, r = -n, a = n, h = i, l = i, u = t, c = e, p = t - n, d = t + n, f = e - n, m = e + n;
                    return {
                        txm: h,
                        txa: u,
                        tym: l,
                        tya: c,
                        zoom: i,
                        x0s: p,
                        x1s: d,
                        y0s: f,
                        y1s: m,
                        x0w: s,
                        y0w: r,
                        x1w: o,
                        y1w: a
                    }
                }, i.prototype.onClick = function () {
                    return 1
                }, i
            }(t.Base.Legend);
            e.Legend = n
        }(e = t.NetChart || (t.NetChart = {}))
    }(e = t.Internal || (t.Internal = {}))
}(ZoomCharts || (ZoomCharts = {}));
var ZoomCharts;
!function (t) {
    var e;
    !function (t) {
        var e;
        !function (e) {
            var i = function (t) {
                function e() {
                    t.apply(this, arguments), this.dataFunction = null, this.preloaded = null
                }

                return __extends(e, t), e
            }(t.ItemsChart.SettingsData);
            e.SettingsData = i;
            var n = function (e) {
                function i(t, i) {
                    e.call(this, t, i), this.nodes = {}, this.links = {}, this.nodeToLinks = {}, this.pendingNodes = {}, this.requestedNodes = {}, this.pendingAllData = !1, this.requestedAllData = !1, this.nextLinkId = 0, this.hasAllData = !this.hasDataFunc()
                }

                return __extends(i, e), i.otherEnd = function (t, e) {
                    return e === t.from ? t.to : e === t.to ? t.from : null
                }, i.multiLinkId = function (e) {
                    return e.from < e.to ? e.from + t.Base.Helpers.SeparatorChar + e.to : e.to + t.Base.Helpers.SeparatorChar + e.from
                }, i.prototype.hasDataFunc = function () {
                    return this.dataSettings.dataFunction || this.dataSettings.url
                }, i.prototype.buildRequest = function () {
                    if (this.pendingAllData && !this.requestedAllData)return this.pendingNodes = {}, this.requestedAllData = !0, {nodes: []};
                    var t = [];
                    for (var e in this.pendingNodes)if (t.push(e), delete this.pendingNodes[e], this.requestedNodes[e] = !0, t.length > this.dataSettings.requestMaxUnits)break;
                    return 0 === t.length ? null : {nodes: t}
                }, i.prototype.dataFunc = function (e, i, n) {
                    var s = this.dataSettings;
                    if (s.dataFunction) s.dataFunction(e.nodes || null, i, n); else if (s.url) {
                        var o = [];
                        if (e.nodes) {
                            for (var r = "", a = 0; a < e.nodes.length; a++)r.length && (r += ","), r += encodeURIComponent(e.nodes[a]);
                            o.push(["nodes", r])
                        }
                        t.Base.Data.doRequest(s.url, s, o, i, n)
                    } else n({error: "Chart configuration does not define data retrieval function"})
                }, i.prototype.verifyData = function (e, i) {
                    i.hasOwnProperty("links") || (i.links = []), i.hasOwnProperty("nodes") || (i.nodes = []);
                    var n = !0;
                    if (!t.Base.Helpers.isArray(i.nodes)) {
                        var s = i.nodes;
                        i.nodes = [];
                        for (var o in s) {
                            var r = s[o];
                            r.id = o, i.nodes.push(r)
                        }
                    }
                    if (!t.Base.Helpers.isArray(i.links)) {
                        var a = i.links;
                        i.links = [];
                        for (var o in a) {
                            var h = a[o];
                            h.id = o, i.links.push(h)
                        }
                    }
                    this.chart.log(e ? "Got " + i.nodes.length + " data on  " + e.nodes : "Got " + i.nodes.length + " data on all nodes");
                    for (var l = !(e && e.nodes.length > 0), u = !(e && e.nodes.length > 0 && i.nodes.length > 0), c = {}, p = 0; p < i.nodes.length; p++) {
                        var r = i.nodes[p];
                        c.hasOwnProperty(r.id) && this.chart.error("Data response: Multiple nodes with the same ID: " + r.id), c[r.id] = !0, e && e.nodes.indexOf(r.id) > -1 && (l = !0, u = u || r.loaded)
                    }
                    c = {};
                    for (var d = 0; d < i.links.length; d++) {
                        var h = i.links[d];
                        h.hasOwnProperty("id") && c.hasOwnProperty(h.id) && this.chart.error("Data response: Multiple links with the same ID: " + h.id), c[h.id] = !0
                    }
                    if (l) {
                        if (!u) {
                            this.chart.error("Data response: loaded field was not set on any of the requested nodes, adding manually");
                            for (var p = 0; p < i.nodes.length; p++) {
                                var r = i.nodes[p];
                                e.nodes.indexOf(r.id) > -1 && (r.loaded = !0)
                            }
                        }
                    } else this.chart.error("Data response: Results set did not contain any of requested nodes: ", e.nodes), n = !1;
                    return n
                }, i.prototype.addVerifiedData = function (t, e) {
                    var i = !this.hasDataFunc(), n = {};
                    this.updateGraph(e, i);
                    for (var s = 0; s < e.nodes.length; s++) {
                        var o = e.nodes[s];
                        o.loaded && (n[o.id] = !0, delete this.requestedNodes[o.id]), o.error && (delete this.requestedNodes[o.id], n[o.id] = !0)
                    }
                    if (t)if (0 === t.nodes.length) this.pendingNodes = {}, this.hasAllData = !0; else for (var s = 0; s < t.nodes.length; s++) {
                        var r = t.nodes[s];
                        this.requestedNodes[r] && (this.pendingNodes[r] = !0, delete this.requestedNodes[r])
                    }
                    for (var a = {}, h = {}, s = 0; s < e.nodes.length; s++) {
                        var o = e.nodes[s];
                        this.isFilteredNode(o.id) || (a[o.id] = o)
                    }
                    for (var l = 0; l < e.links.length; l++) {
                        var u = e.links[l];
                        h[u.id] = !0
                    }
                    return {
                        dataLoadedNodesIds: n,
                        netChartDataNodesIds: a,
                        netChartDataLinksIds: h
                    }
                }, i.prototype.requestFailedPermanently = function (t) {
                    if (t.nodes) {
                        for (var e = [], i = 0; i < t.nodes.length; i++) {
                            var n = t.nodes[i];
                            e.push({id: n, error: "Bad response", loaded: !0})
                        }
                        this.addVerifiedData(t, {nodes: e, links: []})
                    }
                    this.chart.error("Failed data request, giving up on nodes: ", t.nodes)
                }, i.prototype.removeData = function (t) {
                    var e = [];
                    if (t.nodes)for (var i = 0; i < t.nodes.length; i++) {
                        var n = t.nodes[i];
                        this.removeNode(n.id, e)
                    }
                    if (t.links)for (var s = 0; s < t.links.length; s++) {
                        var o = t.links[s], r = this.links[o.id];
                        r && this.removeLink(r)
                    }
                    for (var a = 0; a < e.length; a++)this.removeLink(e[a])
                }, i.prototype.exportData = function () {
                    var t = [], e = [];
                    for (var i in this.nodes) {
                        var n = this.nodes[i];
                        t.push(n)
                    }
                    for (var i in this.links) {
                        var s = this.links[i];
                        e.push(s)
                    }
                    return {nodes: t, links: e}
                }, i.prototype.applyPreloadedData = function () {
                    this.dataSettings.randomNodes > 0 ? this.addData(this.genRandomGraph(this.dataSettings)) : e.prototype.applyPreloadedData.call(this)
                }, i.prototype.getNodeData = function (t) {
                    return this.nodes.hasOwnProperty(t) ? this.nodes[t] : (this.requestNodeData(t), null)
                }, i.prototype.nodeRemoved = function (t) {
                    delete this.pendingNodes[t], delete this.requestedNodes[t]
                }, i.prototype.getLinkData = function (t) {
                    return this.links[t]
                }, i.prototype.getNodeLinks = function (t) {
                    return this.nodes.hasOwnProperty(t) && this.nodes[t].loaded ? this.applyLinkFilter(t) : (this.requestNodeData(t), null)
                }, i.prototype.getNodeCollectedLinks = function (t) {
                    return this.applyLinkFilter(t)
                }, i.prototype.getNodeLinksRaw = function (t) {
                    return this.nodeToLinks[t]
                }, i.prototype.isLoaded = function (t) {
                    return this.nodes.hasOwnProperty(t) && this.nodes[t].loaded
                }, i.prototype.isFilteredNode = function (t) {
                    var e = this.settings.filters.nodeFilter, i = this.nodes[t];
                    return e && i ? !e(i, i.loaded ? this.nodeToLinks[t] : null) : !1
                }, i.prototype.getNodes = function () {
                    var t = this.settings.filters.nodeFilter;
                    if (!t)return this.nodes;
                    var e = {};
                    for (var i in this.nodes) {
                        var n = this.nodes[i];
                        t(n, n.loaded ? this.nodeToLinks[i] : null) && (e[i] = n)
                    }
                    return e
                }, i.prototype.applyLinkFilter = function (e) {
                    var n = this.nodes[e], s = this.nodeToLinks[e];
                    if (!s || 0 === s.length)return [];
                    var o = this.settings.filters.linkFilter, r = this.settings.filters.nodeFilter, a = this.settings.filters.nodeLinksProcessor, h = this.settings.filters.multilinkProcessor;
                    if (r && !r(n, n.loaded ? s : null))return [];
                    if (r || o) {
                        for (var l = [], u = 0; u < s.length; u++) {
                            var c = s[u], p = i.otherEnd(c, e), d = this.nodes[p];
                            if (o) {
                                var f = void 0, m = void 0;
                                if (c.from === e ? (f = n, m = d) : (f = d, m = n), !o(c, f, m))continue
                            }
                            (!r || r(d, d.loaded ? this.nodeToLinks[p] : null)) && l.push(c)
                        }
                        s = l
                    }
                    if (a && (s = a(n, s)), h) {
                        for (var g = {}, u = 0; u < s.length; u++) {
                            var c = s[u];
                            g[i.otherEnd(c, e)] = !0
                        }
                        if (t.Base.Helpers.countProperties(g) < s.length) {
                            for (var l = [], y = {}, v = {}, S = 0; S < s.length; S++) {
                                var C = s[S], b = i.multiLinkId(C);
                                y.hasOwnProperty(b) ? v.hasOwnProperty(b) ? v[b].push(C) : v[b] = [y[b], C] : y[b] = C
                            }
                            for (var S = 0; S < s.length; S++) {
                                var C = s[S], b = i.multiLinkId(C);
                                v.hasOwnProperty(b) || l.push(C)
                            }
                            for (var x in v) {
                                var _ = v[x], C = _[0], w = h(_, this.nodes[C.from], this.nodes[C.to]);
                                t.Base.Helpers.isArray(w) ? l.concat(w) : w && l.push(w)
                            }
                            s = l
                        }
                    }
                    return s
                }, i.prototype.requestAllNodes = function () {
                    return this.hasAllData ? !1 : (this.pendingAllData || (this.pendingAllData = !0, this.scheduleRequests()), !0)
                }, i.prototype.requestNodeData = function (t) {
                    !this.hasDataFunc() || this.pendingNodes.hasOwnProperty(t) || this.requestedNodes.hasOwnProperty(t) || (this.pendingNodes[t] = !0, this.scheduleRequests())
                }, i.prototype.updateGraph = function (e, i) {
                    for (var n = 0; n < e.nodes.length; n++) {
                        var s = e.nodes[n];
                        s.id = s.id.toString(), i && (s.loaded = !0), this.nodes.hasOwnProperty(s.id) ? !s.error && s.loaded && t.Base.Helpers.extendDataItem(this.nodes[s.id], s) : (this.nodes[s.id] = s, this.nodeToLinks[s.id] = [])
                    }
                    for (var o = 0; o < e.links.length; o++) {
                        var r = e.links[o];
                        if (r.hasOwnProperty("id") ? r.id = r.id.toString() : (r.id = t.Base.Helpers.SeparatorChar + this.nextLinkId, this.nextLinkId += 1), this.links.hasOwnProperty(r.id)) {
                            var a = this.links[r.id];
                            r.hasOwnProperty("from") && (r.from = r.from.toString()), r.hasOwnProperty("to") && (r.to = r.to.toString()), r.from && a.from !== r.from || r.to && a.to !== r.to ? this.chart.error("Changing link from,to not supported") : t.Base.Helpers.extendDataItem(a, r)
                        } else {
                            if (!r.hasOwnProperty("from")) {
                                this.chart.error("Link.from missing for link " + r.id);
                                continue
                            }
                            if (r.from = r.from.toString(), !r.hasOwnProperty("to")) {
                                this.chart.error("Link.to missing for link " + r.id);
                                continue
                            }
                            r.to = r.to.toString(), this.nodes.hasOwnProperty(r.from) || (this.nodes[r.from] = {
                                id: r.from,
                                loaded: i
                            }, this.nodeToLinks[r.from] = []), this.nodes.hasOwnProperty(r.to) || (this.nodes[r.to] = {
                                id: r.to,
                                loaded: i
                            }, this.nodeToLinks[r.to] = []), this.links[r.id] = r, this.nodeToLinks[r.from].push(r), this.nodeToLinks[r.to].push(r)
                        }
                    }
                }, i.prototype.removeNode = function (t, e) {
                    this.chart.graph.removeNode(t), delete this.pendingNodes[t], delete this.requestedNodes[t];
                    var i = this.nodes[t];
                    if (i) {
                        delete this.nodes[t];
                        var n = this.nodeToLinks[t];
                        if (n) {
                            delete this.nodeToLinks[t];
                            for (var s = 0; s < n.length; s++) {
                                var o = n[s];
                                e.push(o)
                            }
                        }
                    }
                }, i.prototype.removeLink = function (e) {
                    this.chart.graph.removeLink(e.id), delete this.links[e.id], this.nodeToLinks[e.from] && t.Base.Helpers.removeFromArray(this.nodeToLinks[e.from], e), this.nodeToLinks[e.to] && t.Base.Helpers.removeFromArray(this.nodeToLinks[e.to], e)
                }, i.prototype.genRandomGraph = function (e) {
                    var i, n = new t.Base.Random(32131), s = e.randomNodes, o = e.randomLinks;
                    i = "grid" === e.random ? this.genRandomGrid(s, e.randomGridLinkProbability) : "tree" === e.random ? this.genRandomTree(s, e.randomTreeDensity) : this.genRandomUniform(s, o);
                    for (var r = 0; r < i.nodes.length; r++) {
                        var a = i.nodes[r];
                        a.style = {label: "Node " + a.id}, a.value = 10 + 40 * n.get()
                    }
                    for (var h = 0; h < i.links.length; h++) {
                        var l = i.links[h];
                        l.style = {label: "Link " + l.id}, l.value = 1 + 5 * n.get()
                    }
                    return i
                }, i.prototype.genRandomGrid = function (e, i) {
                    for (var n = [], s = [], o = 0; e - 1 >= o; o++) {
                        var r = {id: "n" + o, loaded: !0};
                        n.push(r)
                    }
                    for (var a = Math.ceil(Math.sqrt(e)), h = new t.Base.Random(32131), l = 0; a - 1 >= l; l++)for (var u = 0; a - 1 >= u; u++) {
                        var c = u + l * a;
                        c >= e || (u > 0 && h.get() <= i && s.push({
                            from: "n" + c,
                            to: "n" + (c - 1)
                        }), l > 0 && h.get() <= i && s.push({
                            from: "n" + c,
                            to: "n" + (c - a)
                        }))
                    }
                    for (var p = 0; p < s.length; p++) {
                        var d = s[p];
                        d.id = "" + p
                    }
                    return {nodes: n, links: s}
                }, i.prototype.genRandomUniform = function (e, i) {
                    for (var n = new t.Base.Random(32131), s = [], o = [], r = 0; e > r; r++) {
                        var a = {id: "n" + r, loaded: !0};
                        if (s.length > 0) {
                            var h = {
                                id: "l" + r,
                                from: a.id,
                                to: s[n.get() * s.length | 0].id
                            };
                            o.push(h)
                        }
                        s.push(a)
                    }
                    for (var r = o.length; i - 1 >= r; r++) {
                        var h = {
                            id: "l" + (r + 1),
                            from: s[n.get() * s.length | 0].id,
                            to: s[n.get() * s.length | 0].id
                        };
                        o.push(h)
                    }
                    return {nodes: s, links: o}
                }, i.prototype.genRandomTree = function (e, i) {
                    for (var n = new t.Base.Random(31927832), s = {
                        id: "n0",
                        loaded: !0
                    }, o = [s], r = [s], a = []; r.length < e;) {
                        var h = n.getArrayElement(o);
                        t.Base.Helpers.removeFromArray(o, h);
                        for (var l = Math.max(1, Math.ceil(n.get() * i)), u = 0; l > u; u++) {
                            var c = {
                                id: "n" + r.length,
                                loaded: !0
                            }, p = {id: "l" + r.length, from: h.id, to: c.id};
                            a.push(p), r.push(c), o.push(c)
                        }
                    }
                    return {nodes: r, links: a}
                }, i
            }(t.Base.Data);
            e.Data = n
        }(e = t.NetChart || (t.NetChart = {}))
    }(e = t.Internal || (t.Internal = {}))
}(ZoomCharts || (ZoomCharts = {}));
var ZoomCharts;
!function (t) {
    var e;
    !function (t) {
        var e;
        !function (e) {
            var i = function () {
                function t() {
                    this.mode = "showall", this.initialNodes = null, this.focusNodeExpansionRadius = 2, this.focusNodeTailExpansionRadius = .3, this.focusAutoFadeout = !0, this.numberOfFocusNodes = 3, this.minNumberOfFocusNodes = 1, this.expandDelay = 0, this.expandOnClick = !0, this.autoZoomOnFocus = !1
                }

                return t
            }();
            e.SettingsNavigation = i;
            var n = function (i) {
                function n(t) {
                    i.call(this), this.nodes = {}, this.lastExpandTime = 0, this.nextId = 0, this.hasData = !1, this.changes = !1, this.animationOrder = 100, this.paintOrder = 5, this.updateOrder = 1500, this.chart = t, this.layer = this.chart.layer, this.graph = this.chart.graph, this.scene = this.chart.scene
                }

                return __extends(n, i), n.prototype.clear = function (t) {
                    this.chart.events.notifySceneChanges({navigation: !0}), this.nodes = {}, this.chart.notifyChartUpdate(t)
                }, n.prototype.addOrUpdateAction = function (e, i, n) {
                    this.chart.events.notifySceneChanges({navigation: !0});
                    var o = this.nodes[e];
                    return o || (o = new s, o.id = e, this.nodes[e] = o), o.actionId = ++this.nextId, t.Base.Helpers.extend(o, i), this.chart.notifyChartUpdate(n), o
                }, n.prototype.hideNode = function (t, e) {
                    return this.addOrUpdateAction(t, {hidden: !0}, e)
                }, n.prototype.collapseNode = function (t, e) {
                    return this.addOrUpdateAction(t, {collapsed: !0, expanded: !1}, e)
                }, n.prototype.addFocusNode = function (t, e, i) {
                    return this.addOrUpdateAction(t, {relevance: e, initial: !0}, i)
                }, n.prototype.expandNode = function (t, e) {
                    return this.addOrUpdateAction(t, {expanded: !0, collapsed: !1}, e)
                }, n.prototype.unfocusNode = function (t, e) {
                    return this.addOrUpdateAction(t, {initial: !1}, e)
                }, n.prototype.removeNode = function (t) {
                    return delete this.nodes[t]
                }, n.prototype.save = function () {
                    return this.nodes
                }, n.prototype.restore = function (e) {
                    this.nodes = {};
                    for (var i in e) {
                        var n = e[i], o = new s;
                        t.Base.Helpers.extend(o, n), this.nodes[i] = o, this.nextId = Math.max(o.actionId, this.nextId)
                    }
                    this.chart.events.notifySceneChanges({navigation: !0}), this.chart.notifyChartUpdate("restore")
                }, n.prototype.getInitialNodes = function () {
                    var e = this.scene.settings.navigation.initialNodes;
                    return t.Base.Helpers.isString(e) ? e = [e] : t.Base.Helpers.isArray(e) || (e = []), e
                }, n.prototype.onNewDataObject = function () {
                    if (this.hasData = !1, "showall" !== this.scene.settings.navigation.mode)return this.scene.loading = !1;
                    var t = this.getInitialNodes();
                    if (0 === t.length)return this.scene.loading = this.scene.mainData.requestAllNodes();
                    for (var e = 0; e < t.length; e++) {
                        var i = t[e];
                        this.scene.mainData.getNodeData(i)
                    }
                }, n.prototype.showInitialNodes = function () {
                    this.clear("init");
                    var t = this.scene.settings.navigation, e = this.getInitialNodes();
                    if ("focusnodes" === t.mode)for (var i = 0; i < e.length; i++) {
                        var n = e[i];
                        this.addFocusNode(n, -1, "init")
                    } else if ("manual" === t.mode)for (var i = 0; i < e.length; i++) {
                        var n = e[i];
                        this.addFocusNode(n, 1, "init")
                    }
                    this.chart.notifyChartUpdate("init")
                }, n.prototype.onSceneChange = function (t) {
                    if (t.changes.navigation || t.changes.dataArrived || this.layer.hasTopologyChanges() || t.changes.settings || t.changes.filters || t.changes.data) {
                        if (this.scene.settings.navigation.expandDelay && this.lastExpandTime > t.timeStamp - this.scene.settings.navigation.expandDelay && !t.changes.filters && this.hasData && !t.changes.dataArrived)return void this.chart.events.notifySceneChanges({navigation: !0});
                        t.changes.dataArrived && (this.hasData = !0, this.scene.loading = !1), this.resolveConflicts();
                        var e = this.computeRelevances(), i = e.expandedRelevances, n = e.expandedNodes, s = e.expandedLinks, o = e.expandUnfinished, r = e.loadingNodes, a = i;
                        if (this.hasData) {
                            var h = !0;
                            o && this.scene.settings.navigation.expandDelay && (h = !1, this.lastExpandTime = t.timeStamp, this.chart.events.notifySceneChanges({navigation: !0}));
                            var l, u;
                            t.changes.dataArrived ? (l = t.changes.netChartDataNodesIds, u = t.changes.netChartDataLinksIds) : (l = {}, u = {}), t.changes.newGraph = this.updateGraph(a, s, l, u), this.applyRelevances(i, n, r), h && this.cleanupInivisibleNodes()
                        }
                    }
                }, n.prototype.resolveConflicts = function () {
                    for (var t in this.nodes) {
                        var i = this.nodes[t];
                        if (i.expanded)for (var n = this.scene.mainData.getNodeCollectedLinks(t), s = 0; s < n.length; s++) {
                            var o = n[s], r = e.Data.otherEnd(o, t), a = this.nodes[r];
                            a && a.actionId < i.actionId && a.hidden && delete this.nodes[r]
                        }
                    }
                    if ("focusnodes" === this.scene.settings.navigation.mode) {
                        var h = this.scene.settings.navigation.numberOfFocusNodes, l = [];
                        for (var u in this.nodes) {
                            var i = this.nodes[u];
                            i.initial && l.push(i)
                        }
                        l.sort(function (t, e) {
                            return t.actionId - e.actionId
                        });
                        for (var c = 0; l.length - c > h;)l[c].initial = !1, c++;
                        if (c > 0)for (var t in this.nodes)this.nodes[t].expanded = !1
                    }
                }, n.prototype.getFocusNodeCount = function () {
                    var t = 0;
                    for (var e in this.nodes)this.nodes[e].initial && t++;
                    return t
                }, n.prototype.cleanupInivisibleNodes = function () {
                    for (var t in this.nodes) {
                        var e = this.nodes[t];
                        "focusnodes" !== this.scene.settings.navigation.mode && this.scene.mainData.isFilteredNode(t) ? delete this.nodes[t] : e.initial || e.hidden || this.graph.idToNode.hasOwnProperty(t) || delete this.nodes[t]
                    }
                }, n.prototype.computeRelevances = function () {
                    this.changes = !1;
                    var i = this.graph.idToNode, n = this.scene.mainData.nodes, s = this.scene.mainData.dataSettings.preloadNodeLinks, o = {}, r = {}, a = {}, h = {}, l = [], u = this.scene.settings.navigation.mode, c = !!this.scene.settings.navigation.expandDelay && "focusnodes" === u, p = !1;
                    if ("focusnodes" === u) {
                        var d = [];
                        for (var f in this.nodes) {
                            var m = this.nodes[f];
                            m.initial && d.push(m)
                        }
                        d.sort(function (t, e) {
                            return e.actionId - t.actionId
                        });
                        for (var g = 1 + this.scene.settings.navigation.focusNodeExpansionRadius, y = 1 + this.scene.settings.navigation.focusNodeTailExpansionRadius, v = (g - y) / Math.max(1, this.scene.settings.navigation.numberOfFocusNodes - 1), S = 0, C = 0; C < d.length; C++) {
                            var m = d[C], f = m.id, b = m.relevance;
                            0 > b && (b = g), b = Math.max(0, b - S), S += v, o[f] = b, l.push(f)
                        }
                    } else if ("manual" === u) {
                        var d = [];
                        for (var f in this.nodes) {
                            var m = this.nodes[f];
                            d.push(m)
                        }
                        d.sort(function (t, e) {
                            return e.actionId - t.actionId
                        });
                        for (var f in this.nodes) {
                            var m = this.nodes[f];
                            m.collapsed || (l.push(f), o[f] = m.relevance)
                        }
                        !t.Base.Helpers.hasProperties(l) && d.length > 0 && (l.push(d[0].id), o[d[0].id] = 1)
                    } else {
                        var x = this.scene.mainData.getNodes();
                        for (var f in x)l.push(f), o[f] = 1.01
                    }
                    for (; l.length > 0;) {
                        var f = l.pop(), _ = o[f], m = this.nodes[f], w = void 0;
                        if (m) {
                            if (m.hidden) {
                                delete o[f];
                                continue
                            }
                            m.expanded && 2 > _ && (_ = 2, o[f] = Math.max(1, o[f])), w = m.expanded || _ > 1 && !m.collapsed && !r.hasOwnProperty(f)
                        } else w = _ > 1;
                        if (this.scene.mainData.getNodeData(f)) {
                            if (w && c && !i.hasOwnProperty(f) && (n.hasOwnProperty(f) && (p = !0), w = !1), !r.hasOwnProperty(f))if (w) {
                                r[f] = !0;
                                var L = this.scene.mainData.getNodeLinks(f);
                                L || (h[f] = !0, L = this.scene.mainData.getNodeCollectedLinks(f)), a[f] = L;
                                for (var T = _ - 1, M = 0; M < L.length; M++) {
                                    var P = L[M], k = e.Data.otherEnd(P, f);
                                    (!o.hasOwnProperty(k) || T > o[k]) && (o[k] = T, l.push(k))
                                }
                            } else if (s) {
                                var L = this.scene.mainData.getNodeLinks(f);
                                L || (h[f] = !0, L = this.scene.mainData.getNodeCollectedLinks(f)), a[f] = L
                            } else a[f] = this.scene.mainData.getNodeCollectedLinks(f)
                        } else this.scene.loading = !0, delete o[f]
                    }
                    return {
                        expandedRelevances: o,
                        expandedNodes: r,
                        expandedLinks: a,
                        expandUnfinished: p,
                        loadingNodes: h
                    }
                }, n.prototype.updateGraph = function (t, e, i, n) {
                    var s = this.graph.replaceGraph(t, e);
                    return this.graph.updateGraphWithNewData(i, n), s
                }, n.prototype.applyRelevances = function (e, i, n) {
                    var s = "focusnodes" === this.scene.settings.navigation.mode, o = null, r = 0;
                    for (var a in e) {
                        var h = e[a], l = this.graph.idToNode[a];
                        if (l) {
                            var u = this.nodes[a], c = i.hasOwnProperty(a), p = s && u && u.initial, d = n.hasOwnProperty(a);
                            (c !== l.expanded || p !== l.focused || l.relevance !== h || l.loading !== d) && (l.expanded = c, l.focused = p, l.relevance = h, l.loading = d, this.layer.touchNode(l)), p && (null === o || r < u.actionId) && (o = l, r = u.actionId)
                        }
                    }
                    this.scene.lastFocusNode = o, t.Base.Helpers.hasProperties(n) && (this.scene.loading = !0);
                    for (var f in this.graph.idToLink) {
                        var m = this.graph.idToLink[f], g = Math.min(m.from.relevance, m.to.relevance);
                        g !== m.relevance && (m.relevance = g, this.layer.touchLink(m))
                    }
                }, n
            }(t.Base.ChartElement);
            e.Navigator = n;
            var s = function () {
                function t() {
                    this.id = null, this.relevance = -1, this.initial = !1, this.stopped = !1, this.hidden = !1, this.expanded = !1, this.collapsed = !1, this.actionId = 0
                }

                return t
            }()
        }(e = t.NetChart || (t.NetChart = {}))
    }(e = t.Internal || (t.Internal = {}))
}(ZoomCharts || (ZoomCharts = {}));
var ZoomCharts;
!function (t) {
    var e;
    !function (t) {
        var e;
        !function (t) {
            var e = function () {
                function t(t) {
                    this.seed = t, this.A = 48271, this.M = 2147483647, this.Q = this.M / this.A, this.R = this.M % this.A, this.oneOverM = 1 / this.M
                }

                return t.prototype.get = function () {
                    var t = this.seed / this.Q, e = this.seed % this.Q, i = this.A * e - this.R * t;
                    return this.seed = i > 0 ? i : i + this.M, this.seed * this.oneOverM
                }, t.prototype.getArrayElement = function (t) {
                    return t[Math.floor(t.length * this.get())]
                }, t
            }();
            t.Random = e
        }(e = t.Base || (t.Base = {}))
    }(e = t.Internal || (t.Internal = {}))
}(ZoomCharts || (ZoomCharts = {}));
var ZoomCharts;
!function (t) {
    var e;
    !function (t) {
        var e;
        !function (e) {
            var i = function (t) {
                function e() {
                    t.apply(this, arguments), this.lastFocusNode = null
                }

                return __extends(e, t), e
            }(t.ItemsChart.Scene);
            e.Scene = i
        }(e = t.NetChart || (t.NetChart = {}))
    }(e = t.Internal || (t.Internal = {}))
}(ZoomCharts || (ZoomCharts = {}));
var ZoomCharts;
!function (t) {
    var e;
    !function (t) {
        var e;
        !function (e) {
            var i;
            !function (e) {
                var i = function () {
                    function e() {
                        this.maxLeafCount = 5, this.root = null, this.freeNodeRoot = null, this.temperature = 0, this.nodeCount = 0
                    }

                    return e.test = function () {
                        var i = new e;
                        i.maxLeafCount = 2, i.temperature = 1;
                        var n = [], s = {
                            z: 0,
                            dx: 0,
                            dy: 0,
                            dz: 0,
                            repulsiveForceX: 0,
                            repulsiveForceY: 0,
                            repulsiveForceZ: 0,
                            fsum: 0
                        };
                        return n.push(t.Base.Helpers.extend({
                            r: 5,
                            x: 10,
                            y: 10
                        }, s)), n.push(t.Base.Helpers.extend({
                            r: 5,
                            x: 0,
                            y: 0
                        }, s)), n.push(t.Base.Helpers.extend({
                            r: 5,
                            x: 0,
                            y: 10
                        }, s)), n.push(t.Base.Helpers.extend({
                            r: 5,
                            x: 10,
                            y: 0
                        }, s)), n.push(t.Base.Helpers.extend({
                            r: 5,
                            x: 10,
                            y: 10
                        }, s)), n.push(t.Base.Helpers.extend({
                            r: 5,
                            x: 20,
                            y: 0
                        }, s)), n.push(t.Base.Helpers.extend({
                            r: 5,
                            x: 25,
                            y: 0
                        }, s)), i.buildTree(n)
                    }, e._swap = function (t, e, i) {
                        var n = t[e];
                        return t[e] = t[i], t[i] = n
                    }, e.prototype.buildTree = function (t) {
                        this.iters = 0;
                        var e = t.length;
                        this.root && this.freeNode(this.root), this.root = this.newNode(), e > 0 && this.buildTreeRecursive(t, 0, e, this.root);
                        for (var i = 0; e - 1 >= i; i++)t[i].repulsiveForceX = 0, t[i].repulsiveForceY = 0, t[i].repulsiveForceZ = 0;
                        return this.calculateForces()
                    }, e.prototype.freeNode = function (t) {
                        return t.left && this.freeNode(t.left), t.right && this.freeNode(t.right), t.left = this.freeNodeRoot, this.freeNodeRoot = t
                    }, e.prototype.newNode = function () {
                        var t;
                        return this.freeNodeRoot ? (t = this.freeNodeRoot, this.freeNodeRoot = t.left, t.left = null, t.right = null, t.leafCount = 0, t.sizeEstimate = 0, t.forceLinkList.length = 0) : (t = new n, t.forceLinkList = [], t.leaves = new Array(this.maxLeafCount)), t.repulsiveForceX = 0, t.repulsiveForceY = 0, t.repulsiveForceZ = 0, t
                    }, e.prototype.addForceLink = function (t, e) {
                        return t.forceLinkList.push(e)
                    }, e.prototype.getMedianX = function (t, i, n) {
                        n -= 1;
                        for (var s = (i + n) / 2 | 0; ;) {
                            if (i >= n)return s;
                            if (n === i + 1 && t[i].x > t[n].x)return e._swap(t, i, n), s;
                            var o = (i + n) / 2 | 0;
                            t[o].x > t[n].x && e._swap(t, o, n), t[i].x > t[n].x && e._swap(t, i, n), t[o].x > t[i].x && e._swap(t, o, i), e._swap(t, o, i + 1);
                            for (var r = i + 1, a = n; ;) {
                                for (; ;)if (r += 1, !(t[i].x > t[r].x))break;
                                for (; ;)if (a -= 1, !(t[a].x > t[i].x))break;
                                if (r > a)break;
                                var h = t[r];
                                t[r] = t[a], t[a] = h
                            }
                            e._swap(t, i, a), s >= a && (i = r), a >= s && (n = a - 1)
                        }
                    }, e.prototype.getMedianY = function (t, i, n) {
                        n -= 1;
                        for (var s = (i + n) / 2 | 0; ;) {
                            if (i >= n)return s;
                            if (n === i + 1)return t[i].y > t[n].y && e._swap(t, i, n), s;
                            var o = (i + n) / 2 | 0;
                            t[o].y > t[n].y && e._swap(t, o, n), t[i].y > t[n].y && e._swap(t, i, n), t[o].y > t[i].y && e._swap(t, o, i), e._swap(t, o, i + 1);
                            for (var r = i + 1, a = n; ;) {
                                for (; ;)if (r += 1, !(t[i].y > t[r].y))break;
                                for (; ;)if (a -= 1, !(t[a].y > t[i].y))break;
                                if (r > a)break;
                                var h = t[r];
                                t[r] = t[a], t[a] = h
                            }
                            e._swap(t, i, a), s >= a && (i = r), a >= s && (n = a - 1)
                        }
                    }, e.prototype.buildTreeRecursive = function (t, e, i, n) {
                        for (var s = t[e].x, o = t[e].y, r = s, a = o, h = e + 1; i - 1 >= h; h++) {
                            var l = t[h], u = l.x, c = l.y;
                            s > u && (s = u), u > r && (r = u), o > c && (o = c), c > a && (a = c)
                        }
                        n.sizeEstimate = Math.max(r - s, a - o), n.sizeEstimate = n.sizeEstimate * n.sizeEstimate + .1, n.sizeEstimate *= 2;
                        var p = i - e;
                        if (p <= this.maxLeafCount) {
                            n.leafCount = p;
                            for (var u = 0, c = 0, d = 0, f = 0, h = 0; p - 1 >= h; h++) {
                                var m = t[h + e];
                                u += m.x, c += m.y, d += m.z, f += m.r, n.leaves[h] = m
                            }
                            var g = 1 / p;
                            return n.r = f, n.x = u * g, n.y = c * g, void(n.z = d * g)
                        }
                        var y;
                        y = r - s > a - o ? this.getMedianX(t, e, i) : this.getMedianY(t, e, i), y++;
                        var v = this.newNode();
                        n.left = v, this.buildTreeRecursive(t, e, y, v), v = this.newNode(), n.right = v, this.buildTreeRecursive(t, y, i, v);
                        var S = 1 / p;
                        n.r = n.right.r + n.left.r, n.x = (n.left.x * (y - e) + n.right.x * (i - y)) * S, n.y = (n.left.y * (y - e) + n.right.y * (i - y)) * S, n.z = (n.left.z * (y - e) + n.right.z * (i - y)) * S
                    }, e.prototype.calculateForces = function () {
                        var t = new Array(this.nodeCount), e = 0, i = 0;
                        for (null !== this.root.left ? (t[i] = this.root.left, i++, t[i] = this.root.right, i++, this.addForceLink(this.root.left, this.root.right)) : (t[i] = this.root, i++); i > e;) {
                            var n = t[e];
                            e++;
                            var s = 1 / n.r;
                            if (null !== n.left) {
                                this.processTreeNode(n, n.left), this.processTreeNode(n, n.right), t[i] = n.left, i++, t[i] = n.right, i++;
                                var o = n.left.r * s, r = n.repulsiveForceX * o, a = n.repulsiveForceY * o;
                                n.left.repulsiveForceX += r, n.left.repulsiveForceY += a, n.right.repulsiveForceX += n.repulsiveForceX - r, n.right.repulsiveForceY += n.repulsiveForceY - a, this.addForceLink(n.left, n.right)
                            } else for (var h = 0; h <= n.leafCount - 1; h++) {
                                var l = n.leaves[h];
                                this.processLeafNode(n, l);
                                var o = l.r * s;
                                l.repulsiveForceX += n.repulsiveForceX * o, l.repulsiveForceY += n.repulsiveForceY * o;
                                for (var u = h + 1; u <= n.leafCount - 1; u++) {
                                    var c = n.leaves[u];
                                    this.forceBetweenParticles(l, c)
                                }
                            }
                            n.forceLinkList.length = 0
                        }
                    }, e.prototype.processTreeNode = function (t, e) {
                        for (var i = t.forceLinkList.length, s = 0; i - 1 >= s; s++) {
                            var o = t.forceLinkList[s], r = e.x - o.x, a = e.y - o.y, h = r * r + a * a, l = e.sizeEstimate;
                            if (o instanceof n && (l += o.sizeEstimate), h > l) {
                                var u = e.r * o.r / (h * Math.sqrt(h)), c = r * u;
                                e.repulsiveForceX += c, o.repulsiveForceX -= c;
                                var p = a * u;
                                e.repulsiveForceY += p, o.repulsiveForceY -= p
                            } else o instanceof n ? this.addForceLink(o, e) : this.addForceLink(e, o)
                        }
                    }, e.prototype.processLeafNode = function (t, e) {
                        for (var i = 0; i < t.forceLinkList.length; i++) {
                            var s = t.forceLinkList[i];
                            if (s instanceof n) {
                                var o = e.x - s.x, r = e.y - s.y, a = o * o + r * r, h = s.sizeEstimate;
                                if (a > h) {
                                    var l = e.r * s.r / (a * Math.sqrt(a)), u = o * l;
                                    e.repulsiveForceX += u, s.repulsiveForceX -= u;
                                    var c = r * l;
                                    e.repulsiveForceY += c, s.repulsiveForceY -= c
                                } else this.addForceLink(s, e)
                            } else this.forceBetweenParticles(e, s)
                        }
                    }, e.prototype.forceBetweenParticles = function (t, e) {
                        var i, n = t.x - e.x, s = t.y - e.y, o = t.z - e.z, r = n * n + s * s + o * o, a = t.r + e.r;
                        i = r * this.temperature < a ? .25 * this.temperature * Math.sqrt(this.temperature * a) : .25 * a * a / (r * Math.sqrt(r)), t.repulsiveForceX += n * i, e.repulsiveForceX -= n * i, t.repulsiveForceY += s * i, e.repulsiveForceY -= s * i, t.repulsiveForceZ += o * i, e.repulsiveForceZ -= o * i
                    }, e
                }();
                e.BHTree = i;
                var n = function () {
                    function t() {
                        this.forceLinkList = null, this.x = 0, this.y = 0, this.r = 0, this.fx = 0, this.fy = 0, this.sizeEstimate = 0, this.left = null, this.right = null, this.repulsiveForceX = 0, this.repulsiveForceY = 0, this.repulsiveForceZ = 0, this.leafCount = 0, this.leaves = null, this.nodes = null
                    }

                    return t
                }();
                e.RepulsiveTreeNode = n
            }(i = e.Layouts || (e.Layouts = {}))
        }(e = t.ItemsChart || (t.ItemsChart = {}))
    }(e = t.Internal || (t.Internal = {}))
}(ZoomCharts || (ZoomCharts = {}));
var ZoomCharts;
!function (t) {
    var e;
    !function (t) {
        var e;
        !function (t) {
            var e;
            !function (t) {
                var e = function () {
                    function t(t, e) {
                        this.edgecnt = 0, this.nodecnt = t, this.maxedges = e, this.increment = e + 1, this.nodestart = new Array(t), this.enodes = new Array(e), this.next = new Array(e);
                        for (var i = 0; i <= this.nodecnt - 1; i++)this.nodestart[i] = -1
                    }

                    return t.prototype.addEdge = function (t, e) {
                        return this.edgecnt >= this.maxedges && (this.maxedges += this.increment, this.increment *= 2, this.next.length = this.maxedges, this.enodes.length = this.maxedges), this.enodes[this.edgecnt] = e, this.next[this.edgecnt] = this.nodestart[t], this.nodestart[t] = this.edgecnt, this.edgecnt++
                    }, t.prototype.addUndirectEdge = function (t, e) {
                        return this.addEdge(t, e), this.addEdge(e, t)
                    }, t
                }();
                t.GraphAdjacency = e
            }(e = t.Layouts || (t.Layouts = {}))
        }(e = t.ItemsChart || (t.ItemsChart = {}))
    }(e = t.Internal || (t.Internal = {}))
}(ZoomCharts || (ZoomCharts = {}));
var ZoomCharts;
!function (t) {
    var e;
    !function (t) {
        var e;
        !function (e) {
            var i;
            !function (e) {
                var i = function () {
                    function i(t) {
                        this.nodeRepulsionFactor = 15, this.componentCenterFactor = .005, this.linkForceFactor = .2, this.nodeDegreeModifier = 1.2, this.forceReductionFactor = 1, this.stability = 1, this.temperature = 0, this.unitTemperature = 0, this.randomLayoutRadius = 0, this.zAxisAttraction = 1, this.nodesForRepulsion = null, this.repulsiveForceTree = null, this.globalForceX = 0, this.globalForceY = 0, this.centerX = 0, this.centerY = 0, this.aspectRatio = null, this.random = t, this.nodeCount = 0, this.nodes = [], this.forceX = [], this.forceY = [], this.forceZ = [], this.forceSum = [], this.oldForceX = [], this.oldForceY = [], this.oldForceZ = [], this.componentX = [], this.componentY = [], this.componentSum = [], this.componentNodeCount = [], this.nodesForRepulsion = [], this.nodesAspect = 1, this.idToIndex = {}, this.repulsiveForceTree = new e.BHTree
                    }

                    return i.prototype.updateParams = function (t, e, i) {
                        this.aspectRatio = i, this.nodeDegreeModifier = e, this.spacing = t
                    }, i.prototype.updateGraph = function (t, e, i) {
                        if (i = i || t.length !== this.nodeCount) {
                            var o = this.nodes, r = this.oldForceX, a = this.oldForceY, h = this.oldForceZ, l = this.idToIndex;
                            this.nodeCount = t.length, this.oldForceX = new Array(this.nodeCount), this.oldForceY = new Array(this.nodeCount), this.oldForceZ = new Array(this.nodeCount), this.forceX = new Array(this.nodeCount), this.forceY = new Array(this.nodeCount), this.forceZ = new Array(this.nodeCount), this.forceSum = new Array(this.nodeCount), this.nodes = new Array(this.nodeCount), this.idToIndex = {};
                            for (var u = 0, c = 0, p = 0; p < t.length; p++) {
                                var d = t[p], f = d.id, m = new s;
                                m.edges = [];
                                var g = d.outerBounds.w(), y = d.outerBounds.h();
                                if (y > 0 && (u += y / g, c += 1), this.idToIndex[f] = p, this.nodes[p] = m, l.hasOwnProperty(f)) {
                                    var v = l[f], S = o[v];
                                    m.z = S.z, this.oldForceX[p] = r[v], this.oldForceY[p] = a[v], this.oldForceZ[p] = h[v]
                                } else this.oldForceX[p] = 0, this.oldForceY[p] = 0, this.oldForceZ[p] = 0
                            }
                            this.nodesForRepulsion = this.nodes.slice(), this.nodesAspect = c > 0 ? Math.max(.3, u / c) : 1
                        }
                        for (var p = 0; p < t.length; p++) {
                            var d = t[p], C = this.nodes[p], g = d.outerBounds.w(), y = d.outerBounds.h();
                            C.offsetX = d.outerBounds.x0 + d.outerBounds.x1, C.offsetY = d.outerBounds.y0 + d.outerBounds.y1, C.x = d.x + C.offsetX, C.y = d.y + C.offsetY, C.r = .5 * Math.max(1, g), C.minr = Math.max(1, (y + .5 * g) / 3), C.zattr = d.visibility, C.edges.length = 0, C.locked = d.locked, this.forceX[p] = 0, this.forceY[p] = 0, this.forceZ[p] = 0, this.forceSum[p] = 0
                        }
                        for (var b = {
                            U: "D",
                            "null": null,
                            D: "U",
                            L: "R",
                            R: "L"
                        }, x = 0; x < e.length; x++) {
                            var _ = e[x], w = _.strength, L = _.length, T = _.visibility, M = this.nodes[this.idToIndex[_.from.id]], P = this.nodes[this.idToIndex[_.to.id]];
                            M && P ? M !== P && (M.edges.push(new n(P, w, L, T, _.direction)), P.edges.push(new n(M, w, L, T, b[_.direction]))) : console.log("Layout: missing node for link: " + _.from.id + " " + _.to.id + ", topology = " + i)
                        }
                        i && this.computeComponents();
                        for (var k = this.spacing / 2, D = 0; D < this.nodes.length; D++) {
                            for (var m = this.nodes[D], I = 0, A = 0; A < m.edges.length; A++) {
                                var B = m.edges[A];
                                I += B.to.edges.length * B.vis
                            }
                            var E = Math.sqrt(I);
                            m.r += k, m.minr += k, E > 4 && (m.r += (E - 4) * m.r / 4 * this.nodeDegreeModifier, m.minr += (E - 4) * m.minr / 4 * this.nodeDegreeModifier)
                        }
                        for (var O = 0, F = 0, N = 0, D = 0; D < this.nodes.length; D++) {
                            for (var m = this.nodes[D], z = 0, A = 0; A < m.edges.length; A++) {
                                var B = m.edges[A], R = B.to;
                                if (!(m.locked && R.locked || m === R)) {
                                    N++;
                                    var H = m.minr + R.minr;
                                    if (B.len > 0) {
                                        var Z = B.len, U = Math.min(20, B.strength);
                                        B.len = Math.max(1, H * Z), B.K = 30 * U / B.len, z += B.K, O += B.len
                                    } else {
                                        var U = B.strength;
                                        B.K = U, z += B.K, O += H
                                    }
                                }
                            }
                            m.fsum = z, F += m.r * m.r
                        }
                        return N > 0 ? (this.randomLayoutRadius = Math.max(1, O / 10), this.unitTemperature = O / N / 50) : (this.randomLayoutRadius = Math.max(1, Math.sqrt(F)), this.unitTemperature = 1)
                    }, i.prototype.computeComponents = function () {
                        this.componentX = [], this.componentY = [], this.componentSum = [], this.componentNodeCount = [];
                        for (var t = new Array(this.nodeCount), e = 0; e < this.nodes.length; e++) {
                            var i = this.nodes[e];
                            i.component = -1
                        }
                        for (var n = 0, e = 0; e < this.nodes.length; e++) {
                            var i = this.nodes[e];
                            if (!(i.component >= 0)) {
                                i.component = n;
                                var s = 0, o = 0, r = 0;
                                for (t[r] = i, r += 1; r > o;) {
                                    i = t[o], o += 1, s += 1;
                                    for (var a = 0; a < i.edges.length; a++) {
                                        var h = i.edges[a], l = h.to;
                                        -1 === l.component && (l.component = n, t[r] = l, r += 1)
                                    }
                                }
                                this.componentNodeCount.push(s), this.componentX.push(0), this.componentY.push(0), this.componentSum.push(0), n += 1
                            }
                        }
                    }, i.prototype.updateComponents = function () {
                        for (var t = 0; t <= this.componentNodeCount.length - 1; t++)this.componentX[t] = 0, this.componentY[t] = 0, this.componentSum[t] = 0;
                        for (var e = 0; e < this.nodes.length; e++) {
                            var i = this.nodes[e], t = i.component;
                            this.componentX[t] += i.x * i.r, this.componentY[t] += i.y * i.r, this.componentSum[t] += i.r
                        }
                        for (var t = 0; t <= this.componentNodeCount.length - 1; t++)this.componentX[t] /= this.componentSum[t], this.componentY[t] /= this.componentSum[t]
                    }, i.prototype.globalLayout = function (t, e, i) {
                        if (!(this.nodeCount <= 0)) {
                            if (i) {
                                if (1 === this.nodeCount)return void(t[0].x = t[0].y = 0);
                                this.initialRandomLayout()
                            }
                            for (var n = 0, s = 0; s < this.nodes.length; s++) {
                                var o = this.nodes[s];
                                o.locked || n++
                            }
                            var r = Math.floor(Math.sqrt(n) + 10), a = 2 * r;
                            this.forceReductionFactor = 1, this.temperature = (2 * Math.sqrt(n) + 20) * this.unitTemperature, this.zAxisAttraction = .02;
                            for (var h = (new Date).getTime(), l = 3; this.temperature > this.unitTemperature && (a-- <= 0 && (a = 3 * r / l++, this.temperature = this.temperature / 1.5 - .5, this.temperature < 20 * this.unitTemperature && (this.zAxisAttraction = 1.5 * this.zAxisAttraction + .02)), this.randomnodesForRepulsion(), this.repulsiveForceTree.temperature = 1.75 * this.zAxisAttraction, this.repulsiveForceTree.buildTree(this.nodesForRepulsion), this.moveNodesGlobal(), !((new Date).getTime() > h + e)););
                            return i && this.centerNodes(), this.storeNodes(t)
                        }
                    }, i.prototype.initialRandomLayout = function () {
                        for (var t = this.nodeCount, e = new Array(t), i = 0; t - 1 >= i; i++)e[i] = i;
                        for (var i = 0; t >= i; i++) {
                            var n = Math.floor(this.random.get() * (t - i)) + i, s = e[i];
                            e[i] = e[n], e[n] = s
                        }
                        for (var o = this.randomLayoutRadius, r = 2 * Math.PI / this.nodeCount, a = 0; a < this.nodes.length; a++) {
                            var h = this.nodes[a];
                            if (this.oldForceX[a] = 0, this.oldForceY[a] = 0, this.oldForceZ[a] = 0, h.z = this.random.get() - .5, !h.locked) {
                                var l = o + h.r;
                                h.x = l * Math.cos(e[a] * r), h.y = l * Math.sin(e[a] * r)
                            }
                        }
                    }, i.prototype.timedLayout = function (t, e) {
                        if (!(this.nodeCount <= 1) && e > 0) {
                            var i = 0;
                            .1 > e ? (i = 2, this.forceReductionFactor = Math.max(.002, Math.min(this.forceReductionFactor, 10 * e))) : i = Math.min(6, Math.round(2 + 10 * e)), this.zAxisAttraction = this.nodeRepulsionFactor / 28, this.temperature = this.unitTemperature;
                            for (var n = 0; i - 1 >= n; n++)this.randomnodesForRepulsion(), this.applyAspect(1 / this.nodesAspect), this.repulsiveForceTree.temperature = 1.75 * this.zAxisAttraction, this.repulsiveForceTree.buildTree(this.nodesForRepulsion), this.applyAspect(this.nodesAspect), this.moveNodesIncremental();
                            return this.storeNodes(t)
                        }
                    }, i.prototype.prepareAspectRatio = function (t) {
                        for (var e, i, n, s, o, r, a, h = this.nodes, l = h[0].x, u = h[0].y, c = l, p = u, d = !0, f = 1; f <= this.nodeCount - 1; f++)l = Math.min(l, h[f].x), c = Math.max(c, h[f].x), u = Math.min(u, h[f].y), p = Math.max(p, h[f].y);
                        var m = (l + c) / 2, g = (u + p) / 2, y = c - l, v = p - u;
                        return 0 === y || 0 === v ? d = !1 : (e = Math.sqrt(this.aspectRatio), i = Math.sqrt(y * v), n = i * e / y, s = i / e / v, n = t * n + (1 - t), s = t * s + (1 - t), o = m - m * n, r = g - g * s, a = 1 / this.forceReductionFactor), {
                            scaleX: n,
                            incX: o,
                            scaleY: s,
                            incY: r,
                            invForce: a,
                            aspectRatioPrepared: d
                        }
                    }, i.prototype.updateAspectRatioNode = function (t, e, i) {
                        return this.forceX[i] += (e.x * (t.scaleX - 1) + t.incX) * t.invForce, this.forceY[i] += (e.y * (t.scaleY - 1) + t.incY) * t.invForce
                    }, i.prototype.updateAspectRatio = function (t) {
                        for (var e = this.prepareAspectRatio(t), i = this.nodes, n = 0; n <= this.nodeCount - 1; n++) {
                            var s = i[n];
                            this.updateAspectRatioNode(e, s, n)
                        }
                    }, i.prototype.moveNodesGlobal = function () {
                        this.initIteration();
                        var t, e = .5 * this.temperature, i = this.forceReductionFactor;
                        this.aspectRatio && (t = this.prepareAspectRatio(.005), t.aspectRatioPrepared || (this.aspectRatio = null));
                        for (var n = 0; n <= this.nodeCount - 1; n++) {
                            var s = this.nodes[n];
                            if (!s.locked) {
                                this.calculateForce(n, .5), this.aspectRatio && this.updateAspectRatioNode(t, s, n);
                                var o = this.oldForceX[n] = this.forceX[n], r = this.oldForceY[n] = this.forceY[n], a = this.oldForceZ[n] = this.forceZ[n], h = this.forceSum[n];
                                o *= h, r *= h, a *= h;
                                var l = o * o + r * r + a * a;
                                l < this.temperature * this.temperature && l > .001 && (l = this.temperature / Math.sqrt(l), o *= l, r *= l, a *= l), s.x += o * i + (this.random.get() - .5) * e, s.y += r * i + (this.random.get() - .5) * e, s.z += a * i + (this.random.get() - .5) * e
                            }
                        }
                    }, i.prototype.moveNodesIncremental = function () {
                        this.initIteration();
                        for (var t = 0; t <= this.nodeCount - 1; t++)this.nodes[t].locked || this.calculateForce(t, 0);
                        if (this.aspectRatio) {
                            var e = Math.min(.4, .5 / Math.pow(this.nodeCount, .5));
                            this.updateAspectRatio(e)
                        }
                        for (var i = 0, n = 0, s = 0, o = 0, r = new Array(this.nodeCount), t = 0; t <= this.nodeCount - 1; t++)if (!this.nodes[t].locked) {
                            var a = this.forceX[t], h = this.forceY[t], l = this.forceZ[t], u = this.forceSum[t], c = a * a + h * h + l * l;
                            if (c * u * u > this.unitTemperature * this.unitTemperature * .05 * .05) {
                                o += c;
                                var p = this.oldForceX[t] * a + this.oldForceY[t] * h + this.oldForceZ[t] * l;
                                s += p, p > 0 ? n += p : i -= p
                            } else r[t] = !0
                        }
                        this.stability = (n - 5 * i) / this.nodeCount, s > 1e-7 ? this.forceReductionFactor *= 1 + .4 / 1.618033989 : -1e-7 > s && (this.forceReductionFactor /= 1.4);
                        for (var d = this.globalForceX / this.nodeCount, f = this.globalForceY / this.nodeCount, t = 0; t <= this.nodeCount - 1; t++)this.forceX[t] += d, this.forceY[t] += f;
                        this.forceReductionFactor = Math.min(1, this.forceReductionFactor), this.forceReductionFactor = Math.max(.002, this.forceReductionFactor);
                        for (var t = 0; t <= this.nodeCount - 1; t++) {
                            var m = this.nodes[t];
                            if (!m.locked && !r[t]) {
                                var u = this.forceSum[t] * this.forceReductionFactor;
                                m.x += this.forceX[t] * u, m.y += this.forceY[t] * u, m.z += this.forceZ[t] * u
                            }
                            this.oldForceX[t] = this.forceX[t], this.oldForceY[t] = this.forceY[t], this.oldForceZ[t] = this.forceZ[t]
                        }
                    }, i.prototype.initIteration = function () {
                        for (var t = 0, e = 0, i = 0, n = 0; n < this.nodes.length; n++) {
                            var s = this.nodes[n];
                            i += s.r, t += s.x * s.r, e += s.y * s.r
                        }
                        return this.centerX = t / i, this.centerY = e / i, this.updateComponents(), this.globalForceX = 0, this.globalForceY = 0
                    }, i.prototype.applyAspect = function (t) {
                        for (var e = 0; e < this.nodes.length; e++) {
                            var i = this.nodes[e];
                            i.y *= t
                        }
                    }, i.prototype.calculateForce = function (t, e) {
                        for (var i = this.nodes[t], n = this.oldForceX[t] * e, s = this.oldForceY[t] * e, o = this.oldForceZ[t] * e, r = 0; r < i.edges.length; r++) {
                            var a = i.edges[r], h = a.to, l = a.len, u = i.x - i.offsetX - h.x + h.offsetX, c = i.y - i.offsetY - h.y + h.offsetY, p = i.z - h.z;
                            a.direction && ("U" === a.direction ? (c -= l, l = 0) : "D" === a.direction ? (c += l, l = 0) : "L" === a.direction ? (u -= l, l = 0) : "R" === a.direction && (u += l, l = 0));
                            var d = Math.sqrt(u * u + c * c + p * p);
                            .01 > d && (d = .01);
                            var f = (l - d) * a.K / d * this.linkForceFactor;
                            n += f * u, s += f * c, o += f * p
                        }
                        n += i.repulsiveForceX * this.nodeRepulsionFactor, s += i.repulsiveForceY * this.nodeRepulsionFactor, o += i.repulsiveForceZ * this.nodeRepulsionFactor;
                        var m = i.zattr * this.zAxisAttraction;
                        o -= i.z * m;
                        var g = i.component, y = this.componentX[g] - this.centerX, v = this.componentY[g] - this.centerY, S = Math.min(10, Math.sqrt(this.componentNodeCount[g])), C = y * S * this.componentCenterFactor, b = v * S * this.componentCenterFactor;
                        if (n -= C, s -= b, this.globalForceX += C, this.globalForceY += b, isNaN(n))throw"Internal error: Nan in layout";
                        return this.forceX[t] = n, this.forceY[t] = s, this.forceZ[t] = o, i.fsum + m !== 0 ? this.forceSum[t] = 1 / (i.fsum + m) : void 0
                    }, i.prototype.storeNodes = function (t) {
                        for (var e = 0; e <= this.nodeCount - 1; e++) {
                            var i = this.nodes[e];
                            i.locked || (t[e].x = i.x - i.offsetX, t[e].y = i.y - i.offsetY)
                        }
                    }, i.prototype.centerNodes = function () {
                        for (var e = new t.Base.Random(243178931), i = this.nodes, n = i[0].x, s = n, o = i[0].y, r = o, a = 1; a <= this.nodeCount - 1; a++)n = Math.min(n, i[a].x), s = Math.max(s, i[a].x), o = Math.min(o, i[a].y), r = Math.max(r, i[a].y);
                        for (var h = (n + s) / 2, l = (o + r) / 2, a = 0; a <= this.nodeCount - 1; a++) {
                            var u = i[a];
                            if (u.x -= h, u.y -= l, !u.locked) {
                                var c = .3 * u.r;
                                u.x += e.get() * c, u.y += e.get() * c
                            }
                        }
                    }, i.prototype.randomnodesForRepulsion = function () {
                        for (var t = 0; t <= this.nodeCount - 1; t++) {
                            var e = Math.floor(this.random.get() * (this.nodeCount - t)) + t, i = this.nodesForRepulsion[t];
                            this.nodesForRepulsion[t] = this.nodesForRepulsion[e], this.nodesForRepulsion[e] = i
                        }
                    }, i
                }();
                e.TimedSpringEmbedder = i;
                var n = function () {
                    function t(t, e, i, n, s) {
                        this.to = null, this.K = 0, this.len = 0, this.strength = 0, this.vis = 0, this.direction = null, this.to = t, this.vis = n, this.len = i, this.strength = e, this.direction = s
                    }

                    return t
                }();
                e.SpringEdge = n;
                var s = function () {
                    function t() {
                        this.x = 0, this.y = 0, this.z = 0, this.r = 1, this.zattr = 1, this.repulsiveForceX = 0, this.repulsiveForceY = 0, this.repulsiveForceZ = 0, this.component = 0, this.locked = !1, this.offsetX = 0, this.offsetY = 0, this.minr = 0, this.fsum = 0, this.edges = []
                    }

                    return t
                }();
                e.SpringNode = s
            }(i = e.Layouts || (e.Layouts = {}))
        }(e = t.ItemsChart || (t.ItemsChart = {}))
    }(e = t.Internal || (t.Internal = {}))
}(ZoomCharts || (ZoomCharts = {}));
var ZoomCharts;
!function (t) {
    var e;
    !function (t) {
        var e;
        !function (e) {
            var i = function (i) {
                function n(t, e, n, s) {
                    i.call(this, t, n), this.useFadeout = !1, this.imageCache = {}, this.imageLoading = {}, this.multilinks = {}, this.labelRenderer = null, this.events = e, this.useFadeout = s, this.layerSettings = n;
                    var o = this.layerSettings.style;
                    this.style = o, this.scaleNodesWithZoom = o.scaleObjectsWithZoom, this.scaleLinksWithZoom = null == o.scaleLinksWithZoom ? o.scaleObjectsWithZoom : o.scaleLinksWithZoom
                }

                return __extends(n, i), n.prototype.createStyleUpdater = function (t) {
                    return new e.NodesStyle(t, this, this.useFadeout)
                }, n.prototype.updateStyle = function (t) {
                    var e = !t.changes.newGraph;
                    this.styleUpdater.updateLayer(t, e)
                }, n.prototype.postprocessStyle = function (t) {
                    i.prototype.postprocessStyle.call(this, t), this.animateSize(t)
                }, n.prototype.animateSize = function (t) {
                    var e = t.timeStamp, i = t.changes.newGraph, n = t.dtime, s = !1, o = this.style.fadeTime;
                    i = i || !(o > 0) || n > o;
                    var r = [], a = [];
                    if (i) {
                        for (var h = 0, l = this.nodes(); h < l.length; h++) {
                            var u = l[h];
                            u.removed ? (u.visibility = 0, r.push(u)) : u.targetHWidth !== u.hWidth && (u.added = !1, u.visibility = 1, u.hHeight = u.targetHHeight, u.hWidth = u.targetHWidth)
                        }
                        for (var c = 0, p = this.links(); c < p.length; c++) {
                            var d = p[c];
                            d.removed ? (d.visibility = 0, a.push(d)) : d.targetRadius !== d.currentRadius && (d.added = !1, d.visibility = 1, d.currentRadius = d.targetRadius)
                        }
                    } else {
                        for (var f = o > 0 ? Math.max(0, Math.pow(.2, n / o)) : 0, m = .01, h = 0, l = this.nodes(); h < l.length; h++) {
                            var u = l[h];
                            u.added === !0 && (u.added = e), u.added + o < e && (u.added = !1), u.removed === !0 && (u.removed = e), u.removed ? (s = !0, u.visibility = f, u.hHeight = u.hHeight * f, u.hWidth = u.hWidth * f, e - u.removed < o ? u.visibility = 1 - (e - u.removed) / o : r.push(u)) : (e - u.added < o ? (u.visibility = (e - u.added) / o, s = !0) : u.visibility = 1, u.targetHWidth !== u.hWidth && (s = !0, u.hHeight = u.hHeight * f + u.targetHHeight * (1 - f), u.hWidth = u.hWidth * f + u.targetHWidth * (1 - f), Math.abs(u.hHeight - u.targetHHeight) < m * u.targetHHeight && (u.hHeight = u.targetHHeight, u.hWidth = u.targetHWidth)))
                        }
                        for (var c = 0, p = this.links(); c < p.length; c++) {
                            var d = p[c];
                            d.added === !0 && (d.added = e), d.added + o < e && (d.added = !1), d.removed === !0 && (d.removed = e), d.removed ? (s = !0, d.currentRadius = d.currentRadius * f, e - d.removed < o ? d.visibility = 1 - (e - d.removed) / o : a.push(d)) : (e - d.added < o && !d.invisible ? (d.visibility = (e - d.added) / o, s = !0) : d.visibility = 1, d.targetRadius !== d.currentRadius && (s = !0, d.currentRadius = d.currentRadius * f + d.targetRadius * (1 - f), Math.abs(d.currentRadius - d.targetRadius) < m * d.targetRadius && (d.currentRadius = d.targetRadius)))
                        }
                    }
                    for (var g = 0; g < a.length; g++) {
                        var y = a[g];
                        this.deleteLink(y)
                    }
                    for (var v = 0; v < r.length; v++) {
                        var S = r[v];
                        this.deleteNode(S)
                    }
                    s && (t.changes.position = !0, t.animating = !0)
                }, n.prototype.paintPrepare = function (t) {
                    this.computeNodeRenderRadii(), this.multilinks = this.updateMultilinks(), (t.changes.position || this.hasTopologyChanges()) && this.placePies()
                }, n.prototype.paintSelection = function (e, i, n) {
                    var s = this.getGeometry(), o = s.txm, r = s.txa, a = s.tym, h = s.tya, l = s.zoom, u = e.context, c = this.style.selection, p = c.sizeProportional, d = c.sizeConstant;
                    u.beginPath();
                    for (var f = 0; f < i.length; f++) {
                        var m = i[f];
                        m.shape.adaptToViewport(o, r, a, h, l), m.shape.paintSelection(u, p, d)
                    }
                    for (var f = 0; f < n.length; f++) {
                        var g = n[f], y = (g.currentRadius * (1 + p) + d) * l, v = g.from, S = g.to, C = v.x * o + r, b = v.y * a + h, x = S.x * o + r, _ = S.y * a + h, w = C - x, L = b - _, T = 1 / Math.sqrt(w * w + L * L), M = w * T, P = L * T;
                        if (0 !== g.currentCenterOffset) {
                            var k = P * g.currentCenterOffset * l, D = -M * g.currentCenterOffset * l;
                            C += k, b += D, x += k, _ += D
                        }
                        M *= y, P *= y, u.moveTo(C + P, b - M), u.lineTo(C - P, b + M), u.lineTo(x - P, _ + M), u.lineTo(x + P, _ - M), u.closePath()
                    }
                    return t.Base.Graphics.paint(u, c)
                }, n.prototype.paintLinks = function (t, e) {
                    this.labelRenderer = t.labelRenderer;
                    var i = this.getGeometry();
                    return this.paintLinksImpl(t, e, this.multilinks, {
                        geometry: i,
                        paintDetails: i.zoom > this.style.linkDetailMinZoom
                    })
                }, n.prototype.paintNodes = function (t, e) {
                    this.labelRenderer = t.labelRenderer;
                    var i = this.getGeometry();
                    t.animating = this.paintNodesImpl(t, e, {
                            geometry: i,
                            paintDetails: i.zoom > this.style.nodeDetailMinZoom
                        }, t.timeStamp) || t.animating
                }, n.prototype.updateMultilinks = function () {
                    if (!this.hasTopologyChanges())return this.multilinks;
                    for (var t = this.links(), e = {}, i = 0; i < t.length; i++) {
                        var n = t[i], s = n.multiId;
                        if (e.hasOwnProperty(s)) {
                            var o = e[s];
                            o instanceof Array ? o.push(n) : e[s] = [o, n]
                        } else e[s] = n
                    }
                    return e
                }, n.prototype.getNodeImage = function (e) {
                    var i = this;
                    if (!e.image)return null;
                    var n = e.tintImage && e.fillColor, s = e.imageCropping, o = e.image, r = o;
                    if (n && (o += "##" + e.fillColor), this.imageCache.hasOwnProperty(o))return this.imageCache[o];
                    if (this.imageLoading[o])return null;
                    var a = function (r) {
                        return s && (r = t.Base.Graphics.cropImageToCircle(r, s)), n && (r = t.Base.Graphics.applyColorToImage(r, e.fillColor, !1)), i.imageCache[o] = r, delete i.imageLoading[o], i.events.notifySceneChanges({layout: !0}), r
                    }, h = this.scene.assetsLoader.getAssetImage(r);
                    return h ? a(h) : null
                }, n.prototype.computeNodeRenderRadii = function () {
                    for (var t = this.getGeometry().zoom, e = 0, i = this.nodes(); e < i.length; e++) {
                        var n = i[e], s = n.hHeight * t, o = n.hWidth * t;
                        n.lineWidth && (s += n.lineWidth / 2, o += n.lineWidth / 2), n.renderHheight = s, n.renderHwidth = o
                    }
                }, n.prototype.paintLinksImpl = function (e, i, n, s) {
                    var o = e.context, r = s.geometry.txm, a = s.geometry.txa, h = s.geometry.tym, l = s.geometry.tya, u = s.geometry.linkZoom, c = s.geometry.x0w, p = s.geometry.y0w, d = s.geometry.x1w, f = s.geometry.y1w, m = 1 / u, g = this.scaleNodesWithZoom ? 1 : 1 / this.scene.zoom;
                    o.textAlign = "center", o.textBaseline = "middle";
                    for (var y = this.style, v = y.linkDetailMinSize * y.linkDetailMinSize, S = s.paintDetails, C = y.multilinkSpacing * u, b = y.linkDecorationScale, x = y.linkDecorationMinSize, _ = y.linkLabelScaleBase, w = 2, L = 5, T = .1, M = 0; M < i.length; M++) {
                        var P = i[M];
                        if (!P.invisible) {
                            var k = P.from.x, D = P.from.y, I = P.to.x, A = P.to.y, B = P.currentItems, E = B && B.length && B[0].rotateWithLink, O = void 0, F = P.from.renderHheight, N = P.to.renderHheight, z = P.from.renderHwidth, R = P.to.renderHwidth, H = t.Base.Geometry.clipSegmentToBounds(k, D, I, A, (F + z) * g, (N + R) * g, c, p, d, f);
                            if (H) {
                                k = H[0], D = H[1], I = H[2], A = H[3], k = k * r + a, D = D * h + l, I = I * r + a, A = A * h + l;
                                var Z = I - k, U = A - D, W = Z * Z + U * U, V = Math.max(.25, P.currentRadius * u * .5), G = P.hovered || P.from.hovered || P.to.hovered, Y = G || S && W > v;
                                if (W > 25) {
                                    var j = Math.sqrt(W);
                                    if (E && (O = Math.atan2(U, Z) * (180 / Math.PI), k >= I && (O -= 180), P.currentItems[0].angle = O), P.toPieValue > 0) {
                                        var q = N + w, X = q + L + T * N;
                                        this.paintLinkPie(o, I, A, q, X, P.toPie0, P.toPie1, P.toPieColor), N = X
                                    }
                                    if (F + N > j)continue;
                                    var J = 1 / j, K = Z * J, Q = U * J, $ = void 0, te = void 0;
                                    if ($ = P.from.shape.distanceToEdge(F, z, K, Q), te = P.to.shape.distanceToEdge(N, R, -K, -Q), $ + te >= j)continue;
                                    var ee = Math.min((j - $ - te) / 4, Math.max(x, V * b));
                                    P.fromDecoration && ($ += ee), P.toDecoration && (te += ee), k += K * $, D += Q * $, I -= K * te, A -= Q * te, Z = I - k, U = A - D, j = j - $ - te, J = 1 / j;
                                    var ie = P.multiId, ne = n[ie];
                                    if (ne instanceof Array) {
                                        var se = ne.length, oe = Math.min(C * (se - 1), 1.5 * F, 1.5 * N), re = oe * (ne.indexOf(P) - (se - 1) / 2) / (se - 1);
                                        P.from.id > P.to.id && (re = -re), P.currentCenterOffset = re * m, k -= Q * re, I -= Q * re, D += K * re, A += K * re
                                    } else P.currentCenterOffset = 0;
                                    if (o.beginPath(), P.fromDecoration && this.paintLinkDecoration(o, k, D, K, Q, ee, P.fromDecoration, P.fillColor), P.toDecoration && this.paintLinkDecoration(o, I, A, -K, -Q, ee, P.toDecoration, P.fillColor), P.lineDash) {
                                        var ae = k + Q * V, he = D - K * V, le = k - Q * V, ue = D + K * V;
                                        if (P.lineDash.length > 0)for (var ce = P.lineDash, pe = ce.length, de = ce.reduce(function (t, e) {
                                                return t + e
                                            }) * u, fe = 0, me = 0; j / de >= me; me++) {
                                            for (var ge = 0; pe - 1 >= ge; ge += 2) {
                                                var ye = me * de + fe;
                                                if (ye > j - V)break;
                                                var ve = ye + ce[ge] * u, Se = ve >= j - V ? j - V : ve;
                                                o.moveTo(ae + ye * K, he + ye * Q), o.lineTo(le + ye * K, ue + ye * Q), o.lineTo(le + Se * K, ue + Se * Q), o.lineTo(ae + Se * K, he + Se * Q), o.closePath(), fe += u * (ce[ge] + ce[ge + 1])
                                            }
                                            fe = 0
                                        } else for (var Ce = Math.max(5, 3 * V), me = 0; j / Ce >= me; me += 2) {
                                            var ye = me * Ce, Se = Math.min((me + 1) * Ce, j);
                                            o.moveTo(ae + ye * K, he + ye * Q), o.lineTo(le + ye * K, ue + ye * Q), o.lineTo(le + Se * K, ue + Se * Q), o.lineTo(ae + Se * K, he + Se * Q), o.closePath()
                                        }
                                    } else o.moveTo(k + Q * V, D - K * V), o.lineTo(k - Q * V, D + K * V), o.lineTo(I - Q * V, A + K * V), o.lineTo(I + Q * V, A - K * V), o.closePath();
                                    if (P.renderPoints = {
                                            x0: k,
                                            y0: D,
                                            x1: I,
                                            y1: A
                                        }, P.renderBounds = new t.Base.Rect(k, D, I, A), t.Base.Graphics.fill(o, P), Y && P.currentItems && !P.removed) {
                                        var be = void 0, xe = void 0;
                                        G ? (be = t.Base.Helpers.toleranceMax(u, 1, .9), xe = t.Base.Helpers.toleranceMax(V / _, 1, .9)) : (be = u, xe = V / _), this.paintLinkItems(o, be, xe, k, D, K, Q, j, V, P.currentItems, P.renderBounds)
                                    }
                                } else if (P.fillColor) {
                                    if (o.beginPath(), o.lineWidth = Math.max(.1, 2 * V), o.strokeStyle = P.fillColor, P.dashed)for (var j = Math.sqrt(W), J = 1 / j, K = Z * J, Q = U * J, Ce = Math.max(5, 3 * V), me = 0; j / Ce >= me; me += 2) {
                                        var ye = me * Ce, Se = Math.min((me + 1) * Ce, j);
                                        o.moveTo(k + ye * K, D + ye * Q), o.lineTo(k + Se * K, D + Se * Q)
                                    } else o.moveTo(k, D), o.lineTo(I, A);
                                    o.stroke(), P.renderPoints = {
                                        x0: k,
                                        y0: D,
                                        x1: I,
                                        y1: A
                                    }, P.renderBounds = new t.Base.Rect(k, D, I, A)
                                }
                            }
                        }
                    }
                    return !1
                }, n.prototype.paintNodesImpl = function (i, n, s, o) {
                    var r = !1, a = i.context, h = s.geometry.txm, l = s.geometry.txa, u = s.geometry.tym, c = s.geometry.tya, p = s.geometry.zoom, d = s.geometry.x0s, f = s.geometry.x1s, m = s.geometry.y0s, g = s.geometry.y1s, y = 1 / h, v = s.paintDetails, S = this.style.nodeDetailMinSize * this.style.nodeDetailMinSize * y * y, C = this.style.hiddenLinks, b = this.style.nodeLabelScaleBase;
                    a.textAlign = "center", a.textBaseline = "middle", t.Base.Graphics.textStyle(a, this.style.nodeLabel);
                    for (var x = this.style.removedColor, _ = 0; _ < n.length; _++) {
                        var w = n[_];
                        if (w.data && !w.invisible) {
                            var L = w.shape;
                            if (L.adaptToViewport(h, l, u, c, p), null != w.anchorX && null != w.anchorY && w.anchorMode === e.NodeAnchorMode.Floating) {
                                var T = w.anchorX * h + l, M = w.anchorY * u + c, P = L.getAnchor(), k = L.x + P.x, D = L.y + P.y, I = k - T, A = D - M, B = D;
                                0 > A && (B = Math.max(B, M - A * Math.min(.3, Math.abs(I) / A))), a.beginPath(), a.moveTo(k, D), a.lineTo(k, B), a.lineTo(T, M), t.Base.Graphics.stroke(a, w.anchorStyle)
                            }
                        }
                    }
                    for (var _ = 0; _ < n.length; _++) {
                        var w = n[_], L = w.shape;
                        if (w.data && L.isInViewport(d, f, m, g, p)) {
                            var E = w.opacity, O = w.outerBounds.w(), F = w.outerBounds.h(), N = v && O * F > S || w.hovered;
                            if (1 > E && (a.globalAlpha = E), N && !w.removed) {
                                var z = w.dataLinksFiltered.length - w.links.length;
                                if (z > 0)if (w.relevance < 1) {
                                    var R = C.lineColor;
                                    C.lineColor = t.Base.Graphics.blendColors(x, R, w.relevance), this.paintHiddenLinks(a, w, L.x, L.y, L.r, L.w, z, C, C.size * p), C.lineColor = R
                                } else this.paintHiddenLinks(a, w, L.x, L.y, L.r, L.w, z, C, C.size * p)
                            }
                            if (L.paint(a, this.labelRenderer, N), N && !w.removed) {
                                var H = void 0, Z = void 0;
                                w.hovered ? (H = t.Base.Helpers.toleranceMax(p, 1, .9), Z = t.Base.Helpers.toleranceMin(b, L.r, .9)) : (H = p, Z = b), this.paintNodeDetails(w, L.x, L.y, L.w, L.r, H, Z, i)
                            }
                            1 > E && (a.globalAlpha = 1)
                        }
                    }
                    if (this.scene.settings.advanced.perNodeLoadingIndicator) {
                        var U = this.scene.settings.advanced.style.loadingArcStyle;
                        a.save(), a.lineCap = "round", a.lineWidth = U.lineWidth, a.strokeStyle = U.lineColor;
                        var W = o / 1400;
                        W = 2 * (W - Math.floor(W)) * Math.PI;
                        for (var V = W + Math.PI / 2, _ = 0; _ < n.length; _++) {
                            var w = n[_], L = w.shape;
                            if (w.loading || w.image && null === this.getNodeImage(w)) {
                                if (!L.isInViewport(d, f, m, g, p))continue;
                                r = !0, a.beginPath(), a.arc(L.x, L.y, L.r, W, V), a.stroke()
                            }
                        }
                        a.restore()
                    }
                    return r
                }, n.prototype.paintLinkDecoration = function (e, i, n, s, o, r, a, h) {
                    e.fillStyle = h, "circle" === a ? (e.moveTo(i + r, n), e.arc(i, n, r, 0, 2 * Math.PI, !0)) : "arrow" === a ? (e.moveTo(i - s * r, n - o * r), e.lineTo(i + s * r - o * r, n + o * r + s * r), e.lineTo(i + s * r + o * r, n + o * r - s * r)) : t.Base.Helpers.error("Unrecognized link decoration value. Valid values are 'circle' and 'arrow'.")
                }, n.prototype.paintLinkPie = function (e, i, n, s, o, r, a, h) {
                    var l = (s + o) / 2, u = o - s;
                    e.beginPath(), e.arc(i, n, l, r, a), t.Base.Graphics.paint(e, {
                        lineColor: h,
                        lineWidth: u
                    })
                }, n.prototype.paintLinkItems = function (t, e, i, n, s, o, r, a, h, l, u) {
                    for (var c = 0; c < l.length; c++) {
                        var p = l[c], d = p.x || 0, f = p.y || 0, m = p.px || 0, g = p.py || 0, y = p.lx || 0, v = p.ly || 0;
                        m = a * (m + 1) * .5 + y, g = g * h + v;
                        var S = n + o * m - r * g + d, C = s + r * m + o * g + f, b = 0;
                        b = p.scaleWithSize ? i : p.scaleWithZoom ? e : 1, this.labelRenderer.paint(t, S, C, b, p), u.addRect(p.currentBounds)
                    }
                }, n.prototype.paintHiddenLinks = function (t, e, i, n, s, o, r, a, h) {
                    var l, u, c = 2 * Math.PI;
                    if (e.links.length > 0) {
                        for (var p = 0, d = 0, f = 0; f < e.links.length; f++) {
                            var m = e.links[f];
                            p += m.otherEnd(e).x, d += m.otherEnd(e).y
                        }
                        p = e.x - p / e.links.length, d = e.y - d / e.links.length;
                        var g = 1 / Math.sqrt(p * p + d * d);
                        l = p * g, u = d * g
                    } else l = 1, u = 0;
                    var y = c / r / 3, v = Math.cos(-y * (r - 1) / 2), S = Math.sin(-y * (r - 1) / 2), C = l * v - u * S, b = l * S + u * v, x = C;
                    v = Math.cos(y), S = Math.sin(y), t.beginPath();
                    for (var _ = 1; r >= _; _++) {
                        var w = e.shape.distanceToEdge(s, o, x, b);
                        t.moveTo(i + x * w, n + b * w), t.lineTo(i + x * (w + h), n + b * (w + h)), C = x * v - b * S, b = x * S + b * v, x = C
                    }
                    t.strokeStyle = a.lineColor, t.lineWidth = a.lineWidth, t.stroke()
                }, n.prototype.findObjectAt = function (e, i, n) {
                    var s = this.scene, o = s.fromDisplay(e, i), r = o.x, a = o.y, h = 1 / s.zoom, l = this.scaleLinksWithZoom ? h : 1, u = null, c = [], p = null, d = n, f = s.hoverNode;
                    if (f && f.layer === this && !f.invisible) {
                        var m = f.shape.hitTest(r, a, h, d * h);
                        if (d > m / h) {
                            d = m / h, u = f;
                            var g = this.findItem(e, i, u, n);
                            if (g && (p = g.item, d = Math.min(d, g.distance)), 0 >= d)return {
                                object: u,
                                details: p
                            }
                        }
                    }
                    for (var y = this.nodes(), v = y.length - 1; v >= 0; v--) {
                        var S = y[v];
                        if (!S.removed && !S.invisible && t.Base.Geometry.distanceToRect(r - S.x, a - S.y, S.outerBounds) < d * h) {
                            var m = S.shape.hitTest(r, a, h, d * h);
                            if (0 >= m) {
                                d = 0, u = S;
                                break
                            }
                            d > m / h && (d = m / h, u = S), c.push(S)
                        }
                    }
                    if (d > 0) {
                        var C = s.hoverLink;
                        if (C && C.layer === this && !C.invisible) {
                            var b = C.targetRadius / 2 * l, x = C.renderPoints, _ = t.Base.Geometry.distanceToSegmentSq(x.x0, x.y0, x.x1, x.y1, e, i);
                            if ((d + b) * (d + b) >= _) {
                                d = 0, u = C;
                                var g = this.findItem(e, i, u, n);
                                if (g && (p = g.item, d = Math.min(d, g.distance)), 0 >= d)return {
                                    object: u,
                                    details: p
                                }
                            }
                        }
                    }
                    if (d > 0)for (var w = 0, L = this.links(); w < L.length; w++) {
                        var T = L[w], x = T.renderPoints;
                        if (!T.removed && !T.invisible && x && t.Base.Geometry.distanceToRect(e, i, T.renderBounds) < d) {
                            var b = T.targetRadius / l * 2, _ = t.Base.Geometry.distanceToSegmentSq(x.x0, x.y0, x.x1, x.y1, e, i), M = Math.min(d * d, b * b);
                            M > _ && (d = Math.sqrt(_), u = T), c.push(T)
                        }
                    }
                    if (0 === d) {
                        var g = this.findItem(e, i, u, n);
                        return {object: u, details: g ? g.item : null}
                    }
                    for (var v = 0; v < c.length; v++) {
                        var P = c[v], g = this.findItem(e, i, P, n);
                        g && g.distance < d && (d = g.distance, u = P, p = g.item)
                    }
                    return d > n && (u = null, p = null), {object: u, details: p}
                }, n.prototype.findItem = function (i, n, s, o) {
                    if (!s)return null;
                    var r = o * o, a = this.scene.hoverItem;
                    if (a && a.hwidth && s.currentItems.indexOf(a) > -1) {
                        var h = t.Base.Geometry.distanceToRect(i, n, a.currentBounds, !0);
                        if (r >= h)return {item: a, distance: Math.sqrt(h)}
                    }
                    var l = null, u = o * o;
                    if (s instanceof e.Node) {
                        var c = s.shape.currentLabel;
                        if (c && c.currentBounds) {
                            var h = t.Base.Geometry.distanceToRect(i, n, c.currentBounds, !0);
                            u > h && (l = c, u = h)
                        }
                    }
                    for (var p = 0; p < s.currentItems.length; p++) {
                        var d = s.currentItems[p];
                        if (d.hwidth) {
                            var h = t.Base.Geometry.distanceToRect(i, n, d.currentBounds, !0);
                            u >= h && (l = d, u = h)
                        }
                    }
                    return u > r || !l ? null : {item: l, distance: Math.sqrt(u)}
                }, n.prototype.getGraphBounds = function (e) {
                    if (void 0 === e && (e = this.nodes()), 0 === e.length)return new t.Base.Rect(0, 0, 0, 0);
                    for (var i = t.Base.Rect.createEmpty(), n = 0; n < e.length; n++) {
                        var s = e[n];
                        if (!s.removed) {
                            var o = s.x, r = s.y, a = s.outerBounds;
                            i.addBounds(a.x0 + o, a.y0 + r, a.x1 + o, a.y1 + r)
                        }
                    }
                    return i
                }, n.prototype.getNodeNeighborsBounds = function (e) {
                    var i = this.nodes();
                    if (0 === i.length)return new t.Base.Rect(0, 0, 0, 0);
                    for (var n = e.outerBounds.clone().moveBy(e.x, e.y), s = e, o = 0; o < e.links.length; o++) {
                        var r = e.links[o];
                        if (s = r.otherEnd(e), !s.removed) {
                            var a = s.outerBounds, h = s.x, l = s.y;
                            n.addBounds(a.x0 + h, a.y0 + l, a.x1 + h, a.y1 + l)
                        }
                    }
                    return n
                }, n.prototype.rotateNodes = function (e, i, n) {
                    for (var s, o = this.nodes(), r = Math.sin(n), a = Math.cos(n), h = 0; h < o.length; h++) {
                        var l = o[h];
                        s = t.Base.Geometry.rotateVector(l.x - e, l.y - i, r, a), l.x = e + s.x, l.y = i + s.y
                    }
                }, n.prototype.placePies = function () {
                    for (var t = 2 * Math.PI, e = [], i = 0, n = this.nodes(); i < n.length; i++) {
                        for (var s = n[i], o = 0, r = 0; r < s.links.length; r++) {
                            var a = s.links[r];
                            a.to === s && a.toPieValue > 0 && (o += a.toPieValue, e.push(a), a._angle = Math.atan2(a.to.y - a.from.y, a.to.x - a.from.x))
                        }
                        if (o > 0) {
                            e.sort(function (t, e) {
                                return t._angle - e._angle
                            });
                            for (var h = t / o, l = 0, u = 0, c = 0; c < e.length; c++) {
                                var p = e[c];
                                p.toPie0 = l, l += p.toPieValue * h, p.toPie1 = l;
                                var d = p._angle - (p.toPie0 + p.toPie1) / 2;
                                0 > d && (d += 2 * Math.PI), u += d
                            }
                            u /= e.length, u -= Math.PI;
                            for (var f = 0; f < e.length; f++) {
                                var m = e[f];
                                m.toPie0 += u, m.toPie1 += u
                            }
                            e = []
                        }
                    }
                }, n
            }(e.ItemsLayer);
            e.NodesLayer = i
        }(e = t.ItemsChart || (t.ItemsChart = {}))
    }(e = t.Internal || (t.Internal = {}))
}(ZoomCharts || (ZoomCharts = {}));
var ZoomCharts;
!function (t) {
    var e;
    !function (t) {
        var e;
        !function (t) {
            var e;
            !function (t) {
                var e = {}.hasOwnProperty, i = function () {
                    function t(t, e, i, n, s, o) {
                        null == o && (o = s), this.endAngle = n, this.startAngle = i, this.xSpacing = s, this.ySpacing = o, this.cy = e, this.cx = t
                    }

                    return t.prototype.getMainLinks = function (t) {
                        this.visitedNodes = {}, this.visitedNodes[t.id] = !0;
                        for (var e = {}, i = [t]; i.length > 0;) {
                            for (var n = [], s = 0; s < i.length; s++)for (var o = i[s], r = 0, a = this.getSublinks(o); r < a.length; r++) {
                                var h = a[r];
                                e[h.id] = !0, n.push(h.otherEnd(o))
                            }
                            i = n
                        }
                        return e
                    }, t.prototype.layoutGraph = function (t) {
                        return this.visitedNodes = {}, this.visitedNodes[t.id] = !0, this.subnodes = {}, this.radiuses = [], this.minAngle = {}, this.computeMaxRadius(t), this.placeNodeRec(t, 0, this.startAngle, this.endAngle - this.startAngle)
                    }, t.prototype.getSubnodes = function (t) {
                        var i = t.id;
                        if (this.subnodes[i])return this.subnodes[i];
                        for (var n = [], s = 0; s < t.links.length; s++) {
                            var o = t.links[s], r = o.otherEnd(t);
                            e.call(this.visitedNodes, r.id) || (n.push(r), this.visitedNodes[r.id] = !0)
                        }
                        return this.subnodes[i] = n, n
                    }, t.prototype.getSublinks = function (t) {
                        for (var i = [], n = 0; n < t.links.length; n++) {
                            var s = t.links[n];
                            if (!s.removed) {
                                var o = s.otherEnd(t);
                                e.call(this.visitedNodes, o.id) || (i.push(s), this.visitedNodes[o.id] = !0)
                            }
                        }
                        return i
                    }, t.prototype.getNodeSize = function (t) {
                        var e = t.bounds;
                        return Math.max(e.w(), e.h()) * t.visibility
                    }, t.prototype.computeMaxRadius = function (t) {
                        var e = this.xSpacing, i = 0;
                        this.radiuses[0] = i;
                        for (var n = 1, s = [t]; s.length > 0;) {
                            for (var o = 0, r = 0, a = [], h = 0; h < s.length; h++) {
                                t = s[h];
                                for (var l = this.getNodeSize(t), u = 0, c = this.getSubnodes(t); u < c.length; u++) {
                                    var p = c[u], d = this.getNodeSize(p);
                                    o = Math.max(o, d + l), r += e + d, a.push(p)
                                }
                            }
                            var f = Math.max(i + .5 * o + e, r / (2 * Math.PI));
                            this.radiuses[n] = f, i = f, s = a, n += 1
                        }
                    }, t.prototype.computeMinAngle = function (t, i) {
                        var n = t.id;
                        if (e.call(this.minAngle, n))return this.minAngle[n];
                        for (var s = this.xSpacing, o = this.radiuses[i], r = this.getNodeSize(t), a = (r + s) / o, h = 0, l = 0, u = this.getSubnodes(t); l < u.length; l++) {
                            var c = u[l];
                            h += this.computeMinAngle(c, i + 1)
                        }
                        return a = Math.max(a, h), this.minAngle[n] = a, a
                    }, t.prototype.placeNodeRec = function (t, e, i, n) {
                        var s = i + .5 * n, o = this.radiuses[e];
                        t.x = this.cx + o * Math.cos(s), t.y = this.cy + o * Math.sin(s);
                        var r = this.getSubnodes(t);
                        if (r.length > 0) {
                            for (var a = 0, h = 0; h < r.length; h++) {
                                var l = r[h];
                                a += this.computeMinAngle(l, e + 1)
                            }
                            for (var u = n / a, c = i, h = 0; h < r.length; h++) {
                                var l = r[h], p = this.computeMinAngle(l, e + 1) * u;
                                this.placeNodeRec(l, e + 1, c, p), c += p
                            }
                        }
                    }, t
                }();
                t.RadialLayout = i
            }(e = t.Layouts || (t.Layouts = {}))
        }(e = t.ItemsChart || (t.ItemsChart = {}))
    }(e = t.Internal || (t.Internal = {}))
}(ZoomCharts || (ZoomCharts = {}));
var ZoomCharts;
!function (t) {
    var e;
    !function (t) {
        var e;
        !function (t) {
            var e;
            !function (t) {
                function e(t) {
                    if (0 === t.children.length)return 0;
                    var e = t.children[0], i = t.children[t.children.length - 1];
                    return (e.node.x - e.hWidth + (i.node.x + i.hWidth)) / 2
                }

                function i(t, e, i, n, s) {
                    var o = null === e ? 0 : e.levelIndex + 1, r = null === i ? t.length : i.levelIndex;
                    if (s)for (var a = null === e ? 0 : e.node.x + e.hWidth + n, h = o; r > h; h++) {
                        var l = t[h];
                        a += l.hWidth, l.node.x = a, a += l.hWidth + n
                    } else for (var a = null === i ? 0 : i.node.x - i.hWidth - n, h = r - 1; h >= o; h--) {
                        var l = t[h];
                        a -= l.hWidth, l.node.x = a, a -= l.hWidth + n
                    }
                }

                var n = {}.hasOwnProperty, s = function () {
                    function t(t, e) {
                        this.children = [], this.parent = null, this.shift = 0, this.node = t, this.level = e, this.hWidth = t.outerBounds.w() / 2
                    }

                    return t
                }(), o = function () {
                    function t(t, e) {
                        this.ySpacing = null === e ? t : e, this.xSpacing = t
                    }

                    return t.prototype.layoutGraph = function (t) {
                        this.layoutNodes(this.wrapNodes(t))
                    }, t.prototype.wrapNodes = function (t) {
                        if (null === t)return null;
                        var e = {}, i = [new s(t, 0)], o = 0, r = 0;
                        e[t.id] = i[0];
                        for (var a = 0; a < i.length; a++)for (var h = i[a], l = h.node, u = 0; u < l.links.length; u++) {
                            var c = l.links[u];
                            if (c.to === l) {
                                var p = void 0;
                                n.call(e, c.from.id) ? p = e[c.from.id] : (p = new s(c.from, h.level - 1), o === h.level && o--, e[c.from.id] = p, i.push(p)), null === h.parent && h.level === p.level + 1 && (h.parent = p, p.children.push(h))
                            } else {
                                var p = void 0;
                                n.call(e, c.to.id) ? p = e[c.to.id] : (p = new s(c.to, h.level + 1), r === h.level && r++, e[c.to.id] = p, i.push(p)), null === p.parent && p.level === h.level + 1 && (h.children.push(p), p.parent = h)
                            }
                        }
                        for (var d = new Array(r - o + 1), a = 0; a < d.length; a++)d[a] = [];
                        for (var a = 0; a < i.length; a++) {
                            var h = i[a];
                            h.level -= o, null === h.parent && (h.levelIndex = d[h.level].length, d[h.level].push(h))
                        }
                        for (var f = 0; f < d.length; f++)for (var m = d[f], g = 0; g < m.length; g++)for (var y = m[g], v = 0; v < y.children.length; v++) {
                            var S = f + 1, C = y.children[v];
                            C.level = S, C.levelIndex = d[S].length, d[S].push(C)
                        }
                        return d
                    }, t.prototype.layoutNodes = function (t) {
                        if (null !== t) {
                            i(t[t.length - 1], null, null, this.xSpacing, !0);
                            for (var n = t.length - 2; n >= 0; n--) {
                                for (var s = t[n], o = null, r = void 0, a = 0, h = 0; h < s.length; h++) {
                                    if (s[h].children.length > 0) {
                                        r = s[h];
                                        break
                                    }
                                    a += s[h].node.bounds.w()
                                }
                                if (a += this.xSpacing * r.levelIndex + r.hWidth, r.node.x = e(r), r.levelIndex > 0) {
                                    var l = s[r.levelIndex - 1], u = l.node.x + l.hWidth + this.xSpacing + r.hWidth;
                                    u > r.node.x && (r.shift = u - r.node.x, r.node.x += r.shift)
                                }
                                for (i(s, null, r, this.xSpacing, !1); ;) {
                                    o = r, r = null;
                                    for (var h = o.levelIndex + 1; h < s.length; h++)if (s[h].children.length > 0) {
                                        r = s[h];
                                        break
                                    }
                                    if (null === r)break;
                                    r.node.x = e(r) + o.shift, r.shift = o.shift;
                                    for (var c = 0, h = o.levelIndex + 1; h < r.levelIndex; h++)c += s[h].node.bounds.w();
                                    var p = o.hWidth + r.hWidth + c + (r.levelIndex - o.levelIndex) * this.xSpacing, d = r.node.x - o.node.x;
                                    if (p > d) {
                                        var f = p - d;
                                        r.node.x += f, r.shift += f, d = p, i(s, o, r, this.xSpacing, !0)
                                    } else if (o.parent === r.parent) {
                                        var m = (d - o.hWidth - r.hWidth - c) / (r.levelIndex - o.levelIndex);
                                        i(s, o, r, m, !0)
                                    } else {
                                        for (var g = null, y = null, h = o.levelIndex + 1; h <= r.levelIndex; h++)if (s[h].parent !== o.parent) {
                                            g = s[h];
                                            break
                                        }
                                        for (var h = r.levelIndex - 1; h >= o.levelIndex; h--)if (s[h].parent !== r.parent) {
                                            y = s[h];
                                            break
                                        }
                                        if (i(s, o, g, this.xSpacing, !0), i(s, y, r, this.xSpacing, !1), g.levelIndex !== y.levelIndex - 1) {
                                            var v = s[g.levelIndex - 1], S = s[y.levelIndex + 1], m = (r.node.x - o.node.x - r.hWidth - o.hWidth - c - this.xSpacing * (v.levelIndex - o.levelIndex + r.levelIndex - S.levelIndex)) / (S.levelIndex - v.levelIndex);
                                            i(s, v, S, m, !0)
                                        }
                                    }
                                }
                                i(s, o, null, this.xSpacing, !0)
                            }
                            for (var C = 0, n = 0; n < t.length; n++) {
                                for (var s = t[n], b = 0, h = 0; h < s.length; h++)b = Math.max(b, s[h].node.outerBounds.h());
                                C += b / 2;
                                for (var h = 0; h < s.length; h++) {
                                    var x = s[h];
                                    x.node.y = C;
                                    for (var _ = 0; _ < x.children.length; _++) {
                                        var w = x.children[_];
                                        w.node.x += x.shift, w.shift += x.shift
                                    }
                                }
                                C += b / 2 + this.ySpacing
                            }
                        }
                    }, t.prototype.getMainLinks = function (t) {
                        if (null === t)return null;
                        var e = {}, i = {}, s = [t];
                        i[t.id] = 0;
                        for (var o = 0; o < s.length; o++)for (var r = s[o], a = i[r.id], h = 0; h < r.links.length; h++) {
                            var l = r.links[h];
                            l.to === r ? n.call(i, l.from.id) ? i[l.from.id] < a && (e[l.id] = !0) : (s.push(l.from), i[l.from.id] = a - 1, e[l.id] = !0) : n.call(i, l.to.id) ? i[l.to.id] > a && (e[l.id] = !0) : (s.push(l.to), i[l.to.id] = a + 1, e[l.id] = !0)
                        }
                        return e
                    }, t
                }();
                t.HierarchyLayout = o
            }(e = t.Layouts || (t.Layouts = {}))
        }(e = t.ItemsChart || (t.ItemsChart = {}))
    }(e = t.Internal || (t.Internal = {}))
}(ZoomCharts || (ZoomCharts = {}));
var ZoomCharts;
!function (t) {
    var e;
    !function (t) {
        var e;
        !function (e) {
            var i = function () {
                function t() {
                    this.mode = "dynamic", this._currentMode = "dynamic", this.nodeSpacing = 16, this.rowSpacing = null, this.incrementalLayoutMaxTime = 300, this.initialLayoutMaxTime = 2e3, this.layoutFreezeTimeout = 1e4, this.layoutFreezeMinTimeout = 1500, this.aspectRatio = !1, this.globalLayoutOnChanges = !0, this.advanced = {adaptiveFreezeTreshold: 1.2}
                }

                return t
            }();
            e.SettingsLayout = i;
            var n = function (e) {
                function i(i) {
                    e.call(this), this.idleSince = 0, this.noMovementSince = 0, this.layoutMovement = 0, this.animationOrder = 600, this.paintOrder = 10, this.updateOrder = 1600, this.chart = i, this.scene = i.scene, this.settings = this.scene.settings.layout, this.layer = this.chart.layer, this.random = new t.Base.Random(1), this.springs = new t.ItemsChart.Layouts.TimedSpringEmbedder(this.random)
                }

                return __extends(i, e), i.prototype.onSceneChange = function (t) {
                    (t.changes.settingsChanges && t.changes.settingsChanges.layout || t.changes.navigation || this.layer.hasTopologyChanges()) && this.updateBackgroundLinks()
                }, i.prototype.doAnimations = function (e) {
                    var i = this.settings.layoutFreezeTimeout, n = this.settings.layoutFreezeMinTimeout, s = this.layer.hasTopologyChanges(), o = this.layer.hasStyleChanges(), r = e.dtime;
                    (0 === this.idleSince || e.animating || s || e.changes.coordinates || e.changes.layout || e.changes.bounds) && (this.idleSince = e.timeStamp, this.noMovementSince = 0);
                    var a = !1;
                    if ("radial" === this.settings._currentMode || "hierarchy" === this.settings._currentMode) this.layoutMovement = this.doRadialLayout(s || e.changes.layout, o, 0, !1, !1), a = !0; else {
                        var h = {}, l = !1, u = "dynamic" === this.settings._currentMode, c = 1;
                        if (s) {
                            this.random = new t.Base.Random(1);
                            var p = this.placeNewNodes();
                            h = p.newNodes, l = p.majorChanges, a = !0
                        } else if (u) {
                            var d = e.timeStamp - this.idleSince;
                            if (this.layoutMovement < this.settings.advanced.adaptiveFreezeTreshold)if (0 !== this.noMovementSince) {
                                var f = e.timeStamp - this.noMovementSince;
                                c = Math.min((n - f) / n, c)
                            } else this.noMovementSince = e.timeStamp;
                            c = Math.min((i - d) / n, c)
                        }
                        if (c > 0) {
                            var m = l ? this.settings.initialLayoutMaxTime : this.settings.incrementalLayoutMaxTime;
                            this.layoutMovement = this.doForceLayout(r * c, s || e.changes.layout, o, h, m, l, u), e.animating = !0, a = !0
                        }
                    }
                    a && (e.changes.position = !0)
                }, i.prototype.resetLayout = function () {
                    this.random = new t.Base.Random(1), this.springs.random = this.random;
                    for (var e = {}, i = 0, n = this.layer.nodes(); i < n.length; i++) {
                        var s = n[i];
                        e[s.id] = s, s.x = 0, s.y = 0, s.userLock = !1
                    }
                    this.doLayout(0, 1, !0, !0, e, 1e4, !0), this.idleSince = 0
                }, i.prototype.placeNewNodes = function () {
                    for (var t = {}, e = !1, i = 0, n = this.layer.nodes(); i < n.length; i++) {
                        var s = n[i];
                        (null === s.x || null === s.y) && (t[s.id] = !0)
                    }
                    for (var i = 0, n = this.layer.nodes(); i < n.length; i++) {
                        var s = n[i], o = 1;
                        if (t.hasOwnProperty(s.id)) {
                            var r = 0, a = 0, h = 0;
                            o = 1;
                            for (var l = void 0, u = 0; u < s.links.length; u++) {
                                var c = s.links[u], p = c.otherEnd(s);
                                t.hasOwnProperty(p.id) || (l = p, a += p.x, h += p.y, r += 1)
                            }
                            var d = void 0, f = void 0;
                            if (r > 1) d = a / r, f = h / r, o = .5; else if (1 === r) {
                                for (var m = 0, g = 0, y = 0, u = 0; u < l.links.length; u++) {
                                    var c = l.links[u], v = c.otherEnd(l);
                                    v === s || t.hasOwnProperty(v.id) || (g += v.x - l.x, y += v.y - l.y, m += 1)
                                }
                                if (m > 0) {
                                    var S = Math.sqrt(g * g + y * y);
                                    if (S > 0) {
                                        var C = 1 / (S * m);
                                        g *= C, y *= C, d = l.x - g * l.hHeight * 1.2, f = l.y - y * l.hHeight * 1.2, o = .2
                                    } else d = l.x, f = l.y
                                } else e = !0, d = l.x, f = l.y
                            } else e = !0, d = 0, f = 0;
                            s.x = d + (this.random.get() - .5) * o * (s.hHeight + 1), s.y = f + (this.random.get() - .5) * o * (s.hHeight + 1)
                        }
                    }
                    return {newNodes: t, majorChanges: e}
                }, i.prototype.doLayout = function (t, e, i, n, s, o, r, a) {
                    return void 0 === r && (r = !1), void 0 === a && (a = !0), "radial" === this.settings._currentMode || "hierarchy" === this.settings._currentMode ? this.doRadialLayout(i, n, o, r, a) : this.doForceLayout(e, i, n, s, o, r, a)
                }, i.prototype.updateBackgroundLinks = function () {
                    var e = this.layer.links(), i = this.layer.nodes();
                    if ("radial" === this.settings._currentMode || "hierarchy" === this.settings._currentMode) {
                        var n;
                        n = this.scene.lastFocusNode ? this.scene.lastFocusNode : i[0];
                        var s = {};
                        n && (s = ("radial" === this.settings._currentMode ? new t.ItemsChart.Layouts.RadialLayout(0, 0, 0, 0, 0, 0) : new t.ItemsChart.Layouts.HierarchyLayout(0, 0)).getMainLinks(n));
                        for (var o = 0; o < e.length; o++) {
                            var r = e[o], a = !s.hasOwnProperty(r.id);
                            r.background !== a && (r.background = a, this.layer.touchLink(r))
                        }
                    } else for (var o = 0; o < e.length; o++) {
                        var r = e[o];
                        r.background && (r.background = !1, this.layer.touchLink(r))
                    }
                }, i.prototype.doRadialLayout = function (e, i, n, s, o) {
                    void 0 === s && (s = !1), void 0 === o && (o = !0);
                    for (var r = this.layer.nodes(), a = 0; a < r.length; a++) {
                        var h = r[a];
                        h.locked = h.userLock || h.locks > 0
                    }
                    var l;
                    if (l = this.scene.lastFocusNode ? this.scene.lastFocusNode : r[0]) {
                        var u;
                        switch (this.settings._currentMode) {
                            case"radial":
                                u = new t.ItemsChart.Layouts.RadialLayout(0, 0, .5 * -Math.PI, 1.5 * Math.PI, this.settings.nodeSpacing, this.settings.rowSpacing);
                                break;
                            case"hierarchy":
                                u = new t.ItemsChart.Layouts.HierarchyLayout(this.settings.nodeSpacing, this.settings.rowSpacing);
                                break;
                            default:
                                throw new Error("Layout mode '" + this.settings._currentMode + "' is not supported.")
                        }
                        u.layoutGraph(l)
                    }
                    return 0
                }, i.prototype.doForceLayout = function (e, i, n, s, o, r, a) {
                    var h = (this.scene.width + 1) / (this.scene.height + 1);
                    h > 0 || (h = null);
                    for (var l = this.scene.settings.layout.aspectRatio ? h : null, u = this.settings.nodeSpacing, c = 1, p = this.layer.nodes(), d = !1, f = !1, m = 0; m < p.length; m++) {
                        var g = p[m];
                        g.locked = g.userLock || g.locks > 0, f = f || g.locked, d = d || 1 !== g.visibility
                    }
                    for (var y = {}, v = [], S = 0, C = this.layer.links(); S < C.length; S++) {
                        var b = C[S], x = b.multiId, _ = b.targetStrength, w = b.targetLength, L = b.visibility;
                        if (b.removed || b.added) {
                            var T = b.from.links.length > 1 && b.to.links.length > 1, M = void 0;
                            M = T || b.removed ? .2 : _, b.added && (w = .2 + (w - .2) * L, _ = _ * L + M * (1 - L))
                        }
                        if (y.hasOwnProperty(x)) {
                            var P = y[x];
                            P.strength = Math.max(_, P.strength), P.length = Math.max(w, P.length), P.visibility = Math.max(L, P.visibility)
                        } else {
                            var P = {
                                from: b.from,
                                to: b.to,
                                strength: _,
                                length: w,
                                visibility: L,
                                direction: b.direction
                            };
                            y[x] = P, v.push(P)
                        }
                    }
                    if (this.springs.updateParams(u, c, l), r || t.Base.Helpers.hasProperties(s)) {
                        for (var m = 0; m < p.length; m++) {
                            var g = p[m];
                            g.locked = g.locked || !s.hasOwnProperty(g.id)
                        }
                        this.springs.updateGraph(p, v, i), r || this.scene.settings.layout.globalLayoutOnChanges ? (this.springs.updateParams(u, c, h), this.springs.globalLayout(p, o, r && !f), this.springs.updateParams(u, c, l)) : this.springs.timedLayout(p, .001 * e)
                    }
                    if (a || d) {
                        if (!a)for (var m = 0; m < p.length; m++) {
                            var g = p[m];
                            g.locked = g.locked || !g.removed && !g.added
                        }
                        this.springs.updateGraph(p, v, i), this.springs.timedLayout(p, .001 * e)
                    }
                    return this.springs.stability
                }, i
            }(t.Base.ChartElement);
            e.Layout = n
        }(e = t.NetChart || (t.NetChart = {}))
    }(e = t.Internal || (t.Internal = {}))
}(ZoomCharts || (ZoomCharts = {}));
var ZoomCharts;
!function (t) {
    var e;
    !function (t) {
        var e;
        !function (t) {
            var e;
            !function (e) {
                e.ToolbarItemNames.fullscreen = function (e, i) {
                    return new t.Bar.ToggleButton(e, {
                        label: e.settings.localization.toolbar.fullscreenButton,
                        title: e.settings.localization.toolbar.fullscreenTitle,
                        cssClass: "DVSL-bar-btn-fullscreen",
                        cssClassEnabled: "DVSL-bar-btn-fullscreen-active",
                        showLabels: i.showLabels,
                        onEnable: function () {
                            return e.setFullscreen(!0)
                        },
                        onDisable: function () {
                            return e.setFullscreen(!1)
                        },
                        getChartState: function () {
                            return e.isFullscreen()
                        }
                    })
                }
            }(e = t.Bar || (t.Bar = {}))
        }(e = t.Base || (t.Base = {}))
    }(e = t.Internal || (t.Internal = {}))
}(ZoomCharts || (ZoomCharts = {}));
var ZoomCharts;
!function (t) {
    var e;
    !function (t) {
        var e;
        !function (t) {
            var e;
            !function (e) {
                e.ToolbarItemNames.back = function (e, i) {
                    return new t.Bar.UserButton(e, {
                        label: e.settings.localization.toolbar.backButton,
                        cssClass: "DVSL-bar-btn-back",
                        title: e.settings.localization.toolbar.backTitle,
                        showLabels: i.showLabels,
                        onClick: function () {
                            return e.back(!0, "user")
                        }
                    })
                }
            }(e = t.Bar || (t.Bar = {}))
        }(e = t.Base || (t.Base = {}))
    }(e = t.Internal || (t.Internal = {}))
}(ZoomCharts || (ZoomCharts = {}));
var ZoomCharts;
!function (t) {
    var e;
    !function (t) {
        var e;
        !function (e) {
            var i;
            !function (i) {
                var n = function (e) {
                    function i(i, n) {
                        var s = this;
                        e.call(this, i), this.options = n, this.chart = i, this.scene = i.scene, this.events = i.events, this.scrolling = this.chart.scrolling;
                        var o = t.Base.Helpers.createDom("li", null, null, null), r = t.Base.Helpers.createDom("span", "DVSL-NC-zoom", null, o);
                        this.handle = t.Base.Helpers.createDom("em", null, null, r), this.mouse = new t.Base.MouseEvents(o, this.scene.settings.advanced.pointer), this.mouse.listen("drag", function (t) {
                            return s.zoomMove(t)
                        }), this.mouse.listen("down", function (t) {
                            return s.zoomDown(t)
                        }), this.domElement = o
                    }

                    return __extends(i, e), i.prototype.zoomDown = function (t) {
                        t.y < 100 && this.zoomMove(t)
                    }, i.prototype.zoomMove = function (t) {
                        var e = t.y - 10;
                        e = Math.max(0, Math.min(80, e)), this.handle.style.top = e + "px";
                        var i = this.getZoomValue(e / 80);
                        this.chart.autoZoom.manualZoom(i / this.scene.zoom), this.events.notifySceneChanges({position: !0}), t.consumed = !0
                    }, i.prototype.getSliderPosition = function () {
                        var t = this.scene.settings.interaction.zooming.zoomExtent, e = t[0], i = t[1], n = Math.log(Math.max(e, Math.min(i, this.scene.zoom)));
                        return e = Math.log(e), i = Math.log(i), 1 - (n - e) / (i - e)
                    }, i.prototype.getZoomValue = function (t) {
                        var e = this.scene.settings.interaction.zooming.zoomExtent, i = e[0], n = e[1];
                        i = Math.log(i), n = Math.log(n);
                        var s = (1 - t) * (n - i) + i;
                        return Math.exp(s)
                    }, i.prototype.doAnimations = function () {
                        var t = this.getSliderPosition();
                        return this.handle.style.top = 80 * t + "px"
                    }, i.prototype.remove = function () {
                        return this.mouse.remove()
                    }, i
                }(t.Base.Bar.Item);
                i.ZoomControl = n, t.Base.Bar.ToolbarItemNames.zoomcontrol = function (t, i) {
                    return new e.Bar.ZoomControl(t, i)
                }
            }(i = e.Bar || (e.Bar = {}))
        }(e = t.NetChart || (t.NetChart = {}))
    }(e = t.Internal || (t.Internal = {}))
}(ZoomCharts || (ZoomCharts = {}));
var ZoomCharts;
!function (t) {
    var e;
    !function (t) {
        var e;
        !function (e) {
            var i;
            !function (e) {
                t.Base.Bar.ToolbarItemNames.rearrange = function (e, i) {
                    return new t.Base.Bar.UserButton(e, {
                        label: e.settings.localization.toolbar.rearrangeButton,
                        cssClass: "DVSL-bar-btn-rearrange",
                        title: e.settings.localization.toolbar.rearrangeTitle,
                        showLabels: i.showLabels,
                        onClick: function () {
                            return e.resetLayout()
                        }
                    })
                }, t.Base.Bar.ToolbarItemNames.freeze = function (e, i) {
                    return new t.Base.Bar.ToggleButton(e, {
                        label: e.settings.localization.toolbar.freezeButton,
                        cssClass: "DVSL-bar-btn-lock-all",
                        cssClassEnabled: "DVSL-bar-btn-lock-all-active",
                        title: e.settings.localization.toolbar.freezeTitle,
                        titleActive: e.settings.localization.toolbar.unfreezeTitle,
                        showLabels: i.showLabels,
                        getChartState: function () {
                            return "static" === e.scene.settings.layout._currentMode
                        },
                        onEnable: function () {
                            e.scene.settings.layout._currentMode = "static", e.events.notifySceneChanges({layout: !0})
                        },
                        onDisable: function () {
                            e.scene.settings.layout._currentMode = e.scene.settings.layout.mode, e.events.notifySceneChanges({layout: !0})
                        }
                    })
                }, t.Base.Bar.ToolbarItemNames.fit = function (e, i) {
                    return new t.Base.Bar.ToggleButton(e, {
                        label: e.settings.localization.toolbar.fitButton,
                        cssClass: "DVSL-bar-btn-fit",
                        cssClassEnabled: "DVSL-bar-btn-fit-active",
                        title: e.settings.localization.toolbar.fitTitle,
                        showLabels: i.showLabels,
                        getChartState: function () {
                            return "overview" === e.scene.autoZoomMode
                        },
                        onEnable: function () {
                            return e.autoZoom.setZoom("overview")
                        },
                        onDisable: function () {
                            return e.autoZoom.setZoom("auto")
                        }
                    })
                };
                var i = function (e) {
                    function i() {
                        e.call(this), this.enabled = !0, this.side = "bottom", this.align = "left", this.showLabels = !1, this.items = [new t.Base.SettingsToolbarItem("fit"), new t.Base.SettingsToolbarItem("rearrange"), new t.Base.SettingsToolbarItem("freeze"), new t.Base.SettingsToolbarItem("back"), new t.Base.SettingsToolbarItem("fullscreen"), new t.Base.SettingsToolbarItem("zoomcontrol", "bottom", "left")]
                    }

                    return __extends(i, e), i
                }(t.Base.SettingsToolbar);
                e.SettingsToolbar = i;
                var n = function (t) {
                    function e() {
                        t.apply(this, arguments), this.rearrangeButton = "Rearrange", this.rearrangeTitle = "Rearrange elements", this.freezeButton = "Freeze", this.freezeTitle = "Lock all", this.unfreezeTitle = "Unlock all", this.fitButton = "Fit", this.fitTitle = "Fit to screen"
                    }

                    return __extends(e, t), e
                }(t.Base.SettingsLocalizationToolbar);
                e.SettingsLocalizationToolbar = n
            }(i = e.Bar || (e.Bar = {}))
        }(e = t.NetChart || (t.NetChart = {}))
    }(e = t.Internal || (t.Internal = {}))
}(ZoomCharts || (ZoomCharts = {}));
var ZoomCharts;
!function (t) {
    var e;
    !function (t) {
        var e;
        !function (e) {
            var i = function (i) {
                function r(a) {
                    i.call(this, t.Base.SettingsMapping.NetChartSettings), this.theme = r.FlatTheme, this.data = [], this.area = new s, this.style = new t.ItemsChart.SettingsNodesLayerStyle, this.layout = new e.SettingsLayout, this.filters = {
                        nodeFilter: null,
                        linkFilter: null,
                        nodeLinksProcessor: null,
                        multilinkProcessor: null
                    }, this.interaction = new o, this.navigation = new e.SettingsNavigation, this.nodeMenu = new t.ItemsChart.SettingsNodeMenu(["hide", "expand", "focus", "lock"]), this.toolbar = new e.Bar.SettingsToolbar, this.localization = new n, this.legend = new e.SettingsLegend, this.apply(a), this._initializing = !1
                }

                return __extends(r, i), r.prototype.apply = function (t) {
                    this.applyCompatibility(t, [{
                        from: "navigation.nodeExpansionRadius",
                        to: "navigation.focusNodeExpansionRadius"
                    }]);
                    var e = i.prototype.apply.call(this, t);
                    return e.layout && e.layout.mode && (this.layout._currentMode = this.layout.mode), e
                }, r.FlatTheme = {advanced: {themeCSSClass: "DVSL-flat"}}, r.DarkTheme = {
                    advanced: {themeCSSClass: "DVSL-dark"},
                    area: {style: {fillColor: "rgba(28,26,28,1)"}},
                    title: {margin: 15, style: {fillColor: "#A8A7A8"}},
                    legend: {text: {fillColor: "#A8A7A8"}},
                    style: {
                        link: {fillColor: "#4C4C4C"},
                        linkHovered: {shadowColor: "#fff"},
                        hiddenLinks: {lineColor: "#A8A7A8"},
                        nodeHovered: {
                            shadowColor: "#fff",
                            shadowOffsetY: 0,
                            shadowBlur: 12
                        },
                        nodeLabel: {
                            padding: 1,
                            backgroundStyle: {lineColor: null, fillColor: "#333333"},
                            textStyle: {fillColor: "#A8A7A8"}
                        },
                        linkLabel: {
                            padding: .6,
                            backgroundStyle: {lineColor: "#A8A7A8", fillColor: "#333333"},
                            textStyle: {fillColor: "#A8A7A8"}
                        },
                        selection: {
                            shadowColor: "rgba(255,255,255,0.6)",
                            sizeConstant: 4,
                            shadowBlur: 24,
                            shadowOffsetY: 4
                        }
                    }
                }, r
            }(t.ItemsChart.Settings);
            e.Settings = i;
            var n = function (t) {
                function i() {
                    t.apply(this, arguments), this.toolbar = new e.Bar.SettingsLocalizationToolbar, this.menu = {
                        dynaminc: "Dynamic",
                        fixed: "Fixed",
                        focus: "Focus",
                        unfocus: "Unfocus",
                        collapse: "Collapse",
                        expand: "Expand",
                        hide: "Hide"
                    }
                }

                return __extends(i, t), i
            }(t.Base.SettingsLocalization);
            e.SettingsLocalization = n;
            var s = function (t) {
                function e() {
                    t.apply(this, arguments), this.centerX = .5, this.centerY = .5, this.paddingTop = 0, this.paddingLeft = 0, this.paddingRight = 0, this.paddingBottom = 0
                }

                return __extends(e, t), e
            }(t.Base.SettingsArea);
            e.SettingsArea = s;
            var o = function (t) {
                function e() {
                    t.apply(this, arguments), this.zooming = new a, this.selection = new r, this.rotation = {fingers: !1}
                }

                return __extends(e, t), e
            }(t.ItemsChart.SettingsInteraction);
            e.SettingsInteraction = o;
            var r = function (t) {
                function e() {
                    t.apply(this, arguments)
                }

                return __extends(e, t), e
            }(t.ItemsChart.SettingsInteractionSelection);
            e.SettingsInteractionSelection = r;
            var a = function (t) {
                function e() {
                    t.apply(this, arguments), this.initialAutoZoom = "overview", this.zoomExtent = [.5, 4], this.autoZoomExtent = [.5, 1], this.autoZoomSize = .98, this.autoZoomPositionEllasticity = 2.5e-7
                }

                return __extends(e, t), e
            }(t.ItemsChart.SettingsInteractionZooming);
            e.SettingsInteractionZooming = a
        }(e = t.NetChart || (t.NetChart = {}))
    }(e = t.Internal || (t.Internal = {}))
}(ZoomCharts || (ZoomCharts = {}));
var ZoomCharts;
!function (t) {
    var e;
    !function (t) {
        t.moment = function () {
            function t(t, e, i) {
                switch (arguments.length) {
                    case 2:
                        return null != t ? t : e;
                    case 3:
                        return null != t ? t : null != e ? e : i;
                    default:
                        throw new Error("Implement me")
                }
            }

            function e(t, e) {
                return _e.call(t, e)
            }

            function i() {
                return {
                    empty: !1,
                    unusedTokens: [],
                    unusedInput: [],
                    overflow: -2,
                    charsLeftOver: 0,
                    nullInput: !1,
                    invalidMonth: null,
                    invalidFormat: !1,
                    userInvalidated: !1,
                    iso: !1
                }
            }

            function n(t) {
                Se.suppressDeprecationWarnings === !1 && "undefined" != typeof console && console.warn && console.warn("Deprecation warning: " + t)
            }

            function s(t, e) {
                var i = !0;
                return d(function () {
                    return i && (n(t), i = !1), e.apply(this, arguments)
                }, e)
            }

            function o(t, e) {
                di[t] || (n(e), di[t] = !0)
            }

            function r(t, e) {
                return function (i) {
                    return g(t.call(this, i), e)
                }
            }

            function a(t, e) {
                return function (i) {
                    return this.localeData().ordinal(t.call(this, i), e)
                }
            }

            function h(t, e) {
                var i, n, s = 12 * (e.year() - t.year()) + (e.month() - t.month()), o = t.clone().add(s, "months");
                return 0 > e - o ? (i = t.clone().add(s - 1, "months"), n = (e - o) / (o - i)) : (i = t.clone().add(s + 1, "months"), n = (e - o) / (i - o)), -(s + n)
            }

            function l(t, e, i) {
                var n;
                return null == i ? e : null != t.meridiemHour ? t.meridiemHour(e, i) : null != t.isPM ? (n = t.isPM(i), n && 12 > e && (e += 12), n || 12 !== e || (e = 0), e) : e
            }

            function u() {
            }

            function c(t, e) {
                e !== !1 && A(t), f(this, t), this._d = new Date(+t._d), mi === !1 && (mi = !0, Se.updateOffset(this), mi = !1)
            }

            function p(t) {
                var e = L(t), i = e.year || 0, n = e.quarter || 0, s = e.month || 0, o = e.week || 0, r = e.day || 0, a = e.hour || 0, h = e.minute || 0, l = e.second || 0, u = e.millisecond || 0;
                this._milliseconds = +u + 1e3 * l + 6e4 * h + 36e5 * a, this._days = +r + 7 * o, this._months = +s + 3 * n + 12 * i, this._data = {}, this._locale = Se.localeData(), this._bubble()
            }

            function d(t, i) {
                for (var n in i)e(i, n) && (t[n] = i[n]);
                return e(i, "toString") && (t.toString = i.toString), e(i, "valueOf") && (t.valueOf = i.valueOf), t
            }

            function f(t, e) {
                var i, n, s;
                if ("undefined" != typeof e._isAMomentObject && (t._isAMomentObject = e._isAMomentObject), "undefined" != typeof e._i && (t._i = e._i), "undefined" != typeof e._f && (t._f = e._f), "undefined" != typeof e._l && (t._l = e._l), "undefined" != typeof e._strict && (t._strict = e._strict), "undefined" != typeof e._tzm && (t._tzm = e._tzm), "undefined" != typeof e._isUTC && (t._isUTC = e._isUTC), "undefined" != typeof e._offset && (t._offset = e._offset), "undefined" != typeof e._pf && (t._pf = e._pf), "undefined" != typeof e._locale && (t._locale = e._locale), Ae.length > 0)for (i in Ae)n = Ae[i], s = e[n], "undefined" != typeof s && (t[n] = s);
                return t
            }

            function m(t) {
                return 0 > t ? Math.ceil(t) : Math.floor(t)
            }

            function g(t, e, i) {
                for (var n = "" + Math.abs(t), s = t >= 0; n.length < e;)n = "0" + n;
                return (s ? i ? "+" : "" : "-") + n
            }

            function y(t, e) {
                var i = {milliseconds: 0, months: 0};
                return i.months = e.month() - t.month() + 12 * (e.year() - t.year()), t.clone().add(i.months, "M").isAfter(e) && --i.months, i.milliseconds = +e - +t.clone().add(i.months, "M"), i
            }

            function v(t, e) {
                var i;
                return e = N(e, t), t.isBefore(e) ? i = y(t, e) : (i = y(e, t), i.milliseconds = -i.milliseconds, i.months = -i.months), i
            }

            function S(t, e) {
                return function (i, n) {
                    var s, r;
                    return null === n || isNaN(+n) || (o(e, "moment()." + e + "(period, number) is deprecated. Please use moment()." + e + "(number, period)."), r = i, i = n, n = r), i = "string" == typeof i ? +i : i, s = Se.duration(i, n), C(this, s, t), this
                }
            }

            function C(t, e, i, n) {
                var s = e._milliseconds, o = e._days, r = e._months;
                n = null == n ? !0 : n, s && t._d.setTime(+t._d + s * i), o && fe(t, "Date", de(t, "Date") + o * i), r && pe(t, de(t, "Month") + r * i), n && Se.updateOffset(t, o || r)
            }

            function b(t) {
                return "[object Array]" === Object.prototype.toString.call(t)
            }

            function x(t) {
                return "[object Date]" === Object.prototype.toString.call(t) || t instanceof Date
            }

            function _(t, e, i) {
                var n, s = Math.min(t.length, e.length), o = Math.abs(t.length - e.length), r = 0;
                for (n = 0; s > n; n++)(i && t[n] !== e[n] || !i && M(t[n]) !== M(e[n])) && r++;
                return r + o
            }

            function w(t) {
                if (t) {
                    var e = t.toLowerCase().replace(/(.)s$/, "$1");
                    t = ri[t] || ai[e] || e
                }
                return t
            }

            function L(t) {
                var i, n, s = {};
                for (n in t)e(t, n) && (i = w(n), i && (s[i] = t[n]));
                return s
            }

            function T(t) {
                var e, i;
                if (0 === t.indexOf("week")) e = 7, i = "day"; else {
                    if (0 !== t.indexOf("month"))return;
                    e = 12, i = "month"
                }
                Se[t] = function (n, s) {
                    var o, r, a = Se._locale[t], h = [];
                    if ("number" == typeof n && (s = n, n = void 0), r = function (t) {
                            var e = Se().utc().set(i, t);
                            return a.call(Se._locale, e, n || "")
                        }, null != s)return r(s);
                    for (o = 0; e > o; o++)h.push(r(o));
                    return h
                }
            }

            function M(t) {
                var e = +t, i = 0;
                return 0 !== e && isFinite(e) && (i = e >= 0 ? Math.floor(e) : Math.ceil(e)), i
            }

            function P(t, e) {
                return new Date(Date.UTC(t, e + 1, 0)).getUTCDate()
            }

            function k(t, e, i) {
                return he(Se([t, 11, 31 + e - i]), e, i).week
            }

            function D(t) {
                return I(t) ? 366 : 365
            }

            function I(t) {
                return t % 4 === 0 && t % 100 !== 0 || t % 400 === 0
            }

            function A(t) {
                var e;
                t._a && -2 === t._pf.overflow && (e = t._a[Le] < 0 || t._a[Le] > 11 ? Le : t._a[Te] < 1 || t._a[Te] > P(t._a[we], t._a[Le]) ? Te : t._a[Me] < 0 || t._a[Me] > 24 || 24 === t._a[Me] && (0 !== t._a[Pe] || 0 !== t._a[ke] || 0 !== t._a[De]) ? Me : t._a[Pe] < 0 || t._a[Pe] > 59 ? Pe : t._a[ke] < 0 || t._a[ke] > 59 ? ke : t._a[De] < 0 || t._a[De] > 999 ? De : -1, t._pf._overflowDayOfYear && (we > e || e > Te) && (e = Te), t._pf.overflow = e)
            }

            function B(t) {
                return null == t._isValid && (t._isValid = !isNaN(t._d.getTime()) && t._pf.overflow < 0 && !t._pf.empty && !t._pf.invalidMonth && !t._pf.nullInput && !t._pf.invalidFormat && !t._pf.userInvalidated, t._strict && (t._isValid = t._isValid && 0 === t._pf.charsLeftOver && 0 === t._pf.unusedTokens.length && void 0 === t._pf.bigHour)), t._isValid
            }

            function E(t) {
                return t ? t.toLowerCase().replace("_", "-") : t
            }

            function O(t) {
                for (var e, i, n, s, o = 0; o < t.length;) {
                    for (s = E(t[o]).split("-"), e = s.length, i = E(t[o + 1]), i = i ? i.split("-") : null; e > 0;) {
                        if (n = F(s.slice(0, e).join("-")))return n;
                        if (i && i.length >= e && _(s, i, !0) >= e - 1)break;
                        e--
                    }
                    o++
                }
                return null
            }

            function F(t) {
                return Ie[t]
            }

            function N(t, e) {
                var i, n;
                return e._isUTC ? (i = e.clone(), n = (Se.isMoment(t) || x(t) ? +t : +Se(t)) - +i, i._d.setTime(+i._d + n), Se.updateOffset(i, !1), i) : Se(t).local()
            }

            function z(t) {
                return t.match(/\[[\s\S]/) ? t.replace(/^\[|\]$/g, "") : t.replace(/\\/g, "")
            }

            function R(t) {
                var e, i, n = t.match(Fe);
                for (e = 0, i = n.length; i > e; e++)n[e] = pi[n[e]] ? pi[n[e]] : z(n[e]);
                return function (s) {
                    var o = "";
                    for (e = 0; i > e; e++)o += n[e] instanceof Function ? n[e].call(s, t) : n[e];
                    return o
                }
            }

            function H(t, e) {
                return t.isValid() ? (e = Z(e, t.localeData()), hi[e] || (hi[e] = R(e)), hi[e](t)) : t.localeData().invalidDate()
            }

            function Z(t, e) {
                function i(t) {
                    return e.longDateFormat(t) || t
                }

                var n = 5;
                for (Ne.lastIndex = 0; n >= 0 && Ne.test(t);)t = t.replace(Ne, i), Ne.lastIndex = 0, n -= 1;
                return t
            }

            function U(t, e) {
                var i, n = e._strict;
                switch (t) {
                    case"Q":
                        return qe;
                    case"DDDD":
                        return Je;
                    case"YYYY":
                    case"GGGG":
                    case"gggg":
                        return n ? Ke : He;
                    case"Y":
                    case"G":
                    case"g":
                        return $e;
                    case"YYYYYY":
                    case"YYYYY":
                    case"GGGGG":
                    case"ggggg":
                        return n ? Qe : Ze;
                    case"S":
                        if (n)return qe;
                    case"SS":
                        if (n)return Xe;
                    case"SSS":
                        if (n)return Je;
                    case"DDD":
                        return Re;
                    case"MMM":
                    case"MMMM":
                    case"dd":
                    case"ddd":
                    case"dddd":
                        return We;
                    case"a":
                    case"A":
                        return e._locale._meridiemParse;
                    case"x":
                        return Ye;
                    case"X":
                        return je;
                    case"Z":
                    case"ZZ":
                        return Ve;
                    case"T":
                        return Ge;
                    case"SSSS":
                        return Ue;
                    case"MM":
                    case"DD":
                    case"YY":
                    case"GG":
                    case"gg":
                    case"HH":
                    case"hh":
                    case"mm":
                    case"ss":
                    case"ww":
                    case"WW":
                        return n ? Xe : ze;
                    case"M":
                    case"D":
                    case"d":
                    case"H":
                    case"h":
                    case"m":
                    case"s":
                    case"w":
                    case"W":
                    case"e":
                    case"E":
                        return ze;
                    case"Do":
                        return n ? e._locale._ordinalParse : e._locale._ordinalParseLenient;
                    default:
                        return i = new RegExp(K(J(t.replace("\\", ""))), "i")
                }
            }

            function W(t) {
                t = t || "";
                var e = t.match(Ve) || [], i = e[e.length - 1] || [], n = (i + "").match(si) || ["-", 0, 0], s = +(60 * n[1]) + M(n[2]);
                return "+" === n[0] ? s : -s
            }

            function V(t, e, i) {
                var n, s = i._a;
                switch (t) {
                    case"Q":
                        null != e && (s[Le] = 3 * (M(e) - 1));
                        break;
                    case"M":
                    case"MM":
                        null != e && (s[Le] = M(e) - 1);
                        break;
                    case"MMM":
                    case"MMMM":
                        n = i._locale.monthsParse(e, t, i._strict), null != n ? s[Le] = n : i._pf.invalidMonth = e;
                        break;
                    case"D":
                    case"DD":
                        null != e && (s[Te] = M(e));
                        break;
                    case"Do":
                        null != e && (s[Te] = M(parseInt(e.match(/\d{1,2}/)[0], 10)));
                        break;
                    case"DDD":
                    case"DDDD":
                        null != e && (i._dayOfYear = M(e));
                        break;
                    case"YY":
                        s[we] = Se.parseTwoDigitYear(e);
                        break;
                    case"YYYY":
                    case"YYYYY":
                    case"YYYYYY":
                        s[we] = M(e);
                        break;
                    case"a":
                    case"A":
                        i._meridiem = e;
                        break;
                    case"h":
                    case"hh":
                        i._pf.bigHour = !0;
                    case"H":
                    case"HH":
                        s[Me] = M(e);
                        break;
                    case"m":
                    case"mm":
                        s[Pe] = M(e);
                        break;
                    case"s":
                    case"ss":
                        s[ke] = M(e);
                        break;
                    case"S":
                    case"SS":
                    case"SSS":
                    case"SSSS":
                        s[De] = M(1e3 * parseFloat("0." + e));
                        break;
                    case"x":
                        i._d = new Date(M(e));
                        break;
                    case"X":
                        i._d = new Date(1e3 * parseFloat(e));
                        break;
                    case"Z":
                    case"ZZ":
                        i._useUTC = !0, i._tzm = W(e);
                        break;
                    case"dd":
                    case"ddd":
                    case"dddd":
                        n = i._locale.weekdaysParse(e), null != n ? (i._w = i._w || {}, i._w.d = n) : i._pf.invalidWeekday = e;
                        break;
                    case"w":
                    case"ww":
                    case"W":
                    case"WW":
                    case"d":
                    case"e":
                    case"E":
                        t = t.substr(0, 1);
                    case"gggg":
                    case"GGGG":
                    case"GGGGG":
                        t = t.substr(0, 2), e && (i._w = i._w || {}, i._w[t] = M(e));
                        break;
                    case"gg":
                    case"GG":
                        i._w = i._w || {}, i._w[t] = Se.parseTwoDigitYear(e)
                }
            }

            function G(e) {
                var i, n, s, o, r, a, h;
                i = e._w, null != i.GG || null != i.W || null != i.E ? (r = 1, a = 4, n = t(i.GG, e._a[we], he(Se(), 1, 4).year), s = t(i.W, 1), o = t(i.E, 1)) : (r = e._locale._week.dow, a = e._locale._week.doy, n = t(i.gg, e._a[we], he(Se(), r, a).year), s = t(i.w, 1), null != i.d ? (o = i.d, r > o && ++s) : o = null != i.e ? i.e + r : r), h = le(n, s, o, a, r), e._a[we] = h.year, e._dayOfYear = h.dayOfYear
            }

            function Y(e) {
                var i, n, s, o, r = [];
                if (!e._d) {
                    for (s = q(e), e._w && null == e._a[Te] && null == e._a[Le] && G(e), e._dayOfYear && (o = t(e._a[we], s[we]), e._dayOfYear > D(o) && (e._pf._overflowDayOfYear = !0), n = se(o, 0, e._dayOfYear), e._a[Le] = n.getUTCMonth(), e._a[Te] = n.getUTCDate()), i = 0; 3 > i && null == e._a[i]; ++i)e._a[i] = r[i] = s[i];
                    for (; 7 > i; i++)e._a[i] = r[i] = null == e._a[i] ? 2 === i ? 1 : 0 : e._a[i];
                    24 === e._a[Me] && 0 === e._a[Pe] && 0 === e._a[ke] && 0 === e._a[De] && (e._nextDay = !0, e._a[Me] = 0), e._d = (e._useUTC ? se : ne).apply(null, r), null != e._tzm && e._d.setUTCMinutes(e._d.getUTCMinutes() - e._tzm), e._nextDay && (e._a[Me] = 24)
                }
            }

            function j(t) {
                var e;
                t._d || (e = L(t._i), t._a = [e.year, e.month, e.day || e.date, e.hour, e.minute, e.second, e.millisecond], Y(t))
            }

            function q(t) {
                var e = new Date;
                return t._useUTC ? [e.getUTCFullYear(), e.getUTCMonth(), e.getUTCDate()] : [e.getFullYear(), e.getMonth(), e.getDate()]
            }

            function X(t) {
                if (t._f === Se.ISO_8601)return void $(t);
                t._a = [], t._pf.empty = !0;
                var e, i, n, s, o, r = "" + t._i, a = r.length, h = 0;
                for (n = Z(t._f, t._locale).match(Fe) || [], e = 0; e < n.length; e++)s = n[e], i = (r.match(U(s, t)) || [])[0], i && (o = r.substr(0, r.indexOf(i)), o.length > 0 && t._pf.unusedInput.push(o), r = r.slice(r.indexOf(i) + i.length), h += i.length), pi[s] ? (i ? t._pf.empty = !1 : t._pf.unusedTokens.push(s), V(s, i, t)) : t._strict && !i && t._pf.unusedTokens.push(s);
                t._pf.charsLeftOver = a - h, r.length > 0 && t._pf.unusedInput.push(r), t._pf.bigHour === !0 && t._a[Me] <= 12 && (t._pf.bigHour = void 0), t._a[Me] = l(t._locale, t._a[Me], t._meridiem), Y(t), A(t)
            }

            function J(t) {
                return t.replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function (t, e, i, n, s) {
                    return e || i || n || s
                })
            }

            function K(t) {
                return t.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&")
            }

            function Q(t) {
                var e, n, s, o, r;
                if (0 === t._f.length)return t._pf.invalidFormat = !0, void(t._d = new Date(0 / 0));
                for (o = 0; o < t._f.length; o++)r = 0, e = f({}, t), null != t._useUTC && (e._useUTC = t._useUTC), e._pf = i(), e._f = t._f[o], X(e), B(e) && (r += e._pf.charsLeftOver, r += 10 * e._pf.unusedTokens.length, e._pf.score = r, (null == s || s > r) && (s = r, n = e));
                d(t, n || e)
            }

            function $(t) {
                var e, i, n = t._i, s = ti.exec(n);
                if (s) {
                    for (t._pf.iso = !0, e = 0, i = ii.length; i > e; e++)if (ii[e][1].exec(n)) {
                        t._f = ii[e][0] + (s[6] || " ");
                        break
                    }
                    for (e = 0, i = ni.length; i > e; e++)if (ni[e][1].exec(n)) {
                        t._f += ni[e][0];
                        break
                    }
                    n.match(Ve) && (t._f += "Z"), X(t)
                } else t._isValid = !1
            }

            function te(t) {
                $(t), t._isValid === !1 && (delete t._isValid, Se.createFromInputFallback(t))
            }

            function ee(t, e) {
                var i, n = [];
                for (i = 0; i < t.length; ++i)n.push(e(t[i], i));
                return n
            }

            function ie(t) {
                var e, i = t._i;
                void 0 === i ? t._d = new Date : x(i) ? t._d = new Date(+i) : null !== (e = Be.exec(i)) ? t._d = new Date(+e[1]) : "string" == typeof i ? te(t) : b(i) ? (t._a = ee(i.slice(0), function (t) {
                                        return parseInt(t, 10)
                                    }), Y(t)) : "object" == typeof i ? j(t) : "number" == typeof i ? t._d = new Date(i) : Se.createFromInputFallback(t)
            }

            function ne(t, e, i, n, s, o, r) {
                var a = new Date(t, e, i, n, s, o, r);
                return 1970 > t && a.setFullYear(t), a
            }

            function se(t) {
                for (var e = [], i = 1; i < arguments.length; i++)e[i - 1] = arguments[i];
                var n = new Date(Date.UTC.apply(null, arguments));
                return 1970 > t && n.setUTCFullYear(t), n
            }

            function oe(t, e) {
                if ("string" == typeof t)if (isNaN(t)) {
                    if (t = e.weekdaysParse(t), "number" != typeof t)return null
                } else t = parseInt(t, 10);
                return t
            }

            function re(t, e, i, n, s) {
                return s.relativeTime(e || 1, !!i, t, n)
            }

            function ae(t, e, i) {
                var n = Se.duration(t).abs(), s = xe(n.as("s")), o = xe(n.as("m")), r = xe(n.as("h")), a = xe(n.as("d")), h = xe(n.as("M")), l = xe(n.as("y")), u = s < li.s && ["s", s] || 1 === o && ["m"] || o < li.m && ["mm", o] || 1 === r && ["h"] || r < li.h && ["hh", r] || 1 === a && ["d"] || a < li.d && ["dd", a] || 1 === h && ["M"] || h < li.M && ["MM", h] || 1 === l && ["y"] || ["yy", l];
                return u[2] = e, u[3] = +t > 0, u[4] = i, re.apply({}, u)
            }

            function he(t, e, i) {
                var n, s = i - e, o = i - t.day();
                return o > s && (o -= 7), s - 7 > o && (o += 7), n = Se(t).add(o, "d"), {
                    week: Math.ceil(n.dayOfYear() / 7),
                    year: n.year()
                }
            }

            function le(t, e, i, n, s) {
                var o, r, a = se(t, 0, 1).getUTCDay();
                return a = 0 === a ? 7 : a, i = null != i ? i : s, o = s - a + (a > n ? 7 : 0) - (s > a ? 7 : 0), r = 7 * (e - 1) + (i - s) + o + 1, {
                    year: r > 0 ? t : t - 1,
                    dayOfYear: r > 0 ? r : D(t - 1) + r
                }
            }

            function ue(t) {
                var e, i = t._i, n = t._f;
                return t._locale = t._locale || Se.localeData(t._l), null === i || void 0 === n && "" === i ? Se.invalid({nullInput: !0}) : ("string" == typeof i && (t._i = i = t._locale.preparse(i)), Se.isMoment(i) ? new c(i, !0) : (n ? b(n) ? Q(t) : X(t) : ie(t), e = new c(t), e._nextDay && (e.add(1, "d"), e._nextDay = void 0), e))
            }

            function ce(t, e) {
                var i, n;
                if (1 === e.length && b(e[0]) && (e = e[0]), !e.length)return Se();
                for (i = e[0], n = 1; n < e.length; ++n)e[n][t](i) && (i = e[n]);
                return i
            }

            function pe(t, e) {
                var i;
                return "string" == typeof e && (e = t.localeData().monthsParse(e), "number" != typeof e) ? t : (i = Math.min(t.date(), P(t.year(), e)), t._d["set" + (t._isUTC ? "UTC" : "") + "Month"](e, i), t)
            }

            function de(t, e) {
                return t._d["get" + (t._isUTC ? "UTC" : "") + e]()
            }

            function fe(t, e, i) {
                return "Month" === e ? pe(t, i) : t._d["set" + (t._isUTC ? "UTC" : "") + e](i)
            }

            function me(t, e) {
                return function (i) {
                    return null != i ? (fe(this, t, i), Se.updateOffset(this, e), this) : de(this, t)
                }
            }

            function ge(t) {
                return 400 * t / 146097
            }

            function ye(t) {
                return 146097 * t / 400
            }

            function ve(t) {
                Se.duration.fn[t] = function () {
                    return this._data[t]
                }
            }

            for (var Se, Ce, be = "2.9.0", xe = Math.round, _e = Object.prototype.hasOwnProperty, we = 0, Le = 1, Te = 2, Me = 3, Pe = 4, ke = 5, De = 6, Ie = {}, Ae = [], Be = /^\/?Date\((\-?\d+)/i, Ee = /(\-)?(?:(\d*)\.)?(\d+)\:(\d+)(?:\:(\d+)\.?(\d{3})?)?/, Oe = /^(-)?P(?:(?:([0-9,.]*)Y)?(?:([0-9,.]*)M)?(?:([0-9,.]*)D)?(?:T(?:([0-9,.]*)H)?(?:([0-9,.]*)M)?(?:([0-9,.]*)S)?)?|([0-9,.]*)W)$/, Fe = /(\[[^\[]*\])|(\\)?(Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Q|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|mm?|ss?|S{1,4}|x|X|zz?|ZZ?|.)/g, Ne = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g, ze = /\d\d?/, Re = /\d{1,3}/, He = /\d{1,4}/, Ze = /[+\-]?\d{1,6}/, Ue = /\d+/, We = /[0-9]*['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+|[\u0600-\u06FF\/]+(\s*?[\u0600-\u06FF]+){1,2}/i, Ve = /Z|[\+\-]\d\d:?\d\d/gi, Ge = /T/i, Ye = /[\+\-]?\d+/, je = /[\+\-]?\d+(\.\d{1,3})?/, qe = /\d/, Xe = /\d\d/, Je = /\d{3}/, Ke = /\d{4}/, Qe = /[+-]?\d{6}/, $e = /[+-]?\d+/, ti = /^\s*(?:[+-]\d{6}|\d{4})-(?:(\d\d-\d\d)|(W\d\d$)|(W\d\d-\d)|(\d\d\d))((T| )(\d\d(:\d\d(:\d\d(\.\d+)?)?)?)?([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/, ei = "YYYY-MM-DDTHH:mm:ssZ", ii = [["YYYYYY-MM-DD", /[+-]\d{6}-\d{2}-\d{2}/], ["YYYY-MM-DD", /\d{4}-\d{2}-\d{2}/], ["GGGG-[W]WW-E", /\d{4}-W\d{2}-\d/], ["GGGG-[W]WW", /\d{4}-W\d{2}/], ["YYYY-DDD", /\d{4}-\d{3}/]], ni = [["HH:mm:ss.SSSS", /(T| )\d\d:\d\d:\d\d\.\d+/], ["HH:mm:ss", /(T| )\d\d:\d\d:\d\d/], ["HH:mm", /(T| )\d\d:\d\d/], ["HH", /(T| )\d\d/]], si = /([\+\-]|\d\d)/gi, oi = ("Date|Hours|Minutes|Seconds|Milliseconds".split("|"), {
                Milliseconds: 1,
                Seconds: 1e3,
                Minutes: 6e4,
                Hours: 36e5,
                Days: 864e5,
                Months: 2592e6,
                Years: 31536e6
            }), ri = {
                ms: "millisecond",
                s: "second",
                m: "minute",
                h: "hour",
                d: "day",
                D: "date",
                w: "week",
                W: "isoWeek",
                M: "month",
                Q: "quarter",
                y: "year",
                DDD: "dayOfYear",
                e: "weekday",
                E: "isoWeekday",
                gg: "weekYear",
                GG: "isoWeekYear"
            }, ai = {
                dayofyear: "dayOfYear",
                isoweekday: "isoWeekday",
                isoweek: "isoWeek",
                weekyear: "weekYear",
                isoweekyear: "isoWeekYear"
            }, hi = {}, li = {
                s: 45,
                m: 45,
                h: 22,
                d: 26,
                M: 11
            }, ui = "DDD w W M D d".split(" "), ci = "M D H h m s w W".split(" "), pi = {
                M: function () {
                    return this.month() + 1
                }, MMM: function (t) {
                    return this.localeData().monthsShort(this, t)
                }, MMMM: function (t) {
                    return this.localeData().months(this, t)
                }, D: function () {
                    return this.date()
                }, DDD: function () {
                    return this.dayOfYear()
                }, d: function () {
                    return this.day()
                }, dd: function (t) {
                    return this.localeData().weekdaysMin(this, t)
                }, ddd: function (t) {
                    return this.localeData().weekdaysShort(this, t)
                }, dddd: function (t) {
                    return this.localeData().weekdays(this, t)
                }, w: function () {
                    return this.week()
                }, W: function () {
                    return this.isoWeek()
                }, YY: function () {
                    return g(this.year() % 100, 2)
                }, YYYY: function () {
                    return g(this.year(), 4)
                }, YYYYY: function () {
                    return g(this.year(), 5)
                }, YYYYYY: function () {
                    var t = this.year(), e = t >= 0 ? "+" : "-";
                    return e + g(Math.abs(t), 6)
                }, gg: function () {
                    return g(this.weekYear() % 100, 2)
                }, gggg: function () {
                    return g(this.weekYear(), 4)
                }, ggggg: function () {
                    return g(this.weekYear(), 5)
                }, GG: function () {
                    return g(this.isoWeekYear() % 100, 2)
                }, GGGG: function () {
                    return g(this.isoWeekYear(), 4)
                }, GGGGG: function () {
                    return g(this.isoWeekYear(), 5)
                }, e: function () {
                    return this.weekday()
                }, E: function () {
                    return this.isoWeekday()
                }, a: function () {
                    return this.localeData().meridiem(this.hours(), this.minutes(), !0)
                }, A: function () {
                    return this.localeData().meridiem(this.hours(), this.minutes(), !1)
                }, H: function () {
                    return this.hours()
                }, h: function () {
                    return this.hours() % 12 || 12
                }, m: function () {
                    return this.minutes()
                }, s: function () {
                    return this.seconds()
                }, S: function () {
                    return M(this.milliseconds() / 100)
                }, SS: function () {
                    return g(M(this.milliseconds() / 10), 2)
                }, SSS: function () {
                    return g(this.milliseconds(), 3)
                }, SSSS: function () {
                    return g(this.milliseconds(), 3)
                }, Z: function () {
                    var t = this.utcOffset(), e = "+";
                    return 0 > t && (t = -t, e = "-"), e + g(M(t / 60), 2) + ":" + g(M(t) % 60, 2)
                }, ZZ: function () {
                    var t = this.utcOffset(), e = "+";
                    return 0 > t && (t = -t, e = "-"), e + g(M(t / 60), 2) + g(M(t) % 60, 2)
                }, z: function () {
                    return this.zoneAbbr()
                }, zz: function () {
                    return this.zoneName()
                }, x: function () {
                    return this.valueOf()
                }, X: function () {
                    return this.unix()
                }, Q: function () {
                    return this.quarter()
                }
            }, di = {}, fi = ["months", "monthsShort", "weekdays", "weekdaysShort", "weekdaysMin"], mi = !1; ui.length;)Ce = ui.pop(), pi[Ce + "o"] = a(pi[Ce], Ce);
            for (; ci.length;)Ce = ci.pop(), pi[Ce + Ce] = r(pi[Ce], 2);
            pi.DDDD = r(pi.DDD, 3), d(u.prototype, {
                set: function (t) {
                    var e, i;
                    for (i in t)e = t[i], "function" == typeof e ? this[i] = e : this["_" + i] = e;
                    this._ordinalParseLenient = new RegExp(this._ordinalParse.source + "|" + /\d{1,2}/.source)
                },
                _months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"),
                months: function (t) {
                    return this._months[t.month()]
                },
                _monthsShort: "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"),
                monthsShort: function (t) {
                    return this._monthsShort[t.month()]
                },
                monthsParse: function (t, e, i) {
                    var n, s, o;
                    for (this._monthsParse || (this._monthsParse = [], this._longMonthsParse = [], this._shortMonthsParse = []), n = 0; 12 > n; n++) {
                        if (s = Se.utc([2e3, n]), i && !this._longMonthsParse[n] && (this._longMonthsParse[n] = new RegExp("^" + this.months(s, "").replace(".", "") + "$", "i"), this._shortMonthsParse[n] = new RegExp("^" + this.monthsShort(s, "").replace(".", "") + "$", "i")), i || this._monthsParse[n] || (o = "^" + this.months(s, "") + "|^" + this.monthsShort(s, ""), this._monthsParse[n] = new RegExp(o.replace(".", ""), "i")), i && "MMMM" === e && this._longMonthsParse[n].test(t))return n;
                        if (i && "MMM" === e && this._shortMonthsParse[n].test(t))return n;
                        if (!i && this._monthsParse[n].test(t))return n
                    }
                },
                _weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),
                weekdays: function (t) {
                    return this._weekdays[t.day()]
                },
                _weekdaysShort: "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"),
                weekdaysShort: function (t) {
                    return this._weekdaysShort[t.day()]
                },
                _weekdaysMin: "Su_Mo_Tu_We_Th_Fr_Sa".split("_"),
                weekdaysMin: function (t) {
                    return this._weekdaysMin[t.day()]
                },
                weekdaysParse: function (t) {
                    var e, i, n;
                    for (this._weekdaysParse || (this._weekdaysParse = []), e = 0; 7 > e; e++)if (this._weekdaysParse[e] || (i = Se([2e3, 1]).day(e), n = "^" + this.weekdays(i, "") + "|^" + this.weekdaysShort(i, "") + "|^" + this.weekdaysMin(i, ""), this._weekdaysParse[e] = new RegExp(n.replace(".", ""), "i")), this._weekdaysParse[e].test(t))return e
                },
                _longDateFormat: {
                    LTS: "h:mm:ss A",
                    LT: "h:mm A",
                    L: "MM/DD/YYYY",
                    LL: "MMMM D, YYYY",
                    LLL: "MMMM D, YYYY LT",
                    LLLL: "dddd, MMMM D, YYYY LT"
                },
                longDateFormat: function (t) {
                    var e = this._longDateFormat[t];
                    return !e && this._longDateFormat[t.toUpperCase()] && (e = this._longDateFormat[t.toUpperCase()].replace(/MMMM|MM|DD|dddd/g, function (t) {
                        return t.slice(1)
                    }), this._longDateFormat[t] = e), e
                },
                isPM: function (t) {
                    return "p" === (t + "").toLowerCase().charAt(0)
                },
                _meridiemParse: /[ap]\.?m?\.?/i,
                meridiem: function (t, e, i) {
                    return t > 11 ? i ? "pm" : "PM" : i ? "am" : "AM"
                },
                _calendar: {
                    sameDay: "[Today at] LT",
                    nextDay: "[Tomorrow at] LT",
                    nextWeek: "dddd [at] LT",
                    lastDay: "[Yesterday at] LT",
                    lastWeek: "[Last] dddd [at] LT",
                    sameElse: "L"
                },
                calendar: function (t, e, i) {
                    var n = this._calendar[t];
                    return "function" == typeof n ? n.apply(e, [i]) : n
                },
                _relativeTime: {
                    future: "in %s",
                    past: "%s ago",
                    s: "a few seconds",
                    m: "a minute",
                    mm: "%d minutes",
                    h: "an hour",
                    hh: "%d hours",
                    d: "a day",
                    dd: "%d days",
                    M: "a month",
                    MM: "%d months",
                    y: "a year",
                    yy: "%d years"
                },
                relativeTime: function (t, e, i, n) {
                    var s = this._relativeTime[i];
                    return "function" == typeof s ? s(t, e, i, n) : s.replace(/%d/i, t)
                },
                pastFuture: function (t, e) {
                    var i = this._relativeTime[t > 0 ? "future" : "past"];
                    return "function" == typeof i ? i(e) : i.replace(/%s/i, e)
                },
                ordinal: function (t) {
                    return this._ordinal.replace("%d", t)
                },
                _ordinal: "%d",
                _ordinalParse: /\d{1,2}/,
                preparse: function (t) {
                    return t
                },
                postformat: function (t) {
                    return t
                },
                week: function (t) {
                    return he(t, this._week.dow, this._week.doy).week
                },
                _week: {dow: 0, doy: 6},
                firstDayOfWeek: function () {
                    return this._week.dow
                },
                firstDayOfYear: function () {
                    return this._week.doy
                },
                _invalidDate: "Invalid date",
                invalidDate: function () {
                    return this._invalidDate
                }
            }), Se = function (t, e, n, s) {
                var o;
                return "boolean" == typeof n && (s = n, n = void 0), o = {}, o._isAMomentObject = !0, o._i = t, o._f = e, o._l = n, o._strict = s, o._isUTC = !1, o._pf = i(), ue(o)
            }, Se.suppressDeprecationWarnings = !1, Se.createFromInputFallback = s("moment construction falls back to js Date. This is discouraged and will be removed in upcoming major release. Please refer to https://github.com/moment/moment/issues/1407 for more info.", function (t) {
                t._d = new Date(t._i + (t._useUTC ? " UTC" : ""))
            }), Se.min = function () {
                var t = [].slice.call(arguments, 0);
                return ce("isBefore", t)
            }, Se.max = function () {
                var t = [].slice.call(arguments, 0);
                return ce("isAfter", t)
            }, Se.utc = function (t, e, n, s) {
                var o;
                return "boolean" == typeof n && (s = n, n = void 0), o = {}, o._isAMomentObject = !0, o._useUTC = !0, o._isUTC = !0, o._l = n, o._i = t, o._f = e, o._strict = s, o._pf = i(), ue(o).utc()
            }, Se.unix = function (t) {
                return Se(1e3 * t)
            }, Se.duration = function (t, i) {
                var n, s, o, r, a = t, h = null;
                return Se.isDuration(t) ? a = {
                        ms: t._milliseconds,
                        d: t._days,
                        M: t._months
                    } : "number" == typeof t ? (a = {}, i ? a[i] = t : a.milliseconds = t) : (h = Ee.exec(t)) ? (n = "-" === h[1] ? -1 : 1, a = {
                                y: 0,
                                d: M(h[Te]) * n,
                                h: M(h[Me]) * n,
                                m: M(h[Pe]) * n,
                                s: M(h[ke]) * n,
                                ms: M(h[De]) * n
                            }) : (h = Oe.exec(t)) ? (n = "-" === h[1] ? -1 : 1, o = function (t) {
                                    var e = t && parseFloat(t.replace(",", "."));
                                    return (isNaN(e) ? 0 : e) * n
                                }, a = {
                                    y: o(h[2]),
                                    M: o(h[3]),
                                    d: o(h[4]),
                                    h: o(h[5]),
                                    m: o(h[6]),
                                    s: o(h[7]),
                                    w: o(h[8])
                                }) : null == a ? a = {} : "object" == typeof a && ("from" in a || "to" in a) && (r = v(Se(a.from), Se(a.to)), a = {}, a.ms = r.milliseconds, a.M = r.months), s = new p(a), Se.isDuration(t) && e(t, "_locale") && (s._locale = t._locale), s
            }, Se.version = be, Se.defaultFormat = ei, Se.ISO_8601 = function () {
            }, Se.momentProperties = Ae, Se.updateOffset = function () {
            }, Se.relativeTimeThreshold = function (t, e) {
                return void 0 === li[t] ? !1 : void 0 === e ? li[t] : (li[t] = e, !0)
            }, Se.lang = s("moment.lang is deprecated. Use moment.locale instead.", function (t, e) {
                return Se.locale(t, e)
            }), Se.locale = function (t, e) {
                var i;
                return t && (i = "undefined" != typeof e ? Se.defineLocale(t, e) : Se.localeData(t), i && (Se.duration._locale = Se._locale = i)), Se._locale._abbr
            }, Se.defineLocale = function (t, e) {
                return null !== e ? (e.abbr = t, Ie[t] || (Ie[t] = new u), Ie[t].set(e), Se.locale(t), Ie[t]) : (delete Ie[t], null)
            }, Se.langData = s("moment.langData is deprecated. Use moment.localeData instead.", function (t) {
                return Se.localeData(t)
            }), Se.localeData = function (t) {
                var e;
                if (t && t._locale && t._locale._abbr && (t = t._locale._abbr), !t)return Se._locale;
                if (!b(t)) {
                    if (e = F(t))return e;
                    t = [t]
                }
                return O(t)
            }, Se.isMoment = function (t) {
                return t instanceof c || null != t && e(t, "_isAMomentObject")
            }, Se.isDuration = function (t) {
                return t instanceof p
            };
            for (Ce = fi.length - 1; Ce >= 0; --Ce)T(fi[Ce]);
            Se.normalizeUnits = function (t) {
                return w(t)
            }, Se.invalid = function (t) {
                var e = Se.utc(0 / 0);
                return null != t ? d(e._pf, t) : e._pf.userInvalidated = !0, e
            }, Se.parseZone = function () {
                return Se.apply(null, arguments).parseZone()
            }, Se.parseTwoDigitYear = function (t) {
                return M(t) + (M(t) > 68 ? 1900 : 2e3)
            }, Se.isDate = x, d(Se.fn = c.prototype, {
                clone: function () {
                    return Se(this)
                },
                valueOf: function () {
                    return +this._d - 6e4 * (this._offset || 0)
                },
                unix: function () {
                    return Math.floor(+this / 1e3)
                },
                toString: function () {
                    return this.clone().locale("en").format("ddd MMM DD YYYY HH:mm:ss [GMT]ZZ")
                },
                toDate: function () {
                    return this._offset ? new Date(+this) : this._d
                },
                toISOString: function () {
                    var t = Se(this).utc();
                    return 0 < t.year() && t.year() <= 9999 ? "function" == typeof Date.prototype.toISOString ? this.toDate().toISOString() : H(t, "YYYY-MM-DD[T]HH:mm:ss.SSS[Z]") : H(t, "YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]")
                },
                toArray: function () {
                    var t = this;
                    return [t.year(), t.month(), t.date(), t.hours(), t.minutes(), t.seconds(), t.milliseconds()]
                },
                isValid: function () {
                    return B(this)
                },
                isDSTShifted: function () {
                    return this._a ? this.isValid() && _(this._a, (this._isUTC ? Se.utc(this._a) : Se(this._a)).toArray()) > 0 : !1
                },
                parsingFlags: function () {
                    return d({}, this._pf)
                },
                invalidAt: function () {
                    return this._pf.overflow
                },
                utc: function (t) {
                    return this.utcOffset(0, t)
                },
                local: function (t) {
                    return this._isUTC && (this.utcOffset(0, t), this._isUTC = !1, t && this.subtract(this._dateUtcOffset(), "m")), this
                },
                format: function (t) {
                    var e = H(this, t || Se.defaultFormat);
                    return this.localeData().postformat(e)
                },
                add: S(1, "add"),
                subtract: S(-1, "subtract"),
                diff: function (t, e, i) {
                    var n, s, o = N(t, this), r = 6e4 * (o.utcOffset() - this.utcOffset());
                    return e = w(e), "year" === e || "month" === e || "quarter" === e ? (s = h(this, o), "quarter" === e ? s /= 3 : "year" === e && (s /= 12)) : (n = this - o, s = "second" === e ? n / 1e3 : "minute" === e ? n / 6e4 : "hour" === e ? n / 36e5 : "day" === e ? (n - r) / 864e5 : "week" === e ? (n - r) / 6048e5 : n), i ? s : m(s)
                },
                from: function (t, e) {
                    return Se.duration({
                        to: this,
                        from: t
                    }).locale(this.locale()).humanize(!e)
                },
                fromNow: function (t) {
                    return this.from(Se(), t)
                },
                calendar: function (t) {
                    var e = t || Se(), i = N(e, this).startOf("day"), n = this.diff(i, "days", !0), s = -6 > n ? "sameElse" : -1 > n ? "lastWeek" : 0 > n ? "lastDay" : 1 > n ? "sameDay" : 2 > n ? "nextDay" : 7 > n ? "nextWeek" : "sameElse";
                    return this.format(this.localeData().calendar(s, this, Se(e)))
                },
                isLeapYear: function () {
                    return I(this.year())
                },
                isDST: function () {
                    return this.utcOffset() > this.clone().month(0).utcOffset() || this.utcOffset() > this.clone().month(5).utcOffset()
                },
                day: function (t) {
                    var e = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
                    return null != t ? (t = oe(t, this.localeData()), this.add(t - e, "d")) : e
                },
                month: me("Month", !0),
                startOf: function (t) {
                    switch (t = w(t)) {
                        case"year":
                            this.month(0);
                        case"quarter":
                        case"month":
                            this.date(1);
                        case"week":
                        case"isoWeek":
                        case"day":
                            this.hours(0);
                        case"hour":
                            this.minutes(0);
                        case"minute":
                            this.seconds(0);
                        case"second":
                            this.milliseconds(0)
                    }
                    return "week" === t ? this.weekday(0) : "isoWeek" === t && this.isoWeekday(1), "quarter" === t && this.month(3 * Math.floor(this.month() / 3)), this
                },
                endOf: function (t) {
                    return t = w(t), void 0 === t || "millisecond" === t ? this : this.startOf(t).add(1, "isoWeek" === t ? "week" : t).subtract(1, "ms")
                },
                isAfter: function (t, e) {
                    var i;
                    return e = w("undefined" != typeof e ? e : "millisecond"), "millisecond" === e ? (t = Se.isMoment(t) ? t : Se(t), +this > +t) : (i = Se.isMoment(t) ? +t : +Se(t), i < +this.clone().startOf(e))
                },
                isBefore: function (t, e) {
                    var i;
                    return e = w("undefined" != typeof e ? e : "millisecond"), "millisecond" === e ? (t = Se.isMoment(t) ? t : Se(t), +t > +this) : (i = Se.isMoment(t) ? +t : +Se(t), +this.clone().endOf(e) < i)
                },
                isBetween: function (t, e, i) {
                    return this.isAfter(t, i) && this.isBefore(e, i)
                },
                isSame: function (t, e) {
                    var i;
                    return e = w(e || "millisecond"), "millisecond" === e ? (t = Se.isMoment(t) ? t : Se(t), +this === +t) : (i = +Se(t), +this.clone().startOf(e) <= i && i <= +this.clone().endOf(e))
                },
                min: s("moment().min is deprecated, use moment.min instead. https://github.com/moment/moment/issues/1548", function (t) {
                    return t = Se.apply(null, arguments), this > t ? this : t
                }),
                max: s("moment().max is deprecated, use moment.max instead. https://github.com/moment/moment/issues/1548", function (t) {
                    return t = Se.apply(null, arguments), t > this ? this : t
                }),
                zone: s("moment().zone is deprecated, use moment().utcOffset instead. https://github.com/moment/moment/issues/1779", function (t, e) {
                    return null != t ? ("string" != typeof t && (t = -t), this.utcOffset(t, e), this) : -this.utcOffset()
                }),
                utcOffset: function (t, e) {
                    var i, n = this._offset || 0;
                    return null != t ? ("string" == typeof t && (t = W(t)), Math.abs(t) < 16 && (t = 60 * t), !this._isUTC && e && (i = this._dateUtcOffset()), this._offset = t, this._isUTC = !0, null != i && this.add(i, "m"), n !== t && (!e || this._changeInProgress ? C(this, Se.duration(t - n, "m"), 1, !1) : this._changeInProgress || (this._changeInProgress = !0, Se.updateOffset(this, !0), this._changeInProgress = null)), this) : this._isUTC ? n : this._dateUtcOffset()
                },
                isLocal: function () {
                    return !this._isUTC
                },
                isUtcOffset: function () {
                    return this._isUTC
                },
                isUtc: function () {
                    return this._isUTC && 0 === this._offset
                },
                zoneAbbr: function () {
                    return this._isUTC ? "UTC" : ""
                },
                zoneName: function () {
                    return this._isUTC ? "Coordinated Universal Time" : ""
                },
                parseZone: function () {
                    return this._tzm ? this.utcOffset(this._tzm) : "string" == typeof this._i && this.utcOffset(W(this._i)), this
                },
                hasAlignedHourOffset: function (t) {
                    return t = t ? Se(t).utcOffset() : 0, (this.utcOffset() - t) % 60 === 0
                },
                daysInMonth: function () {
                    return P(this.year(), this.month())
                },
                dayOfYear: function (t) {
                    var e = xe((Se(this).startOf("day") - Se(this).startOf("year")) / 864e5) + 1;
                    return null == t ? e : this.add(t - e, "d")
                },
                quarter: function (t) {
                    return null == t ? Math.ceil((this.month() + 1) / 3) : this.month(3 * (t - 1) + this.month() % 3)
                },
                weekYear: function (t) {
                    var e = he(this, this.localeData()._week.dow, this.localeData()._week.doy).year;
                    return null == t ? e : this.add(t - e, "y")
                },
                isoWeekYear: function (t) {
                    var e = he(this, 1, 4).year;
                    return null == t ? e : this.add(t - e, "y")
                },
                week: function (t) {
                    var e = this.localeData().week(this);
                    return null == t ? e : this.add(7 * (t - e), "d")
                },
                isoWeek: function (t) {
                    var e = he(this, 1, 4).week;
                    return null == t ? e : this.add(7 * (t - e), "d")
                },
                weekday: function (t) {
                    var e = (this.day() + 7 - this.localeData()._week.dow) % 7;
                    return null == t ? e : this.add(t - e, "d")
                },
                isoWeekday: function (t) {
                    return null == t ? this.day() || 7 : this.day(this.day() % 7 ? t : t - 7)
                },
                isoWeeksInYear: function () {
                    return k(this.year(), 1, 4)
                },
                weeksInYear: function () {
                    var t = this.localeData()._week;
                    return k(this.year(), t.dow, t.doy)
                },
                get: function (t) {
                    return t = w(t), this[t]()
                },
                set: function (t, e) {
                    var i;
                    if ("object" == typeof t)for (i in t)this.set(i, t[i]); else t = w(t), "function" == typeof this[t] && this[t](e);
                    return this
                },
                locale: function (t) {
                    var e;
                    return void 0 === t ? this._locale._abbr : (e = Se.localeData(t), null != e && (this._locale = e), this)
                },
                lang: s("moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.", function (t) {
                    return void 0 === t ? this.localeData() : this.locale(t)
                }),
                localeData: function () {
                    return this._locale
                },
                _dateUtcOffset: function () {
                    return 15 * -Math.round(this._d.getTimezoneOffset() / 15)
                }
            }), Se.fn.millisecond = Se.fn.milliseconds = me("Milliseconds", !1), Se.fn.second = Se.fn.seconds = me("Seconds", !1), Se.fn.minute = Se.fn.minutes = me("Minutes", !1), Se.fn.hour = Se.fn.hours = me("Hours", !0), Se.fn.date = me("Date", !0), Se.fn.dates = s("dates accessor is deprecated. Use date instead.", me("Date", !0)), Se.fn.year = me("FullYear", !0), Se.fn.years = s("years accessor is deprecated. Use year instead.", me("FullYear", !0)), Se.fn.days = Se.fn.day, Se.fn.months = Se.fn.month, Se.fn.weeks = Se.fn.week, Se.fn.isoWeeks = Se.fn.isoWeek, Se.fn.quarters = Se.fn.quarter, Se.fn.toJSON = Se.fn.toISOString, Se.fn.isUTC = Se.fn.isUtc, d(Se.duration.fn = p.prototype, {
                _bubble: function () {
                    var t, e, i, n = this._milliseconds, s = this._days, o = this._months, r = this._data, a = 0;
                    r.milliseconds = n % 1e3, t = m(n / 1e3), r.seconds = t % 60, e = m(t / 60), r.minutes = e % 60, i = m(e / 60), r.hours = i % 24, s += m(i / 24), a = m(ge(s)), s -= m(ye(a)), o += m(s / 30), s %= 30, a += m(o / 12), o %= 12, r.days = s, r.months = o, r.years = a
                },
                abs: function () {
                    return this._milliseconds = Math.abs(this._milliseconds), this._days = Math.abs(this._days), this._months = Math.abs(this._months), this._data.milliseconds = Math.abs(this._data.milliseconds), this._data.seconds = Math.abs(this._data.seconds), this._data.minutes = Math.abs(this._data.minutes), this._data.hours = Math.abs(this._data.hours), this._data.months = Math.abs(this._data.months), this._data.years = Math.abs(this._data.years), this
                },
                weeks: function () {
                    return m(this.days() / 7)
                },
                valueOf: function () {
                    return this._milliseconds + 864e5 * this._days + this._months % 12 * 2592e6 + 31536e6 * M(this._months / 12)
                },
                humanize: function (t) {
                    var e = ae(this, !t, this.localeData());
                    return t && (e = this.localeData().pastFuture(+this, e)), this.localeData().postformat(e)
                },
                add: function (t, e) {
                    var i = Se.duration(t, e);
                    return this._milliseconds += i._milliseconds, this._days += i._days, this._months += i._months, this._bubble(), this
                },
                subtract: function (t, e) {
                    var i = Se.duration(t, e);
                    return this._milliseconds -= i._milliseconds, this._days -= i._days, this._months -= i._months, this._bubble(), this
                },
                get: function (t) {
                    return t = w(t), this[t.toLowerCase() + "s"]()
                },
                as: function (t) {
                    var e, i;
                    if (t = w(t), "month" === t || "year" === t)return e = this._days + this._milliseconds / 864e5, i = this._months + 12 * ge(e), "month" === t ? i : i / 12;
                    switch (e = this._days + Math.round(ye(this._months / 12)), t) {
                        case"week":
                            return e / 7 + this._milliseconds / 6048e5;
                        case"day":
                            return e + this._milliseconds / 864e5;
                        case"hour":
                            return 24 * e + this._milliseconds / 36e5;
                        case"minute":
                            return 24 * e * 60 + this._milliseconds / 6e4;
                        case"second":
                            return 24 * e * 60 * 60 + this._milliseconds / 1e3;
                        case"millisecond":
                            return Math.floor(24 * e * 60 * 60 * 1e3) + this._milliseconds;
                        default:
                            throw new Error("Unknown unit " + t)
                    }
                },
                lang: Se.fn.lang,
                locale: Se.fn.locale,
                toIsoString: s("toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)", function () {
                    return this.toISOString()
                }),
                toISOString: function () {
                    var t = Math.abs(this.years()), e = Math.abs(this.months()), i = Math.abs(this.days()), n = Math.abs(this.hours()), s = Math.abs(this.minutes()), o = Math.abs(this.seconds() + this.milliseconds() / 1e3);
                    return this.asSeconds() ? (this.asSeconds() < 0 ? "-" : "") + "P" + (t ? t + "Y" : "") + (e ? e + "M" : "") + (i ? i + "D" : "") + (n || s || o ? "T" : "") + (n ? n + "H" : "") + (s ? s + "M" : "") + (o ? o + "S" : "") : "P0D"
                },
                localeData: function () {
                    return this._locale
                },
                toJSON: function () {
                    return this.toISOString()
                }
            }), Se.duration.fn.toString = Se.duration.fn.toISOString;
            for (Ce in oi)e(oi, Ce) && ve(Ce.toLowerCase());
            return Se.duration.fn.asMilliseconds = function () {
                return this.as("ms")
            }, Se.duration.fn.asSeconds = function () {
                return this.as("s")
            }, Se.duration.fn.asMinutes = function () {
                return this.as("m")
            }, Se.duration.fn.asHours = function () {
                return this.as("h")
            }, Se.duration.fn.asDays = function () {
                return this.as("d")
            }, Se.duration.fn.asWeeks = function () {
                return this.as("weeks")
            }, Se.duration.fn.asMonths = function () {
                return this.as("M")
            }, Se.duration.fn.asYears = function () {
                return this.as("y")
            }, Se.locale("en", {
                ordinalParse: /\d{1,2}(th|st|nd|rd)/,
                ordinal: function (t) {
                    var e = t % 10, i = 1 === M(t % 100 / 10) ? "th" : 1 === e ? "st" : 2 === e ? "nd" : 3 === e ? "rd" : "th";
                    return t + i
                }
            }), Se
        }()
    }(e = t.Internal || (t.Internal = {}))
}(ZoomCharts || (ZoomCharts = {}));
var ZoomCharts;
!function (t) {
    var e;
    !function (t) {
        var e;
        !function (t) {
            var e = function (e) {
                function i(t) {
                    e.call(this), this.animationOrder = 500, this.paintOrder = 35, this.updateOrder = 600, this.container = null, this.backgroundContainer = null, this.background = null, this.canvas = null, this.interactionContainer = null, this.menuContainer = null, this.outerBorder = null, this.scene = null, this.chart = t, this.scene = t.scene
                }

                return __extends(i, e), i.setContainerStyle = function (t) {
                    t.style.position = "absolute", t.style.left = "0px", t.style.right = "0px", t.style.top = "0px", t.style.bottom = "0px"
                }, i.prototype.createDom = function (e) {
                    this.shell = e, this.container = t.Helpers.createDom("div", "DVSL-container DVSL-" + e.chart.api.typeName), this.container.style.position = "relative", this.container.style.width = "100%", this.backgroundContainer = t.Helpers.createDom("div", "DVSL-background-container", null, this.container), i.setContainerStyle(this.backgroundContainer), this.background = t.Helpers.createDom("div", "DVSL-background", null, this.backgroundContainer), i.setContainerStyle(this.background), this.backgroundImage = t.Helpers.createDom("div", "DVSL-background-image", null, this.background), this.canvas = t.Helpers.createDom("canvas", "DVSL-canvas", null, this.container), i.setContainerStyle(this.canvas), this.outerBorder = t.Helpers.createDom("div", "DVSL-border", null, this.container), i.setContainerStyle(this.outerBorder), this.interactionContainer = t.Helpers.createDom("div", "DVSL-interaction", null, this.container), i.setContainerStyle(this.interactionContainer), this.menuContainer = t.Helpers.createDom("div", "DVSL-menu-container DVSL-menu-workaround", null, this.container), i.setContainerStyle(this.menuContainer), t.Helpers.createDom("span", "DVSL-empty", " ", this.menuContainer), this.updateSettings(this.scene.settings), this.interactionContainer.tabIndex = 0
                }, i.prototype.remove = function () {
                }, i.prototype.updateSettings = function (e) {
                    if (t.Helpers.hasProp(e, "area.style.image")) {
                        var i = e.area.style.image;
                        this.backgroundImage.style.backgroundImage = i ? "url(" + i + ")" : ""
                    }
                    t.Helpers.hasProp(e, "advanced.themeCSSClass") && (this.curThemeClass && t.Helpers.removeClass(this.container, this.curThemeClass), this.curThemeClass = this.scene.settings.advanced.themeCSSClass, t.Helpers.addClass(this.container, this.curThemeClass))
                }, i.prototype.doAnimations = function (t) {
                    t.changes.bounds && (this.backgroundImage.style.bottom = this.scene.bottomMargin + "px", this.backgroundImage.style.top = this.scene.topMargin + "px")
                }, i
            }(t.ChartElement);
            t.DomLayer = e
        }(e = t.Base || (t.Base = {}))
    }(e = t.Internal || (t.Internal = {}))
}(ZoomCharts || (ZoomCharts = {}));
var ZoomCharts;
!function (t) {
    var e;
    !function (t) {
        var e;
        !function (t) {
            var e = function () {
                function e(t, e, i) {
                    void 0 === i && (i = []), this.x = i, this.y1 = e, this.y0 = t
                }

                return e.prototype.isEmpty = function () {
                    return 0 === this.x.length
                }, e.prototype.makeCopy = function () {
                    return new e(this.y0, this.y1, this.x.slice(0))
                }, e.prototype.split = function (t) {
                    var i = new e(t, this.y1);
                    return this.y1 = t, i.x = this.x.slice(0), i
                }, e.prototype.add = function (t, e) {
                    for (var i = [], n = this.x.length, s = 0; n > s && this.x[s + 1] < t;)i.push(this.x[s], this.x[s + 1]), s += 2;
                    for (n > s && (t = Math.min(this.x[s], t)); n > s && this.x[s] <= e;)e = Math.max(e, this.x[s + 1]), s += 2;
                    for (i.push(t, e); n > s;)i.push(this.x[s], this.x[s + 1]), s += 2;
                    return this.x = i, this
                }, e.prototype.subtract = function (t, e) {
                    for (var i = [], n = this.x.length, s = 0; n > s && this.x[s + 1] <= t;)i.push(this.x[s], this.x[s + 1]), s += 2;
                    for (n > s && this.x[s] < t && i.push(this.x[s], t); n > s && this.x[s + 1] <= e;)s += 2;
                    for (n > s && this.x[s] < e && (i.push(e, this.x[s + 1]), s += 2); n > s;)i.push(this.x[s], this.x[s + 1]), s += 2;
                    return this.x = i, this
                }, e.prototype.subtractSlice = function (t) {
                    if (this.isEmpty() || t.isEmpty())return this;
                    for (var e = [], i = this.x, n = t.x, s = i.length, o = n.length, r = 0, a = 0, h = i[r], l = i[r + 1]; o > a;) {
                        var u = n[a], c = n[a + 1];
                        if (h >= c) a += 2; else if (u >= l) {
                            if (e.push(h, l), r += 2, r === s)break;
                            h = i[r], l = i[r + 1]
                        } else if (u > h && e.push(h, u), l > c) h = c, a += 2; else {
                            if (r += 2, r === s)break;
                            h = i[r], l = i[r + 1]
                        }
                    }
                    for (; s > r && (e.push(h, l), r += 2, r !== s);)h = i[r], l = i[r + 1];
                    return this.x = e, this
                }, e.prototype.intersectsSlice = function (t) {
                    if (this.isEmpty() || t.isEmpty())return !1;
                    for (var e = this.x, i = t.x, n = e.length, s = i.length, o = 0, r = 0; s > r && n > o;) {
                        var a = e[o], h = e[o + 1], l = i[r], u = i[r + 1];
                        if (a >= u) r += 2; else {
                            if (!(l >= h))return !0;
                            o += 2
                        }
                    }
                    return !1
                }, e.prototype.coversSlice = function (t) {
                    if (t.isEmpty())return !0;
                    for (var e = this.x, i = t.x, n = e.length, s = i.length, o = 0, r = 0; s > r && n > o;) {
                        var a = e[o], h = e[o + 1], l = i[r], u = i[r + 1];
                        if (l >= h) o += 2; else {
                            if (!(l >= a && h >= u))return !1;
                            r += 2
                        }
                    }
                    return r === s
                }, e.prototype.clip = function (t, e) {
                    for (var i = [], n = 0; n <= this.x.length - 2; n += 2) {
                        var s = this.x[n], o = this.x[n + 1];
                        o > t && e > s && (i.push(Math.max(s, t)), i.push(Math.min(o, e)))
                    }
                    return this.x = i, this
                }, e.prototype.tryMerge = function (t) {
                    if (this.x.length !== t.x.length || this.y1 !== t.y0)return !1;
                    for (var e = 0; e <= this.x.length - 1; e++)if (this.x[e] !== t.x[e])return !1;
                    return this.y1 = t.y1, !0
                }, e.prototype.intersects = function (t, e) {
                    for (var i = 0; i <= this.x.length - 2; i += 2) {
                        var n = this.x[i], s = this.x[i + 1];
                        if (e > n && s > t)return !0
                    }
                    return !1
                }, e.prototype.covers = function (t, e) {
                    for (var i = 0; i <= this.x.length - 2; i += 2) {
                        var n = this.x[i], s = this.x[i + 1];
                        if (t >= n && s >= e)return !0
                    }
                    return !1
                }, e.prototype.findOverlappingRect = function (t, e, i) {
                    for (var n = !1, s = 0; s <= this.x.length - 2; s += 2) {
                        var o = this.x[s], r = this.x[s + 1];
                        e > o && r > e - i && (t = Math.min(t, Math.max(o, e - i)), n = !0), r > t && t + i > o && (e = Math.max(e, Math.min(r, t + i)), n = !0)
                    }
                    return {x0: t, x1: e, overlaps: n}
                }, e.prototype.toRects = function (e) {
                    for (var i = 0; i <= this.x.length - 2; i += 2) {
                        var n = this.x[i], s = this.x[i + 1];
                        e.push(new t.Rect(n, this.y0, s, this.y1))
                    }
                }, e
            }();
            t.AreaSlice = e;
            var i = function () {
                function i() {
                    this.slices = [new e(-1e30, 1e30)]
                }

                return i.prototype.makeCopy = function () {
                    var t = new i;
                    t.slices = [];
                    for (var e = 0; e < this.slices.length; e++) {
                        var n = this.slices[e];
                        t.slices.push(n.makeCopy())
                    }
                    return t
                }, i.prototype.getBounds = function () {
                    var e = 1 / 0, i = -1 / 0, n = 1 / 0, s = -1 / 0;
                    if (this.slices.length > 1) {
                        n = this.slices[1].y0, s = this.slices[this.slices.length - 1].y1;
                        for (var o = 0; o < this.slices.length; o++) {
                            var r = this.slices[o];
                            r.x.length > 0 && (e = Math.min(e, r.x[0]), i = Math.max(i, r.x[r.x.length - 1]))
                        }
                    }
                    return new t.Rect(e, n, i, s)
                }, i.prototype.addRect = function (t) {
                    if (t.isEmpty())return this;
                    for (var e = t.x0, i = t.x1, n = t.y0, s = t.y1, o = [], r = null, a = 0; a < this.slices.length; a++) {
                        var h = this.slices[a];
                        if (h.y0 >= s || h.y1 <= n) r && r.tryMerge(h) || (o.push(h), r = h); else {
                            if (n > h.y0) {
                                var l = h.split(n);
                                r && r.tryMerge(h) || (o.push(h), r = h), h = l
                            }
                            if (s < h.y1) {
                                var l = h.split(s);
                                h.add(e, i), r && r.tryMerge(h) || (o.push(h), r = h), h = l
                            } else h.add(e, i);
                            r && r.tryMerge(h) || (o.push(h), r = h)
                        }
                    }
                    return this.slices = o, this
                }, i.prototype.subtractRect = function (t) {
                    if (t.isEmpty())return this;
                    for (var e = t.x0, i = t.x1, n = t.y0, s = t.y1, o = [], r = null, a = 0; a < this.slices.length; a++) {
                        var h = this.slices[a];
                        if (h.y0 >= s || h.y1 <= n) r && r.tryMerge(h) || (o.push(h), r = h); else {
                            if (n > h.y0) {
                                var l = h.split(n);
                                r && r.tryMerge(h) || (o.push(h), r = h), h = l
                            }
                            if (s < h.y1) {
                                var l = h.split(s);
                                h.subtract(e, i), r && r.tryMerge(h) || (o.push(h), r = h), h = l
                            } else h.subtract(e, i);
                            r && r.tryMerge(h) || (o.push(h), r = h)
                        }
                    }
                    return this.slices = o, this
                }, i.prototype.clip = function () {
                    return 1
                }, i.prototype.subtractArea = function (t) {
                    if (t.isEmpty())return this;
                    for (var e = [], i = null, n = this.slices, s = t.slices, o = n.length, r = s.length, a = 0, h = 0, l = n[a]; r > h;) {
                        var u = s[h];
                        if (l.y1 <= u.y0) {
                            if (i && i.tryMerge(l) || (e.push(l), i = l), a += 1, a === o)break;
                            l = n[a]
                        } else if (u.y1 <= l.y0 || u.isEmpty()) h += 1; else {
                            if (l.y0 < u.y0) {
                                var c = l.split(u.y0);
                                i && i.tryMerge(l) || (e.push(l), i = l), l = c
                            }
                            if (l.y1 > u.y1) {
                                var c = l.split(u.y1);
                                l.subtractSlice(u), i && i.tryMerge(l) || (e.push(l), i = l), l = c, h += 1
                            } else {
                                if (l.subtractSlice(u), i && i.tryMerge(l) || (e.push(l), i = l), a += 1, a === o)break;
                                l = n[a]
                            }
                        }
                    }
                    for (; o > a && (i && i.tryMerge(l) || (e.push(l), i = l), a += 1, a !== o);)l = n[a];
                    return this.slices = e, this
                }, i.prototype.intersectsArea = function (t) {
                    if (t.isEmpty() || this.isEmpty())return !1;
                    for (var e = this.slices, i = t.slices, n = e.length, s = i.length, o = 0, r = 0; s > r && n > o;) {
                        var a = i[r], h = e[o];
                        if (h.intersectsSlice(a))return !0;
                        h.y1 < a.y1 ? o += 1 : a.y1 < h.y1 ? r += 1 : (o += 1, r += 1)
                    }
                    return !1
                }, i.prototype.coversArea = function (t) {
                    if (t.isEmpty())return !0;
                    for (var e = this.slices, i = t.slices, n = e.length, s = i.length, o = 0, r = 0; s > r && n > o;) {
                        var a = i[r], h = e[o];
                        if (!h.coversSlice(a))return !1;
                        h.y1 < a.y1 ? o += 1 : a.y1 < h.y1 ? r += 1 : (o += 1, r += 1)
                    }
                    return !0
                }, i.prototype.findOverlappingRect = function (e, i) {
                    if (this.isEmpty())return null;
                    for (var n = this.slices[1].x[0], s = Math.min(this.slices[1].x[1], n + e), o = this.slices[1].y0, r = Math.min(this.slices[1].y1, o + i), a = 0; a < this.slices.length; a++) {
                        var h = this.slices[a];
                        if (h.y0 >= o + i)break;
                        var l = h.findOverlappingRect(n, s, e);
                        n = l.x0, s = l.x1;
                        var u = l.overlaps;
                        u && (r = Math.min(h.y1, o + i))
                    }
                    return new t.Rect(n, o, s, r)
                }, i.prototype.findTopPosition = function (t, e) {
                    for (var i = 1 / 0, n = 0; n < this.slices.length; n++) {
                        var s = this.slices[n];
                        s.covers(t, e) && (i = Math.min(i, s.y0))
                    }
                    return 1 / 0 === i ? 0 : i
                }, i.prototype.intersects = function (t) {
                    for (var e = t.x0, i = t.x1, n = t.y0, s = t.y1, o = 0; o < this.slices.length; o++) {
                        var r = this.slices[o];
                        if (r.y0 < s && r.y1 > n && r.intersects(e, i))return !0
                    }
                    return !1
                }, i.prototype.isEmpty = function () {
                    return 1 === this.slices.length && this.slices[0].isEmpty()
                }, i.prototype.coversRect = function (t) {
                    for (var e = t.x0, i = t.x1, n = t.y0, s = t.y1, o = 0; o < this.slices.length; o++) {
                        var r = this.slices[o];
                        if (n < r.y1 && s > r.y0 && !r.covers(e, i))return !1
                    }
                    return !0
                }, i.prototype.toRects = function () {
                    for (var t = [], e = 0; e < this.slices.length; e++) {
                        var i = this.slices[e];
                        i.toRects(t)
                    }
                    return t
                }, i
            }();
            t.AreaCollection = i
        }(e = t.Base || (t.Base = {}))
    }(e = t.Internal || (t.Internal = {}))
}(ZoomCharts || (ZoomCharts = {}));
var ZoomCharts;
!function (t) {
    var e;
    !function (t) {
        var e;
        !function (t) {
            var e = function () {
                function e(i, n) {
                    var s = this;
                    this.chart = null, this.settings = null, this.scene = null, this.events = null, this.profiler = null, this.container = null, this.canvas = null, this.scaleX = 1, this.scaleY = 1, this.paintRequested = null, this.labelRenderer = null, this.prevTime = null, this.paintNowInProgreess = !1, this.animationInProgress = !1, this.mouseEvents = null, this.innerAreaCache = null, this.chartWidth = 0, this.chartHeight = 0, this.sizeChanged = !0, this.fullScreenMode = !1, this.fullscreenBeforeW = 0, this.fullscreenBeforeH = 0, this.lastCursor = null, this.chart = i, this.settings = i.settings, this.scene = i.scene, this.domLayer = n, this.buildDom(), this.labelRenderer = new t.LabelRenderer(this.settings, this.chart.assetsLoader, this.container), this.mouseEvents = new t.MouseEvents(this.domLayer.interactionContainer, this.settings.advanced.pointer, [this.domLayer.menuContainer]), this.profiler = new t.Profiler(this);
                    for (var o = 0; o < e.MouseEventConfig.length; o++) {
                        var r = e.MouseEventConfig[o];
                        !function (t) {
                            s.mouseEvents.listen(t.ev, function (e) {
                                return s.notifyMouseEvent(e, t)
                            })
                        }(r)
                    }
                    this.events = new t.ChartEvents(i, this), this.events.addElement(this.domLayer), this.containerResizeFunc = function () {
                        return s.updateSize(!1)
                    }, t.Helpers.listenResize(this.container, this.containerResizeFunc), t.Helpers.listen(window, "resize", this.containerResizeFunc)
                }

                return e.prototype.updateSize = function (e) {
                    var i, n, s = this.settings.area;
                    this.fullScreenMode ? (i = window.innerWidth, n = window.innerHeight) : this.fullscreenBeforeW > 0 ? (i = this.fullscreenBeforeW, n = this.fullscreenBeforeH, this.fullscreenBeforeW = 0, this.fullscreenBeforeH = 0) : (i = s.width || Math.min(s.maxWidth, this.container.clientWidth), n = s.height || Math.min(s.maxHeight, this.container.clientHeight), i > 0 && 2 > n && (n = this.settings.area.height || this.settings.area.defaultHeight), i = Math.max(s.minWidth, i), n = Math.max(s.minHeight, n)), (e || i >= 2 && i !== this.chartWidth || n >= 2 && n !== this.chartHeight) && this.setSize(i, n), t.Helpers.updateResize(this.container)
                }, e.prototype.setSize = function (e, i) {
                    this.domLayer.container.style.height = i + "px", this.domLayer.container.style.width = e + "px", this.chart.log("Update size: " + i + ", " + e), this.chartHeight = i, this.chartWidth = e, this.sizeChanged = !0, this.events.setNewSize(new t.Rect(0, 0, e, i), !0), t.Helpers.updateResize(this.container)
                }, e.prototype.setFullscreen = function (e) {
                    e !== this.fullScreenMode && (this.fullScreenMode = e, e ? (this.fullscreenBeforeW = this.scene.chartWidth, this.fullscreenBeforeH = this.scene.chartHeight, t.Helpers.addClass(this.domLayer.container, "DVSL-fullscreen")) : t.Helpers.removeClass(this.domLayer.container, "DVSL-fullscreen"), this.updateSize(!0))
                }, e.prototype.buildDom = function () {
                    if (!this.settings.container)throw new Error("Chart container is not defined in the settings.");
                    if (!t.Helpers.isDomObject(this.settings.container))throw new Error("Chart container is not a DOM object.");
                    this.container = this.settings.container, null != this.container._DVSL_ChartInstance && this.container._DVSL_ChartInstance.remove(), this.container.innerHTML = "", this.container._DVSL_ChartInstance = this.chart, this.domLayer.createDom(this), this.container.appendChild(this.domLayer.container), "undefined" != typeof G_vmlCanvasManager && (G_vmlCanvasManager.init_(document), G_vmlCanvasManager.initElement(this.domLayer.canvas)), this.backgroundContainer = this.domLayer.backgroundContainer, this.interactiveContainer = this.domLayer.interactionContainer, this.menuContainer = this.domLayer.menuContainer, this.canvas = this.domLayer.canvas
                }, e.prototype.remove = function () {
                    this.mouseEvents.remove(), this.domLayer.remove(), t.Helpers.unlistenResize(this.container), delete this.container._DVSL_ChartInstance, t.Helpers.unlisten(window, "resize", this.containerResizeFunc), this.container.innerHTML = ""
                }, e.prototype.updateSettings = function (t) {
                    t.area && this.updateSize(!0), this.domLayer.updateSettings(t)
                }, e.prototype.notifyMouseEvent = function (t, e) {
                    this.chart.removed || this.profiler.mouseEvent(t, e) || (t.noDefault = !1, t.consumed = !1, this.events.onMouseEvent(t, e), t.cursor || (t.cursor = "default"), this.lastCursor !== t.cursor && (this.interactiveContainer.style.cursor = t.cursor, this.menuContainer.style.cursor = t.cursor, this.lastCursor = t.cursor))
                }, e.prototype.notifyKeyEvent = function (t) {
                    this.chart.removed || this.profiler.keyEvent(t, "KeyDown") || this.events.onKeyEvent(t)
                }, e.prototype.requestPaint = function () {
                    var e = this;
                    null === this.paintRequested && (this.paintRequested = this.settings.advanced.useAnimationFrame ? t.Helpers.requestAnimationFrame(function (t, i) {
                            return e.paintScene(i ? t : null)
                        }) : window.setTimeout(function () {
                            return e.paintScene(null)
                        }, 5))
                }, e.prototype.paintNow = function (e) {
                    return void 0 === e && (e = !1), this.paintNowInProgreess ? void this.chart.error("paintNow called from within paintNow call") : (this.paintNowInProgreess = !0, (null !== this.paintRequested || e) && (this.settings.advanced.useAnimationFrame ? t.Helpers.cancelAnimationFrame(this.paintRequested) : window.clearTimeout(this.paintRequested), this.paintScene(null)), void(this.paintNowInProgreess = !1))
                }, e.prototype.paintScene = function (e) {
                    if (!this.chart.removed) {
                        this.paintRequested = null;
                        var i = null !== e ? e : t.Helpers.performanceNow(), n = new t.UpdateEvent;
                        n.timeStamp = i, n.isExport = !1, this.prevTime && this.animationInProgress ? (n.dtime = n.timeStamp - this.prevTime, n.dtime > 1e3 && (n.dtime = 1e3), n.dtime < 1 && (n.dtime = 1)) : n.dtime = 30, this.prevTime = i, this.chartWidth > 0 && this.chartHeight > 0 && (this.sizeChanged && (this.resizeCanvas(), this.sizeChanged = !1), this.innerAreaCache = null, this.events.animateFrame(n), n.animating ? (this.animationInProgress = !0, this.requestPaint()) : this.animationInProgress = !1, this.profiler.paintDone())
                    }
                }, e.prototype.resizeCanvas = function () {
                    var e, i, n = this.chart.settings;
                    if (this.settings.advanced.highDPI) {
                        var s = t.Helpers.canvasScaling();
                        i = s.x, e = s.y
                    } else i = 1, e = 1;
                    var o = Math.min(n.advanced.maxCanvasWidth, Math.round(this.chartWidth * i)), r = Math.min(n.advanced.maxCanvasHeight, Math.round(this.chartHeight * e));
                    this.scaleX = o / this.chartWidth, this.scaleY = r / this.chartHeight, this.canvas.width = o, this.canvas.height = r, this.canvas.style.width = this.chartWidth + "px", this.canvas.style.height = this.chartHeight + "px"
                }, e.prototype.prepareContext = function (t) {
                    var e = this.scene, i = this.canvas.getContext("2d");
                    i.setTransform(1, 0, 0, 1, 0, 0), i.clearRect(0, 0, this.canvas.width, this.canvas.height);
                    var n = this.settings.area.style;
                    n.fillColor && (i.fillStyle = n.fillColor, i.fillRect(0, 0, this.canvas.width, this.canvas.height)), i.setTransform(this.scaleX, 0, 0, this.scaleY, 0, 0), t.context = i, t.scaleX = this.scaleX, t.scaleY = this.scaleY, t.labelRenderer = this.labelRenderer, this.labelRenderer.startFrame(e.chartWidth, e.chartHeight, t.scaleX, t.scaleY)
                }, e.prototype.finalizeContext = function (t) {
                    if (this.settings.area.style.overlayColor) {
                        var e = t.context;
                        e.fillStyle = this.settings.area.style.overlayColor, e.setTransform(1, 0, 0, 1, 0, 0), e.fillRect(0, 0, this.canvas.width, this.canvas.height)
                    }
                    this.settings.advanced.logging && this.labelRenderer.printStats(), this.labelRenderer.finishFrame()
                }, e.prototype.exportToImageGetDimensions = function () {
                    var e = new t.UpdateEvent;
                    e.isExport = !0, e.context = this.canvas.getContext("2d"), e.labelRenderer = this.labelRenderer;
                    var i = this.events.updateLayout(e);
                    return e.isExport = !1, this.events.updateLayout(e), {
                        width: i.w(),
                        height: i.h()
                    }
                }, e.prototype.exportToContext = function (e, i, n, s) {
                    var o = new t.LabelRenderer(this.settings, this.chart.assetsLoader, this.container);
                    o.allowCache = !1, o.startFrame(1, 1, this.scaleX, this.scaleY);
                    var r = new t.UpdateEvent;
                    r.isExport = !0, r.timeStamp = this.prevTime, r.dtime = 0, r.context = e, r.scaleX = this.scaleX, r.scaleY = this.scaleY, r.labelRenderer = o;
                    var a = this.events.updateLayout(r);
                    i = n = 0, e.save(), e.setTransform(s, 0, 0, s, i - a.x0 * s, n - a.y0 * s), this.events.doPaint(r), r.isExport = !1, this.events.updateLayout(r), e.restore()
                }, e.prototype.getChartInnerArea = function () {
                    if (this.innerAreaCache)return this.innerAreaCache;
                    var e = new t.AreaCollection;
                    e.addRect(new t.Rect(this.scene.x0, this.scene.y0, this.scene.x0 + this.scene.width, this.scene.y0 + this.scene.height));
                    for (var i = this.menuContainer.getBoundingClientRect(), n = i.left, s = i.top, o = this.menuContainer.children, r = 0; r < o.length; r += 1) {
                        var a = o[r];
                        if (a.offsetHeight > 0 || a.offsetWidth > 0) {
                            var h = a.getBoundingClientRect();
                            e.subtractRect(new t.Rect(h.left - n, h.top - s, h.right - n, h.bottom - s))
                        }
                    }
                    return this.innerAreaCache = e, e
                }, e.MouseEventConfig = [{
                    ev: t.MouseEvents.EVENT_GLOBAL_DOWN,
                    name: "GlobalPointerDown"
                }, {
                    ev: t.MouseEvents.EVENT_DOWN,
                    name: "PointerDown",
                    captures: !0
                }, {
                    ev: t.MouseEvents.EVENT_UP,
                    name: "PointerUp",
                    needsCapture: !0,
                    releasesCapture: !0
                }, {
                    ev: t.MouseEvents.EVENT_DRAG,
                    name: "PointerDrag",
                    needsCapture: !1,
                    captures: !0
                }, {
                    ev: t.MouseEvents.EVENT_MOVE,
                    name: "PointerMove",
                    captures: !0
                }, {
                    ev: t.MouseEvents.EVENT_LEAVE,
                    name: "PointerOut"
                }, {
                    ev: t.MouseEvents.EVENT_CANCEL,
                    name: "PointerCancel",
                    needsCapture: !0,
                    releasesCapture: !0
                }, {
                    ev: t.MouseEvents.EVENT_CLICK,
                    name: "Click"
                }, {
                    ev: t.MouseEvents.EVENT_RCLICK,
                    name: "RightClick"
                }, {
                    ev: t.MouseEvents.EVENT_DBLCLICK,
                    name: "DoubleClick"
                }, {
                    ev: t.MouseEvents.EVENT_TPLCLICK,
                    name: "TripleClick"
                }, {ev: t.MouseEvents.EVENT_WHEEL, name: "Wheel"}], e
            }();
            t.ChartOuterShell = e;
            var i = function () {
                function e(e, i) {
                    this.fullScreenMode = !1, this.chart = e, this.settings = e.settings, this.scene = e.scene, this.parentShell = i, this.buildDom(), this.events = new t.ChartEvents(e, this), this.parentShell.events.addSubchart(this.chart), this.updateSize()
                }

                return e.prototype.getChartInnerArea = function () {
                    return this.parentShell.getChartInnerArea()
                }, e.prototype.requestPaint = function () {
                    this.parentShell.requestPaint()
                }, e.prototype.paintNow = function (t) {
                    this.parentShell.paintNow(t)
                }, e.prototype.buildDom = function () {
                    this.interactiveContainer = this.parentShell.interactiveContainer, this.backgroundContainer = this.parentShell.backgroundContainer, this.menuContainer = this.parentShell.menuContainer
                }, e.prototype.remove = function () {
                    this.parentShell.events.removeSubchart(this.chart)
                }, e.prototype.updateSettings = function (t) {
                    t.area && this.updateSize()
                }, e.prototype.updateSize = function (e) {
                    void 0 === e && (e = !1);
                    var i = this.settings.area;
                    this.events.setNewSize(new t.Rect(i.left, i.top, i.left + i.width, i.top + i.height), !1)
                }, e.prototype.prepareContext = function (t) {
                    var e = this.settings.area.style;
                    if (e.fillColor) {
                        var i = t.context, n = this.scene;
                        i.fillStyle = e.fillColor, i.fillRect(n.chartLeft, n.chartTop, n.chartWidth, n.chartHeight)
                    }
                }, e.prototype.finalizeContext = function (t) {
                    var e = this.settings.area.style;
                    if (e.overlayColor) {
                        var i = t.context, n = this.scene;
                        i.fillStyle = e.overlayColor, i.fillRect(n.chartLeft, n.chartTop, n.chartWidth, n.chartHeight)
                    }
                }, e.prototype.setFullscreen = function () {
                }, e
            }();
            t.ChartInnerShell = i
        }(e = t.Base || (t.Base = {}))
    }(e = t.Internal || (t.Internal = {}))
}(ZoomCharts || (ZoomCharts = {}));
var ZoomCharts;
!function (t) {
    var e;
    !function (t) {
        var e;
        !function (t) {
            var e = function (e) {
                function i(t) {
                    e.call(this), this.animationOrder = 2e3, this.paintOrder = 70, this.updateOrder = 200, this.scene = null, this.loadingTime = null, this.chart = t, this.scene = t.scene
                }

                return __extends(i, e), i.prototype.doAnimations = function (t) {
                    this.scene.loading && (t.animating = !0)
                }, i.prototype.paintScene = function (e) {
                    var i = this.scene, n = this.scene.getMessage(), s = this.scene.settings.advanced.style.loadingArcStyle, o = this.scene.loading && "hidden" !== s.location;
                    if (o || (this.loadingTime = null), n || o) {
                        null === this.loadingTime && (this.loadingTime = e.timeStamp);
                        var r, a, h = e.context;
                        if ("corner" === s.location ? (r = i.x0 + i.width, a = i.y0) : (r = i.x0 + i.width / 2, a = i.y0 + i.height / 2), n) {
                            t.Graphics.textStyle(h, this.scene.settings.advanced.style.messageTextStyle), h.textBaseline = "middle", h.textAlign = "center";
                            var l = t.Graphics.getTextHeight(h, this.scene.settings.advanced.style.messageTextStyle.font), u = h.measureText(n).width;
                            "corner" === s.location && (r -= u, a += 1.5 * l);
                            var c = a;
                            o && (a -= l, c = a + s.r + l), h.fillText(n, r, c)
                        }
                        if (o) {
                            var p = s.r, d = s.lineWidth;
                            n || "corner" !== s.location || (r -= 1.2 * (p + d), a += 1.2 * (p + d)), h.save(), h.lineCap = "round", h.lineWidth = d;
                            var f = (e.timeStamp - this.loadingTime) / 700 * Math.PI, m = h.createLinearGradient(r + p * Math.cos(f + Math.PI), a + p * Math.sin(f + Math.PI), r + p * Math.cos(f), a + p * Math.sin(f));
                            m.addColorStop(0, s.lineColor), m.addColorStop(1, "transparent"), h.strokeStyle = m, h.beginPath(), h.arc(r, a, p, f, f + Math.PI), h.stroke(), h.restore()
                        }
                    }
                }, i
            }(t.ChartElement);
            t.MessagesOverlay = e
        }(e = t.Base || (t.Base = {}))
    }(e = t.Internal || (t.Internal = {}))
}(ZoomCharts || (ZoomCharts = {}));
var ZoomCharts;
!function (t) {
    var e;
    !function (e) {
        var i;
        !function (i) {
            var n = function () {
                if ("undefined" == typeof document)return "";
                var e = document.currentScript, n = t.PackageInfo.LibraryName;
                "<?" === n.substr(0, 2) && (n = "everything");
                var s = n.indexOf("-");
                s > -1 && (n = n.substr(0, s));
                for (var o = new RegExp("^(.*?/" + n + "(-dev|.min|).js)"), r = document.getElementsByTagName("script"), a = 0; a < r.length; a++) {
                    var h = r[a].src;
                    if (h) {
                        var l = h.match(o);
                        if (l)return l[1] + "/../assets/"
                    }
                }
                return e && e.src ? (i.Helpers.warn("Cannot locate the ZoomCharts script path based on file name '" + n + ".js'. The script path was detected using `document.currentScript` which is not supported on all browsers. Please specify 'assetsUrlBase' in settings when creating the chart for full browser compatibility."), e.src.match(/^([^?#]*)/)[1] + "/../assets/") : ""
            }(), s = function () {
                function t() {
                }

                return t.hasPendingRequests = function () {
                    return i.Helpers.hasProperties(this._imageLoading) || i.Helpers.hasProperties(this.pendingHTMLAssets)
                }, t.getAssetImage = function (t, n) {
                    var s = this;
                    if (this._imageCache.hasOwnProperty(t))return this._imageCache[t];
                    if (this._imageLoading.hasOwnProperty(t))return null;
                    if (!t)return null;
                    var o = function (e) {
                        return delete s._imageLoading[t], s._imageCache[t] = e, n ? n(e) : void 0
                    }, r = function () {
                        var t = e.Resources.ErrorImage, n = s._imageCache[t];
                        if (n) o(n); else if (s._imagesPendingForErrors.push(o), !s._imageLoading.hasOwnProperty(t)) {
                            var r = function (e) {
                                delete s._imageLoading[t], s._imageCache[t] = e;
                                for (var i = 0; i < s._imagesPendingForErrors.length; i++) {
                                    var n = s._imagesPendingForErrors[i];
                                    n(e)
                                }
                                s._imagesPendingForErrors = null
                            };
                            i.Helpers.buildImage(t, r, function () {
                            }), s._imageCache.hasOwnProperty(t) || (s._imageLoading[t] = !0)
                        }
                    };
                    return this._imageLoading[t] = !0, i.Helpers.buildImage(t, o, r), this._imageCache.hasOwnProperty(t) ? this._imageCache[t] : null
                }, t.loadHtmlAssets = function (t, e) {
                    for (var i = this, n = !1, s = 0; s < t.length; s++) {
                        var o = t[s];
                        this.loadedHTMLAssets.hasOwnProperty(o) || (this.pendingHTMLAssets.hasOwnProperty(o) ? n = !0 : this.loadHTMLAsset(o, function (t) {
                                return i.htmlAssetLoaded(t)
                            }) && (this.pendingHTMLAssets[o] = !0, n = !0))
                    }
                    return n ? (this.callbacks.push(e), !0) : !1
                }, t.htmlAssetLoaded = function (t) {
                    if (delete this.pendingHTMLAssets[t], this.loadedHTMLAssets[t] = !0, !i.Helpers.hasProperties(this.pendingHTMLAssets)) {
                        for (var e = 0; e < this.callbacks.length; e += 1)this.callbacks[e](this.errors);
                        this.callbacks = [], this.errors = []
                    }
                }, t.loadHTMLAsset = function (t, e) {
                    var n = this, s = i.Helpers.getExtension(t);
                    if ("css" === s) {
                        var o = document.createElement("link");
                        return o.setAttribute("rel", "stylesheet"), o.setAttribute("href", t), o.setAttribute("type", "text/css"), i.Helpers.listen(o, "load", function () {
                            return e(t)
                        }), i.Helpers.listen(o, "error", function () {
                            n.errors.push("Failed to load asset: " + t), e(t)
                        }), document.getElementsByTagName("head")[0].appendChild(o), setTimeout(function () {
                            if (!n.loadedHTMLAssets.hasOwnProperty(t)) {
                                var i = document.createElement("img");
                                i.onerror = function () {
                                    return e(t)
                                }, i.src = t
                            }
                        }, 200, "skipTestWrapper"), !0
                    }
                    if ("js" === s) {
                        var r = document.createElement("script");
                        return r.setAttribute("src", t), r.setAttribute("type", "text/javascript"), i.Helpers.listen(r, "load", function () {
                            return e(t)
                        }), i.Helpers.listen(r, "error", function () {
                            n.errors.push("Failed to load asset: " + t), e(t)
                        }), document.getElementsByTagName("head")[0].appendChild(r), !0
                    }
                    return this.errors.push("Assets: Do not know how to load " + t), !1
                }, t._imageCache = {}, t._imageLoading = {}, t._imagesPendingForErrors = [], t.loadedHTMLAssets = {}, t.pendingHTMLAssets = {}, t.callbacks = [], t.errors = [], t
            }(), o = function () {
                function e(t) {
                    this.chart = t, this.settings = t.settings, this.assetsUrlBase = this.settings.assetsUrlBase || n, this.assetsUrlBase.length > 0 && "/" !== this.assetsUrlBase[this.assetsUrlBase.length - 1] && (this.assetsUrlBase = this.assetsUrlBase + "/")
                }

                return e.prototype.getAssetUrl = function (e) {
                    return 0 === e.indexOf("builtin://") ? this.settings.advanced.builtinAssets[e.slice(10)] : 0 === e.indexOf("assets://") ? (this.assetsUrlBase || this.chart.error("Cannot locate the ZoomCharts script path based on file name '" + t.PackageInfo.LibraryName + ".js'. Please specify 'assetsUrlBase' in settings when creating the chart."), this.assetsUrlBase + e.slice(9)) : e
                }, e.prototype.hasPendingRequests = function () {
                    return s.hasPendingRequests()
                }, e.prototype.getAssetImage = function (t, e) {
                    var i = this;
                    return s.getAssetImage(this.getAssetUrl(t), function (t) {
                        i.chart.events.requestPaint(), e && e(t)
                    })
                }, e.prototype.loadAssetsList = function (t, e) {
                    for (var i = this, n = [], o = 0; o < t.length; o += 1) {
                        var r = this.getAssetUrl(t[o]);
                        n.push(r)
                    }
                    var a = function (t) {
                        for (var n = 0; n < t.length; n += 1)i.chart.error(t[n]);
                        i.chart.log("Assets loaded"), e()
                    }, h = s.loadHtmlAssets(n, a);
                    return h && this.chart.log("Loading assets"), h
                }, e
            }();
            i.AssetsLoader = o
        }(i = e.Base || (e.Base = {}))
    }(e = t.Internal || (t.Internal = {}))
}(ZoomCharts || (ZoomCharts = {}));
var ZoomCharts;
!function (t) {
    var e;
    !function (t) {
        var e;
        !function (t) {
            var e = function (t) {
                function e(e) {
                    t.call(this), this.animationOrder = 0, this.paintOrder = 1e4, this.touches = {}, this.fps = 0, this.prevFrame = null, this.frameCount = 0, this.chart = e, this.settings = e.settings.advanced, this.captureTouches = this.settings.showTouches
                }

                return __extends(e, t), e.prototype.onSceneChange = function () {
                    this.captureTouches = this.settings.showTouches
                }, e.prototype.paintScene = function (t) {
                    var e = "";
                    if (this.settings.showTimestamp && (e += Math.round(t.timeStamp)), this.settings.showFPS) {
                        if (this.frameCount += 1, this.prevFrame) {
                            var i = Math.max(t.timeStamp - this.prevFrame, 1) / 1e3, n = 1 / i, s = Math.min(1, 3 * i);
                            this.fps = this.fps * (1 - s) + n * s
                        }
                        this.prevFrame = t.timeStamp, e += "FPS:" + Math.round(this.fps)
                    }
                    var o = t.context;
                    if (this.captureTouches) {
                        var r = 0;
                        for (var a in this.touches) {
                            var h = this.touches[a];
                            if (this.touches.hasOwnProperty(a)) {
                                o.beginPath(), o.moveTo(h.dx, h.dy);
                                for (var l = 0; l < h.trace.length; l++) {
                                    var u = h.trace[l];
                                    o.lineTo(u.x, u.y)
                                }
                                h.cancelled ? (o.strokeStyle = "red", o.fillStyle = "red", o.lineWidth = 1) : h.up ? (o.strokeStyle = "gray", o.fillStyle = "gray", o.lineWidth = 3) : (o.strokeStyle = "rgba(0,139,139,0.5)", o.fillStyle = "rgba(0,139,139,0.5)", o.lineWidth = 3), o.moveTo(h.x + 30, h.y), o.stroke(), o.beginPath(), o.arc(h.x, h.y, 30, 0, 2 * Math.PI), o.fill(), h.up || (r += 1)
                            }
                        }
                        o.beginPath(), o.fillStyle = "black";
                        for (var a in this.touches)if (this.touches.hasOwnProperty(a))for (var h = this.touches[a], l = 0; l < h.trace.length; l++) {
                            var u = h.trace[l];
                            o.rect(u.x - 1, u.y - 1, 2, 2)
                        }
                        o.fill(), e += "\ntouches:" + r
                    }
                    if (e.length > 0) {
                        var c = this.chart.shell.getChartInnerArea(), p = Math.max(30, c.findTopPosition(50, 200));
                        o.fillStyle = "#000", o.textAlign = "start", o.textBaseline = "middle", o.font = "bold 11px Arial", o.fillText(e, 50, p)
                    }
                }, e.prototype.previewPointerDown = function (t) {
                    if (this.captureTouches) {
                        for (var e in this.touches) {
                            var i = this.touches[e];
                            this.touches.hasOwnProperty(e) && i.up && delete this.touches[e]
                        }
                        this.touches[t.identifier] = {
                            dx: t.x,
                            dy: t.y,
                            x: t.x,
                            y: t.y,
                            up: !1,
                            cancelled: !1,
                            trace: []
                        }, t.changes.requestPaint = !0
                    }
                }, e.prototype.previewPointerDrag = function (t) {
                    if (this.captureTouches) {
                        var e = this.touches[t.identifier];
                        e.x = t.x, e.y = t.y, e.trace.push({
                            x: e.x,
                            y: e.y
                        }), t.changes.requestPaint = !0
                    }
                }, e.prototype.previewPointerUp = function (t) {
                    this.captureTouches && (this.touches[t.identifier].up = !0, this.previewPointerDrag(t))
                }, e.prototype.previewPointerCancel = function (t) {
                    if (this.captureTouches) {
                        var e = this.touches[t.identifier];
                        e.up = !0, e.cancelled = !0, this.previewPointerDrag(t), t.changes.requestPaint = !0
                    }
                }, e
            }(t.ChartElement);
            t.TouchMarkers = e
        }(e = t.Base || (t.Base = {}))
    }(e = t.Internal || (t.Internal = {}))
}(ZoomCharts || (ZoomCharts = {}));
var ZoomCharts;
!function (t) {
    var e;
    !function (t) {
        var e;
        !function (t) {
            var e = function () {
                function e() {
                }

                return e.exportToImage = function (t, i, n, s) {
                    i || (i = "png"), void 0 === s && (s = "png" === i);
                    var o = {
                        png: "image/png",
                        jpeg: "image/jpeg"
                    }, r = o[i], a = e.exportToImageGetDimensions(t, n), h = a.width, l = a.height, u = a.scale, c = a.chartWidth, p = a.chartHeight, d = document.createElement("canvas");
                    d.width = h, d.height = l;
                    var f = d.getContext("2d");
                    return s || (f.fillStyle = "#fff", f.fillRect(0, 0, d.width, d.height)), t.shell.exportToContext(f, (h - c * u) / 2, (l - p * u) / 2, u), d.toDataURL(r)
                }, e.exportToPdf = function (t, i, n) {
                    var s, o, r = t.shell.exportToImageGetDimensions(), a = [10, 10, 10, 10], h = 0, l = 0, u = 0, c = 0, p = 72, d = 1, f = 0, m = 0;
                    r.width >= r.height ? (s = [297, 210], o = "l") : (s = [210, 297], o = "p"), h = s[0] / 25.4 * p, l = s[1] / 25.4 * p, d = Math.min(l / r.height, h / r.width), "l" === o ? (f = r.width * d / h * s[0] - a[1] - a[3], u = (s[0] - f - a[1] - a[3]) / 2, m = r.height / r.width * f, c = (s[1] - a[0] - a[2] - m) / 2) : (m = r.height * d / l * s[1] - a[0] - a[2], c = (s[1] - m - a[0] - a[2]) / 2, f = r.width / r.height * m, u = (s[0] - a[1] - a[3] - f) / 2);
                    var g = e.exportToImage(t, "jpeg", {scaling: 3 * d}, n), y = new jsPDF(o, "mm", "a4");
                    return y.addImage(g, "JPEG", a[3] + u, a[0] + c, f, m), y.output("datauristring")
                }, e.exportAndStartDownload = function (t, i, n, s) {
                    var o = this;
                    void 0 === i && (i = "png"), void 0 === n && (n = {}), null == s && (s = void 0), null == n && (n = {}), null == i && (i = "png");
                    var r = {
                        png: "image/png",
                        jpeg: "image/jpeg",
                        csv: "text/csv",
                        xls: "application/vnd.ms-excel",
                        pdf: "application/pdf"
                    }, a = r[i];
                    if ("csv" === i || "xls" === i) {
                        var h = JSON.stringify(t.exportVisibleData());
                        this.proxyExport(t, a, i, h, "json", {})
                    } else if ("png" === i || "jpeg" === i) {
                        var l = e.exportToImage(t, i, n, s);
                        this.proxyExport(t, a, i, l, "base64", n)
                    } else if ("pdf" === i) {
                        var u = function () {
                            var r = e.exportToPdf(t, n, s);
                            o.proxyExport(t, a, i, r, "base64", {})
                        };
                        t.assetsLoader.loadAssetsList(t.settings.advanced.pdfExportAssets, u) || u()
                    } else t.error("Unrecognized export type: " + i)
                }, e.exportToImageGetDimensions = function (e, i) {
                    var n, s = e.shell, o = s.exportToImageGetDimensions(), r = o.width, a = o.height, h = t.Helpers.tryParseFloat(i.width), l = t.Helpers.tryParseFloat(i.height);
                    if (h > 0 && l > 0 ? n = Math.min(h / r, l / a) : h > 0 ? (n = h / r, l = a * n) : l > 0 ? (n = l / a, h = r * n) : (n = i.scaling > 0 ? t.Helpers.tryParseFloat(i.scaling) : 1, n *= Math.max(s.scaleX, s.scaleY), h = r * n, l = a * n), "mm" === i.unit) {
                        if (!(i.dpi > 0 && i.width > 0 && i.height > 0))throw"Invalid export configuration. If unit = mm, dpi, width and height must be supplied";
                        var u = t.Helpers.tryParseFloat(i.dpi) / 25.4;
                        n *= u, h *= u, l *= u
                    }
                    return {width: h, height: l, scale: n, chartWidth: r, chartHeight: a}
                }, e.proxyExport = function (e, i, n, s, o, r) {
                    var a = document.body, h = "data:" === s.substr(0, 5), l = t.Helpers.createDom("a", null, null, null);
                    if (h && void 0 !== l.download) l.download = "export." + n, l.type = l.mimeType = i, l.href = s, a.appendChild(l), l.click(), a.removeChild(l); else {
                        var u = t.Helpers.createDom("form", null, null, null);
                        u.setAttribute("action", e.settings.advanced.exportProxyURL), u.setAttribute("method", "POST"), u.setAttribute("target", "_top"), u.setAttribute("style", "display:none");
                        var c = t.Helpers.createDom("input", null, null, u);
                        c.setAttribute("type", "hidden"), c.setAttribute("name", "type"), c.setAttribute("value", i);
                        var p = t.Helpers.createDom("input", null, null, u);
                        p.setAttribute("type", "hidden"), p.setAttribute("name", "encoding"), p.setAttribute("value", o);
                        var d = t.Helpers.createDom("input", null, null, u);
                        d.setAttribute("type", "hidden"), d.setAttribute("name", "data"), d.setAttribute("value", s);
                        var f = t.Helpers.tryParseInt(r.dpi);
                        if (f > 0) {
                            var m = t.Helpers.createDom("input", null, null, u);
                            m.setAttribute("type", "hidden"), m.setAttribute("name", "setdpi"), m.setAttribute("value", f.toString(10))
                        }
                        a.appendChild(u), u.submit(), a.removeChild(u)
                    }
                }, e
            }();
            t.Export = e
        }(e = t.Base || (t.Base = {}))
    }(e = t.Internal || (t.Internal = {}))
}(ZoomCharts || (ZoomCharts = {}));
var ZoomCharts;
!function (t) {
    var e;
    !function (t) {
        var e;
        !function (t) {
            var e;
            !function (e) {
                var i = function (i) {
                    function n(n, s) {
                        var o = n.settings.localization.toolbar, r = [new e.UserButton(n, {
                            label: o.exportJpeg,
                            onClick: function () {
                                return t.Export.exportAndStartDownload(n, "jpeg", {scaling: 2})
                            }
                        }), new e.UserButton(n, {
                            label: o.exportPNG,
                            onClick: function () {
                                return t.Export.exportAndStartDownload(n, "png", {scaling: 3})
                            }
                        }), new e.UserButton(n, {
                            label: o.exportPDF,
                            onClick: function () {
                                return t.Export.exportAndStartDownload(n, "pdf")
                            }
                        })];
                        n.exportVisibleData && (r.push(new e.UserButton(n, {
                            label: o.exportCSV,
                            onClick: function () {
                                return t.Export.exportAndStartDownload(n, "csv")
                            }
                        })), r.push(new e.UserButton(n, {
                            label: o.exportXLS,
                            onClick: function () {
                                return t.Export.exportAndStartDownload(n, "xls")
                            }
                        }))), s = {
                            showLabels: s.showLabels,
                            title: o.exportTitle,
                            label: o.exportButton,
                            cssClass: "DVSL-bar-btn-export",
                            items: r
                        }, i.call(this, n, s)
                    }

                    return __extends(n, i), n
                }(e.Dropdown);
                e.ExportDropdown = i, t.Bar.ToolbarItemNames["export"] = function (e, i) {
                    return new t.Bar.ExportDropdown(e, i)
                }
            }(e = t.Bar || (t.Bar = {}))
        }(e = t.Base || (t.Base = {}))
    }(e = t.Internal || (t.Internal = {}))
}(ZoomCharts || (ZoomCharts = {}));
var ZoomCharts;
!function (t) {
    var e;
    !function (t) {
        var e;
        !function (t) {
            var e = function (t) {
                function e(e) {
                    t.call(this), this.animationOrder = 2e3, this.paintOrder = 65, this.updateOrder = 0, this.chart = e
                }

                return __extends(e, t), e.prototype.onKeyDown = function (t) {
                    this.chart.isFullscreen() && 27 === t.keyCode ? (this.chart.setFullscreen(!1), t.consumed = !0) : 8 === t.keyCode && this.chart.back(!0, "user") && (t.consumed = !0)
                }, e
            }(t.ChartElement);
            t.KeyShortcuts = e
        }(e = t.Base || (t.Base = {}))
    }(e = t.Internal || (t.Internal = {}))
}(ZoomCharts || (ZoomCharts = {}));
var ZoomCharts;
!function (t) {
    var e;
    !function (t) {
        var e;
        !function (t) {
            var e = "C314F39F62CBF2AEFA1D5BA41E38EFFD080E88849EE210BA17971BF63A55C44E159C9F9ED004F8D50856EC8ECE673690F60C29AAC124B7C46D549D20EB22CC2A387B2FB643700546312114F831133F242CFFD023A1788167025FF398F5F09D1003C47C9B3208860A547577F540D07FF66403097FE27E7BB6B8D76036AD31B62B04EAD1BB8B2C314F6DA7489346978286491D0DF7504E9EE85A4459805F4FFCEE664122FC27B80DAD6751A7A6C0D38E9C2ECD7C0AD1F2B774D6FF81C5A2CE14D608F08E13BEE45663450519774ADF87D34CE6150FC819558EBD336511D51405A42E7A38EBB786ED5050345CBC532ED7C0EECB05C5D6D4D00534249ED4585DFABD", i = function () {
                function t() {
                }

                return t.verifySignature = function (t, i) {
                    var s = new n;
                    return s.setPublic(e, "10001"), s.verify(t, i)
                }, t.hash = function (t) {
                    return n.hash(t)
                }, t
            }();
            t.RsaCrypto = i;
            var n = function () {
                function t(t, e) {
                    null != t && (null == e && "string" != typeof t ? this.fromString(t, 256) : this.fromString(t, e))
                }

                function e() {
                    return new t(null)
                }

                function i(t, e, i, n, s, o) {
                    for (; --o >= 0;) {
                        var r = e * this[t++] + i[n] + s;
                        s = Math.floor(r / 67108864), i[n++] = 67108863 & r
                    }
                    return s
                }

                function n(t, e, i, n, s, o) {
                    for (var r = 32767 & e, a = e >> 15; --o >= 0;) {
                        var h = 32767 & this[t], l = this[t++] >> 15, u = a * h + l * r;
                        h = r * h + ((32767 & u) << 15) + i[n] + (1073741823 & s), s = (h >>> 30) + (u >>> 15) + a * l + (s >>> 30), i[n++] = 1073741823 & h
                    }
                    return s
                }

                function s(t, e, i, n, s, o) {
                    for (var r = 16383 & e, a = e >> 14; --o >= 0;) {
                        var h = 16383 & this[t], l = this[t++] >> 14, u = a * h + l * r;
                        h = r * h + ((16383 & u) << 14) + i[n] + s, s = (h >> 28) + (u >> 14) + a * l, i[n++] = 268435455 & h
                    }
                    return s
                }

                function o(t) {
                    return ee.charAt(t)
                }

                function r(t, e) {
                    var i = ie[t.charCodeAt(e)];
                    return null == i ? -1 : i
                }

                function a(t) {
                    for (var e = this.t - 1; e >= 0; --e)t[e] = this[e];
                    t.t = this.t, t.s = this.s
                }

                function h(t) {
                    this.t = 1, this.s = 0 > t ? -1 : 0, t > 0 ? this[0] = t : -1 > t ? this[0] = t + this.DV : this.t = 0
                }

                function l(t) {
                    var i = e();
                    return i.fromInt(t), i
                }

                function u(e, i) {
                    var n;
                    if (16 == i) n = 4; else if (8 == i) n = 3; else if (256 == i) n = 8; else if (2 == i) n = 1; else if (32 == i) n = 5; else {
                        if (4 != i)return void this.fromRadix(e, i);
                        n = 2
                    }
                    this.t = 0, this.s = 0;
                    for (var s = e.length, o = !1, a = 0; --s >= 0;) {
                        var h = 8 == n ? 255 & e[s] : r(e, s);
                        0 > h ? "-" == e.charAt(s) && (o = !0) : (o = !1, 0 == a ? this[this.t++] = h : a + n > this.DB ? (this[this.t - 1] |= (h & (1 << this.DB - a) - 1) << a, this[this.t++] = h >> this.DB - a) : this[this.t - 1] |= h << a, a += n, a >= this.DB && (a -= this.DB))
                    }
                    8 == n && 0 != (128 & e[0]) && (this.s = -1, a > 0 && (this[this.t - 1] |= (1 << this.DB - a) - 1 << a)), this.clamp(), o && t.ZERO.subTo(this, this)
                }

                function c() {
                    for (var t = this.s & this.DM; this.t > 0 && this[this.t - 1] == t;)--this.t
                }

                function p(t) {
                    if (this.s < 0)return "-" + this.negate().toString(t);
                    var e;
                    if (16 == t) e = 4; else if (8 == t) e = 3; else if (2 == t) e = 1; else if (32 == t) e = 5; else {
                        if (4 != t)return this.toRadix(t);
                        e = 2
                    }
                    var i, n = (1 << e) - 1, s = !1, r = "", a = this.t, h = this.DB - a * this.DB % e;
                    if (a-- > 0)for (h < this.DB && (i = this[a] >> h) > 0 && (s = !0, r = o(i)); a >= 0;)e > h ? (i = (this[a] & (1 << h) - 1) << e - h, i |= this[--a] >> (h += this.DB - e)) : (i = this[a] >> (h -= e) & n, 0 >= h && (h += this.DB, --a)), i > 0 && (s = !0), s && (r += o(i));
                    return s ? r : "0"
                }

                function d() {
                    var i = e();
                    return t.ZERO.subTo(this, i), i
                }

                function f() {
                    return this.s < 0 ? this.negate() : this
                }

                function m(t) {
                    var e = this.s - t.s;
                    if (0 != e)return e;
                    var i = this.t;
                    if (e = i - t.t, 0 != e)return this.s < 0 ? -e : e;
                    for (; --i >= 0;)if (0 != (e = this[i] - t[i]))return e;
                    return 0
                }

                function g(t) {
                    var e, i = 1;
                    return 0 != (e = t >>> 16) && (t = e, i += 16), 0 != (e = t >> 8) && (t = e, i += 8), 0 != (e = t >> 4) && (t = e, i += 4), 0 != (e = t >> 2) && (t = e, i += 2), 0 != (e = t >> 1) && (t = e, i += 1), i
                }

                function y() {
                    return this.t <= 0 ? 0 : this.DB * (this.t - 1) + g(this[this.t - 1] ^ this.s & this.DM)
                }

                function v(t, e) {
                    var i;
                    for (i = this.t - 1; i >= 0; --i)e[i + t] = this[i];
                    for (i = t - 1; i >= 0; --i)e[i] = 0;
                    e.t = this.t + t, e.s = this.s
                }

                function S(t, e) {
                    for (var i = t; i < this.t; ++i)e[i - t] = this[i];
                    e.t = Math.max(this.t - t, 0), e.s = this.s
                }

                function C(t, e) {
                    var i, n = t % this.DB, s = this.DB - n, o = (1 << s) - 1, r = Math.floor(t / this.DB), a = this.s << n & this.DM;
                    for (i = this.t - 1; i >= 0; --i)e[i + r + 1] = this[i] >> s | a, a = (this[i] & o) << n;
                    for (i = r - 1; i >= 0; --i)e[i] = 0;
                    e[r] = a, e.t = this.t + r + 1, e.s = this.s, e.clamp()
                }

                function b(t, e) {
                    e.s = this.s;
                    var i = Math.floor(t / this.DB);
                    if (i >= this.t)return void(e.t = 0);
                    var n = t % this.DB, s = this.DB - n, o = (1 << n) - 1;
                    e[0] = this[i] >> n;
                    for (var r = i + 1; r < this.t; ++r)e[r - i - 1] |= (this[r] & o) << s, e[r - i] = this[r] >> n;
                    n > 0 && (e[this.t - i - 1] |= (this.s & o) << s), e.t = this.t - i, e.clamp()
                }

                function x(t, e) {
                    for (var i = 0, n = 0, s = Math.min(t.t, this.t); s > i;)n += this[i] - t[i], e[i++] = n & this.DM, n >>= this.DB;
                    if (t.t < this.t) {
                        for (n -= t.s; i < this.t;)n += this[i], e[i++] = n & this.DM, n >>= this.DB;
                        n += this.s
                    } else {
                        for (n += this.s; i < t.t;)n -= t[i], e[i++] = n & this.DM, n >>= this.DB;
                        n -= t.s
                    }
                    e.s = 0 > n ? -1 : 0, -1 > n ? e[i++] = this.DV + n : n > 0 && (e[i++] = n), e.t = i, e.clamp()
                }

                function _(e, i) {
                    var n = this.abs(), s = e.abs(), o = n.t;
                    for (i.t = o + s.t; --o >= 0;)i[o] = 0;
                    for (o = 0; o < s.t; ++o)i[o + n.t] = n.am(0, s[o], i, o, 0, n.t);
                    i.s = 0, i.clamp(), this.s != e.s && t.ZERO.subTo(i, i)
                }

                function w(t) {
                    for (var e = this.abs(), i = t.t = 2 * e.t; --i >= 0;)t[i] = 0;
                    for (i = 0; i < e.t - 1; ++i) {
                        var n = e.am(i, e[i], t, 2 * i, 0, 1);
                        (t[i + e.t] += e.am(i + 1, 2 * e[i], t, 2 * i + 1, n, e.t - i - 1)) >= e.DV && (t[i + e.t] -= e.DV, t[i + e.t + 1] = 1)
                    }
                    t.t > 0 && (t[t.t - 1] += e.am(i, e[i], t, 2 * i, 0, 1)), t.s = 0, t.clamp()
                }

                function L(i, n, s) {
                    var o = i.abs();
                    if (!(o.t <= 0)) {
                        var r = this.abs();
                        if (r.t < o.t)return null != n && n.fromInt(0), void(null != s && this.copyTo(s));
                        null == s && (s = e());
                        var a = e(), h = this.s, l = i.s, u = this.DB - g(o[o.t - 1]);
                        u > 0 ? (o.lShiftTo(u, a), r.lShiftTo(u, s)) : (o.copyTo(a), r.copyTo(s));
                        var c = a.t, p = a[c - 1];
                        if (0 != p) {
                            var d = p * (1 << this.F1) + (c > 1 ? a[c - 2] >> this.F2 : 0), f = this.FV / d, m = (1 << this.F1) / d, y = 1 << this.F2, v = s.t, S = v - c, C = null == n ? e() : n;
                            for (a.dlShiftTo(S, C), s.compareTo(C) >= 0 && (s[s.t++] = 1, s.subTo(C, s)), t.ONE.dlShiftTo(c, C), C.subTo(a, a); a.t < c;)a[a.t++] = 0;
                            for (; --S >= 0;) {
                                var b = s[--v] == p ? this.DM : Math.floor(s[v] * f + (s[v - 1] + y) * m);
                                if ((s[v] += a.am(0, b, s, S, 0, c)) < b)for (a.dlShiftTo(S, C), s.subTo(C, s); s[v] < --b;)s.subTo(C, s)
                            }
                            null != n && (s.drShiftTo(c, n), h != l && t.ZERO.subTo(n, n)), s.t = c, s.clamp(), u > 0 && s.rShiftTo(u, s), 0 > h && t.ZERO.subTo(s, s)
                        }
                    }
                }

                function T(i) {
                    var n = e();
                    return this.abs().divRemTo(i, null, n), this.s < 0 && n.compareTo(t.ZERO) > 0 && i.subTo(n, n), n
                }

                function M(t) {
                    this.m = t
                }

                function P(t) {
                    return t.s < 0 || t.compareTo(this.m) >= 0 ? t.mod(this.m) : t
                }

                function k(t) {
                    return t
                }

                function D(t) {
                    t.divRemTo(this.m, null, t)
                }

                function I(t, e, i) {
                    t.multiplyTo(e, i), this.reduce(i)
                }

                function A(t, e) {
                    t.squareTo(e), this.reduce(e)
                }

                function B() {
                    if (this.t < 1)return 0;
                    var t = this[0];
                    if (0 == (1 & t))return 0;
                    var e = 3 & t;
                    return e = e * (2 - (15 & t) * e) & 15, e = e * (2 - (255 & t) * e) & 255, e = e * (2 - ((65535 & t) * e & 65535)) & 65535, e = e * (2 - t * e % this.DV) % this.DV, e > 0 ? this.DV - e : -e
                }

                function E(t) {
                    this.m = t, this.mp = t.invDigit(), this.mpl = 32767 & this.mp, this.mph = this.mp >> 15, this.um = (1 << t.DB - 15) - 1, this.mt2 = 2 * t.t
                }

                function O(i) {
                    var n = e();
                    return i.abs().dlShiftTo(this.m.t, n), n.divRemTo(this.m, null, n), i.s < 0 && n.compareTo(t.ZERO) > 0 && this.m.subTo(n, n), n
                }

                function F(t) {
                    var i = e();
                    return t.copyTo(i), this.reduce(i), i
                }

                function N(t) {
                    for (; t.t <= this.mt2;)t[t.t++] = 0;
                    for (var e = 0; e < this.m.t; ++e) {
                        var i = 32767 & t[e], n = i * this.mpl + ((i * this.mph + (t[e] >> 15) * this.mpl & this.um) << 15) & t.DM;
                        for (i = e + this.m.t, t[i] += this.m.am(0, n, t, e, 0, this.m.t); t[i] >= t.DV;)t[i] -= t.DV, t[++i]++
                    }
                    t.clamp(), t.drShiftTo(this.m.t, t), t.compareTo(this.m) >= 0 && t.subTo(this.m, t)
                }

                function z(t, e) {
                    t.squareTo(e), this.reduce(e)
                }

                function R(t, e, i) {
                    t.multiplyTo(e, i), this.reduce(i)
                }

                function H() {
                    return 0 == (this.t > 0 ? 1 & this[0] : this.s)
                }

                function Z(i, n) {
                    if (i > 4294967295 || 1 > i)return t.ONE;
                    var s = e(), o = e(), r = n.convert(this), a = g(i) - 1;
                    for (r.copyTo(s); --a >= 0;)if (n.sqrTo(s, o), (i & 1 << a) > 0) n.mulTo(o, r, s); else {
                        var h = s;
                        s = o, o = h
                    }
                    return n.revert(s)
                }

                function U(t, e) {
                    var i;
                    return i = 256 > t || e.isEven() ? new M(e) : new E(e), this.exp(t, i)
                }

                function W(e, i) {
                    return new t(e, i)
                }

                function V() {
                    this.n = null, this.e = 0, this.d = null, this.p = null, this.q = null, this.dmp1 = null, this.dmq1 = null, this.coeff = null
                }

                function G(t, e) {
                    null != t && null != e && t.length > 0 && e.length > 0 ? (this.n = W(t, 16), this.e = parseInt(e, 16)) : alert("Invalid RSA public key")
                }

                function Y(t) {
                    return t.modPowInt(this.e, this.n)
                }

                function j(t) {
                    for (var e in se.crypto.Util.DIGESTINFOHEAD) {
                        var i = se.crypto.Util.DIGESTINFOHEAD[e], n = i.length;
                        if (t.substring(0, n) == i)return [e, t.substring(n)]
                    }
                    return []
                }

                function q(t, e) {
                    e = e.replace(oe, ""), e = e.replace(/[ \n]+/g, "");
                    var i = W(e, 16);
                    if (i.bitLength() > this.n.bitLength())return !1;
                    var n = this.doPublic(i), s = n.toString(16).replace(/^1f+00/, ""), o = j(s);
                    if (0 === o.length)return !1;
                    var r = o[1], a = ne.hash(t);
                    return r === a
                }

                {
                    var X, J = 0xdeadbeefcafe, K = 15715070 == (16777215 & J);
                    "undefined" == typeof window ? null : window.crypto || window.msCrypto
                }
                K && "undefined" != typeof navigator && "Microsoft Internet Explorer" === navigator.appName ? (t.prototype.am = n, X = 30) : K && "undefined" != typeof navigator && "Netscape" !== navigator.appName ? (t.prototype.am = i, X = 26) : (t.prototype.am = s, X = 28), t.prototype.DB = X, t.prototype.DM = (1 << X) - 1, t.prototype.DV = 1 << X;
                var Q = 52;
                t.prototype.FV = Math.pow(2, Q), t.prototype.F1 = Q - X, t.prototype.F2 = 2 * X - Q;
                var $, te, ee = "0123456789abcdefghijklmnopqrstuvwxyz", ie = new Array;
                for ($ = "0".charCodeAt(0), te = 0; 9 >= te; ++te)ie[$++] = te;
                for ($ = "a".charCodeAt(0), te = 10; 36 > te; ++te)ie[$++] = te;
                for ($ = "A".charCodeAt(0), te = 10; 36 > te; ++te)ie[$++] = te;
                M.prototype.convert = P, M.prototype.revert = k, M.prototype.reduce = D, M.prototype.mulTo = I, M.prototype.sqrTo = A, E.prototype.convert = O, E.prototype.revert = F, E.prototype.reduce = N, E.prototype.mulTo = R, E.prototype.sqrTo = z, t.prototype.copyTo = a, t.prototype.fromInt = h, t.prototype.fromString = u, t.prototype.clamp = c, t.prototype.dlShiftTo = v, t.prototype.drShiftTo = S, t.prototype.lShiftTo = C, t.prototype.rShiftTo = b, t.prototype.subTo = x, t.prototype.multiplyTo = _, t.prototype.squareTo = w, t.prototype.divRemTo = L, t.prototype.invDigit = B, t.prototype.isEven = H, t.prototype.exp = Z, t.prototype.toString = p, t.prototype.negate = d, t.prototype.abs = f, t.prototype.compareTo = m, t.prototype.bitLength = y, t.prototype.mod = T, t.prototype.modPowInt = U, t.ZERO = l(0), t.ONE = l(1), V.prototype.doPublic = Y, V.prototype.setPublic = G;
                var ne = {};
                ne.utf8Encode = function (t) {
                    return window.unescape(encodeURIComponent(t))
                }, ne.hash = function (t) {
                    t = ne.utf8Encode(t);
                    var e = [1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298], i = [1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225];
                    t += String.fromCharCode(128);
                    for (var n = t.length / 4 + 2, s = Math.ceil(n / 16), o = new Array(s), r = 0; s > r; r++) {
                        o[r] = new Array(16);
                        for (var a = 0; 16 > a; a++)o[r][a] = t.charCodeAt(64 * r + 4 * a) << 24 | t.charCodeAt(64 * r + 4 * a + 1) << 16 | t.charCodeAt(64 * r + 4 * a + 2) << 8 | t.charCodeAt(64 * r + 4 * a + 3)
                    }
                    o[s - 1][14] = 8 * (t.length - 1) / Math.pow(2, 32), o[s - 1][14] = Math.floor(o[s - 1][14]), o[s - 1][15] = 8 * (t.length - 1) & 4294967295;
                    for (var h, l, u, c, p, d, f, m, g = new Array(64), r = 0; s > r; r++) {
                        for (var y = 0; 16 > y; y++)g[y] = o[r][y];
                        for (var y = 16; 64 > y; y++)g[y] = ne.s1(g[y - 2]) + g[y - 7] + ne.s0(g[y - 15]) + g[y - 16] & 4294967295;
                        h = i[0], l = i[1], u = i[2], c = i[3], p = i[4], d = i[5], f = i[6], m = i[7];
                        for (var y = 0; 64 > y; y++) {
                            var v = m + ne.S1(p) + ne.Ch(p, d, f) + e[y] + g[y], S = ne.S0(h) + ne.Maj(h, l, u);
                            m = f, f = d, d = p, p = c + v & 4294967295, c = u, u = l, l = h, h = v + S & 4294967295
                        }
                        i[0] = i[0] + h & 4294967295, i[1] = i[1] + l & 4294967295, i[2] = i[2] + u & 4294967295, i[3] = i[3] + c & 4294967295, i[4] = i[4] + p & 4294967295, i[5] = i[5] + d & 4294967295, i[6] = i[6] + f & 4294967295, i[7] = i[7] + m & 4294967295
                    }
                    return ne.toHexStr(i[0]) + ne.toHexStr(i[1]) + ne.toHexStr(i[2]) + ne.toHexStr(i[3]) + ne.toHexStr(i[4]) + ne.toHexStr(i[5]) + ne.toHexStr(i[6]) + ne.toHexStr(i[7])
                }, ne.ROTR = function (t, e) {
                    return e >>> t | e << 32 - t
                }, ne.S0 = function (t) {
                    return ne.ROTR(2, t) ^ ne.ROTR(13, t) ^ ne.ROTR(22, t)
                }, ne.S1 = function (t) {
                    return ne.ROTR(6, t) ^ ne.ROTR(11, t) ^ ne.ROTR(25, t)
                }, ne.s0 = function (t) {
                    return ne.ROTR(7, t) ^ ne.ROTR(18, t) ^ t >>> 3
                }, ne.s1 = function (t) {
                    return ne.ROTR(17, t) ^ ne.ROTR(19, t) ^ t >>> 10
                }, ne.Ch = function (t, e, i) {
                    return t & e ^ ~t & i
                }, ne.Maj = function (t, e, i) {
                    return t & e ^ t & i ^ e & i
                }, ne.toHexStr = function (t) {
                    for (var e, i = "", n = 7; n >= 0; n--)e = t >>> 4 * n & 15, i += e.toString(16);
                    return i
                };
                var se = {crypto: {Util: {DIGESTINFOHEAD: {sha256: "3031300d060960864801650304020105000420"}}}}, oe = new RegExp("[^0-9a-f]", "gi");
                return V.prototype.verify = q, V.hash = ne.hash, V
            }()
        }(e = t.Base || (t.Base = {}))
    }(e = t.Internal || (t.Internal = {}))
}(ZoomCharts || (ZoomCharts = {}));
var ZoomCharts;
!function (t) {
    var e;
    !function (e) {
        var i;
        !function (e) {
            var i = function () {
                function t(t, i, n) {
                    var o = this;
                    this.api = null, this.scene = null, this.settings = null, this.shell = null, this.events = null, this.removed = !0, this.assetsLoaded = !1, this.toolbar = null, this.data = {}, this.navigator = null, this.curState = null, this.goingBack = !1, this.chartUpdateOrigin = null, this.chartUpdateTimeout = null, this.scene = i, this.settings = t, this.api = n, n._impl = this, this.scene.settings = t, this.scene.assetsLoader = this.assetsLoader = new e.AssetsLoader(this), this.data = {}, this.settings.parentChart ? (this.scene.isActive = !1, this.shell = new e.ChartInnerShell(this, this.settings.parentChart._impl.shell), this.events = this.shell.events) : (this.shell = new e.ChartOuterShell(this, this.createDomLayer()), this.events = this.shell.events, this.events.addElement(new e.TouchMarkers(this)), this.events.addElement(new e.Resizer(this)), this.events.addElement(new e.Credits(this, this.settings.credits))), window.setTimeout(function () {
                        return s.execute(o, !!o.settings.parentChart)
                    }, 500), this.removed = !1, this.EVENT_NAMES = {};
                    var r;
                    for (r in t.events)if (0 === r.indexOf("on")) {
                        var a = r.charAt(2).toLowerCase() + r.slice(3);
                        this.EVENT_NAMES[r] = a, this.EVENT_NAMES[a] = a
                    }
                    this.eventListeners = {}, this.assetsLoaded = !0, this.assetsLoader.loadAssetsList(this.settings.advanced.assets, function () {
                        return o.notifyAssetsLoaded()
                    }) ? this.assetsLoaded = !1 : this.notifyAssetsLoaded(), this.clearData(), this.events.addElement(new e.KeyShortcuts(this)), this.title = this.events.addElement(new e.Title(this)), this.events.addElement(new e.MessagesOverlay(this))
                }

                return t.prototype.onSettingsChanged = function () {
                    return e.Helpers.error("Need to override onSettingsChanged")
                }, t.prototype.createDataObj = function () {
                    return e.Helpers.error("Need to override createDataObj"), null
                }, t.prototype.createDomLayer = function () {
                    return new e.DomLayer(this)
                }, t.prototype.removeData = function () {
                    return e.Helpers.error("Remove data not implemented for this chart")
                }, t.prototype.hideMenu = function () {
                }, t.prototype.updateFilters = function () {
                    this.events.notifySceneChanges({filters: !0})
                }, t.prototype.updateStyle = function () {
                    this.events.notifySceneChanges({style: !0})
                }, t.prototype.defaultDoubleClick = function () {
                }, t.prototype.defaultTripleClick = function () {
                }, t.prototype.defaultClick = function () {
                }, t.prototype.defaultRightClick = function () {
                }, t.prototype.finalInitialize = function () {
                    this.events.notifySceneChanges({
                        settings: !0,
                        settingsChanges: this.scene.settings,
                        data: {}
                    }), this.updateSize(), this.updateEvents(null, this.settings.events)
                }, t.prototype.updateSettings = function (t, i) {
                    var n = this;
                    void 0 === i && (i = null);
                    var s = e.Helpers.clone(this.settings.events), o = this.settings.apply(t), r = {
                        settings: !0,
                        settingsChanges: o
                    };
                    this.removed || (o.events && this.updateEvents(s, this.settings.events), o.advanced && o.advanced.assets && (this.assetsLoader.loadAssetsList(this.settings.advanced.assets, function () {
                        return n.notifyAssetsLoaded()
                    }) ? this.assetsLoaded = !1 : this.notifyAssetsLoaded()), o.data && this.dataSettingsChanged(o.data), this.shell.updateSettings(o), this.onSettingsChanged(o), o.toolbar && this.assetsLoaded && (this.toolbar && this.toolbar.remove(), this.toolbar = new e.Toolbar(this, this.settings.toolbar)), this.events.notifySceneChanges(r), (o.width || o.height || o.maxWidth || o.minWidth || o.minHeight || o.maxHeight) && this.updateSize(!0), i && this.notifySettingsChanged(o, i))
                }, t.prototype.getData = function (t) {
                    if (this.data[t])return this.data[t];
                    var e = this.settings._computedDataMap[t];
                    if (e) {
                        var i = this.createDataObj(e);
                        return i.applyPreloadedData(), this.data[t] = i, i
                    }
                    throw new Error("No data configured for source ID " + t)
                }, t.prototype.addData = function (t, e) {
                    this.removed || this.getData(e).addData(t)
                }, t.prototype.reloadData = function (t, e) {
                    if (void 0 === t && (t = null), void 0 === e && (e = !1), null == e && (e = !1), !this.removed) {
                        this.log("Reload data"), t ? this.data[t] && (this.data[t].remove(), delete this.data[t]) : this.clearData(), this.scene.mainData = this.getData(this.settings.data[0].id);
                        var i = {};
                        for (var n in this.settings._computedDataMap)i[n] = !0;
                        this.events.notifySceneChanges({
                            data: i,
                            dataDeep: e
                        }), this.navigator && this.navigator.onNewDataObject()
                    }
                }, t.prototype.replaceData = function (t, e) {
                    if (void 0 === e && (e = "default"), null == e && (e = "default"), !this.removed) {
                        this.events.clearSceneChanges({dataArrived: null}), this.data[e] && this.data[e].remove();
                        var i = this.data[e] = this.createDataObj(this.settings._computedDataMap[e]);
                        i.addData(t), this.scene.mainData = this.getData(this.settings.data[0].id);
                        var n = {};
                        n[e] = !0, this.events.notifySceneChanges({data: n}), this.navigator && this.navigator.onNewDataObject()
                    }
                }, t.prototype.clearData = function (t) {
                    void 0 === t && (t = !1), null == t && (t = !1);
                    for (var e in this.data) {
                        var i = this.data[e];
                        i.remove()
                    }
                    this.events.clearSceneChanges({dataArrived: null}), this.data = {}, this.scene.mainData = null, t || (this.scene.mainData = this.getData(this.settings.data[0].id))
                }, t.prototype.dataSettingsChanged = function (t) {
                    for (var e in this.data)if (t[e] || !this.settings._computedDataMap[e]) {
                        var i = this.data[e];
                        i.remove(), delete this.data[e]
                    }
                    this.events.clearSceneChanges({dataArrived: null}), this.events.notifySceneChanges({
                        data: t,
                        dataDeep: !0
                    }), this.scene.mainData = this.getData(this.settings.data[0].id), this.navigator && this.navigator.onNewDataObject()
                }, t.prototype.hasPendingRequests = function () {
                    if (!this.assetsLoaded)return !0;
                    if (this.assetsLoader.hasPendingRequests())return !0;
                    for (var t in this.data) {
                        var e = this.data[t];
                        if (e.hasPendingRequests())return !0
                    }
                    return !1
                }, t.prototype.remove = function () {
                    return this.removed ? void e.Helpers.warn("Removing already removed chart") : (this.cancelChartUpdateNotify(), this.removed = !0, this.toolbar && this.toolbar.remove(), this.shell.remove(), this.clearData(!0), this.shell = null, this.scene = null, void(this.events = null))
                }, t.prototype.setFullscreen = function (t) {
                    this.shell.setFullscreen(t)
                }, t.prototype.isFullscreen = function () {
                    return this.shell.fullScreenMode
                }, t.prototype.updateSize = function (t) {
                    void 0 === t && (t = !1), this.removed || this.shell.updateSize(t)
                }, t.prototype.on = function (t, e) {
                    var i = this.EVENT_NAMES[t];
                    return i ? (this.eventListeners[i] || (this.eventListeners[i] = []), this.eventListeners[i].push(e)) : void this.error("Unrecognized event name: " + t)
                }, t.prototype.off = function (t, i) {
                    var n = this.EVENT_NAMES[t];
                    return n ? this.eventListeners[n] ? e.Helpers.removeFromArray(this.eventListeners[n], i) : void 0 : void this.error("Unrecognized event name: " + t)
                }, t.prototype.updateEvents = function (t, e) {
                    for (var i in this.EVENT_NAMES) {
                        var n = this.EVENT_NAMES[i];
                        t && t[i] && this.off(n, t[i]), e[i] && this.on(n, e[i])
                    }
                }, t.prototype.extendEventParams = function (t) {
                    return e.Helpers.error("Need to override extendEventParams"), t
                }, t.prototype.notifyHoverChanged = function (t) {
                    return t.origin = "user", this.dispatchEventParams("hoverChange", this.extendEventParams(t), null)
                }, t.prototype.notifyDoubleClick = function (t) {
                    var e = this;
                    return t.origin = "user", this.dispatchEvent("doubleClick", this.extendEventParams(t), function (t) {
                        return e.defaultDoubleClick(t)
                    })
                }, t.prototype.notifyTripleClick = function (t) {
                    var e = this;
                    return t.origin = "user", this.dispatchEvent("tripleClick", this.extendEventParams(t), function (t) {
                        return e.defaultTripleClick(t)
                    })
                }, t.prototype.notifyRightClick = function (t) {
                    var e = this;
                    return t.origin = "user", this.dispatchEvent("rightClick", this.extendEventParams(t), function (t) {
                        return e.defaultRightClick(t)
                    })
                }, t.prototype.notifyClick = function (t) {
                    var e = this;
                    return t.origin = "user", this.dispatchEvent("click", this.extendEventParams(t), function (t) {
                        return e.defaultClick(t)
                    })
                }, t.prototype.notifySelectionChanged = function (t) {
                    return this.dispatchEventParams("selectionChange", this.extendEventParams({origin: t}), null)
                }, t.prototype.notifySettingsChanged = function (t, e) {
                    return this.dispatchEventParams("settingsChange", this.extendEventParams({
                        changes: t,
                        origin: e
                    }), null)
                }, t.prototype.notifyPositionChange = function (t) {
                    return t.origin = "user", this.dispatchEventParams("positionChange", this.extendEventParams(t), null)
                }, t.prototype.notifyChartUpdate = function (t, i) {
                    var n = this;
                    void 0 === i && (i = !1);
                    var s = this.scene.settings.events.chartUpdateDelay, o = e.Helpers.performanceNow();
                    i && (this.chartUpdateForce = !0), t && (this.chartUpdateWasBack = this.goingBack, this.chartUpdateOrigin = t, this.chartUpdateTime = o), this.chartUpdateState = this.saveNavigation(), s = this.chartUpdateTime + s - o, null === this.chartUpdateTimeout && (this.chartUpdateTimeout = setTimeout(function () {
                        return n.chartUpdateNotify()
                    }, s))
                }, t.prototype.cancelChartUpdateNotify = function () {
                    this.chartUpdateOrigin = null, this.chartUpdateTimeout && (clearTimeout(this.chartUpdateTimeout), this.chartUpdateTimeout = null)
                }, t.prototype.chartUpdateNotify = function () {
                    this.chartUpdateTimeout = null;
                    var t = this.chartUpdateOrigin;
                    if (t) {
                        var e = this.chartUpdateState;
                        return !e || this.curState && JSON.stringify(e) === JSON.stringify(this.curState) ? this.chartUpdateForce ? (this.chartUpdateForce = !1, this.chartUpdateOrigin = null, this.chartUpdateState = null, this.doChartUpdateNotify(t)) : void 0 : (this.chartUpdateForce = !1, !this.chartUpdateWasBack && this.curState && this.scene.pushBack(this.curState), this.curState = e, this.chartUpdateOrigin = null, this.chartUpdateState = null, this.doChartUpdateNotify(t))
                    }
                }, t.prototype.back = function (t, e) {
                    if (void 0 === t && (t = !0), void 0 === e && (e = "api"), 0 === this.scene.backStack.length)return !1;
                    var i = this.scene.backStack.pop();
                    return this.goingBack = !0, this.restoreNavigation(i, t, e), this.goingBack = !1, !0
                }, t.prototype.goHome = function (t, e) {
                    if (void 0 === t && (t = !0), void 0 === e && (e = "api"), 0 === this.scene.backStack.length)return !1;
                    var i = this.scene.backStack[0];
                    return this.restoreNavigation(i, t, e), !0
                }, t.prototype.clearHistory = function () {
                    return this.scene.backStack = [], !0
                }, t.prototype.save = function () {
                    return e.Helpers.error("Need to override save()"), null
                }, t.prototype.restore = function () {
                    e.Helpers.error("Need to override save")
                }, t.prototype.saveNavigation = function () {
                    e.Helpers.error("Need to override saveNavigation")
                }, t.prototype.restoreNavigation = function () {
                    e.Helpers.error("Need to override restoreNavigation")
                }, t.prototype.doChartUpdateNotify = function (t) {
                    return this.dispatchEventParams("chartUpdate", this.extendEventParams({origin: t}), null)
                }, t.prototype.dispatchEventParams = function (t, i, n) {
                    if (!(n || this.eventListeners[t] && this.eventListeners[t].length))return {};
                    var s = e.Helpers.createEvent(t);
                    for (var o in i)i.hasOwnProperty(o) && void 0 === s[o] && (s[o] = i[o]);
                    return this.dispatchEvent(t, s, n)
                }, t.prototype.dispatchEvent = function (t, e, i) {
                    if (!(i || this.eventListeners[t] && this.eventListeners[t].length > 0))return e;
                    if (e.chart = this.api, this.eventListeners[t])for (var n = 0; n < this.eventListeners[t].length; n++) {
                        var s = this.eventListeners[t][n];
                        this.log("Call user event handler, " + t, e), s.call(this.api, e)
                    }
                    return !e.defaultPrevented && i && (this.log("Call default event handler, " + t), i.call(this.api, e)), e
                }, t.prototype.error = function (t, e) {
                    var i = this;
                    void 0 === e && (e = null), this.dispatchEventParams("error", {
                        message: t,
                        arg: e
                    }, function (t) {
                        return i.defaultError(t)
                    })
                }, t.prototype.log = function (t, i) {
                    void 0 === i && (i = null), this.settings.advanced.logging && e.Helpers.log(t, i)
                }, t.prototype.deprecated = function (t, e) {
                    var i = "Deprecated: " + t + ".";
                    e && (i += " Use " + e + " instead"), this.log(i)
                }, t.prototype.defaultError = function (t) {
                    this.settings.events.onError && this.settings.events.onError(t), e.Helpers.error(t.message, t.arg || null)
                }, t.prototype.notifyAssetsLoaded = function () {
                    this.removed || (this.assetsLoaded = !0, this.toolbar || (this.toolbar = new e.Toolbar(this, this.settings.toolbar), this.events.notifySceneChanges({toolbar: !0})), this.updateSize(!0))
                }, t
            }();
            e.Impl = i;
            var n;
            !function (t) {
                t[t.FacetChart = 1] = "FacetChart", t[t.GeoChart = 2] = "GeoChart", t[t.NetChart = 4] = "NetChart", t[t.PieChart = 8] = "PieChart", t[t.TimeChart = 16] = "TimeChart"
            }(n || (n = {}));
            var s = function () {
                function i() {
                }

                return i.checkChartType = function (t, e) {
                    var i = e.lastIndexOf("-", e.indexOf(":"));
                    if (-1 === i || i === e.indexOf("-"))return !0;
                    var s, o = 0;
                    for (i++; (s = e.charCodeAt(i)) > 47 && 58 > s;)o = 10 * o + s - 48, i++;
                    var r = n[t];
                    return r > 0 && (o & r) === r
                }, i.execute = function (i, n) {
                    var s = this, o = window.ZoomChartsLicense, r = window.ZoomChartsLicenseKey;
                    /*o&&r?e.RsaCrypto.verifySignature(o,r)?this._licenseWrittenToConsole||(e.Helpers.log("ZoomCharts license verified: ZCP-s24asdg2gl1: Production licence for *.zxjt.com"),this._licenseWrittenToConsole=!0):e.Helpers.error("The license key for license '"+o+"' is invalid. Please configure the correct key in order to use the charts."):(e.Helpers.error("ZoomCharts license key was not found on the page. Please make sure ZoomChartsLicense and ZoomChartsLicenseKey variables are correctly set before initializing the chart."),o=r="---:");*/
                    var a = ". Please upgrade your license on https://zoomcharts.com", h = i.api.typeName, l = o.charAt(2);
                    if (!this.checkChartType(h, o) && (console.error("ZoomCharts license used on this page does not allow use of " + h + a), l = "-", n))return void this.displayBanner(i, "builtin://logo-development");
                    var u = "builtin://logo-supported-by";
                    switch (l) {
                        case"F":
                            var c = o.match(/(\d\d\d\d-\d\d-\d\d)$/), p = t.PackageInfo.Built;
                            return void(c && c[1] < p && (this.displayBanner(i, u), console.error("ZoomCharts license is not valid for this library version which was released on " + p + a)));
                        case"-":
                        case"S":
                            u = "builtin://logo-development";
                            break;
                        case"X":
                            break;
                        default:
                        case"P":
                            u = null
                    }
                    /*var d=JSON.stringify({protocol:1,version:t.PackageInfo.Version,revision:t.PackageInfo.Revision,libraryName:t.PackageInfo.LibraryName,assetsDomain:"www.zoomcharts.com",pageDomain:"www.zoomcharts.com",chartType:h,license:o.substring(0,o.indexOf(":")),licenseKeyHash:e.RsaCrypto.hash(r)},null," ");e.Helpers.doPostRequest(i.assetsLoader.getAssetUrl("https://api.zoomcharts-cloud.com/lc/v1/"),3e4,d,function(t){*/
                    try {
                        var e = JSON.parse('{"status":1,"bannerImage":"","bannerTarget":"","consoleMessages":[],"protocol":1}');
                        if (1 !== e.protocol)throw"Server response contains invalid protocol.";
                        s.handleServerResponse(i, e)
                    } catch (n) {
                        s.handleServerError(i, "Unable to parse licensing server response: " + n), u && s.displayBanner(i, u)
                    }
                    /*},function(t){s.handleServerError(i,"Unable to contact licensing server: "+t),u&&s.displayBanner(i,u)})*/
                }, i.displayBanner = function (t, i, n) {
                    var s = new e.SettingsCredits;
                    n && (s.url = n), s.imageScaling = .5, s.image = i, s.enabled = !0, s.enabledOnExport = !0, s.location = "inside", t.events.addElement(new e.Credits(t, s))
                }, i.handleServerError = function (t, e) {
                    t.error(e)
                }, i.handleServerResponse = function (t, e) {
                    if (e.consoleMessages && console)for (var i = 0; i < e.consoleMessages.length; i++) {
                        var n = e.consoleMessages[i];
                        switch (n.level) {
                            case"error":
                                console.error(n.text);
                                break;
                            case"warn":
                                console.warn(n.text);
                                break;
                            default:
                            case"info":
                                console.info(n.text)
                        }
                    }
                    if (1 !== e.status)return 2 === e.status ? void this.displayBanner(t, e.bannerImage, e.bannerTarget) : 3 === e.status ? void this.blockChart(t, '<a href="' + e.bannerTarget + '"><img src="' + e.bannerImage + '" title="Problem with the license"/></a>') : void 0
                }, i.parseUriDomain = function (t) {
                    var e = document.createElement("a");
                    return e.href = t, e.hostname || (e.href = e.href), e.hostname
                }, i.blockChart = function (t, e) {
                    var i = t.settings.container;
                    t.remove(), i.innerHTML = "<strong>Unable to use ZoomCharts library because of a licensing issue:</strong><br/>" + e
                }, i._licenseWrittenToConsole = !1, i
            }()
        }(i = e.Base || (e.Base = {}))
    }(e = t.Internal || (t.Internal = {}))
}(ZoomCharts || (ZoomCharts = {}));
var ZoomCharts;
!function (t) {
    var e;
    !function (t) {
        var e;
        !function (e) {
            var i = function (i) {
                function n(t) {
                    i.call(this), this.animationOrder = 2e3, this.updateOrder = 1100, this.scene = null, this.events = null, this.currentObject = null, this.chart = t, this.scene = t.scene, this.events = t.events, this.dragPointers = {}
                }

                return __extends(n, i), n.prototype.onPointerMove = function (t) {
                    this.updateCurrentObject(t), this.currentObject && (this.updateCursor(t), t.hovered = !0)
                }, n.prototype.onPointerOut = function (t) {
                    this.switchCurrentObject(null, null, t)
                }, n.prototype.onPointerDown = function (t) {
                    this.updateCurrentObject(t), this.currentObject instanceof e.Node && (this.updateSelection(t, this.currentObject, !0), this.updateCursor(t), this.scene.settings.interaction.nodesMovable && (this.setPointerNode(t, this.currentObject), t.consumed = !0))
                }, n.prototype.onPointerUp = function (t) {
                    this.dragPointers[t.identifier] && (this.dragPointers[t.identifier].dragging && (t.consumed = !0, this.updateLastNode(t, this.dragPointers[t.identifier].node)), this.updateCursor(t), this.setPointerNode(t, null))
                }, n.prototype.onPointerCancel = function (t) {
                    this.onPointerUp(t)
                }, n.prototype.onPointerDrag = function (t) {
                    var e = this.dragPointers[t.identifier];
                    if (e) {
                        var i = this.scene.fromDisplay(t.x, t.y), n = i.x, s = i.y;
                        e.mouseX = t.x, e.mouseY = t.y, e.dragging = !0, this.dragNodes(e, n, s, this.scene.settings.interaction.selection.lockNodesOnMove), this.updateCursor(t), t.consumed = !0
                    }
                }, n.prototype.onClick = function (t) {
                    if (this.scene.xyInChart(t.x, t.y)) {
                        (!this.currentObject || !this.scene.settings.interaction.selection.nodesSelectable && this.currentObject.isNode || !this.scene.settings.interaction.selection.linksSelectable && this.currentObject.isLink) && this.updateSelection(t, null, !1), this.buildClickEvent(t);
                        var e = this.chart.notifyClick(t);
                        e.defaultPrevented && (t.consumed = !0)
                    }
                }, n.prototype.onRightClick = function (t) {
                    if (this.scene.xyInChart(t.x, t.y)) {
                        this.buildClickEvent(t), this.updateSelection(t, this.currentObject, !1);
                        var e = this.chart.notifyRightClick(t);
                        e.defaultPrevented && (t.consumed = !0)
                    }
                }, n.prototype.onDoubleClick = function (t) {
                    if (this.scene.xyInChart(t.x, t.y)) {
                        this.buildClickEvent(t);
                        var e = this.chart.notifyDoubleClick(t);
                        e.defaultPrevented && (t.consumed = !0)
                    }
                }, n.prototype.onTripleClick = function (t) {
                    if (this.scene.xyInChart(t.x, t.y)) {
                        this.buildClickEvent(t);
                        var e = this.chart.notifyTripleClick(t);
                        e.defaultPrevented && (t.consumed = !0)
                    }
                }, n.prototype.doAnimations = function (t) {
                    for (var e in this.dragPointers) {
                        var i = this.dragPointers[e], n = this.scene.fromDisplay(i.mouseX, i.mouseY), s = n.x, o = n.y;
                        this.dragNodes(i, s, o, !1), t.changes.coordinates = !0
                    }
                }, n.prototype.updateSelection = function (t, e, i) {
                    this.scene.settings.interaction.selection.enabled && (t.shiftKey || t.ctrlKey || !(!e || !this.scene.settings.interaction.selection.nodesSelectable && e.isNode || !this.scene.settings.interaction.selection.linksSelectable && e.isLink) ? e && t.ctrlKey ? (e.selected ? this.scene.removeFromSelection(e) : this.scene.addToSelection(e), this.notifySelectionChanged("user")) : e && t.shiftKey || i && e.selected ? this.scene.addToSelection(e) || this.notifySelectionChanged("user") : e && this.setSelection([e], "user") : this.setSelection([], "user"))
                }, n.prototype.dragNodes = function (e, i, n, s) {
                    var o = i + e.x - e.node.x, r = n + e.y - e.node.y;
                    if (0 !== o || 0 !== r) {
                        if (1 === t.Base.Helpers.countProperties(this.dragPointers) && this.scene.selection.length > 0)for (var a = 0; a < this.scene.selection.length; a++) {
                            var h = this.scene.selection[a];
                            h.isNode && this.moveNode(h, o, r, s)
                        } else this.moveNode(e.node, o, r, s);
                        this.events.notifySceneChanges({coordinates: !0})
                    }
                }, n.prototype.moveNode = function (t, e, i, n) {
                    if (t.x += e, t.y += i, n && (t.userLock = !0), !this.scene.settings.interaction.selection.allowMoveNodesOffscreen) {
                        var s = this.scene.getVisibleBounds(), o = 1.2 * t.renderHwidth / this.scene.zoom, r = 1.2 * t.renderHheight / this.scene.zoom;
                        t.x = Math.min(Math.max(t.x, s.x0 + o), s.x1 - o), t.y = Math.min(Math.max(t.y, s.y0 + r), s.y1 - r)
                    }
                }, n.prototype.setPointerNode = function (t, e) {
                    var i = t.identifier, n = this.dragPointers[i];
                    if (n && (n.node.locks -= 1, delete this.dragPointers[i]), e) {
                        var s = this.scene.fromDisplay(t.x, t.y), o = s.x, r = s.y;
                        this.dragPointers[t.identifier] = {
                            x: e.x - o,
                            y: e.y - r,
                            node: e,
                            mouseX: t.x,
                            mouseY: t.y
                        }, e.locks += 1
                    }
                }, n.prototype.updateCurrentObject = function (t) {
                    if (this.scene.xyInChart(t.x, t.y)) {
                        var e = this.chart.renderer.findObjectAt(t.x, t.y, this.scene.settings.interaction.selection.tolerance);
                        this.switchCurrentObject(e ? e.object : null, e ? e.details : null, t)
                    }
                }, n.prototype.updateCursor = function (t) {
                    t.cursor = this.currentObject && this.currentObject.cursor ? this.currentObject.cursor : "default"
                }, n.prototype.switchCurrentObject = function (t, i, n) {
                    (t !== this.currentObject || i !== this.currentItem) && (n.changes.current = !0, this.scene.setActiveObject(t, i), this.currentObject instanceof e.Node && (this.currentObject.locks -= 1), this.currentObject = t, this.currentItem = i, this.currentObject instanceof e.Node && (this.currentObject.locks += 1), this.chart.notifyHoverChanged(n))
                }, n.prototype.buildClickEvent = function (t) {
                    t.clickItem = this.currentItem, this.currentObject instanceof e.Node ? (t.clickNode = this.currentObject, this.updateLastNode(t, this.currentObject)) : t.clickLink = this.currentObject
                }, n.prototype.updateLastNode = function (t, e) {
                    this.scene.lastClickedNode = e, this.scene.settings.interaction.zooming.autoZoomAfterClick && (this.scene.autoZoomMode = !0, t.changes.zoom = !0)
                }, n.prototype.setSelection = function (t, e) {
                    var i = this.scene.setSelection(t);
                    i && this.notifySelectionChanged(e)
                }, n.prototype.notifySelectionChanged = function (t) {
                    this.events.notifySceneChanges({selection: !0}), this.chart.notifySelectionChanged(t)
                }, n
            }(t.Base.ChartElement);
            e.Selection = i
        }(e = t.ItemsChart || (t.ItemsChart = {}))
    }(e = t.Internal || (t.Internal = {}))
}(ZoomCharts || (ZoomCharts = {}));
var ZoomCharts;
!function (t) {
    var e;
    !function (t) {
        var e;
        !function (e) {
            var i = function () {
                function t() {
                }

                return t
            }();
            e.MenuButton = i;
            var n = function (e) {
                function i(i) {
                    e.call(this), this.animationOrder = 600, this.paintOrder = 40, this.updateOrder = 2e3, this.node = null, this.link = null, this.contents = null, this.x = 0, this.y = 0, this.chart = i, this.container = i.shell.menuContainer, this.scene = i.scene, this.events = i.events, this.buttons = [], this.popup = t.Base.Helpers.createDom("div", "DVSL-Menu", null, this.container);
                    var n = t.Base.Helpers.createDom("a", "DVSL-Menu-close", "X", this.popup);
                    this.popupValue = t.Base.Helpers.createDom("div", "DVSL-Menu-title", null, this.popup), this.detailsDiv = t.Base.Helpers.createDom("div", "DVSL-Menu-details", null, this.popup), this.popupActions = t.Base.Helpers.createDom("nav", null, null, this.popup), this.buildDetailsPanel(this.detailsDiv), this.buildCloseButton(n), this.popup.style.position = "absolute", this.popup.style.display = "none"
                }

                return __extends(i, e), i.prototype.doAnimations = function () {
                    this.node && (this.node.removed || this.link && this.link.removed ? this.hideMenu() : this.node.layer.modifiedNodes.hasOwnProperty(this.node.id) && this.updateMenu())
                }, i.prototype.previewPointerDown = function () {
                    this.hideMenu()
                }, i.prototype.previewWheel = function () {
                    this.hideMenu()
                }, i.prototype.toggleNodeMenu = function (t) {
                    this.node === t ? this.hideMenu() : this.showNodeMenu(t)
                }, i.prototype.toggleLinkMenu = function (t, e, i) {
                    this.link === i ? this.hideMenu() : this.showLinkMenu(t, e, i)
                }, i.prototype.showNodeMenu = function (t) {
                    this.scene.settings.nodeMenu.enabled && (this.node === t ? this.updateMenu() : (this.hideMenu(), this.showPopup(t, null)))
                }, i.prototype.showLinkMenu = function (t, e, i) {
                    this.scene.settings.linkMenu.enabled && (this.x = t, this.y = e, this.link === i ? this.updateMenu() : (this.hideMenu(), this.showPopup(null, i)))
                }, i.prototype.showPopup = function (t, e) {
                    this.node = t, this.link = e, this.node && (this.node.locks += 1), this.buildButtons(), this.contents = null, this.popup.style.display = "block", this.updateMenu(), this.updateXY()
                }, i.prototype.hideMenu = function () {
                    (this.node || this.link) && (this.node && (this.node.locks -= 1), this.node = null, this.link = null, this.popup.style.display = "none")
                }, i.prototype.updateMenu = function () {
                    var e, i, n = this;
                    this.node ? (e = this.scene.settings.nodeMenu, i = this.node) : (e = this.scene.settings.linkMenu, i = this.link);
                    var s = null;
                    if (e.contentsFunction) {
                        var o = this.node, r = this.link, a = function (t) {
                            n.node === o && n.link === r && (n.contents = t, n.popupValue.innerHTML = t)
                        }, h = e.contentsFunction.call(this.chart.api, i.data, i, a);
                        s = t.Base.Helpers.isString(h) ? h : null === this.contents ? "<small>" + this.scene.settings.localization.loadingLabel + "</small>" : this.contents
                    } else s = i.label;
                    s !== this.contents && (this.contents = s, this.popupValue.innerHTML = s), this.updateButtons(), e.showData ? (this.details.innerHTML = JSON.stringify(i.data, null, "  "), this.detailsDiv.style.display = "block") : (this.detailsDiv.style.display = "none", null == s && 0 === this.buttons.length && this.hideMenu())
                }, i.prototype.updateXY = function () {
                    var t, e, i, n, s, o, r = 12;
                    if (this.node) {
                        var a = this.scene.toDisplay(this.node.x, this.node.y);
                        s = a.x, o = a.y, t = o - this.node.renderHheight - r, n = o + this.node.renderHheight + r, e = s - this.node.renderHheight - r, i = s + this.node.renderHheight + r
                    } else t = n = o = this.y, e = this.x - r, i = this.x + r;
                    var h = this.scene.x0, l = this.scene.x0 + this.scene.width, u = this.popup.offsetWidth, c = this.popup.offsetHeight;
                    o = Math.max(Math.min(o, this.scene.y0 + this.scene.height - c), this.scene.y0), l >= i + u ? s = i : e - u >= h ? s = e - u : (s = Math.max(e - u / 2, h), o = n), this.popup.style.left = s + "px", this.popup.style.top = o + "px"
                }, i.prototype.buildButtons = function () {
                    this.popupActions.innerHTML = "", this.buttons = []
                }, i.prototype.updateButtons = function () {
                    for (var t = 0; t < this.buttons.length; t++) {
                        var e = this.buttons[t];
                        e.a.call(this, e.e)
                    }
                }, i.prototype.buildCloseButton = function (t) {
                    var e = this;
                    t.title = this.scene.settings.localization.closeButton, t.href = "#", t.onclick = function (t) {
                        e.hideMenu(), t.preventDefault()
                    }
                }, i.prototype.buildDetailsPanel = function (e) {
                    var i = t.Base.Helpers.createDom("small", null, "Technical data", e), n = this.details = t.Base.Helpers.createDom("pre", null, "", e);
                    n.style.display = "none", i.onclick = function () {
                        n.style.display = "none" === n.style.display ? "block" : "none"
                    }
                }, i
            }(t.Base.ChartElement);
            e.Menu = n
        }(e = t.ItemsChart || (t.ItemsChart = {}))
    }(e = t.Internal || (t.Internal = {}))
}(ZoomCharts || (ZoomCharts = {}));
var ZoomCharts;
!function (t) {
    var e;
    !function (t) {
        var e;
        !function (t) {
            var e = function (e) {
                function i(i) {
                    e.call(this), this.chart = i, this.container = i.shell.interactiveContainer, this.scene = i.scene, this.events = i.events, this.popup = t.Helpers.createDom("div", "DVSL-info-center", null, this.container), t.Helpers.createDom("em", null, null, this.popup), this.popup.style.position = "absolute", this.popup.style.display = "none", this.contents = null, this.visible = !1, this.x0 = null, this.x1 = null, this.y = null, this.contentsChanged = !1
                }

                return __extends(i, e), i.prototype.hide = function () {
                    return this.visible ? (this.visible = !1, this.popup.style.display = "none", !0) : !1
                }, i.prototype.show = function (t, e, i, n) {
                    this.visible = !0, n ? (-1 === n.indexOf("<") && -1 === n.indexOf(">") && (n = "<b>" + n + "</b>"), this.popup.style.display = "block", n !== this.popup.innerHTML && (this.popup.innerHTML = n, this.contentsChanged = !0), this.updateXY(t, e, i)) : this.popup.style.display = "none"
                }, i.prototype.updateContents = function (t) {
                    this.visible || (null === t ? this.hide() : this.show(this.x0, this.x1, this.y, t))
                }, i.prototype.updateXY = function (t, e, i) {
                    if (this.visible || this.contentsChanged || this.x0 !== t || this.x1 !== e || this.y !== i) {
                        this.contentsChanged && (this.contentsChanged = !1, this.width = this.popup.offsetWidth, this.height = this.popup.offsetHeight), this.x0 = t, this.x1 = e, this.y = i;
                        var n, s, o = 12, r = 10, a = this.width, h = this.height;
                        this.scene.x0 <= t - a - r ? (n = t - a - r, s = "DVSL-info-left") : this.scene.x0 + this.scene.width >= e + a + r ? (n = e + r, s = "DVSL-info-right") : (n = (Math.max(t, this.scene.x0) + Math.min(e, this.scene.x0 + this.scene.width) - a) / 2, s = "DVSL-info-center"), i = Math.min(Math.max(this.scene.y0 + o, i - h / 2), this.scene.y0 + this.scene.height - h);
                        var l = this.chart.shell.getChartInnerArea(), u = l.findTopPosition(n, n + a);
                        i = Math.max(u, i), this.popupX = n, this.popupY = i, this.popup.style.left = n + "px", this.popup.style.top = i + "px", this.popupClass !== s && (this.popupClass = s, this.popup.className = s)
                    }
                }, i
            }(t.ChartElement);
            t.InfoPopup = e
        }(e = t.Base || (t.Base = {}))
    }(e = t.Internal || (t.Internal = {}))
}(ZoomCharts || (ZoomCharts = {}));
var ZoomCharts;
!function (t) {
    var e;
    !function (t) {
        var e;
        !function (e) {
            var i = function (i) {
                function n(e) {
                    i.call(this), this.animationOrder = 800, this.paintOrder = 45, this.updateOrder = 2e3, this.chart = e, this.scene = e.scene, this.options = this.scene.settings, this.item = null, this.x = null, this.y = null, this.popup = new t.Base.InfoPopup(e)
                }

                return __extends(n, i), n.prototype.previewPointerMove = function (t) {
                    return this.onMove(t.x, t.y)
                }, n.prototype.doAnimations = function () {
                    return null !== this.x && null !== this.y ? this.onMove(this.x, this.y) : void 0
                }, n.prototype.previewPointerDown = function () {
                    return this.x = this.y = null, this.setCurrentObject(0, 0, null)
                }, n.prototype.previewPointerDrag = function () {
                    return this.x = this.y = null, this.setCurrentObject(0, 0, null)
                }, n.prototype.onPointerOut = function () {
                    return this.x = this.y = null, this.setCurrentObject(0, 0, null)
                }, n.prototype.onMove = function (t, e) {
                    if (this.y = e, this.x = t, this.options.info.enabled) {
                        var i = this.scene.hoverNode ? this.scene.hoverNode : this.scene.hoverLink;
                        return this.setCurrentObject(t, e, i)
                    }
                }, n.prototype.setCurrentObject = function (t, e, i) {
                    if (i) {
                        if (i !== this.item) {
                            var n = this.buildContents(i);
                            this.popup.show(t, t, e, n)
                        } else this.popup.updateXY(t, t, e);
                        return this.item = i
                    }
                    return this.item = null, this.popup.hide()
                }, n.prototype.buildContents = function (t) {
                    var i = this, n = null;
                    if (t instanceof e.Node ? n = this.options.info.nodeContentsFunction : t instanceof e.Link && (n = this.options.info.linkContentsFunction), n) {
                        var s = function (e) {
                            return t === i.item ? i.popup.updateContents(e) : void 0
                        };
                        return n.call(this.chart.api, t.data, t, s)
                    }
                    return t.label
                }, n
            }(t.Base.ChartElement);
            e.InfoPopup = i
        }(e = t.ItemsChart || (t.ItemsChart = {}))
    }(e = t.Internal || (t.Internal = {}))
}(ZoomCharts || (ZoomCharts = {}));
var ZoomCharts;
!function (t) {
    var e;
    !function (t) {
        var e;
        !function (e) {
            var i = function (t) {
                function i(i, n, s) {
                    t.call(this, i, n, s), this.selection = this.events.addElement(new e.Selection(this))
                }

                return __extends(i, t), i.prototype.getNode = function () {
                    throw new Error("Method not implemented in derived class")
                }, i.prototype.expandNode = function () {
                    throw new Error("Method not implemented in derived class")
                }, i.prototype.collapseNode = function () {
                    throw new Error("Method not implemented in derived class")
                }, i.prototype.removeFocusNode = function () {
                    throw new Error("Method not implemented in derived class")
                }, i.prototype.addFocusNode = function () {
                    throw new Error("Method not implemented in derived class")
                }, i.prototype.lockNode = function () {
                    throw new Error("Method not implemented in derived class")
                }, i.prototype.unlockNode = function () {
                    throw new Error("Method not implemented in derived class")
                }, i.prototype.hideNode = function () {
                    throw new Error("Method not implemented in derived class")
                }, i.prototype.setSelection = function (t) {
                    for (var i, n = [], s = 0; s < t.length; s++) {
                        var o = t[s];
                        o instanceof e.Node || o instanceof e.Link ? n.push(o) : (i = this.getNode(o)) ? n.push(i) : this.error("SetSelection: Non chart object in selection: " + o)
                    }
                    return this.selection.setSelection(n, "api")
                }, i.prototype.scrollIntoView = function () {
                    throw new Error("Method not implemented in the derived class")
                }, i
            }(t.Base.Impl);
            e.Impl = i
        }(e = t.ItemsChart || (t.ItemsChart = {}))
    }(e = t.Internal || (t.Internal = {}))
}(ZoomCharts || (ZoomCharts = {}));
var ZoomCharts;
!function (t) {
    var e;
    !function (t) {
        var e;
        !function (t) {
            var e = function () {
                function e(t, i, n, s, o) {
                    if (void 0 === s && (s = "<>"), void 0 === o && (o = null), this.formula = null, this.startTime = null, this.fromColor = null, this.toColor = null, this.t = 0, this.startSpeed = 0, null == s && (s = "<>"), this.duration = n, this.from = t, this.to = i, (void 0 === this.from || null === this.from) && (this.from = this.to), this.startTime = o, this.x = this.from, this.t = this.startTime, !e.easingFormulas[s])throw"Easing formula not defined: " + s;
                    this.formula = e.easingFormulas[s]
                }

                return e.prototype.jump = function (t) {
                    return this.to = t, this.from = t, this.x = t, this.t = this.startTime = 0
                }, e.prototype.retarget = function (t, e) {
                    return void 0 === e && (e = null), this.startSpeed = this.finished(this.t) ? 0 : this._getSpeed(), null !== e ? (this.from = this.get(e), this.startTime = e) : (this.startTime = this.t, this.from = this.x), this.to = t, this
                }, e.prototype.retargetColor = function (t, e) {
                    return void 0 === e && (e = null), this.startSpeed = 0, this.from = this.x, this.to = t, this.fromColor = null, this.toColor = null, this.startTime = e, this
                }, e.prototype.switchCoordinates = function (t, e) {
                    this.from = this.from * e + t, this.x = this.x * e + t, this.to = this.to * e + t, this.startSpeed = this.startSpeed * e
                }, e.prototype.updateAndGet = function (t, e) {
                    var i = this.x !== t;
                    return t !== this.to && this.retarget(t, e), {
                        value: this.get(e),
                        changes: i
                    }
                }, e.prototype.updateAndGetFixed = function (t, e) {
                    var i = this.x !== t;
                    return t !== this.to && (this.startSpeed = 0, this.startTime = e, this.from = this.x, this.to = t, this.fromColor = null, this.toColor = null), {
                        value: this.get(e),
                        changes: i
                    }
                }, e.prototype.updateColorAndGet = function (t, e) {
                    var i = this.x !== t;
                    return t !== this.to && this.retargetColor(t, e), {
                        value: this.getColor(e),
                        changes: i
                    }
                }, e.prototype.get = function (t) {
                    if (this.duration <= 0)return this.t = t, this.x = this.to, this.to;
                    this.startTime || (this.startTime = t);
                    var e = Math.min(1, Math.max(t - this.startTime, 0) / this.duration);
                    if (e >= 1)return this.t = 0, this.x = this.to, this.to;
                    var i = this.formula(e), n = i * (this.to - this.from);
                    if (this.startSpeed && 1 > e) {
                        var s = this.startSpeed * e * this.duration;
                        n = n * i + s * (1 - i)
                    }
                    return n = this.from + n, this.t = t, this.x = n, n
                }, e.prototype.getColor = function (e) {
                    if (this.t = e, this.duration <= 0 || this.from === this.to)return this.to;
                    this.startTime || (this.startTime = e), this.fromColor || (this.fromColor = t.CssColorParser.parseCSSColor(this.from)), this.toColor || (this.toColor = t.CssColorParser.parseCSSColor(this.to));
                    var i = Math.min(1, Math.max(e - this.startTime, 0) / this.duration), n = this.formula(i), s = 1 - n, o = this.fromColor.R, r = this.fromColor.G, a = this.fromColor.B, h = this.fromColor.A, l = this.toColor.R, u = this.toColor.G, c = this.toColor.B, p = this.toColor.A, d = "rgba(" + Math.round(o * s + l * n) + "," + Math.round(r * s + u * n) + "," + Math.round(a * s + c * n) + "," + (h * s + p * n).toFixed(3) + ")";
                    return this.t = e, this.x = d, d
                }, e.prototype.finished = function (t) {
                    return this.startTime || (this.startTime = t), t >= this.startTime + this.duration
                }, e.prototype._getSpeed = function () {
                    var t = this.t, e = this.duration / 1e3, i = this.get(t - e / 2), n = this.get(t + e / 2);
                    return this.t = t, (n - i) / e
                }, e.easingFormulas = {
                    "=": function (t) {
                        return t
                    }, "<>": function (t) {
                        return .5 > t ? 2 * t * t : -.5 * ((2 * t - 1) * (2 * t - 3) - 1)
                    }, scroll: function (t) {
                        return 1 - (1 - t) * (1 - t)
                    }
                }, e
            }();
            t.Animator = e
        }(e = t.Base || (t.Base = {}))
    }(e = t.Internal || (t.Internal = {}))
}(ZoomCharts || (ZoomCharts = {}));
var ZoomCharts;
!function (t) {
    var e;
    !function (t) {
        var e;
        !function (e) {
            var i = function (e) {
                function i(t) {
                    e.call(this), this.pointer1 = null, this.pointer2 = null, this.x1 = 0, this.y1 = 0, this.x2 = 0, this.y2 = 0, this.centerX = 0, this.centerY = 0, this.centerDistance = 1, this.numPointers = 0, this.animationOrder = 800, this.paintOrder = 15, this.updateOrder = 1300, this.consumablePointers = 0, this.consumableX = null, this.consumableY = null, this.chart = t, this.scene = t.scene, this.events = t.events, this.settings = this.scene.settings, this.pointer1 = null, this.pointer2 = null
                }

                return __extends(i, e), i.prototype.onWheel = function (t) {
                    if (this.scene.xyInChart(t.x, t.y) && this.scene.settings.interaction.zooming.wheel) {
                        var e = Math.pow(1 + this.scene.settings.interaction.zooming.sensitivity, .004 * t.wheely);
                        this.chart.autoZoom.manualZoom(e, t.x, t.y), t.consumed = !0, t.changes.position = !0
                    }
                }, i.prototype.previewPointerDown = function () {
                    this.numPointers += 1
                }, i.prototype.previewPointerUp = function () {
                    this.numPointers -= 1
                }, i.prototype.previewPointerCancel = function () {
                    this.numPointers -= 1
                }, i.prototype.onPointerDown = function (t) {
                    if (null === this.pointer1) {
                        this.pointer1 = t.identifier, this.x1 = t.x, this.y1 = t.y;
                        var e = this.scene.fromDisplay(this.x1, this.y1);
                        this.centerX = e.x, this.centerY = e.y, this.settings.interaction.panning.enabled ? t.consumed = !0 : (this.settings.interaction.zooming.fingers || this.settings.interaction.rotation.fingers) && (t.capture = !0)
                    } else if (null === this.pointer2 && this.settings.interaction.zooming.fingers) {
                        this.pointer2 = t.identifier, this.x2 = t.x, this.y2 = t.y;
                        var e = this.scene.fromDisplay((this.x1 + this.x2) / 2, (this.y1 + this.y2) / 2);
                        this.centerX = e.x, this.centerY = e.y;
                        var i = this.x1 - this.x2, n = this.y1 - this.y2, s = Math.sqrt(i * i + n * n);
                        this.centerDistance = s / this.scene.zoom, t.consumed = !0
                    }
                }, i.prototype.onPointerDrag = function (t) {
                    if (this.scene.autoZoomMode = !1, t.identifier === this.pointer1 && null === this.pointer2)if (this.settings.interaction.panning.enabled) {
                        this.x1 = t.x, this.y1 = t.y;
                        var e = this.scene.fromDisplay(t.x, t.y), i = e.x, n = e.y;
                        this.scene.centerX += this.centerX - i, this.scene.centerY += this.centerY - n, t.changes.position = !0, t.consumed = !0
                    } else t.capture = !0; else t.identifier === this.pointer1 && this.settings.interaction.zooming.fingers ? (this.decrementConsumablePointers(t.changedPointerCount), 0 === this.consumablePointers ? (null === this.consumableX && (this.consumableX = this.x2, this.consumableY = this.y2), this.twoFingerDrag(t.x, t.y, this.consumableX, this.consumableY), t.changes.position = !0) : (this.consumableX = t.x, this.consumableY = t.y), t.consumed = !0) : t.identifier === this.pointer2 && (this.decrementConsumablePointers(t.changedPointerCount), 0 === this.consumablePointers ? (null === this.consumableX && (this.consumableX = this.x1, this.consumableY = this.y1), this.twoFingerDrag(this.consumableX, this.consumableY, t.x, t.y), t.changes.position = !0) : (this.consumableX = t.x, this.consumableY = t.y), t.consumed = !0)
                }, i.prototype.onPointerUp = function (t) {
                    if (this.pointer2 === t.identifier) {
                        this.pointer2 = null;
                        var e = this.scene.fromDisplay(this.x1, this.y1);
                        this.centerX = e.x, this.centerY = e.y, this.x2 = null, this.y2 = null
                    } else if (this.pointer1 === t.identifier)if (null !== this.pointer2) {
                        this.pointer1 = this.pointer2, this.pointer2 = null;
                        var e = this.scene.fromDisplay(this.x2, this.y2);
                        this.centerX = e.x, this.centerY = e.y, this.x1 = this.x2, this.y1 = this.y2, this.x2 = null, this.y2 = null
                    } else this.pointer1 = null, this.x1 = null, this.x1 = null
                }, i.prototype.onPointerCancel = function (t) {
                    this.onPointerUp(t)
                }, i.prototype.onDoubleClick = function (t) {
                    var e = this.settings.interaction.zooming.doubleClickZoom;
                    e && this.settings.interaction.zooming.zoomInOnDoubleClick && (this.chart.autoZoom.manualZoom(e, t.x, t.y), t.changes.position = !0, t.consumed = !0)
                }, i.prototype.twoFingerDrag = function (t, e, i, n) {
                    var s = i - t, o = n - e, r = this.settings.layout.mode;
                    !this.settings.interaction.rotation.fingers || "static" !== r && "dynamic" !== r || this._twoFingerRotation(t, e, i, n);
                    var a = Math.sqrt(s * s + o * o) / this.scene.zoom, h = (i + t) / 2, l = (n + e) / 2;
                    if (!this.settings.interaction.rotation.fingers && this.settings.interaction.panning.enabled) {
                        var u = this.scene.fromDisplay(h, l);
                        this.scene.centerX += this.centerX - u.x, this.scene.centerY += this.centerY - u.y
                    }
                    if (this.settings.interaction.zooming.fingers) {
                        var c = a / this.centerDistance;
                        this.chart.autoZoom.manualZoom(c, h, l)
                    }
                    this.x1 = t, this.y1 = e, this.x2 = i, this.y2 = n, this.consumableX = this.consumableY = null
                }, i.prototype.decrementConsumablePointers = function (t) {
                    0 === this.consumablePointers && (this.consumablePointers = t), this.consumablePointers -= 1
                }, i.prototype._twoFingerRotation = function (e, i, n, s) {
                    var o = n - e, r = s - i, a = Math.atan2(r, o), h = Math.atan2(this.y2 - this.y1, this.x2 - this.x1), l = a - h;
                    if (0 === l)return !1;
                    var u, c, p, d, f, m = e - this.x1, g = i - this.y1, y = n - this.x2, v = s - this.y2, S = m * m + g * g, C = y * y + v * v;
                    S >= C ? (u = this.x1, c = this.y1, p = e, d = i, f = Math.sqrt(S)) : (u = this.x2, c = this.y2, p = n, d = s, f = Math.sqrt(C));
                    var b = p - u, x = d - c, _ = b / f, w = x / f, L = (Math.PI + l) / 2, T = Math.PI - L, M = t.Base.Geometry.rotateVector(_, w, Math.sin(T), Math.cos(T)), P = t.Base.Geometry.rotateVector(_, w, Math.sin(L), Math.cos(L)), k = t.Base.Geometry.lineIntersectsLine(0, 0, M.x, M.y, b, x, b + P.x, x + P.y);
                    if (1 / 0 === k)return !1;
                    var D = u + M.x * k, I = c + M.y * k, A = this.scene.fromDisplay(D, I);
                    return this.chart.layer.rotateNodes(A.x, A.y, l), !0
                }, i
            }(t.Base.ChartElement);
            e.Scrolling = i
        }(e = t.NetChart || (t.NetChart = {}))
    }(e = t.Internal || (t.Internal = {}))
}(ZoomCharts || (ZoomCharts = {}));
var ZoomCharts;
!function (t) {
    var e;
    !function (t) {
        var e;
        !function (e) {
            var i = function (e) {
                function i(t) {
                    e.call(this), this.animationOrder = 500, this.paintOrder = 35, this.updateOrder = 1800, this.chart = t, this.scene = t.scene, this.events = t.events
                }

                return __extends(i, e), i.prototype.doAnimations = function (t) {
                    var e = this.chart.layer;
                    e.updateStyle(t), e.postprocessStyle(t)
                }, i.prototype.paintScene = function (e) {
                    t.Base.Graphics.pushClip(e.context, this.scene.x0, this.scene.y0, this.scene.width, this.scene.height);
                    var i = this.chart.layer;
                    i.setBounds(this.scene.x0, this.scene.y0, this.scene.x0 + this.scene.width, this.scene.y0 + this.scene.height), i.paint(e), t.Base.Graphics.popClip(e.context)
                }, i.prototype.paintLinks = function (t, e, i, n) {
                    this.chart.layer.paintLinksImpl(t, e, i, n)
                }, i.prototype.paintNodes = function (t, e, i, n) {
                    this.chart.layer.paintNodesImpl(t, e, i, n)
                }, i.prototype.findObjectAt = function (t, e, i) {
                    return this.chart.layer.findObjectAt(t, e, i)
                }, i
            }(t.Base.ChartElement);
            e.Renderer = i
        }(e = t.NetChart || (t.NetChart = {}))
    }(e = t.Internal || (t.Internal = {}))
}(ZoomCharts || (ZoomCharts = {}));
var ZoomCharts;
!function (t) {
    var e;
    !function (t) {
        var e;
        !function (e) {
            var i = function () {
                function e(t, e) {
                    this.idToNode = {}, this.idToLink = {}, this.layer = e, this.chart = t, this.settings = this.chart.settings, this.state = {}, this.userLoading = !1
                }

                return e.prototype.exportCoordinates = function (t) {
                    for (var e = 0; e < t.length; e++) {
                        var i = t[e], n = this.idToNode[i.id];
                        n && (i.x = n.x, i.y = n.y)
                    }
                }, e.prototype.save = function () {
                    var t = {};
                    for (var e in this.idToNode) {
                        var i = this.idToNode[e];
                        t[i.id] = {x: i.x, y: i.y, r: i.hHeight, w: i.hWidth}
                    }
                    return t
                }, e.prototype.restore = function (t) {
                    this.state = {};
                    for (var e in t) {
                        var i = t[e];
                        if (this.idToNode.hasOwnProperty(e)) {
                            var n = this.idToNode[e];
                            n.x = i.x, n.y = i.y, n.hHeight = i.r, n.hWidth = i.w ? i.w : i.r
                        } else this.state[e] = i
                    }
                }, e.prototype.lockNode = function (t, e, i) {
                    if (void 0 === e && (e = null), void 0 === i && (i = null), this.idToNode.hasOwnProperty(t)) {
                        var n = this.idToNode[t];
                        n.userLock = !0, null !== e && null !== i && (n.x = e, n.y = i), this.layer.touchNode(n)
                    } else this.chart.error("Locking nonexistant node: " + t)
                }, e.prototype.unlockNode = function (t) {
                    if (this.idToNode.hasOwnProperty(t)) {
                        var e = this.idToNode[t];
                        e.userLock = !1, this.layer.touchNode(e)
                    } else this.chart.error("Locking nonexistant node: " + t)
                }, e.prototype.addNode = function (e) {
                    var i = this.layer.addNode(e);
                    this.idToNode[e] = i;
                    var n = this.chart.getData("default"), s = n.getNodeData(e);
                    if (!s)throw"Internal error";
                    if (i.data = s, i.dataLinks = n.getNodeLinksRaw(e), i.dataLinksFiltered = [], t.Base.Helpers.isNumber(s.x) && (i.x = s.x), t.Base.Helpers.isNumber(s.y) && (i.y = s.y), this.state.hasOwnProperty(e)) {
                        var o = this.state[e];
                        i.x = o.x, i.y = o.y, i.hHeight = o.r, i.hWidth = o.w ? o.w : o.r, delete this.state[e]
                    }
                    return i
                }, e.prototype.tryAddLink = function (t) {
                    if (this.idToLink.hasOwnProperty(t.id)) {
                        var e = this.idToLink[t.id];
                        return e.data !== t && (e.data = t, this.layer.touchLink(e)), e
                    }
                    if (this.idToNode.hasOwnProperty(t.from) && this.idToNode.hasOwnProperty(t.to)) {
                        var e = this.layer.addLink(t.id, t.from, t.to);
                        return e.data = t, this.idToLink[t.id] = e, e
                    }
                    return null
                }, e.prototype.removeNode = function (e) {
                    if (this.idToNode.hasOwnProperty(e)) {
                        for (var i = this.idToNode[e], n = 0; n < i.links.length; n++) {
                            var s = i.links[n];
                            delete this.idToLink[s.id];
                            var o = s.otherEnd(i);
                            o !== i && (t.Base.Helpers.removeFromArray(o.links, s), this.layer.touchNode(o)), this.layer.removeLink(s)
                        }
                        i.links = [], delete this.idToNode[e], this.layer.removeNode(i);
                        var r = this.chart.getData("default");
                        return r.nodeRemoved(e)
                    }
                }, e.prototype.removeLink = function (e) {
                    if (this.idToLink.hasOwnProperty(e)) {
                        var i = this.idToLink[e];
                        return delete this.idToLink[e], t.Base.Helpers.removeFromArray(i.from.links, i), t.Base.Helpers.removeFromArray(i.to.links, i), this.layer.touchNode(i.from), this.layer.touchNode(i.to), this.layer.removeLink(i)
                    }
                }, e.prototype.removeAll = function () {
                    return this.replaceGraph({}, {})
                }, e.prototype.exportData = function () {
                    var t = [], e = [];
                    for (var i in this.idToNode) {
                        var n = this.idToNode[i];
                        t.push(n.data)
                    }
                    for (var i in this.idToLink) {
                        var s = this.idToLink[i];
                        e.push(s.data)
                    }
                    return {nodes: t, links: e}
                }, e.prototype.replaceGraph = function (t, e) {
                    var i = !0, n = {};
                    for (var s in this.idToNode) {
                        var o = this.idToNode[s];
                        o.links.length = 0
                    }
                    var r = this.idToNode, a = this.idToNode = {};
                    for (var s in t) {
                        var h = r[s];
                        if (h ? (i = !1, a[s] = h) : h = this.addNode(s), e.hasOwnProperty(s))for (var l = h.dataLinksFiltered = e[s], u = 0; u < l.length; u++) {
                            var c = l[u];
                            n[c.id] = c
                        }
                    }
                    var p = this.idToLink, d = this.idToLink = {};
                    for (var s in n) {
                        var f = n[s], m = p[s];
                        if (m) {
                            var g = f.from, y = f.to;
                            a.hasOwnProperty(g) && a.hasOwnProperty(y) && (a[g].links.push(m), a[y].links.push(m), d[s] = m)
                        } else this.tryAddLink(f)
                    }
                    for (var s in p) {
                        var v = p[s];
                        d.hasOwnProperty(s) || (this.layer.touchNode(v.from), this.layer.touchNode(v.to), this.layer.removeLink(v))
                    }
                    for (var s in r) {
                        var o = r[s];
                        a.hasOwnProperty(s) || this.layer.removeNode(o)
                    }
                    return i
                }, e.prototype.updateGraphWithNewData = function (e, i) {
                    var n = this.chart.getData("default");
                    if (e)for (var s in e) {
                        var o = e[s];
                        if (this.idToNode.hasOwnProperty(s)) {
                            var r = this.idToNode[s];
                            r.data = n.getNodeData(s), r.dataLinks = n.getNodeLinksRaw(s), t.Base.Helpers.isNumber(o.x) && (r.x = o.x), t.Base.Helpers.isNumber(o.y) && (r.y = o.y), this.layer.touchNode(r)
                        }
                    }
                    if (i)for (var s in i)if (this.idToLink.hasOwnProperty(s)) {
                        var a = this.idToLink[s];
                        a.data = n.getLinkData(s), this.layer.touchLink(a)
                    }
                }, e
            }();
            e.Graph = i
        }(e = t.NetChart || (t.NetChart = {}))
    }(e = t.Internal || (t.Internal = {}))
}(ZoomCharts || (ZoomCharts = {}));
var ZoomCharts;
!function (t) {
    var e;
    !function (t) {
        var e;
        !function (t) {
            var e = function () {
                function t(t, e, i) {
                    void 0 === i && (i = !1), this._direction = 1, this._endTime = 0, this._midTime = 0, this._startTime = 0, this._preventOvershoot = !1, this._setTargetPending = !1, this._settableTargetValue = 0, this._settableAcceleration = 0, this._acceleration = t, this._initialValue = this._targetValue = e, this._preventOvershoot = i
                }

                return t.prototype.setTarget = function (t, e, i) {
                    if (null == e)return this._settableTargetValue = t, this._settableAcceleration = i, void(this._setTargetPending = !0);
                    this._settableAcceleration = null, this._setTargetPending = !1, null != i && this.setAcceleration(i, e);
                    var n = this._getDeltaT(e), s = this._getDistanceToV0(n), o = this._composeValue(e, s), r = Math.abs(t - o), a = t > o ? 1 : -1;
                    if (e < this._startTime && (this._direction *= -1), this._targetValue = t, e < this._endTime)if (s > r || this._direction !== a)if (this._preventOvershoot)if (this._direction === a) {
                        var h = this._getCurrentVelocity(n);
                        this._acceleration = h * h / (2 * r), this._startTime = e - h / this._acceleration, this._initialValue = o - r * this._direction
                    } else this._startTime = e, this._initialValue = o; else this._startTime = e + n, this._initialValue = o + s * this._direction; else(e >= this._midTime || e <= this._startTime) && (this._startTime = e - n, this._initialValue = o - s * this._direction); else this._startTime = e, this._initialValue = o;
                    this._direction = this._targetValue > this._initialValue ? 1 : -1;
                    var l = Math.abs(this._targetValue - this._initialValue), u = Math.sqrt(l / this._acceleration);
                    this._midTime = this._startTime + u, this._endTime = this._startTime + 2 * u
                }, t.prototype.getValue = function (t) {
                    return this._setTargetPending && this.setTarget(this._settableTargetValue, t, this._settableAcceleration), this.finished(t) ? this._targetValue : this._composeValue(t, this._getDistanceToV0(this._getDeltaT(t)))
                }, t.prototype.getTargetValue = function () {
                    return this._targetValue
                }, t.prototype.finished = function (t) {
                    return this._setTargetPending ? !1 : t >= this._endTime
                }, t.prototype.jump = function (t, e, i) {
                    if (this._initialValue = this._targetValue = t, this._startTime = this._midTime = this._endTime = 0, null != e && null != i && 0 !== e) {
                        var n = e > 0 ? 1 : -1, s = Math.abs(e / this._acceleration);
                        this._direction = n, this._midTime = i, this._endTime = i + s, this._targetValue = t + this._getDistanceToV0(s) * n
                    }
                    return this._targetValue
                }, t.prototype.setAcceleration = function (t, e) {
                    if (t !== this._acceleration) {
                        var i = e < this._endTime;
                        if (i) {
                            var n = this._getDeltaT(e), s = this._getCurrentVelocity(n), o = this._composeValue(e, this._getDistanceToV0(n));
                            e < this._startTime && (s = -s), this._acceleration = t, this.jump(o, s * this._direction, e)
                        } else this._acceleration = t
                    }
                }, t.prototype._composeValue = function (t, e) {
                    return t < this._startTime ? this._initialValue + e * this._direction : t < this._midTime ? this._initialValue + e * this._direction : t < this._endTime ? this._targetValue - e * this._direction : this._targetValue
                }, t.prototype._getDistanceToV0 = function (t) {
                    return this._acceleration * t * t / 2
                }, t.prototype._getDeltaT = function (t) {
                    return t < this._startTime ? this._startTime - t : t < this._midTime ? t - this._startTime : t < this._endTime ? this._endTime - t : 0
                }, t.prototype._getCurrentVelocity = function (t) {
                    return t * this._acceleration
                }, t
            }();
            t.Inertia = e
        }(e = t.Base || (t.Base = {}))
    }(e = t.Internal || (t.Internal = {}))
}(ZoomCharts || (ZoomCharts = {}));
var ZoomCharts;
!function (t) {
    var e;
    !function (t) {
        var e;
        !function (e) {
            var i = function (e) {
                function i(i) {
                    e.call(this), this.numPointers = 0, this.resetZoom = !1, this.animationOrder = 700, this.paintOrder = 20, this.updateOrder = 2e3, this.chart = i, this.scene = i.scene, this.layer = i.layer, this.events = i.events, this.settings = this.scene.settings;
                    var n = this._getInertiaAccelerations();
                    this.inertiaX = new t.Base.Inertia(n.x, 0), this.inertiaY = new t.Base.Inertia(n.y, 0), this.inertiaZ = new t.Base.Inertia(n.z, 0)
                }

                return __extends(i, e), i.prototype.setZoom = function (e, i) {
                    void 0 === i && (i = !0), null == i && (i = !0);
                    var n = 1 + this.scene.settings.interaction.zooming.sensitivity;
                    if ("auto" === e) this.scene.autoZoomMode = !0, this.autoZoom(i); else if ("overview" === e) this.scene.autoZoomMode = "overview", this.autoZoom(i); else {
                        var s;
                        "in" === e ? s = 1 / this.inertiaZ.getTargetValue() * n : "out" === e ? s = 1 / this.inertiaZ.getTargetValue() / n : null === (s = t.Base.Helpers.tryParseFloat(e, null)) && (this.chart.error("Invalid zoom value: " + e), s = 1 / this.inertiaZ.getTargetValue()), this.manualZoom(s / this.scene.zoom, void 0, void 0, i)
                    }
                    this.chart.events.notifySceneChanges({position: !0})
                }, i.prototype.previewPointerDown = function () {
                    this.numPointers += 1
                }, i.prototype.previewPointerUp = function () {
                    this.numPointers -= 1
                }, i.prototype.previewPointerCancel = function () {
                    this.numPointers -= 1
                }, i.prototype.doAnimations = function (e) {
                    if (t.Base.Helpers.hasProp(e, "changes.settingsChanges.interaction.zooming") && (this.scene.autoZoomMode = this.scene.settings.interaction.zooming.initialAutoZoom, "true" === this.scene.autoZoomMode ? this.scene.autoZoomMode = !0 : "false" === this.scene.autoZoomMode && (this.scene.autoZoomMode = !1)), this.resetZoom || e.changes.newGraph) this.resetZoom = !1, this.setZoom("overview", !1); else if (0 === this.numPointers && this.layer.nodes().length > 0) {
                        this.scene.autoZoomMode && this.autoZoom(!0) && (e.changes.position = !0);
                        var i = e.timeStamp, n = this.inertiaX.getValue(i), s = this.inertiaY.getValue(i), o = 1 / this.inertiaZ.getValue(i);
                        (n !== this.scene.centerX || s !== this.scene.centerY || o !== this.scene.zoom) && (this.scene.centerX = n, this.scene.centerY = s, this.scene.zoom = o, e.changes.position = !0), this.inertiaX.finished(i) && this.inertiaY.finished(i) && this.inertiaZ.finished(i) || (e.animating = !0)
                    } else this.inertiaX.jump(this.scene.centerX), this.inertiaY.jump(this.scene.centerY), this.inertiaZ.jump(1 / this.scene.zoom)
                }, i.prototype._getInertiaAccelerations = function () {
                    var t = this.scene.settings.interaction.zooming.autoZoomPositionEllasticity, e = .5 * (this.scene.width + this.scene.height) * t;
                    return {x: e, y: e, z: 2 * t}
                }, i.prototype.autoZoom = function (t, e) {
                    var i = !1, n = this.computeAutoZoom("overview" === this.scene.autoZoomMode), s = n.centerX, o = n.centerY, r = n.zoom, a = .01, h = 1 + a, l = 1 - a, u = 1 / this.inertiaZ.getTargetValue() / r, c = this._getInertiaAccelerations();
                    (u > h || l > u) && (t ? this.inertiaZ.setTarget(1 / r, e, c.z) : (this.inertiaZ.jump(1 / r), this.scene.zoom = r), i = !0);
                    var p = this.scene.width, d = (this.inertiaX.getTargetValue() - s) * r / p;
                    (d > a || -a > d) && (t ? this.inertiaX.setTarget(s, e, c.x) : (this.inertiaX.jump(s), this.scene.centerX = s), i = !0);
                    var f = this.scene.height, m = (this.inertiaY.getTargetValue() - o) * r / f;
                    return (m > a || -a > m) && (t ? this.inertiaY.setTarget(o, e, c.y) : (this.inertiaY.jump(o), this.scene.centerY = o), i = !0), i
                }, i.prototype.getOnscreenBounds = function (t) {
                    void 0 === t && (t = 1), null == t && (t = 1);
                    var e = this.scene.width * t, i = this.scene.height * t, n = this.scene.settings.area.paddingLeft, s = this.scene.settings.area.paddingRight, o = this.scene.settings.area.paddingTop, r = this.scene.settings.area.paddingBottom;
                    return 1 >= n && (n = e * n), s = 1 >= s ? e * (1 - s) : e - s, 1 >= o && (o = i * o), r = 1 >= r ? i * (1 - r) : i - r, {
                        sx0: n,
                        sy0: o,
                        sx1: s,
                        sy1: r
                    }
                }, i.prototype.computeAutoZoom = function (t, e) {
                    var i = this.layer.getGraphBounds(e), n = i.x0, s = i.y0, o = i.x1, r = i.y1;
                    n === o && s === r && (n = 0, o = 1, s = 0, r = 1);
                    var a = this.scene.width * this.scene.settings.interaction.zooming.autoZoomSize, h = this.scene.height * this.scene.settings.interaction.zooming.autoZoomSize, l = this.getOnscreenBounds(this.scene.settings.interaction.zooming.autoZoomSize), u = l.sx0, c = l.sy0, p = l.sx1, d = l.sy1, f = Math.min((p - u) / (o - n), (d - c) / (r - s)), m = this.scene.settings.interaction.zooming.autoZoomExtent, g = this.scene.lastClickedNode;
                    f = Math.min(m[1], f);
                    var y, v;
                    if (t) y = (n + o) / 2 - a * (this.scene.settings.area.centerX - .5) / f, v = (s + r) / 2 - h * (this.scene.settings.area.centerY - .5) / f; else if (f = Math.max(f, m[0]), g)if (g.expanded && g.links.length > 1) {
                        var S = this.layer.getNodeNeighborsBounds(g), C = S.x0, b = S.y0, x = S.x1, _ = S.y1, w = Math.min((p - u) / (x - C), (d - c) / (_ - b));
                        y = (C + x) / 2, v = (b + _) / 2, f = Math.min(w, f)
                    } else y = g.x, v = g.y; else y = this.scene.centerX, v = this.scene.centerY;
                    var L = n - (u - a / 2) / f, T = o - (p - a / 2) / f, M = s - (c - h / 2) / f, P = r - (d - h / 2) / f, k = this.scene.centerX, D = this.scene.centerY;
                    return t ? (k = Math.min(L, Math.max(T, y)), D = Math.min(M, Math.max(P, v))) : (T > k && y > k ? k = Math.min(T, y) : k > L && k > y && (k = Math.max(L, y)), P > D && v > D ? D = Math.min(P, v) : D > M && D > v && (D = Math.max(M, v))), {
                        centerX: k,
                        centerY: D,
                        zoom: f * this.scene.settings.interaction.zooming.autoZoomSize
                    }
                }, i.prototype.manualZoom = function (t, e, i, n) {
                    void 0 === e && (e = null), void 0 === i && (i = null), void 0 === n && (n = !1), null == n && (n = !1);
                    var s, o = this.settings.interaction.zooming.zoomExtent, r = this.layer.getGraphBounds(), a = r.x0, h = r.y0, l = r.x1, u = r.y1;
                    if (t > 1) s = Math.max(this.scene.zoom, Math.min(o[1], this.scene.zoom * t)); else if (1 > t) {
                        var c = this.getOnscreenBounds(), p = c.sx0, d = c.sy0, f = c.sx1, m = c.sy1, g = Math.min((f - p) / (l - a), (m - d) / (u - h));
                        s = Math.min(this.scene.zoom, Math.max(Math.min(o[0], g), this.scene.zoom * t))
                    } else s = this.scene.zoom;
                    t = s / this.scene.zoom;
                    var y, v;
                    if (null !== e && null !== i) {
                        var S = this.scene.fromDisplay(e, i);
                        y = S.x, v = S.y
                    } else if (this.scene.selection.length > 0) {
                        for (var C = 0, b = 0, x = 0, _ = 0; _ < this.scene.selection.length; _++) {
                            var w = this.scene.selection[_];
                            w.isNode && (C += w.x, b += w.y, x += 1)
                        }
                        x > 0 && (y = C / x, v = b / x)
                    }
                    var L, T;
                    y && v ? (L = (this.scene.centerX - y) / t + y, T = (this.scene.centerY - v) / t + v) : (L = y = this.scene.centerX, T = v = this.scene.centerY);
                    var M = this.scene.zoom * t, P = this.scene.getVisibleBounds();
                    if (a > y || y > l) {
                        var k;
                        k = P.x0 > a && P.x1 > l ? Math.max(l - P.x1, a - P.x0) : P.x1 < l && P.x0 < a ? Math.min(l - P.x1, a - P.x0) : 0, L += k
                    }
                    if (h > v || v > u) {
                        var D;
                        D = P.y0 > h && P.y1 > u ? Math.max(u - P.y1, h - P.y0) : P.y1 < u && P.y0 < a ? Math.min(u - P.y1, h - P.y0) : 0, T += D
                    }
                    if (n && M !== this.scene.zoom ? this.inertiaZ.setTarget(1 / M) : (this.inertiaZ.jump(1 / M), this.scene.zoom = M), !n || L === this.scene.centerX && T === this.scene.centerY) this.scene.centerX = L, this.scene.centerY = T, this.inertiaX.jump(L), this.inertiaY.jump(T); else {
                        var I = this._getInertiaAccelerations();
                        this.inertiaX.setTarget(L, null, I.x), this.inertiaY.setTarget(T, null, I.y)
                    }
                    return this.scene.autoZoomMode = !1
                }, i.prototype.scrollIntoView = function (e) {
                    var i = t.Base.Helpers.performanceNow();
                    this.scene.autoZoomMode = !1;
                    var n = this._getInertiaAccelerations(), s = this.computeAutoZoom(!0, e);
                    this.inertiaX.setTarget(s.centerX, i, n.x), this.inertiaY.setTarget(s.centerY, i, n.y), this.inertiaZ.setTarget(1 / s.zoom, i, n.z), this.chart.events.notifySceneChanges({position: !0})
                }, i
            }(t.Base.ChartElement);
            e.AutoZoom = i
        }(e = t.NetChart || (t.NetChart = {}))
    }(e = t.Internal || (t.Internal = {}))
}(ZoomCharts || (ZoomCharts = {}));
var ZoomCharts;
!function (t) {
    var e;
    !function (t) {
        var e;
        !function (e) {
            var i = function (e) {
                function i() {
                    e.apply(this, arguments)
                }

                return __extends(i, e), i.prototype.buildButtons = function () {
                    if (e.prototype.buildButtons.call(this), this.node)for (var i = 0; i < this.scene.settings.nodeMenu.buttons.length; i++) {
                        var n = this.scene.settings.nodeMenu.buttons[i], s = void 0, o = void 0;
                        "expand" === n ? (s = t.Base.Helpers.createDom("a", "DVSL-NC-button-expand", null, this.popupActions), o = this.updateExpandButton) : "focus" === n ? (s = t.Base.Helpers.createDom("a", "DVSL-NC-button-focus", null, this.popupActions), o = this.updateFocusButton) : "lock" === n ? (s = t.Base.Helpers.createDom("a", "DVSL-NC-button-lock", null, this.popupActions), o = this.updateLockButton) : "hide" === n && (s = t.Base.Helpers.createDom("a", "DVSL-NC-button-hide", null, this.popupActions), o = this.updateHideButton), s.href = "#", this.buttons.push({
                            e: s,
                            a: o
                        })
                    }
                }, i.prototype.canUnfocusNode = function () {
                    return !this.node.focused || "focusnodes" !== this.scene.settings.navigation.mode || this.chart.navigator.getFocusNodeCount() > this.scene.settings.navigation.minNumberOfFocusNodes
                }, i.prototype.updateExpandButton = function (t) {
                    var e = this;
                    if (!this.node.expanded || this.node.dataLinksFiltered.length > this.node.links.length) {
                        var i = this.scene.settings.localization.menu.expand;
                        t.className = "DVSL-NC-button-expand", t.title = i, t.innerHTML = i, t.onclick = function (t) {
                            e.chart.expandNode(e.node.id), t.preventDefault()
                        }
                    } else {
                        var n = this.scene.settings.localization.menu.collapse;
                        t.className = "DVSL-NC-button-collapse", t.title = n, t.innerHTML = n, t.onclick = function (t) {
                            e.chart.collapseNode(e.node.id), t.preventDefault()
                        }
                    }
                }, i.prototype.updateFocusButton = function (t) {
                    var e = this;
                    if (this.node.focused)if (this.canUnfocusNode()) {
                        var i = this.scene.settings.localization.menu.unfocus;
                        t.className = "DVSL-NC-button-unfocus", t.title = i, t.innerHTML = i, t.onclick = function (t) {
                            e.chart.removeFocusNode(e.node.id), t.preventDefault()
                        }, t.style.display = ""
                    } else t.style.display = "none"; else {
                        var n = this.scene.settings.localization.menu.focus;
                        t.className = "DVSL-NC-button-focus", t.title = n, t.innerHTML = n, t.onclick = function (t) {
                            e.chart.addFocusNode(e.node.id, -1), t.preventDefault()
                        }
                    }
                }, i.prototype.updateLockButton = function (t) {
                    var e = this;
                    if (this.node.userLock) {
                        var i = this.scene.settings.localization.menu.fixed;
                        t.className = "DVSL-NC-button-lock", t.title = i, t.innerHTML = i, t.onclick = function (i) {
                            e.chart.unlockNode(e.node.id), e.updateLockButton(t), i.preventDefault()
                        }
                    } else {
                        var n = this.scene.settings.localization.menu.dynaminc;
                        t.className = "DVSL-NC-button-unlock", t.title = n, t.innerHTML = n, t.onclick = function (i) {
                            e.chart.lockNode(e.node.id), e.updateLockButton(t), i.preventDefault()
                        }
                    }
                }, i.prototype.updateHideButton = function (t) {
                    var e = this;
                    if (this.canUnfocusNode()) {
                        var i = this.scene.settings.localization.menu.hide;
                        t.className = "DVSL-NC-button-hide", t.title = i, t.innerHTML = i, t.onclick = function (t) {
                            e.chart.hideNode(e.node.id), t.preventDefault()
                        }, t.style.display = ""
                    } else t.style.display = "none"
                }, i
            }(t.ItemsChart.Menu);
            e.Menu = i
        }(e = t.NetChart || (t.NetChart = {}))
    }(e = t.Internal || (t.Internal = {}))
}(ZoomCharts || (ZoomCharts = {}));
var ZoomCharts;
!function (t) {
    var e;
    !function (t) {
        var e;
        !function (e) {
            var i = function (i) {
                function n(n, s) {
                    i.call(this, new e.Settings(n), new e.Scene, s);
                    var o = "focusnodes" === this.settings.navigation.mode && this.settings.navigation.focusAutoFadeout;
                    this.layer = new t.ItemsChart.NodesLayer(this.scene, this.events, this.settings, o), this.graph = new e.Graph(this, this.layer), this.navigator = this.events.addElement(new e.Navigator(this)), this.scrolling = this.events.addElement(new e.Scrolling(this)), this.layout = this.events.addElement(new e.Layout(this)), this.info = this.events.addElement(new t.ItemsChart.InfoPopup(this)), this.menu = this.events.addElement(new e.Menu(this)), this.autoZoom = this.events.addElement(new e.AutoZoom(this)), this.renderer = this.events.addElement(new e.Renderer(this)), this.legend = this.events.addElement(new e.Legend(this)), this.autoZoom.resetZoom = !0, this.scene.loading = !1, this.navigator.onNewDataObject(), this.navigator.showInitialNodes(), this.finalInitialize()
                }

                return __extends(n, i), n.prototype.createDataObj = function (t) {
                    return new e.Data(this, t)
                }, n.prototype.onSettingsChanged = function (t) {
                    var e = {};
                    this.layer.onSettingsChanged(t);
                    var i = t.navigation && (t.navigation.mode || t.navigation.initialNodes);
                    t.data && (t.data.dataFunction || t.data.format || t.data.preloaded || t.data.url || t.data.randomNodes) && (this.navigator.onNewDataObject(), i = !0), i && (this.navigator.showInitialNodes(), this.autoZoom.resetZoom = !0), t.filters && (e.filters = !0), t.style && (e.style = !0), this.events.notifySceneChanges(e)
                }, n.prototype.save = function () {
                    var t = this.graph.save(), e = this.navigator.save();
                    return JSON.stringify({xy: t, nav: e})
                }, n.prototype.restore = function (t) {
                    if (t) {
                        var e = JSON.parse(t), i = e.xy, n = e.nav;
                        n && this.navigator.restore(n), i && this.graph.restore(i), this.autoZoom.resetZoom = !0
                    }
                }, n.prototype.saveNavigation = function () {
                    var t = JSON.stringify(this.navigator.save());
                    return "{}" === t ? null : t
                }, n.prototype.restoreNavigation = function (t) {
                    this.navigator.restore(JSON.parse(t))
                }, n.prototype.getCurrentNodes = function () {
                    for (var t = [], e = 0, i = this.layer.nodes(); e < i.length; e++) {
                        var n = i[e];
                        n.removed || t.push(n)
                    }
                    return t
                }, n.prototype.getCurrentLinks = function () {
                    for (var t = [], e = 0, i = this.layer.links(); e < i.length; e++) {
                        var n = i[e];
                        n.removed || t.push(n)
                    }
                    return t
                }, n.prototype.getNodeDimensions = function (e) {
                    var i;
                    if (i = t.Base.Helpers.isString(e) ? this.getNode(e) : e, !i)return null;
                    var n = this.scene.toDisplay(i.x, i.y), s = n.x, o = n.y, r = i.hHeight * this.scene.zoom, a = i.hWidth * this.scene.zoom;
                    return {x: s, y: o, radius: r, hwidth: a}
                }, n.prototype.lockNode = function (e, i, n) {
                    void 0 === i && (i = null), void 0 === n && (n = null), t.Base.Helpers.isObjectOrArray(e) && (e = e.id), this.graph.lockNode(e, i, n)
                }, n.prototype.unlockNode = function (t) {
                    t.id && (t = t.id), this.graph.unlockNode(t)
                }, n.prototype.addFocusNode = function (t, e) {
                    return t.id && (t = t.id), this.settings.navigation.autoZoomOnFocus && (this.scene.autoZoomMode = !0), this.navigator.addFocusNode(t, e, "api")
                }, n.prototype.clearFocus = function () {
                    this.navigator.clear("api")
                }, n.prototype.removeFocusNode = function (t) {
                    return t.id && (t = t.id), this.navigator.unfocusNode(t, "api")
                }, n.prototype.expandNode = function (t) {
                    return t.id && (t = t.id), this.navigator.expandNode(t, "api")
                }, n.prototype.collapseNode = function (t) {
                    return t.id && (t = t.id), this.navigator.collapseNode(t, "api")
                }, n.prototype.hideNode = function (t) {
                    return t.id && (t = t.id), this.navigator.hideNode(t, "api")
                }, n.prototype.getNode = function (t) {
                    return this.layer.idToNode[t]
                }, n.prototype.getLink = function (t) {
                    return this.layer.idToLink[t]
                }, n.prototype.touchObjects = function (t) {
                    for (var e = 0; e < t.length; e++) {
                        var i = this.layer, n = i.findObjectById(t[e]);
                        n && i.touchNodeOrLink(n)
                    }
                }, n.prototype.setZoom = function (t) {
                    this.autoZoom.setZoom(t, !0)
                }, n.prototype.zoomIn = function () {
                    throw new Error("Not implemented.")
                }, n.prototype.resetLayout = function () {
                    this.layout.resetLayout(), this.scene.settings.layout._currentMode = this.scene.settings.layout.mode, this.autoZoom.setZoom("overview", !1), this.events.notifySceneChanges({layout: !0})
                }, n.prototype.removeData = function (t, e) {
                    if (void 0 === e && (e = "default"), null == e && (e = "default"), !this.removed) {
                        if (t.nodes)for (var i = 0; i < t.nodes.length; i++) {
                            var n = t.nodes[i];
                            this.navigator.removeNode(n.id.toString())
                        }
                        var s = this.getData(e);
                        s.removeData(t);
                        var o = {};
                        o[e] = !0, this.events.notifySceneChanges({data: o})
                    }
                }, n.prototype.exportData = function (t, e) {
                    var i;
                    return i = t ? this.graph.exportData() : this.scene.mainData.exportData(), e && this.graph.exportCoordinates(i.nodes), i
                }, n.prototype.hideMenu = function () {
                    this.menu.hideMenu()
                }, n.prototype.extendEventParams = function (t) {
                    if (t.x || t.y) {
                        var e = this.scene.fromDisplay(t.x, t.y);
                        t.chartX = e.x, t.chartY = e.y
                    }
                    return t.nodes = this.layer.nodes(), t.links = this.layer.links(), t.hoverLink = this.scene.hoverLink, t.hoverNode = this.scene.hoverNode, t.hoverItem = this.scene.hoverItem, t.selection = this.scene.selection, t
                }, n.prototype.defaultClick = function (t) {
                    if (!t.shiftKey && !t.ctrlKey && t.clickNode) {
                        var e = t.clickNode;
                        this.scene.settings.navigation.expandOnClick && (e.expanded ? e.expanded && "manual" === this.scene.settings.navigation.mode && (this.collapseNode(e.id), t.preventDefault()) : (this.expandNode(e.id), t.preventDefault()))
                    }
                }, n.prototype.defaultRightClick = function (t) {
                    t.clickNode && (this.scene.mainData.getNodeLinks(t.clickNode.id), this.menu.toggleNodeMenu(t.clickNode), t.preventDefault()), t.clickLink && (this.menu.toggleLinkMenu(t.x, t.y, t.clickLink), t.preventDefault())
                }, n.prototype.defaultDoubleClick = function (t) {
                    var e = t.clickNode;
                    e && (this.addFocusNode(e.id, -1), t.preventDefault())
                }, n.prototype.scrollIntoView = function (e) {
                    for (var i, n = [], s = 0; s < e.length; s++) {
                        var o = e[s];
                        o instanceof t.ItemsChart.Node ? n.push(o) : (i = this.getNode(o)) ? n.push(i) : this.error("scrollIntoView: Non chart object has been passed: " + o)
                    }
                    this.autoZoom.scrollIntoView(n)
                }, n
            }(t.ItemsChart.Impl);
            e.Impl = i
        }(e = t.NetChart || (t.NetChart = {}))
    }(e = t.Internal || (t.Internal = {}))
}(ZoomCharts || (ZoomCharts = {}));
var ZoomCharts;
!function (t) {
    var e;
    !function (t) {
        var e;
        !function (t) {
            var e = function () {
                function e() {
                }

                return e.prototype.customize = function (t) {
                    var e = this.constructor.themes;
                    if (!e.hasOwnProperty(t))throw new Error("The chart does not contain a predefined theme named `" + t + "`.");
                    return this.updateSettings(e[t])
                }, e.prototype.saveState = function () {
                    return this._impl.save()
                }, e.prototype.restoreState = function (t, e) {
                    void 0 === e && (e = !1), null == e && (e = !1), this._impl.restore(t, e)
                }, e.prototype.fullscreen = function (t) {
                    return t === !0 ? this._impl.setFullscreen(!0) : t === !1 && this._impl.setFullscreen(!1), this._impl.isFullscreen()
                }, e.prototype.createEmptySettings = function () {
                    throw new Error("Not implemented in derived class.")
                }, e.prototype.updateSettings = function (t) {
                    return void 0 === t && (t = {}), t && this._impl.updateSettings(t, "api"), this
                }, e.prototype.updateFilters = function () {
                    this._impl.updateFilters(null)
                }, e.prototype.updateStyle = function () {
                    this._impl.updateStyle(null)
                }, e.prototype.on = function (t, e) {
                    return this._impl.on(t, e)
                }, e.prototype.off = function (t, e) {
                    return this._impl.off(t, e)
                }, e.prototype.updateSize = function () {
                    return this._impl.updateSize(!0), this
                }, e.prototype.reloadData = function (t) {
                    return void 0 === t && (t = null), this._impl.reloadData(t)
                }, e.prototype.addData = function (t, e) {
                    return void 0 === e && (e = "default"), null == e && (e = "default"), this._impl.addData(t, e)
                }, e.prototype.removeData = function (t, e) {
                    return void 0 === e && (e = "default"), null == e && (e = "default"), this._impl.removeData(t, e)
                }, e.prototype.replaceData = function (t, e) {
                    return void 0 === e && (e = "default"), null == e && (e = "default"), this._impl.replaceData(t, e)
                }, e.prototype.remove = function () {
                    return this._impl.remove()
                }, e.prototype.saveAsImage = function (t, e, i) {
                    return this.exportImageAsString(t, e, i)
                }, e.prototype.exportGetDimensions = function (t) {
                    return this.exportImageGetDimensions(t)
                }, e.prototype.exportImageAsString = function (e, i, n) {
                    return t.Export.exportToImage(this._impl, e, i, n)
                }, e.prototype.exportImageGetDimensions = function (e) {
                    return t.Export.exportToImageGetDimensions(this._impl, e)
                }, e.prototype["export"] = function (e, i, n) {
                    return t.Export.exportAndStartDownload(this._impl, e, i, n)
                }, e.prototype.addSubchartContainer = function (t) {
                    this._impl.shell.interactiveContainer.appendChild(t)
                }, e.prototype.paintNow = function (t) {
                    return void 0 === t && (t = !1), this._impl.events.paintNow(t), this
                }, e.prototype.hideMenu = function () {
                    return this._impl.hideMenu(), this
                }, e.prototype.back = function () {
                    return this._impl.back(), this
                }, e.prototype.home = function () {
                    return this._impl.goHome()
                }, e.prototype.clearHistory = function () {
                    return this._impl.clearHistory(), this
                }, e.prototype.closePopup = function () {
                    return this._impl.deprecated("closePopup", "hideMenu"), this.hideMenu(), this
                }, e.prototype.profiler = function () {
                    return this._impl.shell.profiler
                }, e.prototype.measureFps = function (t, e) {
                    return this._impl.deprecated("measureFps"), this.profiler().measureFps(t, e)
                }, e.themes = {}, e
            }();
            t.Api = e
        }(e = t.Base || (t.Base = {}))
    }(e = t.Internal || (t.Internal = {}))
}(ZoomCharts || (ZoomCharts = {}));
var ZoomCharts;
!function (t) {
    var e = function (e) {
        function i(n) {
            var s = this;
            e.call(this), this.typeName = "NetChart", this._impl = i.chartFactoryMethod ? i.chartFactoryMethod(function (e) {
                    return new t.Internal.NetChart.Impl(e, s)
                }, n) : new t.Internal.NetChart.Impl(n, this)
        }

        return __extends(i, e), i.prototype.createEmptySettings = function () {
            return t.Internal.Base.SettingsHelper.createEmptySettings(t.Internal.Base.SettingsMapping.NetChartSettings)
        }, i.prototype.updateSettings = function (i) {
            return t.Internal.Base.SettingsHelper.cleanupEmptySettings(i), e.prototype.updateSettings.call(this, i), this
        }, i.prototype.updateStyle = function (t) {
            t ? (this._impl.touchObjects(t), this._impl.events.requestPaint()) : this._impl.updateStyle(null)
        }, i.prototype.getNode = function (t) {
            return this._impl.getNode(t)
        }, i.prototype.getLink = function (t) {
            return this._impl.getLink(t)
        }, i.prototype.showNode = function (t) {
            return this._impl.addFocusNode(t, .9)
        }, i.prototype.hideNode = function (t) {
            return this._impl.hideNode(t)
        }, i.prototype.expandNode = function (t) {
            return this._impl.expandNode(t)
        }, i.prototype.addFocusNode = function (t, e) {
            return void 0 === e && (e = -1), null == e && (e = -1), this._impl.addFocusNode(t, e)
        }, i.prototype.removeFocusNode = function (t) {
            return this._impl.removeFocusNode(t)
        }, i.prototype.clearFocus = function () {
            return this._impl.clearFocus()
        }, i.prototype.collapseNode = function (t) {
            return this._impl.collapseNode(t)
        }, i.prototype.lockNode = function (t, e, i) {
            return this._impl.lockNode(t, e, i)
        }, i.prototype.unlockNode = function (t) {
            return this._impl.unlockNode(t)
        }, i.prototype.zoom = function (t) {
            return t && this._impl.setZoom(t), this._impl.scene.zoom
        }, i.prototype.resetLayout = function () {
            return this._impl.resetLayout()
        }, i.prototype.selection = function (t) {
            return t && this._impl.setSelection(t), this._impl.scene.selection
        }, i.prototype.zoomIn = function (t, e) {
            return void 0 === e && (e = !0), null == e && (e = !0), this._impl.zoomIn(t, e)
        }, i.prototype.nodes = function () {
            return this._impl.getCurrentNodes()
        }, i.prototype.links = function () {
            return this._impl.getCurrentLinks()
        }, i.prototype.getNodeDimensions = function (t) {
            return this._impl.getNodeDimensions(t)
        }, i.prototype.exportData = function (t, e) {
            return void 0 === t && (t = !0), void 0 === e && (e = !0), null == e && (e = !0), null == t && (t = !0), this._impl.exportData(t, e)
        }, i.prototype.scrollIntoView = function (t) {
            this._impl.scrollIntoView(t)
        }, i.themes = {dark: t.Internal.NetChart.Settings.DarkTheme}, i.chartFactoryMethod = null, i
    }(t.Internal.Base.Api);
    t.NetChart = e, t.Internal.Base.Helpers.exportSymbol("NetChart", t.NetChart)
}(ZoomCharts || (ZoomCharts = {}));
var ZoomCharts;
!function (t) {
    var e;
    !function (t) {
        var e;
        !function (e) {
            var i = function (e) {
                function i() {
                    e.apply(this, arguments), this.panel = new t.Base.SettingsLegendPanel("bottom", "left", void 0, 95), this.advanced = new n
                }

                return __extends(i, e), i
            }(t.Base.SettingsLegend);
            e.SettingsLegend = i;
            var n = function (t) {
                function e() {
                    t.apply(this, arguments), this.disabledSeries = {
                        fillColor: "rgba(191,187,185,0.3)",
                        lineColor: "rgba(64,62,62,0.3)",
                        textColor: "rgba(64,62,62,0.3)"
                    }
                }

                return __extends(e, t), e
            }(t.Base.SettingsLegendAdvanced);
            e.SettingsLegendAdvanced = n;
            var s = function (i) {
                function n(t) {
                    i.call(this, t), this.paintOrder = 75, this.updateOrder = 100
                }

                return __extends(n, i), n.prototype.onSceneChange = function (e) {
                    i.prototype.onSceneChange.call(this, e);
                    var n = e.changes;
                    n.settings && (this.updateSettings(n.settingsChanges), t.Base.Helpers.hasProp(n, "settingsChanges._computedSeries") && (this.rebuildItems(), n.bounds = !0))
                }, n.prototype.updateSettings = function (e) {
                    t.Base.Helpers.hasProp(e, "legend.text.fillColor") && (this.baseTextColor = this.settings.text.fillColor)
                }, n.prototype.doAnimations = function () {
                    return this.hoverObject = this.scene.hoverSeriesItem ? this.scene.settings._computedSeries[this.scene.hoverSeriesItem.seriesIndex] : null
                }, n.prototype.paintMarker = function (i, n, s, o, r) {
                    var a = i.context, h = this.settings.marker.size, l = r.data, u = n - h / 2, c = n, p = n + h / 2, d = h / 2.1, f = h / 2, m = 3 * h / 4;
                    a.beginPath();
                    var g = s + h / 2, y = t.Base.Helpers.realClone(l);
                    if (!l.enabled) {
                        var v = this.settings.advanced.disabledSeries;
                        y.style.fillColor = l.style.fillColor ? v.fillColor : null, y.style.lineColor = v.lineColor
                    }
                    if ("line" === y.type) {
                        var S = [[d, f, m]], C = [u, c, p], b = [C, [g - d, g - f, g - m]];
                        y.style.marker.width *= .8;
                        var x = g - f, _ = new e.Renderers.Line([y]);
                        _.paintLines(a, [y], [{segments: b}], [null], S, g), _.paintMarkers(a, y, [c], [f], [x])
                    } else if ("columns" === y.type) {
                        var S = [h, h], w = h / 2, C = [n], L = new e.Renderers.Columns(this.scene, [y]);
                        L.paintStack(a, C, [w], [S], [null], g)
                    } else {
                        var T = new e.Renderers.Candlestick(this.scene, [y]), w = h / 2, M = [[0], [h / 3], [2 * h / 3], [h]], C = [n];
                        T.paintStack(a, C, [w], M, [null], g)
                    }
                }, n.prototype.rebuildItems = function () {
                    for (var t = [], e = this.scene.settings._computedSeries, i = this.settings.advanced.disabledSeries, n = {}, s = 0; s < e.length; s++) {
                        var o = e[s], r = o.enabled ? o.style.fillColor : i.fillColor, a = o.enabled ? this.baseTextColor : i.textColor, h = o.nameLegend || o.name || this.chart.settings.localization.unnamedSeries;
                        if ("candlestick" === o.type) {
                            if (void 0 !== n[o.stack])continue;
                            n[o.stack] = !0
                        }
                        t.push({fillColor: r, textColor: a, label: h, data: o})
                    }
                    return this.setItems(t)
                }, n.prototype.onClick = function (t) {
                    var e, i = this.findItemAt(t.x, t.y);
                    if (i) {
                        for (var n = this.scene.settings._computedSeries, s = 0; s < n.length; s++) {
                            var o = n[s], r = o.type;
                            if (o === i) {
                                if ("candlestick" === r) {
                                    e = o.stack;
                                    break
                                }
                                o.enabled = !o.enabled
                            }
                        }
                        if (e)for (var a = 0; a < n.length; a++) {
                            var o = n[a];
                            o.stack === e && (o.enabled = !o.enabled)
                        }
                        this.chart.events.notifySceneChanges({
                            settings: !0,
                            settingsChanges: {_computedSeries: {}}
                        }), t.preventDefault()
                    }
                }, n
            }(t.Base.Legend);
            e.Legend = s
        }(e = t.LinearChart || (t.LinearChart = {}))
    }(e = t.Internal || (t.Internal = {}))
}(ZoomCharts || (ZoomCharts = {}));
var ZoomCharts;
!function (t) {
    var e;
    !function (t) {
        var e;
        !function (e) {
            var i = function () {
                function t() {
                    this.enabled = !0, this.logScale = !1, this.position = "outside", this.side = "left", this.title = null, this.minValue = null, this.maxValue = null, this.size = null, this.hgrid = null, this.axisLine = !1, this.scaleAdjustmentTolerance = .3, this.scaleAdjustmentAnimationDelay = 200, this.scaleAdjustmentAnimation = "=", this.scaleStep = null, this.scaleMinStep = 0, this.zeroLine = "visible", this.valueFormatterFunction = null, this.style = {
                        title: {
                            fillColor: "#000000",
                            font: "13px Arial",
                            reverseDirection: !1,
                            alignment: "center",
                            margin: 5
                        },
                        tick: {lineColor: "#AAAAAA"},
                        axisLine: {lineColor: "rgba(127,127,127,0.5)", lineWidth: 1},
                        valueLabel: {fillColor: "#000000", font: "11px Arial", margin: 0},
                        labelSpacing: 25,
                        baseLine: {
                            lineColor: "rgba(127,127,127,0.5)",
                            depthColor: "rgba(127,127,127,0.5)",
                            lineWidth: 1,
                            lineDepth: 0
                        },
                        hgrid: {lineColor: "rgba(255,255,255,0.2)"}
                    }, this.thresholds = []
                }

                return t
            }();
            e.SettingsValueAxis = i;
            var n = function () {
                function t() {
                    this.from = -1 / 0, this.to = 1 / 0, this.position = "under", this.style = {
                        fillColor: "rgba(255,133,152,0.2)",
                        lineColor: "rgba(255,0,0,0.5)",
                        lineWidth: 1,
                        lineDash: null
                    }
                }

                return t
            }();
            e.SettingsValueAxisThreshold = n;
            var s = function () {
                function e(e, i) {
                    var n = this;
                    this.locations = [], this.values = [], this.labels = [], this.title = null, this.cachedUnits = [], this.isPrimary = !1, this.options = i, this.events = e.events, this.scene = e.scene, this.isLogScale = this.options.logScale, this.isInside = "inside" === this.options.position, this.panel = new t.Base.ChartPanel, this.panel.packingOrder = 110, this.panel.computeSize = function (t, e, i, s) {
                        return n.computePanelSize(t, e, i, s)
                    }, this.lastMaxValue = 0, this.lastMinValue = 0, this.minValue = 0, this.maxValue = 0, this.scale = 0, this.zeroY = 0, this.logOffset = 1, this.minValueAnimation = null, this.maxValueAnimation = null, this.axisChanged = !1, this.seriesDepth = 0, this.seriesMinValue = null, this.seriesMaxValue = null, this.series = 0, this.createTitle()
                }

                return e.prototype.createTitle = function () {
                    var e = new t.Base.Label;
                    e.text = this.options.title, e.textStyle = this.options.style.title, e.align = this.options.style.title.alignment, e.aspectRatio = 0;
                    var i = "right" === this.options.side, n = this.options.style.title.reverseDirection, s = i ? 90 : -90;
                    e.angle = n ? -s : s, this.title = e
                }, e.prototype.getPanel = function () {
                    return this.options.enabled ? (this.panel.location = this.options.position, this.panel.side = this.options.side, this.panel) : null
                }, e.prototype.setPanel = function (t) {
                    this.panel = t
                }, e.prototype.computePanelSize = function (e, i, n, s) {
                    var o = 0;
                    return this.title && (this.title.maxWidth = i, s.measure(n, this.title, this.title), o += 2 * (this.options.style.title.margin + this.title.hheight)), this.options.size ? o = this.options.size : (t.Base.Graphics.textStyle(n, this.options.style.valueLabel), o += 2 * this.options.style.valueLabel.margin + n.measureText("1999.9 M").width), {
                        width: Math.round(o),
                        height: i
                    }
                }, e.prototype.recieveSeriesGeometry = function (t, e, i) {
                    return null !== this.options.minValue ? this.seriesMinValue = this.options.minValue : void 0 !== t && (this.seriesMinValue = null !== this.seriesMinValue ? Math.min(t, this.seriesMinValue) : t), null !== this.options.maxValue ? this.seriesMaxValue = this.options.maxValue : void 0 !== e && (this.seriesMaxValue = null !== this.seriesMaxValue ? Math.max(e, this.seriesMaxValue) : e), this.seriesDepth = Math.max(i, this.seriesDepth)
                }, e.prototype.updateMinMax = function (e) {
                    var i = e.changes && e.changes.bounds || 0 === this.locations.length;
                    e.changes.settings && (this.isLogScale = this.options.logScale, this.isInside = "inside" === this.options.position, i = !0), this.shouldChangeScale() && (this.seriesMinValue !== this.lastMinValue && (i = !0, null === this.lastMinValue || e.changes.displayUnit || this.minValue === this.maxValue ? this.minValueAnimation = null : this.minValueAnimation ? this.minValueAnimation.retarget(this.seriesMinValue, e.timeStamp) : this.minValueAnimation = new t.Base.Animator(this.lastMinValue, this.seriesMinValue, this.options.scaleAdjustmentAnimationDelay, this.options.scaleAdjustmentAnimation, e.timeStamp), this.lastMinValue = this.seriesMinValue), this.seriesMaxValue !== this.lastMaxValue && (i = !0, null === this.lastMaxValue || e.changes.displayUnit || this.minValue === this.maxValue ? this.maxValueAnimation = null : this.maxValueAnimation ? this.maxValueAnimation.retarget(this.seriesMaxValue, e.timeStamp) : this.maxValueAnimation = new t.Base.Animator(this.lastMaxValue, this.seriesMaxValue, this.options.scaleAdjustmentAnimationDelay, this.options.scaleAdjustmentAnimation, e.timeStamp), this.lastMaxValue = this.seriesMaxValue)), this.seriesMaxValue = this.options.minValue, this.seriesMinValue = this.options.maxValue;
                    var n, s;
                    return this.minValueAnimation ? (i = !0, n = this.minValueAnimation.get(e.timeStamp), this.minValueAnimation.finished(e.timeStamp) && (this.minValueAnimation = null)) : n = this.lastMinValue, this.maxValueAnimation ? (i = !0, s = this.maxValueAnimation.get(e.timeStamp), this.maxValueAnimation.finished(e.timeStamp) && (this.maxValueAnimation = null)) : s = this.lastMaxValue, this.axisChanged = i, i && this.computeNewScale(n, s), this.minValueAnimation || this.maxValueAnimation ? e.animating = !0 : void 0
                }, e.prototype.doAnimations = function () {
                    if (this.axisChanged && (this.axisChanged = !1, this.options.enabled)) {
                        this.locations = [], this.values = [];
                        var e = parseInt(this.options.style.valueLabel.font, 10) / 2 * 1.5;
                        isNaN(e) && (e = 0);
                        var i, n = "right" === this.options.side, s = this.scene.y0, o = s + this.scene.height;
                        if (this.scale <= 0) {
                            i = this.options.scaleStep ? this.options.scaleStep : 100;
                            var r = this.options.style.labelSpacing, a = o - r, h = 1;
                            for (this.options.logScale || (h = i); a > s;)this.locations.push(a), this.values.push(h), this.options.logScale ? h *= 10 : h += i, a -= r
                        } else {
                            if (this.isLogScale) {
                                for (var l = this.calcExpValuePerLine(), u = l.unit, c = l.valueMultiplier, p = 1 / u; ;) {
                                    p *= c;
                                    var d = this.zeroY - this.valueToRelativeY(p);
                                    if (s > d - e)break;
                                    d >= this.scene.height || (this.locations.push((0 | d) - .5), this.values.push(p))
                                }
                                for (p = -1 / u; ;) {
                                    p *= c;
                                    var d = this.zeroY - this.valueToRelativeY(p);
                                    if (d >= o)break;
                                    this.locations.push((0 | d) - .5), this.values.push(p)
                                }
                            } else {
                                i = this.calcLinearValuePerLine();
                                for (var p = 0; ;) {
                                    p += i;
                                    var d = this.zeroY - this.valueToRelativeY(p);
                                    if (s >= d - e)break;
                                    d >= this.scene.height || (this.locations.push(0 | d), this.values.push(p))
                                }
                                for (p = 0; ;) {
                                    p -= i;
                                    var d = this.zeroY - this.valueToRelativeY(p);
                                    if (d >= o)break;
                                    this.locations.push(0 | d), this.values.push(p)
                                }
                            }
                            this.minValue < 0 && this.maxValue > 0 && (this.locations.push(0 | this.zeroY), this.values.push(0))
                        }
                        var f, m, g, y = this.options.valueFormatterFunction;
                        if (!this.isLogScale) {
                            var v = this.getUnitAndName(i, this.scene.settings);
                            f = v.unit, m = v.digitsAfterComma, g = v.name
                        }
                        for (var S = 0; S < this.values.length; S++) {
                            var p = this.values[S];
                            if (this.isLogScale) {
                                var v = this.getUnitAndName(p, this.scene.settings);
                                f = v.unit, m = v.digitsAfterComma, g = v.name
                            }
                            var C = (p / f).toFixed(m);
                            "" !== f && p && (C = C + " " + g), y && (C = y(p, g, f, C));
                            var b = new t.Base.Label;
                            b.text = C.toString(), b.aspectRatio = 0, b.textStyle = this.options.style.valueLabel, this.isInside || (b.align = n ? "start" : "end"), this.labels[S] = b
                        }
                    }
                }, e.prototype.paintUnder = function (t) {
                    var e = this.options;
                    if (e.thresholds && e.thresholds.length)for (var i = 0; i < e.thresholds.length; i++) {
                        var n = e.thresholds[i];
                        "under" === n.position && this.paintThreshold(t.context, n)
                    }
                }, e.prototype.paint = function (e) {
                    var i = e.context, n = this.options;
                    if (n.thresholds && n.thresholds.length)for (var s = 0; s < n.thresholds.length; s++) {
                        var o = n.thresholds[s];
                        "above" === o.position && this.paintThreshold(i, o)
                    }
                    if (n.enabled && this.locations.length > 0 && (this.paintGrid(i), this.paintZeroLine(e.context), this.paintLabels(i, e.labelRenderer)), this.options.enabled && this.options.axisLine) {
                        var r = t.Base.Graphics.beginStrokeAndFill(i, this.options.style.axisLine);
                        this.paintAxisLine(r), t.Base.Graphics.endStrokeAndFill(i, r, this.options.style.axisLine)
                    }
                }, e.prototype.shouldChangeScale = function () {
                    var t = this.seriesMinValue, e = this.seriesMaxValue;
                    if (null === t || null === e)return !1;
                    if (null === this.lastMinValue || null === this.lastMaxValue || !(this.lastMinValue < this.lastMaxValue))return !0;
                    if ("center" === this.options.zeroLine ? (e = Math.max(e, -t), t = -e) : "visible" === this.options.zeroLine && (t = Math.min(t, 0), e = Math.max(e, 0)), t < this.minValue || e > this.maxValue)return !0;
                    var i = (this.lastMaxValue - this.lastMinValue) * this.options.scaleAdjustmentTolerance;
                    return t > this.lastMinValue + i || e < this.lastMaxValue - i ? !0 : !1
                }, e.prototype.computeNewScale = function (e, i) {
                    var n = this.scene.height, s = this.scene.y0;
                    if ("center" === this.options.zeroLine ? (i = Math.max(i, -e), e = -i) : "visible" === this.options.zeroLine && (e = Math.min(e, 0), i = Math.max(i, 0)), null !== this.options.minValue && (e = this.options.minValue), null !== this.options.maxValue && (i = this.options.maxValue), !(n > 0 && i > e))return this.minValue = 0, this.maxValue = 0, this.logOffset = 1, this.scale = 0, void(this.zeroY = s + n);
                    var o = 0;
                    this.options.scaleStep > 0 ? o = this.options.scaleStep : this.options.scaleMinStep > 0 && (o = this.options.scaleMinStep), o > 0 && (0 > e && (e = Math.floor(e / o) * o), i > 0 && (i = Math.ceil(i / o) * o));
                    var r = i - e;
                    if (0 !== e && -100 !== e)if (this.isLogScale) e = t.Base.Helpers.sign(e) * Math.pow(Math.abs(e), 1 - t.Base.Helpers.sign(e) * this.options.scaleAdjustmentTolerance); else {
                        var a = e - r * this.options.scaleAdjustmentTolerance;
                        e > 0 ? e = Math.max(0, a) : 0 > e && (e = Math.min(0, a))
                    }
                    if (0 !== i && 100 !== i)if (this.isLogScale) i = t.Base.Helpers.sign(i) * Math.pow(Math.abs(i), 1 + t.Base.Helpers.sign(i) * this.options.scaleAdjustmentTolerance); else {
                        var h = i + r * this.options.scaleAdjustmentTolerance;
                        i > 0 ? i = Math.max(0, h) : 0 > i && (i = Math.min(0, h))
                    }
                    null !== this.options.minValue && (e = this.options.minValue), null !== this.options.maxValue && (i = this.options.maxValue), this.minValue = e, this.maxValue = i;
                    var l;
                    this.isLogScale ? 0 >= e && i >= 0 ? (this.logOffset = 1, l = Math.log(i + this.logOffset) + Math.log(-e + this.logOffset)) : 0 > e ? (this.logOffset = 1 - e, l = Math.log(-e + this.logOffset)) : i > 0 && (this.logOffset = 1 + i, l = Math.log(i + this.logOffset)) : l = i - e, this.scale = Math.min(n, n / l);
                    var u = this.valueToRelativeY(e);
                    this.zeroY = s + n + u
                }, e.prototype.valueToRelativeY = function (t) {
                    return this.isLogScale ? t > 0 ? this.scale * Math.log(t + this.logOffset) : 0 > t ? -this.scale * Math.log(-t + this.logOffset) : 0 : this.scale * t
                }, e.prototype.calcLinearValuePerLine = function () {
                    if (this.options.scaleStep)return this.options.scaleStep;
                    var t = this.options.style.labelSpacing / this.scale, e = Math.log(t) / Math.log(10), i = Math.pow(10, Math.floor(e - 1));
                    for (i = Math.max(i, this.options.scaleMinStep); t > i;) {
                        if (2 * i >= t)return 2 * i;
                        if (i > 10 && 2.5 * i >= t)return 2.5 * i;
                        if (5 * i >= t)return 5 * i;
                        i *= 10
                    }
                    return i
                }, e.prototype.calcExpValuePerLine = function () {
                    var t = this.valueToRelativeY(10) - this.valueToRelativeY(1), e = 10, i = 10, n = t;
                    if (n > 4 * this.options.style.labelSpacing)return {
                        unit: 2,
                        valueMultiplier: 2
                    };
                    for (; n < this.options.style.labelSpacing;)e *= 10, n += t;
                    return {unit: i, valueMultiplier: e}
                }, e.prototype.getUnitAndName = function (t, e) {
                    t = Math.abs(t);
                    var i = this.isLogScale ? "log" : "lin";
                    "undefined" == typeof this.cachedUnits[i] && (this.cachedUnits[i] = []);
                    var n = 1, s = "";
                    if (this.cachedUnits[i][t])return this.cachedUnits[i][t];
                    for (var o in e.localization.valueUnits) {
                        var r = e.localization.valueUnits[o], a = Math.abs(t / r);
                        if ("lin" === i) {
                            if (1e3 > a && a >= 1) {
                                n = r, s = o;
                                break
                            }
                        } else"log" === i && t === Math.round(t / r) * r && r > n && (n = r, s = o)
                    }
                    var h = 0;
                    if (t > 0)for (var l = 1; l > t;)h += 1, l /= 10;
                    return this.cachedUnits[i][t] = {
                        unit: n,
                        digitsAfterComma: h,
                        name: s
                    }, {unit: n, digitsAfterComma: h, name: s}
                }, e.prototype.paintGrid = function (e) {
                    if (this.options.hgrid !== !1 && (null != this.options.hgrid || this.isPrimary)) {
                        var i = this.options.style.hgrid.lineColor;
                        this.options.style.hgrid.lineWidth = 1, t.Base.Graphics.clearShadow(e);
                        for (var n = t.Base.Graphics.beginStrokeAndFill(e, this.options.style.hgrid), s = this.scene.x0, o = this.scene.x0 + this.scene.width, r = 0; r < this.locations.length; r++) {
                            var a = this.locations[r];
                            0 !== this.values[r] && (n.moveTo(s, a + .5), n.lineTo(o, a + .5))
                        }
                        t.Base.Graphics.endStrokeAndFill(e, n, this.options.style.hgrid);
                        var h = t.Base.Graphics.colorTone(i, .5, .5);
                        if (h.opacity < .3) {
                            this.options.style.hgrid.lineColor = h.color, n = t.Base.Graphics.beginStrokeAndFill(e, this.options.style.hgrid);
                            for (var r = 0; r < this.locations.length; r++) {
                                var a = this.locations[r];
                                0 !== this.values[r] && (n.moveTo(s, a - .5), n.lineTo(o, a - .5))
                            }
                            t.Base.Graphics.endStrokeAndFill(e, n, this.options.style.hgrid), this.options.style.hgrid.lineColor = i
                        }
                    }
                }, e.prototype.paintAxisLine = function (t) {
                    var e, i = this.options.side, n = this.panel.left, s = this.panel.right, o = this.scene.y0 + this.scene.height;
                    this.isInside ? ("right" === i && (e = n), "left" === i && (e = s)) : e = "right" === i ? n - .5 : s + .5, t.moveTo(e, this.scene.y0), t.lineTo(e, o)
                }, e.prototype.paintZeroLine = function (e) {
                    if (!(this.zeroY > this.scene.height)) {
                        var i, n = Math.max(this.options.style.baseLine.lineDepth, this.seriesDepth), s = this.scene.x0, o = this.scene.x0 + this.scene.width, r = Math.round(this.zeroY) - .5 * (this.options.style.baseLine.lineWidth || 1);
                        n > 0 ? (i = t.Base.Graphics.beginStroke(e, this.options.style.baseLine), i.moveTo(s, r), i.lineTo(s + n, r - n), i.lineTo(o, r - n), i.lineTo(o, r), i.closePath(), e.fillStyle = this.options.style.baseLine.depthColor, e.fill(), t.Base.Graphics.endStroke(e, i, this.options.style.baseLine)) : (i = t.Base.Graphics.beginStroke(e, this.options.style.baseLine), i.moveTo(s, r), i.lineTo(o, r), t.Base.Graphics.endStroke(e, i, this.options.style.baseLine))
                    }
                }, e.prototype.paintThreshold = function (e, i) {
                    if (0 !== this.scale) {
                        var n = this.scene.x0, s = this.scene.x0 + this.scene.width, o = this.scene.y0, r = o + this.scene.height, a = this.zeroY - this.valueToRelativeY(i.from), h = this.zeroY - this.valueToRelativeY(i.to);
                        a = a >= r - .5 ? (0 | r) + .5 : (this.zeroY - this.valueToRelativeY(i.from) | 0) - .5, h = o - .5 >= h ? (0 | o) + .5 : (this.zeroY - this.valueToRelativeY(i.to) | 0) - .5, i.style.fillColor && (e.fillStyle = i.style.fillColor, e.beginPath(), e.rect(n, h, this.scene.width, a - h), e.fill(), e.closePath());
                        var l = t.Base.Graphics.beginStroke(e, i.style);
                        a - .5 !== r && (l.moveTo(n, a), l.lineTo(s, a)), h - .5 !== o && (l.moveTo(n, h), l.lineTo(s, h)), t.Base.Graphics.endStroke(e, l, i.style)
                    }
                }, e.prototype.paintLabels = function (e, i) {
                    var n = this.panel.left, s = this.panel.right, o = "right" === this.options.side;
                    if (this.options.title && this.title) {
                        var r, a = this.scene.y0, h = this.scene.height, l = this.title.hheight, u = this.options.style.title.margin, c = a + .5 * h;
                        o ? (r = s - u - l, s -= l + 2 * u) : (r = n + u + l, n += l + 2 * u), i.paintWithStyle(e, r, c, 1, this.title, this.title)
                    }
                    var p, d = (n + s) / 2;
                    if (p = o ? n : s - 4, !this.isInside) {
                        e.beginPath();
                        for (var f = 0; f < this.locations.length; f++) {
                            var m = this.locations[f];
                            e.moveTo(p, m), e.lineTo(p + 4, m)
                        }
                        t.Base.Graphics.stroke(e, this.options.style.tick)
                    }
                    for (var g = 0; g < this.locations.length; g++) {
                        var y = this.locations[g], v = this.labels[g], S = void 0;
                        i.measure(e, v), S = this.isInside ? d : o ? p + v.hwidth + 7 : p - v.hwidth - 3, i.paintWithStyle(e, S, y, 1, v, v)
                    }
                }, e
            }();
            e.ValueAxis = s
        }(e = t.LinearChart || (t.LinearChart = {}))
    }(e = t.Internal || (t.Internal = {}))
}(ZoomCharts || (ZoomCharts = {}));
var ZoomCharts;
!function (t) {
    var e;
    !function (t) {
        var e;
        !function (e) {
            var i;
            !function (e) {
                var i = function () {
                    function e(t, e) {
                        this.series = e, this.scene = t, this.prevy = []
                    }

                    return e.prototype.paintStack = function (t, e, i, n, s, o) {
                        if (this.zeroY = o, e.length > 0) {
                            var r = this.series, a = this.prevy;
                            a.length < e.length && (a = this.prevy = new Array(e.length));
                            for (var h = 0; h <= e.length - 1; h++)a[h] = o;
                            for (var l = i[0] + i[i.length - 1], u = 0; u < r.length; u++) {
                                var c = r[u], p = s[u];
                                l >= 2 || p ? this.plainColumns(t, c.style, e, i, a, n, p, u) : this.outline(t, c.style, e, i, a, n[u])
                            }
                        }
                    }, e.prototype.hitTest = function (e, i, n, s, o, r, a) {
                        var h = e.length;
                        if (!(h > 1))return {result: null, distance: 1 / 0};
                        var l = this.series, u = t.Base.Helpers.binSearch(e, r), c = e[u] - i[u], p = e[u] + i[u];
                        if (c > r && u > 0) {
                            var d = e[u - 1] - i[u - 1], f = e[u - 1] + i[u - 1];
                            (f > r || Math.abs(f - r) < Math.abs(c - r)) && (u -= 1, c = d, p = f)
                        }
                        for (var m = null, g = 1 / 0, y = o, v = 0; v < l.length; v++) {
                            var S = n[v][u];
                            if (t.Base.Helpers.isNumber(S)) {
                                var C = y - S, b = Math.min(y, C), x = Math.max(y, C), _ = t.Base.Geometry.distanceToRect(r, a, c, b, p, x);
                                g > _ && (g = _, m = {
                                    x0: c,
                                    y0: b,
                                    x1: p,
                                    y1: x,
                                    seriesIndex: v,
                                    isMarker: !1
                                }), y = C
                            }
                        }
                        return {result: m, distance: g}
                    }, e.prototype.outline = function (t, e, i, n, s, o) {
                        var r = i.length;
                        if (r > 1) {
                            t.fillStyle = e.strokeStyle ? e.lineColor : e.fillColor;
                            for (var a = this.zeroY, h = 0; r - 1 >= h; h++) {
                                var l = i[h] - n[h], u = i[h] + n[h], c = o[h];
                                if (null !== c) {
                                    var p = s[h];
                                    c = a - c, t.fillRect(l, p, u - l + .5, c - p), s[h] = c
                                }
                            }
                        }
                    }, e.prototype.plainColumns = function (e, i, n, s, o, r, a, h) {
                        for (var l, u = this.scene.y0, c = this.scene.height, p = i.minHeight, d = u + c, f = r[h], m = null, g = i.depth, y = i.shadowColor, v = null, S = 0, C = 0; C < n.length; C++) {
                            var b = n[C], x = f[C];
                            if (t.Base.Helpers.isNumber(x)) {
                                var _ = s[C], w = o[C], L = w - x;
                                o[C] = L;
                                var T = b - _, M = _ + _, P = void 0, k = void 0, D = void 0;
                                if (L > w) {
                                    P = Math.max(L - w, p), k = w;
                                    for (var I = !0, A = h - 1; A > 0;) {
                                        if (null !== r[A][C]) {
                                            I = !1;
                                            break
                                        }
                                        A--
                                    }
                                    D = I
                                } else {
                                    if (!(w > L))continue;
                                    P = Math.max(w - L, p), k = w - P;
                                    for (var B = !0, A = h + 1; A < r.length;) {
                                        if (null !== r[A][C]) {
                                            B = !1;
                                            break
                                        }
                                        A++
                                    }
                                    D = B
                                }
                                var E = a ? a[C] : i;
                                if (E || (E = i), m !== E && (m = E, m.lineColor && (S = m.lineWidth), m._currentFillGradient ? l = m._currentFillGradient : (l = m.fillColor, m.gradient && 1 !== m.gradient && l && (l = e.createLinearGradient(0, d, 0, d - 2 * c / 3), l.addColorStop(0, t.Base.Graphics.deriveColor(m.fillColor, m.gradient, 1)), l.addColorStop(1, m.fillColor))), e.fillStyle = l, m.fillColor && g && (v = m.fillColor, t.Base.Helpers.isNumber(m.depthBrightness) && (v = t.Base.Graphics.deriveColor(v, m.depthBrightness, 1)))), v && (e.beginPath(), t.Base.Graphics.applyShadow(e, m), D ? (e.moveTo(T + g, k - g), e.lineTo(T + M + g, k - g), e.lineTo(T + M + g, k + P - g), e.lineTo(T + M, k + P), e.lineTo(T + M, k), e.lineTo(T, k)) : (e.moveTo(T + M, k), e.lineTo(T + M + g, k - g), e.lineTo(T + M + g, k + P - g), e.lineTo(T + M, k + P), e.lineTo(T + M, k)), e.closePath(), e.fillStyle = v, e.fill(), t.Base.Graphics.clearShadow(e), e.fillStyle = l), !v && y && t.Base.Graphics.applyShadow(e, m), l && (e.fillRect(T, k, M, P), !v && y && t.Base.Graphics.clearShadow(e)), S > 0) {
                                    k += S / 2, T += S / 2, M -= S, P -= S;
                                    var O = t.Base.Graphics.beginStroke(e, m);
                                    M > 0 ? P > 0 ? (O.moveTo(T, k), O.lineTo(T + M, k), O.lineTo(T + M, k + P), O.lineTo(T, k + P), O.lineTo(T, k)) : S > 0 && (e.moveTo(T, w), e.lineTo(T + M, w)) : S > 0 && (e.moveTo(b, k), e.lineTo(b, k + P)), t.Base.Graphics.endStroke(e, O, m)
                                }
                                if (l || v || !y || t.Base.Graphics.clearShadow(e), m.previewData) {
                                    e.beginPath();
                                    for (var F = 0, N = L - w, z = 0; z < m.previewData.length; z++) {
                                        var R = m.previewData[z];
                                        F += R, x = w + F * N, e.moveTo(T, x), e.lineTo(T + M, x)
                                    }
                                    e.lineWidth = 1, e.strokeStyle = m.previewLineColor, e.stroke()
                                }
                            }
                        }
                    }, e
                }();
                e.Columns = i
            }(i = e.Renderers || (e.Renderers = {}))
        }(e = t.LinearChart || (t.LinearChart = {}))
    }(e = t.Internal || (t.Internal = {}))
}(ZoomCharts || (ZoomCharts = {}));
var ZoomCharts;
!function (t) {
    var e;
    !function (t) {
        var e;
        !function (t) {
            var e = function () {
                function t(t, e, i, n) {
                    void 0 === i && (i = 0), void 0 === n && (n = t.length), null == n && (n = t.length), null == i && (i = 0), this.n0 = i;
                    var s = [];
                    s.length = n - i;
                    var o = 0;
                    s[n - i - 1] = (e[n - 1] - e[n - 2]) / (t[n - 1] - t[n - 2]);
                    var r, a = (e[i + 1] - e[i]) / (t[i + 1] - t[i]);
                    for (r = i + 1; n - 1 > r; r++) {
                        var h = (e[r + 1] - e[r]) / (t[r + 1] - t[r]), l = void 0;
                        if (0 === a) l = o = 0; else {
                            l = (a + h) / 2;
                            var u = (o * o + l * l) / (a * a);
                            if (u > 9) {
                                var c = 3 / Math.sqrt(u);
                                o = c * o, l = c * l
                            }
                        }
                        s[r - i - 1] = o, o = l, a = h
                    }
                    s[r - i - 1] = o, this.x = t, this.y = e, this.m = s
                }

                return t.prototype.interpolate = function (t, e) {
                    var i = this.x[t + 1] - this.x[t], n = (e - this.x[t]) / i, s = n * n, o = s * n, r = 2 * o - 3 * s + 1, a = o - 2 * s + n, h = -2 * o + 3 * s, l = o - s, u = r * this.y[t] + a * i * this.m[t - this.n0] + h * this.y[t + 1] + l * i * this.m[t - this.n0 + 1];
                    return u
                }, t.prototype.interpolateArray = function (t, e, i, n, s) {
                    for (var o = this.x[t], r = this.y[t], a = this.m[t - this.n0], h = this.y[t + 1], l = this.m[t - this.n0 + 1], u = this.x[t + 1] - o, c = 1 / u, p = i; n > p; p++) {
                        var d = (e[p] - o) * c, f = d * d, m = f * d, g = 2 * m - 3 * f + 1, y = m - 2 * f + d, v = -2 * m + 3 * f, S = m - f, C = g * r + y * u * a + v * h + S * u * l;
                        s.push(C)
                    }
                }, t.prototype.clear = function () {
                    this.m.length = 0
                }, t
            }();
            t.MonotoneCurve = e
        }(e = t.Base || (t.Base = {}))
    }(e = t.Internal || (t.Internal = {}))
}(ZoomCharts || (ZoomCharts = {}));
var ZoomCharts;
!function (t) {
    var e;
    !function (t) {
        var e;
        !function (e) {
            var i;
            !function (e) {
                var i = function () {
                    function e(t) {
                        this.series = t, this.centers = [], this.seriesData = [];
                        for (var e = 0; e < t.length; e++)this.seriesData.push({
                            markerY: [],
                            segments: []
                        });
                        this.prevyL = [], this.prevyR = []
                    }

                    return e.prototype.paintStack = function (t, e, i, n, s, o) {
                        if (this.zeroY = o, this.styles = s, this.centers = e, e.length > 0) {
                            this.paintLines(t, this.series, this.seriesData, i, n, o);
                            for (var r = 0; r < this.series.length; r++) {
                                var a = this.series[r];
                                this.paintMarkers(t, a, this.centers, n[r], this.seriesData[r].markerY)
                            }
                        }
                    }, e.prototype.paintLines = function (t, e, i, n, s, o) {
                        this.zeroY = o, this.computeLineSegments(n, this.zeroY, s);
                        for (var r = [], a = 0; a < e.length; a++) {
                            var h = e[a];
                            this.paintLine(t, h.style, r, i[a].segments), r = this.seriesData[a].segments
                        }
                    }, e.prototype.paintMarkers = function (e, i, n, s, o) {
                        if (i.style.marker && i.style.marker.shape && i.style.marker.width) {
                            var r = i.style.marker, a = r.fillColor;
                            a || (a = i.style.lineColor), a || (a = i.style.fillColor), e.fillStyle = a;
                            for (var h = r.width / 2, l = r.shape, u = 0; u < s.length; u++) {
                                var c = s[u];
                                null !== c && (e.beginPath(), t.Base.Graphics.strokeMarker(e, l, n[u], o[u], h), e.fill())
                            }
                        }
                    }, e.prototype.hitTest = function (e, i, n, s, o, r, a, h) {
                        var l = this.series;
                        e = this.centers;
                        var u = e.length;
                        if (!(u > 0))return {result: null, distance: 1 / 0};
                        for (var c = Math.min(t.Base.Helpers.binSearch(e, r), u - 2), p = null, d = 1 / 0, f = o - a, m = 0; m < l.length; m++) {
                            for (var g = l[m], y = g.style, v = this.seriesData[m], S = Math.max(0, c - 2); S < Math.min(u, c + 3); S++) {
                                var C = n[m][S];
                                if (null !== C && y.marker) {
                                    var b = e[S], x = v.markerY[S], _ = y.marker.width / 2, w = r - b, L = a - x, T = Math.sqrt(w * w + L * L);
                                    _ + h > T && d > T - _ && (d = T - _, p = {
                                        x0: b,
                                        y0: x,
                                        x1: b,
                                        y1: x,
                                        seriesIndex: m,
                                        isMarker: !0
                                    })
                                }
                            }
                            for (var M = null, P = v.segments, S = 0; S < P.length; S += 2)for (var k = P[S], D = P[S + 1], I = k[0], A = 1; A < k.length; A++) {
                                var B = k[A];
                                if (r + h >= I && B >= r - h) {
                                    var E = D[A - 1], O = D[A], F = Math.sqrt(t.Base.Geometry.distanceToSegmentSq(I, E, B, O, r, a));
                                    h > F && d >= F && (d = F, p = {
                                        x0: I,
                                        y0: E,
                                        x1: B,
                                        y1: O,
                                        seriesIndex: m,
                                        isMarker: !1
                                    })
                                }
                                if (r >= I && B >= r) {
                                    var E = D[A - 1], O = D[A], N = t.Base.Geometry.lineIntersectsSegment(r, a, 0, 1, I, E, B, O);
                                    1 / 0 !== N && (M = N)
                                }
                                I = B
                            }
                            null !== M && (t.Base.Helpers.sign(M) !== t.Base.Helpers.sign(f) && (y.fillColor || y.fillGradient) && d >= 0 && (d = 0, p = {
                                x0: 0,
                                y0: 0,
                                x1: 1,
                                y1: 1,
                                seriesIndex: m,
                                isMarker: !1
                            }), f = M)
                        }
                        return {result: p, distance: Math.max(d, 0)}
                    }, e.prototype.computeLineSegments = function (t, e, i) {
                        var n = this.centers.length, s = this.prevyL, o = this.prevyR;
                        s.length < n && (s.length = n, o.length = n);
                        for (var r = 0; n > r; r++)s[r] = e, o[r] = e;
                        for (var a = s, h = 0; h < this.series.length; h++) {
                            var l = this.series[h], u = this.seriesData[h];
                            if (u.segments.length = 0, u.markerY.length < n && (u.markerY.length = n), l.style.steps) {
                                var c = this.buildStepSegments(this.centers, t, e, s, o, a, i[h], l.data.noDataPolicy);
                                u.segments = c.segments, u.markerY = c.markerY
                            } else {
                                var p = this.buildLineSegments(this.centers, e, s, o, a, i[h], l.data.noDataPolicy);
                                if (u.segments = p.segments, u.markerY = p.markerY, l.style.smoothing)for (var d = 0; d < u.segments.length; d += 2) {
                                    var f = this.smoothLine(u.segments[d], u.segments[d + 1]);
                                    u.segments[d] = f.x, u.segments[d + 1] = f.y
                                }
                            }
                            a = u.markerY
                        }
                    }, e.prototype.buildLineSegments = function (t, e, i, n, s, o, r) {
                        var a = [], h = [], l = [];
                        if ("zero" === r) {
                            for (var u = 0; u < t.length; u++) {
                                var c = t[u], p = o[u], d = i[u], f = n[u];
                                null !== p ? (a.push(s[u] - p), h.push(c), l.push(d - p), d !== f && (h.push(c), l.push(f - p)), i[u] -= p, n[u] -= p) : (a.push(s[u]), d !== f ? (l.push(d), l.push(f), h.push(c), h.push(c)) : (l.push(d), h.push(c)))
                            }
                            return {segments: [h, l], markerY: a}
                        }
                        if ("join" === r) {
                            for (var m = null, u = 0; u < t.length; u++) {
                                var c = t[u], p = o[u], d = i[u], f = n[u];
                                if (null !== p) {
                                    if (null === m) a.push(s[u] - p), h.push(c), l.push(f - p), n[u] -= p; else {
                                        if (u - 1 > m)for (var g = o[m], y = t[m], v = (p - g) / (c - y), S = m + 1; u > S; S++) {
                                            var C = t[S], b = g + v * (C - y);
                                            a.push(s[S] - b);
                                            var x = i[S], _ = n[S];
                                            h.push(C), l.push(x - b), x !== _ && (h.push(C), l.push(_ - b)), i[S] -= b, n[S] -= b
                                        }
                                        a.push(s[u] - p), h.push(c), l.push(d - p), d !== f && (h.push(c), l.push(f - p)), i[u] -= p, n[u] -= p
                                    }
                                    m = u
                                } else null === m && a.push(s[u])
                            }
                            return h.length > 2 && h[h.length - 1] === h[h.length - 2] && (h.pop(), l.pop()), {
                                segments: [h, l],
                                markerY: a
                            }
                        }
                        for (var w = !1, L = [], u = 0; u < t.length; u++) {
                            var c = t[u], p = o[u], d = i[u], f = n[u];
                            null !== p ? (a.push(s[u] - p), w ? (h.length > 1 && i[u - 1] !== n[u - 1] && (h.push(t[u - 1]), l.push(n[u - 1])), h.push(c), l.push(d - p), i[u] -= p, n[u] -= p) : (h.push(c), l.push(f - p), n[u] -= p), w = !0) : (a.push(s[u]), w && (h.length > 0 && (1 === h.length && (h.push(h[0]), l.push(l[0])), L.push(h, l), h = [], l = []), n[u - 1] += o[u - 1]), w = !1)
                        }
                        return h.length > 0 && (1 === h.length && (h.push(h[0]), l.push(l[0])), L.push(h, l)), {
                            segments: L,
                            markerY: a
                        }
                    }, e.prototype.buildStepSegments = function (t, e, i, n, s, o, r, a) {
                        for (var h = [], l = [], u = [], c = [], p = null, d = 0, f = 0; f < t.length; f++) {
                            var m = t[f] - e[f], g = r[f];
                            if (null !== g) {
                                null !== p && (u.push(m), c.push(p));
                                var y = o[f] - g;
                                u.push(m), c.push(y), p = y, d = m + 2 * e[f], l.push(y), n[f] = s[f] = y
                            } else if ("zero" === a) {
                                var y = o[f];
                                l.push(y), s[f] = n[f] = y, null !== p && (u.push(d), c.push(p)), u.push(m), c.push(y), p = y, d = m + 2 * e[f]
                            } else if ("join" === a) {
                                var y = null !== p ? p : o[f];
                                l.push(y), s[f] = n[f] = y
                            } else {
                                var y = o[f];
                                l.push(y), s[f] = n[f] = y, u.length > 0 && (null !== p && (u.push(d), c.push(p)), p = null, h.push(u, c), u = [], c = [])
                            }
                        }
                        return u.length > 0 && (null !== p && (u.push(d), c.push(p)), h.push(u, c)), {
                            segments: h,
                            markerY: l
                        }
                    }, e.prototype.smoothLine = function (e, i) {
                        var n = e[0], s = e[e.length - 1], o = (s - n) / e.length;
                        if (2 > o)return {x: e, y: i};
                        var r = [], a = [];
                        r.push(n), a.push(i[0]);
                        for (var h = 0; h + 1 < e.length;) {
                            var l = h + 1;
                            if (e[h] !== e[l])for (; l + 1 < e.length && e[l] !== e[l + 1];)l += 1;
                            if (l - h === 1) r.push(e[l]), a.push(i[l]); else {
                                var u = new t.Base.MonotoneCurve(e, i, h, l + 1);
                                s = e[h];
                                for (var c = h + 1; l >= c; c++) {
                                    n = s, s = e[c];
                                    var p = i[c];
                                    o = s - n;
                                    for (var d = Math.ceil(Math.min(50, Math.max(2, o / 3))), f = o / d, m = r.length; (n += f) < s;)r.push(n);
                                    u.interpolateArray(c - 1, r, m, r.length, a), r.push(s), a.push(p)
                                }
                                u.clear()
                            }
                            h = l
                        }
                        return e.length = 0, i.length = 0, {x: r, y: a}
                    }, e.prototype.paintLine = function (e, i, n, s) {
                        if (i.fillColor || i._currentFillGradient) {
                            i.shadowColor && t.Base.Graphics.applyShadow(e, i), e.fillStyle = i._currentFillGradient ? i._currentFillGradient : i.fillColor, e.beginPath();
                            for (var o = 0; o < s.length; o += 2)this.paintArea(e, s[o], s[o + 1], n);
                            e.fill(), i.shadowColor && t.Base.Graphics.clearShadow(e)
                        }
                        if (i.lineColor) {
                            !i.fillColor && i.shadowColor && t.Base.Graphics.applyShadow(e, i);
                            for (var r = t.Base.Graphics.beginStroke(e, i), o = 0; o < s.length; o += 2) {
                                var a = s[o], h = s[o + 1];
                                r.moveTo(a[0], h[0]);
                                for (var l = 1; l < a.length; l++)r.lineTo(a[l], h[l])
                            }
                            t.Base.Graphics.endStroke(e, r, i), !i.fillColor && i.shadowColor && t.Base.Graphics.clearShadow(e)
                        }
                    }, e.prototype.paintArea = function (t, e, i, n) {
                        t.moveTo(e[0], i[0]);
                        for (var s = 1; s < e.length; s++)t.lineTo(e[s], i[s]);
                        for (var o = e[0], r = e[e.length - 1], a = this.zeroY, h = r, l = n.length - 2; l >= 0; l += -2) {
                            var u = n[l], c = n[l + 1];
                            if (!(u.length < 2 || u[0] > h || u[u.length - 1] < o)) {
                                var p = u.length - 1, d = u[p];
                                h > d && (t.lineTo(h, a), t.lineTo(d, a), h = d);
                                var s = void 0, f = void 0;
                                for (s = p; s >= 0; s--) {
                                    if (f = u[s], h === d) t.lineTo(d, c[s + 1]), h = f; else if (d > h && h > f) {
                                        var m = c[s], g = c[s + 1], y = (h - f) / (d - f), v = m + y * (g - m);
                                        t.lineTo(h, v), h = f
                                    }
                                    if (o >= h) {
                                        h = o;
                                        var m = c[s], g = c[s + 1], y = (h - f) / (d - f), v = m + y * (g - m);
                                        t.lineTo(h, v);
                                        break
                                    }
                                    d = f
                                }
                                -1 === s && h === f && t.lineTo(h, c[0])
                            }
                        }
                        h !== o && (t.lineTo(h, a), t.lineTo(o, a)), t.closePath()
                    }, e
                }();
                e.Line = i
            }(i = e.Renderers || (e.Renderers = {}))
        }(e = t.LinearChart || (t.LinearChart = {}))
    }(e = t.Internal || (t.Internal = {}))
}(ZoomCharts || (ZoomCharts = {}));
var ZoomCharts;
!function (t) {
    var e;
    !function (t) {
        var e;
        !function (e) {
            var i;
            !function (e) {
                var i = function () {
                    function e(t, e) {
                        this.series = e, this.scene = t, this.prevy = []
                    }

                    return e.prototype.paintStack = function (t, e, i, n, s, o) {
                        if (e.length > 0) {
                            var r = this.series[0];
                            this.seriesEnabled = r.enabled;
                            var a = this.prevy;
                            a.length < e.length && (a = this.prevy = new Array(e.length));
                            for (var h = 0; h <= e.length - 1; h++)a[h] = o;
                            this.plainBar(t, r.style, e, i, a, n)
                        }
                    }, e.prototype.hitTest = function (e, i, n, s, o, r, a) {
                        var h = e.length;
                        if (!(h > 1))return {result: null, distance: 1 / 0};
                        var l = this.series, u = t.Base.Helpers.binSearch(e, r), c = e[u] - i[u], p = e[u] + i[u];
                        if (c > r && u > 0) {
                            var d = e[u - 1] - i[u - 1], f = e[u - 1] + i[u - 1];
                            (f > r || Math.abs(f - r) < Math.abs(c - r)) && (u -= 1, c = d, p = f)
                        }
                        for (var m = null, g = 1 / 0, y = o, v = 0; v < l.length; v++) {
                            var S = n[v][u];
                            if (null !== S) {
                                var C = y - S, b = Math.min(y, C), x = Math.max(y, C), _ = t.Base.Geometry.distanceToRect(r, a, c, b, p, x);
                                g > _ && (g = _, m = {
                                    x0: c,
                                    y0: b,
                                    x1: p,
                                    y1: x,
                                    seriesIndex: v,
                                    isMarker: !1
                                }), y = C
                            }
                        }
                        return {result: m, distance: g}
                    }, e.prototype.plainBar = function (e, i, n, s, o, r) {
                        for (var a = 0; a < n.length; a++) {
                            var h = n[a], l = o[a], u = r[0][a], c = r[1][a], p = r[2][a], d = r[3][a];
                            if (void 0 !== d && null !== d || void 0 !== u && null !== u || void 0 !== c && null !== c || void 0 !== p && null !== p) {
                                var f = (h - s[a] || 0) + .5, m = (h + s[a] || 0) + .5, g = (l - d || 0) + .5, y = (l - u || 0) + .5, v = (l - c || 0) + .5, S = (l - p || 0) + .5, C = this.applyPatternStyle(e, i, v, S);
                                if ("bar" === i.pattern) {
                                    var b = t.Base.Graphics.beginStroke(e, C);
                                    b.moveTo(h, y), b.lineTo(h, g), b.moveTo(f, v), b.lineTo(h, v), b.moveTo(m, S), b.lineTo(h, S), t.Base.Graphics.endStroke(e, b, C)
                                } else {
                                    var b = t.Base.Graphics.beginStroke(e, C);
                                    b.moveTo(h, y), b.lineTo(h, v), b.moveTo(h, S), b.lineTo(h, g), t.Base.Graphics.endStroke(e, b, C), b = t.Base.Graphics.beginStroke(e, C, !0), b.moveTo(f, v), b.lineTo(m, v), b.lineTo(m, S), b.lineTo(f, S), b.closePath(), t.Base.Graphics.endStroke(e, b, C, !0)
                                }
                                i.shadowColor && t.Base.Graphics.clearShadow(e)
                            }
                        }
                    }, e.prototype.applyPatternStyle = function (e, i, n, s) {
                        var o = n >= s ? "increase" : "decrease", r = {};
                        if (r = t.Base.Helpers.extendCopy(r, i[o][i.pattern]), !this.seriesEnabled) {
                            var a = this.scene.settings.legend.advanced.disabledSeries;
                            r.lineColor = a.lineColor, void 0 !== r.fillColor && (r.fillColor = a.fillColor)
                        }
                        return i.lineColor && i.shadowColor && t.Base.Graphics.applyShadow(e, i), r
                    }, e
                }();
                e.Candlestick = i
            }(i = e.Renderers || (e.Renderers = {}))
        }(e = t.LinearChart || (t.LinearChart = {}))
    }(e = t.Internal || (t.Internal = {}))
}(ZoomCharts || (ZoomCharts = {}));
var ZoomCharts;
!function (t) {
    var e;
    !function (t) {
        var e;
        !function (e) {
            var i;
            !function (i) {
                var n = function () {
                    function i(t, e, i, n) {
                        this.series = [], this.seriesId = [], this.min = 0, this.max = 0, this.renderingType = null, this.needsAfterProcess = !1, this.paddingLeft = 0, this.paddingRight = 0, this.centers = [], this.radii = [], this.vstack = [], this.countStack = [], this.ystack = [], this.xes = [], this.times = [], this.styles = [], this.calculatedDepth = 0, this.ystackNegative = null, this.va = n, this.options = i, this.cluster = e, this.scene = t, this.va.series++
                    }

                    return i.prototype.addSeries = function (t, e) {
                        this.renderingType || (this.renderingType = e.type), this.series.push(e), this.seriesId.push(t);
                        var i = e;
                        this.calculatedDepth = Math.max(this.calculatedDepth, i.style.depth), "columns" === this.renderingType && (this.paddingLeft = Math.max(this.paddingLeft, i.style.padding[0]), this.paddingRight = Math.max(this.paddingRight, i.style.padding[1]))
                    }, i.prototype.afterInit = function () {
                        "line" === this.renderingType ? this.renderer = new e.Renderers.Line(this.series) : "columns" === this.renderingType ? this.renderer = new e.Renderers.Columns(this.scene, this.series) : "candlestick" === this.renderingType && (this.candleStacks = !0, this.renderer = new e.Renderers.Candlestick(this.scene, this.series))
                    }, i.prototype.process = function (t) {
                        this.processData(t), this.computeMinMax(), this.addLeads(t), this.needsAfterProcess = !0
                    }, i.prototype.afterProcess = function () {
                        return this.needsAfterProcess || this.va.axisChanged ? (this.needsAfterProcess = !1, this.computeY()) : void 0
                    }, i.prototype.paint = function (t) {
                        for (var e = 0; e < this.series.length; e++) {
                            var i = this.series[e], n = i.style;
                            n.fillGradient && (n._currentFillGradient = this.computeFillGradient(t, n.fillGradient))
                        }
                        if (0 !== this.ystack.length)return this.ystackNegative && this.renderer.paintStack(t, this.centers, this.radii, this.ystackNegative, this.styles, this.va.zeroY), this.renderer.paintStack(t, this.centers, this.radii, this.ystack, this.styles, this.va.zeroY)
                    }, i.prototype.hitTestStack = function (e) {
                        var i = t.Base.Helpers.binSearch(this.centers, e), n = this.centers[i] - this.radii[i], s = this.centers[i] + this.radii[i];
                        if (n > e && i > 0) {
                            var o = this.centers[i - 1] - this.radii[i - 1], r = this.centers[i - 1] + this.radii[i - 1];
                            (r > e || Math.abs(r - e) < Math.abs(n - e)) && (i -= 1, n = o, s = r)
                        }
                        return {
                            result: {
                                x0: n,
                                y0: 0,
                                x1: s,
                                y1: 0,
                                series: null,
                                stack: this
                            }, distance: t.Base.Geometry.distanceToRect(e, 0, n, 0, s, 0)
                        }
                    }, i.prototype.hitTest = function (t, e, i) {
                        var n = this.ystackNegative ? this.ystackNegative : this.ystack, s = this.renderer.hitTest(this.centers, this.radii, n, this.styles, this.va.zeroY, t, e, i), o = s.result, r = s.distance;
                        return this.ystackNegative && s.distance < r && (o = s.result), null !== o && (o.seriesIndex = this.seriesId[o.seriesIndex], o.stack = this), {
                            result: o,
                            distance: r
                        }
                    }, i.prototype.computeFillGradient = function (e, i) {
                        for (var n = this.va, s = n.zeroY, o = this.scene.y0, r = this.scene.x0, a = this.scene.height, h = [], l = 0; l < i.length; l++) {
                            var u = i[l], c = s - n.valueToRelativeY(u[0]), p = (c - o) / a;
                            h.push([p, u[1]])
                        }
                        h.sort(function (t, e) {
                            return t[0] - e[0]
                        });
                        for (var d = e.createLinearGradient(r, o, r, o + a), f = null, m = 0; m < h.length; m++) {
                            var g = h[m], y = g[0], v = g[1];
                            if (y > 0) {
                                if (f && f[0] < 0 && d.addColorStop(0, t.Base.Graphics.blendColors(f[1], v, (0 - f[0]) / (y - f[0]))), y > 1) {
                                    f && d.addColorStop(1, t.Base.Graphics.blendColors(f[1], v, (1 - f[0]) / (y - f[0])));
                                    break
                                }
                                d.addColorStop(y, v)
                            }
                            f = g
                        }
                        return d
                    }, i.prototype.processData = function (t) {
                        this.vstack = [], this.countStack = [], this.styles = [];
                        var e = t[this.seriesId[0]];
                        if (0 !== e.times.length) {
                            this.xes = e.xes.slice(e.fromIndex, e.toIndex), this.times = e.times.slice(e.fromIndex, e.toIndex), this.centers = new Array(this.xes.length - 1), this.radii = new Array(this.xes.length - 1), this.cluster.computeStackCenterRadius(this, this.xes, this.centers, this.radii);
                            for (var i = 0; i < this.seriesId.length; i++) {
                                var n = this.seriesId[i];
                                e = t[n], this.vstack.push(e.values.slice(e.fromIndex, e.toIndex - 1)), this.countStack.push(e.counts.slice(e.fromIndex, e.toIndex - 1)), this.styles.push(e.style ? e.style.slice(e.fromIndex, e.toIndex - 1) : null)
                            }
                        }
                    }, i.prototype.addLeads = function (t) {
                        for (var e = 0; e < this.seriesId.length; e++) {
                            var i = this.seriesId[e], n = t[i];
                            n.leadIn && this.injectLead(n.leadIn, e), n.leadOut && this.injectLead(n.leadOut, e)
                        }
                    }, i.prototype.injectLead = function (t, e) {
                        var i = this.series.length, n = t.values[0], s = t.times[0], o = [0], r = [0];
                        this.cluster.computeStackCenterRadius(this, t.xes, o, r);
                        for (var a = o[0], h = r[0], l = 0; l < this.centers.length && this.centers[l] < a;)l++;
                        if (l === this.centers.length || this.centers[l] > a) {
                            this.centers.splice(l, 0, a), this.radii.splice(l, 0, h), this.times.splice(l, 0, s);
                            for (var u = 0; i - 1 >= u; u++)this.vstack[u].splice(l, 0, null), this.countStack[u].splice(l, 0, null), this.styles[u] && this.styles[u].splice(l, 0, null)
                        }
                        this.vstack[e][l] = n, this.countStack[e][l] = t.counts[0]
                    }, i.prototype.getSeparateNegative = function () {
                        var t = this.options.separateNegativeValues;
                        return null === t && (t = "line" !== this.renderingType), t
                    }, i.prototype.computeMinMax = function () {
                        var e = 1 / 0, i = -1 / 0;
                        if (this.vstack.length > 0) {
                            for (var n = this.vstack, s = n[0].length, o = n.length, r = this.options.type, a = this.getSeparateNegative(), h = this.scene.x0, l = h + this.scene.width, u = 0, c = s - 1; s > u && this.centers[u] + this.radii[u] < h;)u += 1;
                            for (; c >= u && this.centers[c] - this.radii[c] > l;)c -= 1;
                            if ("proportional" === r) e = 0, i = 100; else if (this.candleStacks)for (var p = u; c >= p; p++)for (var d = 0; o - 1 >= d; d++) {
                                var f = n[d][p];
                                t.Base.Helpers.isNumber(f) && (e = Math.min(e, f), i = Math.max(i, f))
                            } else if (1 === o)for (var m = n[0], p = u; c >= p; p++) {
                                var f = m[p];
                                t.Base.Helpers.isNumber(f) && (e = Math.min(e, f), i = Math.max(i, f))
                            } else if ("based" === r)for (var p = u; c >= p; p++)for (var d = 0; o - 1 >= d; d++) {
                                var f = n[d][p];
                                t.Base.Helpers.isNumber(f) && (e = Math.min(e, f), i = Math.max(i, f))
                            } else if ("normal" !== r || a) {
                                if ("normal" !== r)throw"stack.type unknown value: " + r;
                                for (var p = u; c >= p; p++)for (var g = 0, y = 0, d = 0; o - 1 >= d; d++) {
                                    var f = n[d][p];
                                    t.Base.Helpers.isNumber(f) && (f > 0 ? y += f : 0 > f && (g += f), e = Math.min(e, g), i = Math.max(i, y))
                                }
                            } else for (var p = u; c >= p; p++)for (var v = 0, d = 0; o - 1 >= d; d++) {
                                var f = n[d][p];
                                t.Base.Helpers.isNumber(f) && (null !== f && (v += f), e = Math.min(e, v), i = Math.max(i, v))
                            }
                        }
                        return this.min = e, this.max = i, i >= e ? this.va.recieveSeriesGeometry(e, i, this.calculatedDepth) : this.va.recieveSeriesGeometry(void 0, void 0, this.calculatedDepth)
                    }, i.prototype.computeY = function () {
                        if (0 !== this.vstack.length) {
                            var t, e = this.options.type, i = this.getSeparateNegative(), n = this.vstack, s = n.length, o = n[0].length, r = this.va, a = null;
                            if ("proportional" === e) {
                                t = n.map(function () {
                                    return []
                                });
                                for (var h = 0; o - 1 >= h; h++) {
                                    for (var l = 0, u = 0; s - 1 >= u; u++) {
                                        var c = n[u][h];
                                        null !== c && (l += Math.abs(c))
                                    }
                                    if (l > 0) {
                                        l *= .01;
                                        for (var u = 0; s - 1 >= u; u++) {
                                            var c = n[u][h];
                                            t[u].push(null !== c ? r.valueToRelativeY(Math.abs(c) / l) : null)
                                        }
                                    } else for (var u = 0; s - 1 >= u; u++)t[u].push(null)
                                }
                            } else if ("based" === e || 1 === s) {
                                t = [];
                                for (var p = n[0].map(function () {
                                    return 0
                                }), d = 0; d < n.length; d++) {
                                    for (var f = n[d], m = new Array(o), g = 0; g < f.length; g++) {
                                        var c = f[g];
                                        if (null !== c) {
                                            var y = r.valueToRelativeY(c);
                                            m[g] = y - p[g], p[g] = y
                                        } else m[g] = null
                                    }
                                    t.push(m)
                                }
                            } else if ("normal" === e && i && this.min < 0 && this.max > 0) {
                                t = n.map(function () {
                                    return []
                                }), a = n.map(function () {
                                    return []
                                });
                                for (var h = 0; o - 1 >= h; h++)for (var u = 0; s - 1 >= u; u++) {
                                    var c = n[u][h];
                                    c > 0 ? (t[u].push(r.valueToRelativeY(c)), a[u].push(null)) : 0 > c ? (t[u].push(null), a[u].push(r.valueToRelativeY(c))) : (t[u].push(null), a[u].push(null))
                                }
                            } else if ("candlestick" === this.renderingType) {
                                t = n.map(function () {
                                    return []
                                });
                                for (var h = 0; o - 1 >= h; h++)for (var u = 0; s - 1 >= u; u++) {
                                    var c = n[u][h];
                                    t[u].push(null !== c ? r.valueToRelativeY(c) : null)
                                }
                            } else {
                                if ("normal" !== e)throw"stack.type unknown value: " + e;
                                var v = 0, S = 0, C = 0;
                                t = n.map(function () {
                                    return []
                                });
                                for (var h = 0; o - 1 >= h; h++)for (var u = 0; s - 1 >= u; u++) {
                                    var c = n[u][h];
                                    if (0 === u && (v = S = C = 0), null !== c) {
                                        S += c;
                                        var b = r.valueToRelativeY(S);
                                        t[u].push(b - C), C = b
                                    } else t[u].push(null)
                                }
                            }
                            this.ystackNegative = a, this.ystack = t
                        }
                    }, i.prototype.exportData = function (t, e) {
                        var i;
                        if (this.times && this.vstack) {
                            for (var n = this.times, s = this.centers.length, o = 0; s > o && n[o + 1] <= t;)o++;
                            for (var r = o; s > r && n[r + 1] < e;)r++;
                            i = [];
                            for (var a = 0; a < this.vstack.length; a++) {
                                var h = this.vstack[a], l = this.countStack[a], u = 0, c = -1 / 0, p = 1 / 0, d = null, f = null;
                                s = 0;
                                var m = this.series[a].data.aggregation, g = !1, y = !1;
                                "sum" === m ? (g = !1, y = !0) : "avg" === m && (g = !0, y = !0);
                                for (var v = o; r >= v; v++) {
                                    var S = h[v], C = 0 | l[v];
                                    null == S || isNaN(S) || (u += g ? S * C : S, c = Math.max(c, S), p = Math.min(p, S), null === d && (d = S), f = S, s += C)
                                }
                                i.push(s > 0 ? {
                                        sum: u,
                                        max: c,
                                        min: p,
                                        first: d,
                                        last: f,
                                        count: s,
                                        avg: y ? u / s : null,
                                        change: f - d
                                    } : null)
                            }
                        } else i = this.series.map(function () {
                            return null
                        });
                        for (var b = [], x = this.series.length - 1; x >= 0; x--) {
                            var _ = this.series[x];
                            b.push({name: _.name || "", values: i[x], config: _})
                        }
                        return {
                            name: this.options.name,
                            stack: this,
                            config: this.options,
                            data: b
                        }
                    }, i
                }();
                i.Stack = n
            }(i = e.Series || (e.Series = {}))
        }(e = t.LinearChart || (t.LinearChart = {}))
    }(e = t.Internal || (t.Internal = {}))
}(ZoomCharts || (ZoomCharts = {}));
var ZoomCharts;
!function (t) {
    var e;
    !function (t) {
        var e;
        !function (e) {
            var i = function (i) {
                function o() {
                    i.apply(this, arguments), this._computedValueAxisList = [], this._computedValueAxis = {}, this._computedSeries = [], this._computedStacks = {}, this.area = new y, this.legend = new e.SettingsLegend, this.valueAxisDefault = new e.SettingsValueAxis, this.valueAxis = {}, this.chartTypes = {
                        columns: {type: "columns"},
                        line: {type: "line"},
                        candlestick: {type: "candlestick"}
                    }, this.stacks = {}, this.seriesDefault = {type: "columns"}, this.series = [], this.info = new p, this.events = new n, this.interaction = new m, this.localization = new d, this.style = {
                        columnColors: ["#32CD32", "#36BEFF", "#FBBD30", "#EE3431", "#894BBC", "#0EC9AC", "#524BBC"],
                        lineColors: ["#32CD32", "#36BEFF", "#FBBD30", "#EE3431", "#894BBC", "#0EC9AC", "#524BBC"]
                    }
                }

                return __extends(o, i), o.prototype.apply = function (n, r) {
                    var a = n.valueAxis;
                    if (a) {
                        var h = [{
                            from: "style.baseLineColor",
                            to: "style.baseLine.lineColor"
                        }, {
                            from: "style.baseLineWidth",
                            to: "style.baseLine.lineWidth"
                        }, {from: "style.hgridLineColor", to: "style.hgrid.lineColor"}];
                        for (var l in a)this.applyCompatibility(a[l], h, "valueAxis[" + l + "]")
                    }
                    this.applyCompatibility(n, [{
                        from: "valueAxis.default",
                        to: "valueAxisDefault"
                    }, {
                        from: "valueAxisDefault.style.baseLineColor",
                        to: "valueAxisDefault.style.baseLine.lineColor"
                    }, {
                        from: "valueAxisDefault.style.baseLineWidth",
                        to: "valueAxisDefault.style.baseLine.lineWidth"
                    }, {
                        from: "valueAxisDefault.style.hgridLineColor",
                        to: "valueAxisDefault.style.hgrid.lineColor"
                    }]);
                    var u = i.prototype.apply.call(this, n);
                    if (this._initializing || u.series || u.chartTypes || u.seriesDefault || u.stacks) {
                        var p = this.series, d = [], f = null, m = null, g = 0;
                        this._computedStacks = t.Base.Helpers.clone(this.stacks);
                        for (var y = 0; y < p.length; y++) {
                            var v = p[y];
                            if (!v.valueAxis || "default" === v.valueAxis || this.valueAxis[v.valueAxis])if (v.data && 0 === v.data.index) t.Base.Helpers.error("Value `0` references the timestamp and cannot be used when specifying `series.data.index`."); else if (v.data && 0 === v.data.countIndex) t.Base.Helpers.error("Value `0` references the timestamp and cannot be used when specifying `series.data.countIndex`."); else if ("candlestick" !== v.type || v.data && v.data.index) d.push(v); else {
                                if (void 0 === v.stack || null === v.stack) {
                                    f = "default" + t.Base.Helpers.SeparatorChar + g++;
                                    var S = new s;
                                    S.name = v.name, this._computedStacks[f] = S
                                }
                                var C = v.data, b = !1;
                                for (var x in o._paramAggregations)if (null === C[x] || void 0 === C[x]) {
                                    b = !0;
                                    break
                                }
                                if (b) {
                                    t.Base.Helpers.error("Each candlestick series should define four data properties: low, high, open, close");
                                    continue
                                }
                                var _ = v.localization;
                                _ || (_ = this.chartTypes.candlestick.localization), _ || (_ = (new c).localization);
                                for (var w in o._paramAggregations) {
                                    var L = t.Base.Helpers.extendCopy({}, v);
                                    m = "series" + t.Base.Helpers.SeparatorChar + g++, L.stack = f, L.id = m, L.name = _[w] || w, L.nameLegend = v.name, L.data = {
                                        aggregation: o._paramAggregations[w],
                                        index: v.data[w]
                                    }, L.style = v.style, d.push(L)
                                }
                            } else t.Base.Helpers.error("The series reference a non-existant value axis `" + v.valueAxis + "`.")
                        }
                        this._computedSeries = t.Base.SettingsHelper.mergeDefaultValues(d, this.seriesDefault, this.chartTypes, r.createInstance, r.getMapping, "series"), this.applySeriesColor(this._computedSeries), u._computedSeries = this._computedSeries
                    }
                    if (this._initializing || u.valueAxis || u.valueAxisDefault || !this._computedValueAxisList.length) {
                        for (var T = !1, M = 0; M < this._computedSeries.length; M++) {
                            var P = this._computedSeries[M];
                            T = T || "default" === P.valueAxis
                        }
                        this._computedValueAxisList = [], this._computedValueAxis = {};
                        var k = this.valueAxisDefault;
                        for (var D in this.valueAxis) {
                            var I = new e.SettingsValueAxis, A = this.valueAxis[D];
                            this.applyCompatibility(A, [{
                                from: "style.baseLineColor",
                                to: "style.baseLine.lineColor"
                            }, {
                                from: "style.baseLineWidth",
                                to: "style.baseLine.lineWidth"
                            }, {
                                from: "style.hgridLineColor",
                                to: "style.hgrid.lineColor"
                            }]), t.Base.SettingsHelper.updateRecursive(I, k, t.Base.SettingsMapping.LinearChartSettingsValueAxis, {}, "valueAxisDefault"), t.Base.SettingsHelper.updateRecursive(I, A, t.Base.SettingsMapping.LinearChartSettingsValueAxis, {}, "valueAxis[" + D + "]"), I.id = D, this._computedValueAxis[D] = I, this._computedValueAxisList.push(I)
                        }
                        if (T && !this.valueAxis["default"]) {
                            var B = new e.SettingsValueAxis;
                            t.Base.SettingsHelper.updateRecursive(B, k, t.Base.SettingsMapping.LinearChartSettingsValueAxis, {}, "valueAxisDefault"), B.id = "default", this._computedValueAxis[B.id] = B, this._computedValueAxisList.push(B)
                        }
                        this._computedValueAxisList.sort(function (t, e) {
                            return t.id.localeCompare(e.id)
                        }), u._computedValueAxis = this._computedValueAxis, u._computedValueAxisList = this._computedValueAxisList
                    }
                    return u
                }, o.prototype.applySeriesColor = function (t) {
                    for (var e = 0, i = 0, n = this.style.columnColors, s = this.style.lineColors, o = 0; o < t.length; o++) {
                        var r = t[o];
                        "columns" === r.type && null == r.style.fillColor ? (r.style.fillColor = n[e], e = (e + 1) % n.length) : "line" === r.type && null == r.style.lineColor && (r.style.lineColor = s[i], i = (i + 1) % s.length)
                    }
                }, o._paramAggregations = {
                    high: "max",
                    open: "first",
                    close: "last",
                    low: "min"
                }, o
            }(t.Base.Settings);
            e.Settings = i;
            var n = function (t) {
                function e() {
                    t.apply(this, arguments), this.onAnimationDone = null
                }

                return __extends(e, t), e
            }(t.Base.SettingsEvents);
            e.SettingsEvents = n;
            var s = function () {
                function t() {
                    this.name = "", this.type = "normal", this.separateNegativeValues = null
                }

                return t
            }();
            e.SettingsStack = s;
            var o = function () {
                function t() {
                    this.id = null, this.enabled = !0, this.data = new a, this.type = "columns", this.valueAxis = "default", this.name = null, this.nameLegend = null, this.showInLegend = !0, this.stack = null, this.cluster = null, this.style = new r
                }

                return t.getMapping = function () {
                    throw new Error("This method is abstract.")
                }, t.createInstance = function () {
                    throw new Error("This method is abstract.")
                }, t
            }();
            e.SettingsSeries = o;
            var r = function () {
                function t() {
                    this.fillColor = null, this.lineColor = null
                }

                return t
            }();
            e.SettingsSeriesStyle = r;
            var a = function () {
                function t() {
                    this.source = "default", this.valueFunction = null, this.aggregation = "sum", this.aggregatedValueFunction = null, this.noDataPolicy = "join"
                }

                return t
            }();
            e.SettingsSeriesData = a;
            var h = function (t) {
                function e() {
                    t.call(this), this.style = new l, this.type = "columns"
                }

                return __extends(e, t), e
            }(o);
            e.SettingsSeriesColumns = h;
            var l = function (t) {
                function e() {
                    t.apply(this, arguments), this.minHeight = 4, this.gradient = .8, this.lineColor = "", this.fillColor = null, this.fillGradient = null, this._currentFillGradient = null, this.lineWidth = 1, this.lineDash = null, this.padding = [3, 3], this.shadowOffsetX = 1, this.shadowOffsetY = -1, this.shadowBlur = 3, this.shadowColor = null, this.depth = 0, this.depthBrightness = .5
                }

                return __extends(e, t), e
            }(r);
            e.SettingsSeriesColumnsStyle = l;
            var u = function (t) {
                function e() {
                    t.call(this), this.style = {
                        lineColor: null,
                        lineDash: null,
                        fillColor: "",
                        fillGradient: null,
                        _currentFillGradient: null,
                        lineWidth: 1,
                        shadowOffsetX: 1,
                        shadowOffsetY: -1,
                        shadowBlur: 5,
                        shadowColor: null,
                        smoothing: !1,
                        steps: !1,
                        marker: {shape: null, width: 10, fillColor: ""},
                        depth: 0
                    }, this.type = "line"
                }

                return __extends(e, t), e
            }(o);
            e.SettingsSeriesLines = u;
            var c = function (t) {
                function e() {
                    t.call(this), this.style = {
                        fillColor: null,
                        lineColor: null,
                        pattern: "candlestick",
                        padding: [1, 1],
                        increase: {
                            bar: {
                                lineColor: "green",
                                shadowColor: null,
                                lineDash: null,
                                lineWidth: 1,
                                shadowOffsetX: 1,
                                shadowOffsetY: -1,
                                shadowBlur: 0
                            },
                            candlestick: {
                                lineColor: "#000",
                                shadowColor: null,
                                lineDash: null,
                                lineWidth: 1,
                                shadowOffsetX: 1,
                                shadowOffsetY: -1,
                                shadowBlur: 0,
                                fillColor: "yellow"
                            }
                        },
                        decrease: {
                            bar: {
                                lineColor: "red",
                                shadowColor: null,
                                lineDash: null,
                                lineWidth: 1,
                                shadowOffsetX: 1,
                                shadowOffsetY: -1,
                                shadowBlur: 0
                            },
                            candlestick: {
                                lineColor: "#000",
                                shadowColor: null,
                                lineDash: null,
                                lineWidth: 1,
                                shadowOffsetX: 1,
                                shadowOffsetY: -1,
                                shadowBlur: 0,
                                fillColor: "black"
                            }
                        }
                    }, this.localization = {
                        high: "high",
                        low: "low",
                        open: "open",
                        close: "close"
                    }, this.type = "candlestick"
                }

                return __extends(e, t), e
            }(o);
            e.SettingsSeriesCandleStick = c;
            var p = function () {
                function t() {
                    this.enabled = !0, this.showNoData = !0, this.valueFormatterFunction = null, this.aggregations = null, this.style = {
                        highlight: {
                            fillColor: "rgba(30,160,220,0.15)",
                            fadeIn: 200,
                            fadeOut: 200
                        }
                    }, this.advanced = {
                        contentsFunction: null,
                        showOnlyHoveredSeries: !1,
                        scope: null,
                        showHeader: !0
                    }
                }

                return t
            }();
            e.SettingsInfoPopup = p;
            var d = function (t) {
                function e() {
                    t.apply(this, arguments), this.valueUnits = {
                        K: 1e3,
                        M: 1e6,
                        B: 1e9,
                        T: 1e12,
                        P: 1e15
                    }, this.noDataLabel = "No data", this.unnamedSeries = "Unnamed", this.toolbar = new f
                }

                return __extends(e, t), e
            }(t.Base.SettingsLocalization);
            e.SettingsLocalization = d;
            var f = function (t) {
                function e() {
                    t.apply(this, arguments), this.linButton = "Lin", this.logButton = "Log", this.linLogTitle = "Switch lin/log scale"
                }

                return __extends(e, t), e
            }(t.Base.SettingsLocalizationToolbar);
            e.SettingsLocalizationToolbar = f;
            var m = function (t) {
                function e() {
                    t.apply(this, arguments), this.swipeSensitivity = .6, this.scrolling = new g, this.zooming = {
                        enabled: !0,
                        wheel: !1,
                        swipe: !0,
                        fingers: !0,
                        fingersMaxZoom: 10,
                        sensitivity: 1,
                        keyboardFactor: 2,
                        upDownTreshold: 10,
                        zoomHighlightThreshold: 1.5
                    }
                }

                return __extends(e, t), e
            }(t.Base.SettingsInteraction);
            e.SettingsInteraction = m;
            var g = function () {
                function t() {
                    this.enabled = !0, this.swipePageFlipping = !0, this.keyboardScrollingFactor = 1, this.kineticFriction = 1e-6
                }

                return t
            }();
            e.SettingsInteractionScrolling = g;
            var y = function (t) {
                function e() {
                    t.apply(this, arguments), this.style = new v
                }

                return __extends(e, t), e
            }(t.Base.SettingsArea);
            e.SettingsArea = y;
            var v = function (t) {
                function e() {
                    t.apply(this, arguments), this.noData = {
                        fillColor: "#888",
                        image: null
                    }, this.zoomHighlight = {
                        fillColor: "rgba(30,160,220,0.15)",
                        fadeIn: 100,
                        fadeOut: 500
                    }, this.zoomHighlightInactive = {fillColor: "rgba(30,160,220,0.08)"}
                }

                return __extends(e, t), e
            }(t.Base.SettingsAreaStyle);
            e.SettingsAreaStyle = v
        }(e = t.LinearChart || (t.LinearChart = {}))
    }(e = t.Internal || (t.Internal = {}))
}(ZoomCharts || (ZoomCharts = {}));
var ZoomCharts;
!function (t) {
    var e;
    !function (t) {
        var e;
        !function (e) {
            var i = function () {
                function i(t, e, i) {
                    this.count = e, this.unit = t, this.name = void 0 === i ? this.count + " " + this.unit : i
                }

                return i.isGoodUnit = function (t) {
                    return i.parsingMap.hasOwnProperty(t)
                }, i.parse = function (t, n, s) {
                    if (void 0 === s && (s = !0), null == t)return null;
                    if (!e.Helpers.isString(t)) {
                        if (t instanceof i)return t;
                        if (s)throw new Error("Cannot parse the unit text because it is not a string: " + t);
                        return null
                    }
                    var o, r = 1, a = t.split(" ");
                    if (2 === a.length) {
                        if (r = e.Helpers.tryParseInt(a[0], null), null === r) {
                            if (s)throw new Error("Cannot parse the time unit - the correct format is `1 s`: " + t);
                            return null
                        }
                        o = a[1]
                    } else {
                        if (1 !== a.length)return null;
                        r = 1, o = a[0]
                    }
                    if (o = i.parsingMap[o], null == o) {
                        if (s)throw new Error("Cannot parse the time unit - unrecognized time unit: " + t);
                        return null
                    }
                    return new i(o, r, n || t)
                }, i.prototype.clone = function () {
                    return new i(this.unit, this.count, this.name)
                }, i.prototype.add = function (e, i) {
                    return void 0 === i && (i = 1), null == i && (i = 1), t.moment(e).utc().add(this.count * i, this.unit).valueOf()
                }, i.prototype.sub = function (e, i) {
                    return void 0 === i && (i = 1), null == i && (i = 1), t.moment(e).utc().subtract(this.count * i, this.unit).valueOf()
                }, i.prototype.numberOfUnits = function (e, n) {
                    return Math.round(t.moment(n).utc().diff(t.moment(e).utc(), i.unitsTranslation[this.unit], !0) / this.count)
                }, i.prototype.toString = function () {
                    return this.count + " " + this.unit
                }, i.prototype.approxTime = function () {
                    return i.timeUnitDiffs[this.unit] * this.count
                }, i.prototype.isSmallerOrEqual = function (t) {
                    return this.approxTime() <= t.approxTime()
                }, i.prototype.isSmaller = function (t) {
                    return this.approxTime() < t.approxTime()
                }, i.prototype.isBigger = function (t) {
                    return this.approxTime() > t.approxTime()
                }, i.prototype.isEqual = function (t) {
                    return this.approxTime() === t.approxTime()
                }, i.prototype.getBigger = function () {
                    return "y" === this.unit ? new i(this.unit, 10 * this.count) : new i(i.toBiggerUnit[this.unit], 1)
                }, i.prototype.roundTimeDown = function (e) {
                    e = Math.round(e);
                    var n = this.count, s = this.unit;
                    if ("ms" === this.unit)return Math.floor(e / n) * n;
                    var o = t.moment(e).utc().startOf(i.unitsTranslation[this.unit]);
                    if ("y" === s)return o.year(Math.floor(o.year() / n) * n), o.valueOf();
                    if ("M" === s) {
                        var r = 12 * o.year() + o.month();
                        return o.add(Math.floor(r / n) * n - r, "M"), o.valueOf()
                    }
                    if ("s" === s)return e = o.valueOf() / 1e3, Math.floor(e / n) * n * 1e3;
                    if ("m" === s)return e = o.valueOf() / 1e3 / 60, Math.floor(e / n) * n * 60 * 1e3;
                    if ("h" === s)return e = o.valueOf() / 1e3 / 60 / 60, Math.floor(e / n) * n * 60 * 60 * 1e3;
                    if ("d" === s) {
                        if (n % 7 !== 0)return e = o.valueOf() / 1e3 / 60 / 60 / 24, Math.floor(e / n) * n * 24 * 60 * 60 * 1e3;
                        s = "w", n /= 7
                    }
                    if ("w" === s)return e = (o.valueOf() / 1e3 / 60 / 60 / 24 - 4) / 7, 24 * (Math.floor(e / n) * n * 7 + 4) * 60 * 60 * 1e3;
                    throw new Error("Unrecognized unit: `" + this.unit + "`")
                }, i.prototype.roundTimeUp = function (e) {
                    return this.roundTimeDown(t.moment(Math.round(e)).utc().add(this.count, this.unit).valueOf() - 1)
                }, i.prototype.roundTimeRound = function (e) {
                    var i = t.moment(Math.round(e)).utc().add(this.count, this.unit);
                    return this.roundTimeDown((i.valueOf() + e - 1) / 2)
                }, i.parsingMap = {
                    milliseconds: "ms",
                    millisecond: "ms",
                    second: "s",
                    seconds: "s",
                    minute: "m",
                    minutes: "m",
                    hour: "h",
                    hours: "h",
                    day: "d",
                    days: "d",
                    week: "w",
                    weeks: "w",
                    month: "M",
                    months: "M",
                    year: "y",
                    years: "y",
                    ms: "ms",
                    s: "s",
                    m: "m",
                    h: "h",
                    d: "d",
                    w: "w",
                    M: "M",
                    y: "y"
                }, i.knownUnits = ["ms", "s", "m", "h", "d", "w", "M", "y"], i.timeUnitDiffs = {
                    ms: 1,
                    s: 1e3,
                    m: 6e4,
                    h: 36e5,
                    d: 864e5,
                    w: 6048e5,
                    M: 26352e5,
                    y: 31536e6
                }, i.unitsTranslation = {
                    s: "second",
                    m: "minute",
                    h: "hour",
                    d: "day",
                    w: "week",
                    M: "month",
                    y: "year"
                }, i.toBiggerUnit = {
                    ms: "s",
                    s: "m",
                    m: "h",
                    h: "d",
                    d: "w",
                    w: "M",
                    M: "y",
                    y: null
                }, i.toSmallerUnit = {
                    ms: null,
                    s: "ms",
                    m: "s",
                    h: "m",
                    d: "h",
                    w: "d",
                    M: "d",
                    y: "M"
                }, i
            }();
            e.TimeStep = i
        }(e = t.Base || (t.Base = {}))
    }(e = t.Internal || (t.Internal = {}))
}(ZoomCharts || (ZoomCharts = {}));
var ZoomCharts;
!function (t) {
    var e;
    !function (t) {
        var e;
        !function (t) {
            var e;
            !function (e) {
                e.ToolbarItemNames.zoomOut = function (e, i) {
                    return new t.Bar.UserButton(e, {
                        label: e.settings.localization.toolbar.zoomoutButton,
                        cssClass: "DVSL-bar-btn-zoomout",
                        title: e.settings.localization.toolbar.zoomoutTitle,
                        showLabels: i.showLabels,
                        onClick: function () {
                            return e.zoomOut(null, !0, "user")
                        }
                    })
                }
            }(e = t.Bar || (t.Bar = {}))
        }(e = t.Base || (t.Base = {}))
    }(e = t.Internal || (t.Internal = {}))
}(ZoomCharts || (ZoomCharts = {}));
var ZoomCharts;
!function (t) {
    var e;
    !function (t) {
        var e;
        !function (e) {
            var i;
            !function (i) {
                var n = function (e) {
                    function i(t, i) {
                        e.call(this, t), this.options = i, this.chart = t, this.linClass = "DVSL-bar-btn-lin", this.logClass = "DVSL-bar-btn-log", i.cssClass = this.linClass, i.title = this.chart.settings.localization.toolbar.linLogTitle, i.label = this.chart.settings.localization.toolbar.linButton, this.createButton(i), this.logScale = !1
                    }

                    return __extends(i, e), i.prototype.onClick = function () {
                        this.chart.setLogScale(!this.chart.scene.settings.valueAxisDefault.logScale, "user")
                    }, i.prototype.onSceneChange = function (e) {
                        (e.toolbar || e.settings && this.chart.scene.settings.valueAxisDefault.logScale !== this.logScale) && (this.logScale = this.chart.scene.settings.valueAxisDefault.logScale, this.logScale ? (t.Base.Helpers.removeClass(this.a, this.linClass), t.Base.Helpers.addClass(this.a, this.logClass), this.options.showLabels && (this.p.innerHTML = this.chart.settings.localization.toolbar.logButton)) : (t.Base.Helpers.removeClass(this.a, this.logClass), t.Base.Helpers.addClass(this.a, this.linClass), this.options.showLabels && (this.p.innerHTML = this.chart.settings.localization.toolbar.linButton)))
                    }, i
                }(t.Base.Bar.Button);
                i.LinLogButton = n, t.Base.Bar.ToolbarItemNames.logScale = function (t, i) {
                    return new e.Bar.LinLogButton(t, i)
                }
            }(i = e.Bar || (e.Bar = {}))
        }(e = t.LinearChart || (t.LinearChart = {}))
    }(e = t.Internal || (t.Internal = {}))
}(ZoomCharts || (ZoomCharts = {}));
var ZoomCharts;
!function (t) {
    var e;
    !function (t) {
        var e;
        !function (e) {
            var i = function (t) {
                function e() {
                    t.apply(this, arguments), this.enabled = !0, this["export"] = !0, this.back = !0, this.zoomOut = !0, this.logScale = !0
                }

                return __extends(e, t), e
            }(t.Base.SettingsToolbar);
            e.SettingsToolbar = i
        }(e = t.LinearChart || (t.LinearChart = {}))
    }(e = t.Internal || (t.Internal = {}))
}(ZoomCharts || (ZoomCharts = {}));
var ZoomCharts;
!function (t) {
    var e;
    !function (t) {
        var e;
        !function (e) {
            var i;
            !function (i) {
                var n = function (t) {
                    function e(e, i) {
                        this.chart = e, this.custom = {name: e.settings.localization.toolbar.customPeriod}, i = {
                            cssClass: "DVSL-bar-btn-month",
                            title: this.chart.settings.localization.toolbar.periodDropdownTitle,
                            name: "",
                            showLabels: i.showLabels
                        }, t.call(this, e, i), this.updateSelectedItem()
                    }

                    return __extends(e, t), e.prototype.onSelectionChange = function (t) {
                        return this.chart.setDisplayPeriod(t.displayPeriodStr, t.displayAnchor, t.displayUnit, !0, "user")
                    }, e.prototype.onSceneChange = function (t) {
                        (t.settingsChanges && (t.settingsChanges.area || t.settingsChanges.toolbar) || t.time || t.toolbar) && this.updateSelectedItem()
                    }, e.prototype.updateSelectedItem = function () {
                        for (var t = 0; t < this.chart.settings.toolbar.periods.length; t++) {
                            var e = this.chart.settings.toolbar.periods[t];
                            if (this.chart.isThisDisplayPeriod(e.displayPeriod, e.displayAnchor))return void this.setSelectedItem(e)
                        }
                        this.setSelectedItem(this.custom)
                    }, e.prototype.getItems = function () {
                        for (var t = [], e = this.chart.settings._minUnit, i = 0; i < this.chart.settings.toolbar.periods.length; i++) {
                            var n = this.chart.settings.toolbar.periods[i], s = n.parse(), o = s.displayPeriod, r = s.displayUnit;
                            r && r.isSmaller(e) || o && o.isSmallerOrEqual(e) || (s.selected = this.chart.isThisDisplayPeriod(n.displayPeriod, s.displayAnchor), t.push(s))
                        }
                        return t
                    }, e
                }(t.Base.Bar.Combobox);
                i.DisplayPeriodDropdown = n, t.Base.Bar.ToolbarItemNames.displayPeriod = function (t, i) {
                    return new e.Bar.DisplayPeriodDropdown(t, i)
                }
            }(i = e.Bar || (e.Bar = {}))
        }(e = t.TimeChart || (t.TimeChart = {}))
    }(e = t.Internal || (t.Internal = {}))
}(ZoomCharts || (ZoomCharts = {}));
var ZoomCharts;
!function (t) {
    var e;
    !function (t) {
        var e;
        !function (e) {
            var i;
            !function (i) {
                var n = function (t) {
                    function e(e, i) {
                        this.chart = e, i = {
                            cssClass: "DVSL-bar-btn-bars",
                            title: this.chart.settings.localization.toolbar.unitDropdownTitle,
                            name: "",
                            showLabels: i.showLabels
                        }, t.call(this, e, i), this.updateSelectedItem()
                    }

                    return __extends(e, t), e.prototype.onSelectionChange = function (t) {
                        return this.chart.setDisplayUnit(t.value, !0, !0, "user")
                    }, e.prototype.onSceneChange = function (t) {
                        return t.settingsChanges && t.settingsChanges.area || t.time || t.toolbar ? this.updateSelectedItem() : void 0
                    }, e.prototype.updateSelectedItem = function () {
                        var t = this.chart.displayUnit;
                        if (t) {
                            for (var e = 0; e < this.chart.settings._displayUnitsParsed.length; e++) {
                                var i = this.chart.settings._displayUnitsParsed[e];
                                if (i.isEqual(t))return void this.setSelectedItem(i)
                            }
                            return this.setSelectedItem({name: t.name, value: t})
                        }
                    }, e.prototype.getItems = function () {
                        for (var t = [], e = this.chart.scene.displayUnit, i = this.chart.getMinSelectableUnit(), n = 0; n < this.chart.settings._displayUnitsParsed.length; n++) {
                            var s = this.chart.settings._displayUnitsParsed[n];
                            t.push({
                                name: s.name,
                                value: s,
                                disabled: s.approxTime() < i.approxTime(),
                                selected: s.isEqual(e)
                            })
                        }
                        return t
                    }, e
                }(t.Base.Bar.Combobox);
                i.DisplayUnitDropdown = n, t.Base.Bar.ToolbarItemNames.displayUnit = function (t, i) {
                    return new e.Bar.DisplayUnitDropdown(t, i)
                }
            }(i = e.Bar || (e.Bar = {}))
        }(e = t.TimeChart || (t.TimeChart = {}))
    }(e = t.Internal || (t.Internal = {}))
}(ZoomCharts || (ZoomCharts = {}));
var ZoomCharts;
!function (t) {
    var e;
    !function (t) {
        var e;
        !function (e) {
            var i = function () {
                function e(t, e, i, n) {
                    this.name = null, this.displayAnchor = null, this.displayPeriod = null, this.displayUnit = null, void 0 === e ? this.displayPeriod = t : (this.name = t, this.displayAnchor = e, this.displayPeriod = i, this.displayUnit = n)
                }

                return e.prototype.parse = function () {
                    var e = this.displayPeriod, i = this.displayUnit;
                    return {
                        name: this.name,
                        displayAnchor: this.displayAnchor,
                        displayPeriod: "max" === e ? null : t.Base.TimeStep.parse(e),
                        displayPeriodStr: this.displayPeriod,
                        displayUnit: "auto" === i ? null : t.Base.TimeStep.parse(i),
                        selected: void 0
                    }
                }, e
            }();
            e.SettingsAreaDisplayPeriod = i;
            var n = function (e) {
                function n() {
                    e.apply(this, arguments), this.enabled = !0, this.logScale = !0, this.zoomOut = !0, this.displayUnit = !0, this.displayPeriod = !0, this.periods = [new i("Last second", "now", "1 s", "25 ms"), new i("Last minute", "now", "1 m", "1 s"), new i("Last hour", "now", "1 h", "1 m"), new i("Last day", "now", "1 d", "1 h"), new i("Last week", "now", "1 w", "6 h"), new i("Last month", "now", "1 M", "1 d"), new i("Last year", "now", "1 y", "1 M"), new i("All data", "newestData", "max", "auto")], this.items = [new t.Base.SettingsToolbarItem("back", "left"), new t.Base.SettingsToolbarItem("zoomOut", "left"), new t.Base.SettingsToolbarItem("logScale", "right"), new t.Base.SettingsToolbarItem("displayPeriod", "right"), new t.Base.SettingsToolbarItem("displayUnit", "right"), new t.Base.SettingsToolbarItem("export", "right")]
                }

                return __extends(n, e), n
            }(t.Base.SettingsToolbar);
            e.SettingsToolbar = n
        }(e = t.TimeChart || (t.TimeChart = {}))
    }(e = t.Internal || (t.Internal = {}))
}(ZoomCharts || (ZoomCharts = {}));
var ZoomCharts;
!function (t) {
    var e;
    !function (t) {
        var e;
        !function (e) {
            var i = function () {
                function e(t) {
                    this.settings = t
                }

                return e.isSmallerOrEqualUnit = function (e, i) {
                    return t.Base.TimeStep.timeUnitDiffs[e] <= t.Base.TimeStep.timeUnitDiffs[i]
                }, e.isSmallerUnit = function (e, i) {
                    return t.Base.TimeStep.timeUnitDiffs[e] < t.Base.TimeStep.timeUnitDiffs[i]
                }, e.prototype.toBiggerDisplayPeriod = function (t) {
                    for (var e = null, i = 0; i < this.settings._displayPeriodsParsed.length; i++) {
                        var n = this.settings._displayPeriodsParsed[i];
                        n.approxTime() > t.approxTime() && (null === e || n.approxTime() < e.approxTime()) && (e = n)
                    }
                    return e
                }, e.prototype.getMinUnitForTime = function (t) {
                    for (var e = null, i = 1 / 0, n = 0; n < this.settings._displayUnitsParsed.length; n++) {
                        var s = this.settings._displayUnitsParsed[n], o = s.approxTime();
                        i > o && o > t && (e = s, i = o)
                    }
                    return e
                }, e.prototype.getBiggerDisplayPeriod = function (t, e) {
                    for (var i = Math.abs(e - t), n = 0, s = null, o = 0; o < this.settings._displayPeriodsParsed.length; o++) {
                        var r = this.settings._displayPeriodsParsed[o], a = r.approxTime(), h = i / a;
                        .9 > h && h > n && (n = h, s = r)
                    }
                    return s
                }, e.prototype.getClosestDisplayPeriod = function (t, e, i) {
                    for (var n = null, s = 0, o = null, r = 1 / 0, a = 0; a < this.settings._displayPeriodsParsed.length; a++) {
                        var h = this.settings._displayPeriodsParsed[a], l = h.approxTime();
                        t >= l && (null === n || l > s) && (n = h, s = l), l >= t && (null === o || r > l) && (o = h, r = l)
                    }
                    return i ? e && e.approxTime() < .8 * t ? e : null !== o && 1.2 * t > r || null === n ? o : n : null !== n && (s > .8 * t || r > 1.2 * t) ? n : o
                }, e.prototype.isAllowedDisplayUnit = function (t) {
                    for (var e = 0; e < this.settings._displayUnitsParsed.length; e++) {
                        var i = this.settings._displayUnitsParsed[e];
                        if (i.isEqual(t))return !0
                    }
                    return !1
                }, e.prototype.computeDisplayUnit = function (t, e, i, n, s, o) {
                    var r = Math.max(o.width, 10), a = Math.min(r / 3, this.settings.timeAxis.maxUnitWidth), h = (s - n) / r * this.settings.timeAxis.minUnitWidth, l = (s - n) / r * a;
                    if (null !== t && null !== e && i) {
                        var u = i.approxTime(), c = (e - t) / (s - n);
                        if (1 === c || l >= u && u >= h)return i
                    }
                    for (var p = this.settings.timeAxis.unitSizePolicy, d = null, f = 0, m = 0; m < this.settings._displayUnitsParsed.length; m++) {
                        var g = this.settings._displayUnitsParsed[m];
                        if (!(g.approxTime() < this.settings._minUnit.approxTime())) {
                            var y = g.approxTime(), v = void 0;
                            v = null === d ? !0 : "min" === p ? y >= h && f > y || h > f && y > f : l >= y && y > f || f > l && f > y, v && (d = g, f = y)
                        }
                    }
                    if (!d)throw console.error(t, e, i, n, s, r), "Could not calculate displayUnit";
                    return d
                }, e.prototype.tryComputeDisplayPeriod = function (e, i, n, s, o, r, a) {
                    var h = null, l = null;
                    if (e && e.indexOf(">") > -1) {
                        var u = e.split(">", 2);
                        h = parseInt(u[0], 10), l = parseInt(u[1], 10)
                    } else if ("max" === e && null !== s && null !== o) h = s, l = "now" === i ? a : o; else if ("max" !== e) {
                        var c, p = t.Base.TimeStep.parse(e);
                        c = "now" === i ? a : "newestData" === i && null !== o ? o : t.Base.Helpers.tryParseFloat(i, null), p && null !== c && (h = p.sub(c), l = c)
                    }
                    if (null === h || null === l)return {
                        from: null,
                        to: null,
                        unit: null
                    };
                    var d = this.computeTimeScaleRange(r), f = d.minTime, m = d.maxTime, g = d.minUnit, y = d.maxUnit, v = "auto" === n ? null : t.Base.TimeStep.parse(n);
                    return l - h > m && (v = y, h = l - m), f > l - h && (v = g, h = l - f), {
                        from: h,
                        to: l,
                        unit: v
                    }
                }, e.prototype.resolveFromTo = function (t, e, i, n, s, o) {
                    return "oldestData" === t && null !== n && (t = i.roundTimeDown(n)), "newestData" === e && null !== s && (e = i.roundTimeUp(s)), "now" === e && (e = i.roundTimeUp(o)), {
                        from: t,
                        to: e
                    }
                }, e.prototype.computeTimeScaleRange = function (t, e) {
                    void 0 === e && (e = this.settings._displayUnitsParsed);
                    for (var i = null, n = 0, s = null, o = 1 / 0, r = 0; r < e.length; r++) {
                        var a = e[r], h = a.approxTime();
                        (null === i || n > h) && (i = a, n = h), (null === s || h > o) && (s = a, o = h)
                    }
                    var l = Math.max(10, t.width), u = l / this.settings.timeAxis.minUnitWidth * o, c = l / this.settings.timeAxis.maxUnitWidth * n;
                    return {minTime: c, maxTime: u, minUnit: i, maxUnit: s}
                }, e.prototype.getLimits = function (e, i, n, s, o) {
                    var r = this.settings.interaction.scrolling, a = r.limitMode, h = o ? null !== a : "block" === a, l = null, u = null;
                    if (h) {
                        l = r.limitFrom, u = r.limitTo;
                        var c = this.resolveFromTo(l, u, n, e, i, s);
                        l = c.from, u = c.to, c = this.resolveFromTo(l, u, n, e, i, s), l = c.from, u = c.to, l = t.Base.Helpers.tryParseFloat(l, null), u = t.Base.Helpers.tryParseFloat(u, null)
                    }
                    return {limitFrom: l, limitTo: u}
                }, e.prototype.preventOverscale = function (t, e, i, n, s, o, r, a, h, l) {
                    var u = this.getLimits(r, a, o, h, l), c = u.limitFrom, p = u.limitTo, d = this.computeTimeScaleRange(t, e), f = d.minTime, m = d.maxTime;
                    if (null !== c && null !== p && s - n > p - c) {
                        var g = (c + p) / 2, y = (p - c) / 2;
                        return y = Math.max(y, f / 2), {from: g - y, to: g + y}
                    }
                    m *= .99, f *= 1.01;
                    var v = s - n;
                    v > m && (v = Math.min(v, m)), v = Math.max(v, f);
                    var S = v === f ? v / (s - n) : 1;
                    return null === i && (i = (n + s) / 2), n === s && n > 0 && console.error("From = To, trouble", n, s), {
                        from: i + (n - i) * S,
                        to: i + (s - i) * S
                    }
                }, e.prototype.preventOverscroll = function (t, e, i, n, s, o, r) {
                    var a = this.getLimits(n, s, t, o, r), h = a.limitFrom, l = a.limitTo, u = this.settings.interaction.scrolling, c = i - e;
                    return null !== h && null !== l && (c = Math.min(c, l - h)), c *= u.overscrollProportion, null !== h && (h -= c), null !== l && (l += c), null !== h && null !== l && i - e > l - h ? e > h ? (c = e - h, e -= c, i -= c) : l > i && (c = i - l, e -= c, i -= c) : null !== l && i > l ? (c = i - l, e -= c, i -= c) : null !== h && h > e && (c = h - e, e = h, i += c), {
                        from: e,
                        to: i
                    }
                }, e.prototype.scroll = function (e, i, n, s, o, r) {
                    var a;
                    if ("displayUnit" === r) a = n.clone(); else if ("page" === r) a = this.getTimeRangeStep(e, i); else {
                        if (!t.Base.TimeStep.isGoodUnit(r))return void t.Base.Helpers.error("Incorrect scroll unit: " + r);
                        a = t.Base.TimeStep.parse(r)
                    }
                    return a.count *= o, "<" === s ? {
                            from: a.sub(e),
                            to: a.sub(i)
                        } : {from: a.add(e), to: a.add(i)}
                }, e.prototype.getTimeRangeStep = function (e, i) {
                    e = Math.round(e), i = Math.round(i);
                    for (var n = null, s = 0; s < t.Base.TimeStep.knownUnits.length; s++) {
                        var o = t.Base.TimeStep.knownUnits[s], r = new t.Base.TimeStep(o, 1), a = r.roundTimeRound(e), h = r.roundTimeRound(i);
                        e === a && i === h && (null === n || n.approxTime() < r.approxTime()) && (n = r)
                    }
                    return n.count = Math.max(1, n.numberOfUnits(e, i)), n
                }, e
            }();
            e.TimeSetup = i
        }(e = t.TimeChart || (t.TimeChart = {}))
    }(e = t.Internal || (t.Internal = {}))
}(ZoomCharts || (ZoomCharts = {}));
var ZoomCharts;
!function (t) {
    var e;
    !function (t) {
        var e;
        !function (e) {
            var i = function (t) {
                function e() {
                    t.apply(this, arguments), this.units = ["s", "m", "h", "d", "M", "y"], this.urlByUnit = null, this.requestMaxUnits = 1e4, this.prefetchRatio = 1, this.minimizeRequests = !1, this.cacheSize = 1e6, this.timestampInSeconds = !1, this.timeZoneOffset = "local", this._computedTimeZoneOffset = null, this.dataFunction = null, this.preloaded = null
                }

                return __extends(e, t), e
            }(t.Base.SettingsData);
            e.SettingsData = i;
            var n = function () {
                function e(e, i) {
                    this.chart = null, this.scene = null, this.settings = null, this.noData = !1, this.dataLimitFrom = null, this.dataLimitTo = null, this.dataLimitFromUnit = null, this.dataLimitToUnit = null, this.dataFrom = null, this.dataTo = null, this.error = null, this.cache = {}, this.requests = {}, this.dataSettings = i, this.scene = e.scene, this.chart = e, this.dataId = "data" + i.id, this.updateDataLimit(null, null, null, null, new t.Base.TimeStep("ms", 1))
                }

                return e.binSearch = function (t, e) {
                    var i = 0;
                    if (!t)throw"no data";
                    for (var n = t.length - 1; n > i;) {
                        var s = (n + i) / 2 | 0;
                        if (t[s][0] < e) i = s + 1; else {
                            if (!(t[s][0] > e)) {
                                for (; s > 0 && t[s - 1][0] === e;)s -= 1;
                                return s
                            }
                            n = s
                        }
                    }
                    return i < t.length && t[i][0] < e ? i + 1 : i
                }, e.linSearchUp = function (t, e, i, n) {
                    if (n) {
                        for (var s = e + 1; s <= t.length - 1; s++)if (null !== n(t[s]))return s
                    } else for (var s = e + 1; s <= t.length - 1; s++)if (null !== t[s][i])return s;
                    return -1
                }, e.linSearchDown = function (t, e, i, n) {
                    if (n) {
                        for (var s = e - 1; s >= 0; s--)if (null !== n(t[s]))return s
                    } else for (var s = e - 1; s >= 0; s--)if (null !== t[s][i])return s;
                    return -1
                }, e.findSubrange = function (t, i, n) {
                    var s = e.binSearch(t, i), o = e.binSearch(t, n);
                    return {i0: s, i1: o}
                }, e.prototype.applyPreloadedData = function () {
                    this.dataSettings.preloaded && this.addData(this.dataSettings.preloaded)
                }, e.prototype.remove = function () {
                    this.scene.setMessage(this.dataId, null);
                    for (var t in this.requests) {
                        var e = this.requests[t];
                        e && (e.callback = null)
                    }
                }, e.prototype.determineDataLimits = function (e, i, n, s) {
                    var o = this;
                    for (e || (e = "y"); e && !(this.dataSettings.units.indexOf(e) > -1);)e = t.Base.TimeStep.toSmallerUnit[e];
                    e || this.chart.error("Cannot load data - no suitable data unit configured");
                    var r = new t.Base.TimeStep(e, 1), a = null, h = null, l = r.approxTime();
                    if (this.dataLimitFromUnit && this.dataLimitFromUnit.approxTime() <= l && (a = this.dataLimitFrom), this.dataLimitToUnit && this.dataLimitToUnit.approxTime() <= l && (h = this.dataLimitTo), (!i || void 0 !== a && null !== a) && (!n || void 0 !== h && null !== h))return void s(this.dataLimitFrom, this.dataLimitTo, e);
                    this.scene.setMessage(this.dataId, this.chart.settings.localization.determiningDataBounds, 999);
                    var u = function (t, e, n, r) {
                        if (!r)return void o.scene.setMessage(o.dataId, null);
                        if (null === o.dataLimitFrom && i) {
                            if (t !== e)return void o.scheduleDataLoading(r, null, e, !1, function (t, i, n) {
                                return u(e, t, i, n)
                            });
                            o.dataLimitFrom = e
                        }
                        return o.scene.setMessage(o.dataId, null), s(o.dataLimitFrom, o.dataLimitTo, r)
                    }, c = function (t, e, i, s, r) {
                        if (!r)return void o.scene.setMessage(o.dataId, null);
                        if (null === o.dataLimitTo && n) {
                            if (e !== s)return void o.scheduleDataLoading(r, s, null, !1, function (e, i, n) {
                                return c(t, s, e, i, n)
                            });
                            o.dataLimitTo = s
                        }
                        return u(t + 1, t, s, r)
                    };
                    return this.scheduleDataLoading(e, null, null, !1, function (t, e, i) {
                        return c(t, e - 1, t, e, i)
                    })
                }, e.prototype.getDataForRange = function (i, n, s, o) {
                    for (var r, a = s.unit, h = null, l = null, u = !1; a;) {
                        if (this.cache.hasOwnProperty(a)) {
                            var c = this.cache[a];
                            if (null !== c && c.from < n && c.to > i) {
                                h = c.from, l = c.to, r = c.values, u = h > i || n > l;
                                break
                            }
                        }
                        a = t.Base.TimeStep.toSmallerUnit[a]
                    }
                    null === a && (u = !0);
                    var p = !1;
                    if (u) {
                        u = !!this.dataSettings.dataFunction || !!this.dataSettings.url || !!this.dataSettings.urlByUnit;
                        var d = i, f = n;
                        null !== this.dataLimitFrom && (d = Math.max(this.dataLimitFrom, d)), null !== this.dataLimitTo && (f = Math.min(this.dataLimitTo, f));
                        var m = !1;
                        if (d >= h && (m = !0, d = Math.max(d, l)), l >= f && (f = Math.min(f, h)), u = u && f > d, u && (!this.dataSettings.minimizeRequests || !this.chart.scrolling.isActive()))for (var g = s.unit; g;) {
                            if (this.dataSettings.units.indexOf(g) > -1 && null !== this.cache[g]) {
                                p = this.scheduleDataLoading(g, d, f, m, o);
                                break
                            }
                            g = t.Base.TimeStep.toSmallerUnit[g]
                        }
                    }
                    if (a) {
                        var y = e.findSubrange(r, i, n), v = y.i0, S = y.i1;
                        return {
                            unit: s.unit,
                            count: s.count,
                            from: h,
                            to: l,
                            values: r,
                            startIndex: v,
                            endIndex: S,
                            loading: p
                        }
                    }
                    return p ? {
                            unit: s.unit,
                            count: s.count,
                            from: h,
                            to: l,
                            values: [],
                            startIndex: 0,
                            endIndex: 0,
                            loading: !0
                        } : {
                            unit: null,
                            count: null,
                            from: null,
                            to: null,
                            values: [],
                            startIndex: 0,
                            endIndex: 0,
                            loading: !1
                        }
                }, e.prototype.updateData = function (e, i, n) {
                    for (; e && !(this.dataSettings.units.indexOf(e) > -1);)e = t.Base.TimeStep.toSmallerUnit[e];
                    if (this.cache.hasOwnProperty(e) && !this.requests[e]) {
                        var s = new t.Base.TimeStep(e, 1), o = s.roundTimeUp(i), r = s.roundTimeDown(this.cache[e].lastTimestamp);
                        o >= r && this.scheduleDataLoading(e, r, o, !1, n)
                    }
                }, e.prototype.scheduleDataLoading = function (e, i, n, s, r) {
                    var a = this;
                    if (!e)throw"No unit";
                    this.chart.log("Scheduling data loading" + e + "," + i + "," + n);
                    var h = t.Base.Helpers.performanceNow();
                    if (this.requests.hasOwnProperty(e) && this.requests[e]) {
                        var l = this.requests[e];
                        if (!(l.time + this.dataSettings.requestTimeout < h))return this.chart.log("Already loading for selected period"), !0;
                        l.callback = null, delete this.requests[e]
                    }
                    var u = i, c = n, p = new t.Base.TimeStep(e, 1);
                    if (null !== u && (u = p.roundTimeDown(u)), null !== c && (c = p.roundTimeUp(c)), null !== u && null !== c) {
                        var d = (c - u) / p.approxTime();
                        d > this.dataSettings.requestMaxUnits && (s ? c = p.add(u, this.dataSettings.requestMaxUnits) : u = p.sub(c, this.dataSettings.requestMaxUnits))
                    }
                    var f = this.getBiggerDataUnit(e);
                    if (f) {
                        if (p = new t.Base.TimeStep(f, 1), null !== u) {
                            var m = p.roundTimeDown(u);
                            null !== this.dataLimitFrom && m <= this.dataLimitFrom && (u = this.dataLimitFrom)
                        }
                        if (null !== c) {
                            var g = p.roundTimeUp(c);
                            null !== this.dataLimitTo && g >= this.dataLimitTo && (c = this.dataLimitTo)
                        }
                    }
                    var y = this.getDataFunction(), v = new o(e, u, c, r, h);
                    if (y) {
                        var S = function (t) {
                            return a.dataReceivedRaw(v, t)
                        }, C = function () {
                            return a.dataFailed(v)
                        };
                        this.requests[e] = v, u = this.convertTimestampFromInternal(u), c = this.convertTimestampFromInternal(c), u === c && null !== c && c++;
                        var b = y(u, c, e, S, C);
                        return this.chart.log("Data requested " + e + ", " + u + ", " + c), (t.Base.Helpers.isObjectOrArray(b) || t.Base.Helpers.isString(b)) && (t.Base.Helpers.warn("Data object should not be returned directly from the `dataFunction` delegate - instead the `success` callback has to be called."), this.dataReceivedRaw(v, b)), !0
                    }
                    return this.chart.log("No data function. Cannot load data?"), !1
                }, e.prototype.dataReceivedRaw = function (t, e) {
                    this.scene.setMessage(this.dataId, null), delete this.requests[t.unit], this.dataArrived(t, e)
                }, e.prototype.dataArrived = function (e, i) {
                    this.chart.log("Data arrived");
                    var n = t.Base.Helpers.parseData(i, this.dataSettings.format, this.chart);
                    t.Base.Helpers.isObjectOrArray(i) && (n = this.cloneDataObject(n)), this.addDataInt(e, n)
                }, e.prototype.cloneDataObject = function (e) {
                    if (1 === this.convertTimestampToInternal(1))return e;
                    e = t.Base.Helpers.clone(e);
                    var i = e.values;
                    if (i) {
                        e.values = i = i.slice();
                        for (var n = 0; n < i.length; n++)i[n] = i[n].slice()
                    }
                    return e
                }, e.prototype.addData = function (t) {
                    t = this.cloneDataObject(t), this.addDataInt(null, t, !0)
                }, e.prototype.addDataInt = function (e, i, n) {
                    if (void 0 === n && (n = !1), null !== i) {
                        if (this.cleanupData(i), i.error)return "no-unit" === i.error && e && (this.cache[e.unit] = null), void this.chart.error(i.errormessage ? i.errormessage : i.error);
                        var s;
                        if (s = e ? this.analyzeData(i, e) : this.analyzeDataNoRequest(i, n), e && t.Base.TimeStep.timeUnitDiffs[s.unit] > t.Base.TimeStep.timeUnitDiffs[e.unit]) this.chart.error("Incorrect data - requested unit " + e.unit + ", got bigger unit - " + s.unit), this.cache[e.unit] = null, e.callback && e.callback(null, null, null); else {
                            if (e && s.unit !== e.unit && (this.cache[e.unit] = null), s.unit && null != s.from && null != s.to) {
                                var o = this.cache[s.unit];
                                o ? this.cache[s.unit].merge(s, this.dataSettings.cacheSize, this.chart, n) : this.cache[s.unit] = s
                            }
                            e && e.callback && e.callback(s.from, s.to, s.unit)
                        }
                        this.chart.events.notifySceneChanges({data: (r = {}, r[this.dataSettings.id] = !0, r)});
                        var r
                    }
                }, e.prototype.dataFailed = function (t) {
                    this.cache[t.unit] || (this.cache[t.unit] = null), this.scene.setMessage(this.dataId, this.chart.settings.localization.dataRequestFailed, 1e3), this.chart.error("Failed data loading request"), t.callback && t.callback(null, null, null)
                }, e.prototype.updateDataLimit = function (t, e, i, n, s) {
                    void 0 !== t && null !== t && (null === this.dataFrom || this.dataFrom > t) && (this.dataFrom = t), void 0 !== e && null !== e && (null === this.dataTo || this.dataTo < e) && (this.dataTo = e), void 0 !== i && null !== i && (this.dataLimitFrom = i, this.dataLimitFromUnit = s, this.dataFrom = Math.max(this.dataFrom, i)), void 0 !== n && null !== n && (this.dataLimitTo = n, this.dataLimitToUnit = s, this.dataTo = Math.min(this.dataTo, n))
                }, e.prototype.cleanupData = function (e) {
                    if (!e.error) {
                        e.error = "bad-response";
                        var i = "";
                        if (e.data && !e.values && (t.Base.Helpers.warn("Use of property `data` in the TimeChart data object (returned from the URL, dataFunction or preloaded property) is deprecated. Please use `values` instead.", null, !0), e.values = e.data), void 0 === e.unit && (i += "\nRequired field 'unit' not set in data"), void 0 === e.values && (i += "\nRequired field 'values' not set in data"), null != e.from && null === (e.from = t.Base.Helpers.tryParseFloat(e.from, null)) && (i += "Field 'from' is not a number."), null != e.to && null === (e.to = t.Base.Helpers.tryParseFloat(e.to, null)) && (i += "Field 'to' is not a number."), null != e.dataLimitFrom && null === (e.dataLimitFrom = t.Base.Helpers.tryParseFloat(e.dataLimitFrom, null)) && (i += "Field 'dataLimitFrom' is not a number."), null != e.dataLimitTo && null === (e.dataLimitTo = t.Base.Helpers.tryParseFloat(e.dataLimitTo, null)) && (i += "Field 'dataLimitTo' is not a number."), null === t.Base.TimeStep.parse(e.unit, void 0, !1) && (i += "Data error: unrecognized data unit: " + e.unit), i.length)return void(e.errormessage = i.substr(2));
                        e.error = null, null != e.from && null != e.to && e.from >= e.to && (this.chart.error("Data logic error. from >= to: " + e.from + ", " + e.to + ". The values will be ignored."), e.from = null, e.to = null), null != e.dataLimitFrom && null != e.dataLimitTo && e.dataLimitFrom >= e.dataLimitTo && (this.chart.error("Data logic error. dataLimitFrom >= dataLimitTo: " + e.dataLimitFrom + ", " + e.dataLimitTo + ". The values will be ignored."), e.dataLimitFrom = null, e.dataLimitTo = null);
                        var n, s, o = e.dataLimitFrom, r = e.dataLimitTo, a = -1e30, h = !1;
                        if (e.values.length > 0) {
                            for (var l = [], u = 0; u < e.values.length; u++) {
                                var c = e.values[u];
                                if (c instanceof Array) {
                                    for (var p = 0; p < c.length; p++) {
                                        var d = c[p];
                                        null !== d && "number" != typeof d && isNaN(c[p] = parseFloat(d)) && (this.chart.error("Data error: the value is not a number: values[" + u + "][" + p + "] = " + d), c[p] = null)
                                    }
                                    c.length && null !== c[0] && ((c[0] < o || c[0] > r) && this.chart.error("Data error: value timestamp outside data limits. values[" + u + "][0] = " + c[0] + ". Limits: " + o + "..." + r), a === c[0] && t.Base.Helpers.warn("There are multiple values given for the same timestamp " + c[0] + " which might produce invalid results."), a > c[0] && !h && (t.Base.Helpers.warn("Data values are not sorted on timestamp in ascending order (timestamp " + c[0] + "). TimeChart will sort the data automatically but to achieve better performance the data source should be sorted."), h = !0), a = c[0], c[0] = this.convertTimestampToInternal(c[0]), l.push(c))
                                } else this.chart.error("Data error: the value at index " + u + " is not an array.")
                            }
                            e.values = l, h && e.values.sort(function (t, e) {
                                return t[0] - e[0]
                            }), n = e.values[0][0], s = e.values[e.values.length - 1][0]
                        }
                        null != e.from && (e.from = this.convertTimestampToInternal(e.from), n < e.from && (t.Base.Helpers.warn("Data logic error. Data time " + n + " outside [from, to) range: " + e.from + ", " + e.to), e.from = n)), null != e.to && (e.to = this.convertTimestampToInternal(e.to), s >= e.to && (t.Base.Helpers.warn("Data logic error. Data time " + s + " outside [from, to) range: " + e.from + ", " + e.to), e.to = s + 1)), null != e.dataLimitFrom && (e.dataLimitFrom = this.convertTimestampToInternal(e.dataLimitFrom)), null != e.dataLimitTo && (e.dataLimitTo = this.convertTimestampToInternal(e.dataLimitTo))
                    }
                }, e.prototype.analyzeDataNoRequest = function (e, i) {
                    var n = this.dataSettings, o = e.from, r = e.to, a = t.Base.TimeStep.parse(e.unit), h = null, l = null;
                    (null == o || null == r) && e.values.length > 0 && (h = e.values[0][0], l = e.values[e.values.length - 1][0], h = a.roundTimeDown(h), l = a.roundTimeUp(l + 1), null == o && (o = h), null == r && (r = l)), null != n.dataFunction || null != n.url || null != e.dataLimitFrom || null != e.dataLimitTo || t.Base.Helpers.hasProperties(n.urlByUnit) || (t.Base.Helpers.warn("Using preloaded data without specifying `dataLimitFrom` and `dataLimitTo` is not recommended - these values will be implied from the data and might result in invalid behavior.", null, 1e30), null == e.dataLimitFrom && (e.dataLimitFrom = Math.min((i ? this.dataLimitFrom : 0) || 1e30, e.from || h)), null == e.dataLimitTo && (e.dataLimitTo = Math.max((i ? this.dataLimitTo : 0) || -1e30, e.to || l))), this.updateDataLimit(h, l, e.dataLimitFrom, e.dataLimitTo, a);
                    var u = new s(e.unit, o, r, e.values);
                    return null != e.error && (u.error = e.error), u
                }, e.prototype.analyzeData = function (e, i) {
                    null === i.from && null == e.from && null != e.dataLimitFrom && (e.from = e.dataLimitFrom), null === i.to && null == e.to && null != e.dataLimitTo && (e.to = e.dataLimitTo);
                    var n = e.from, o = e.to, r = null, a = null;
                    null != n && null != o && n >= o && this.chart.error("Data logic error. from >= to: " + n + ", " + o);
                    var h = t.Base.TimeStep.parse(e.unit);
                    if (e.values.length > 0 ? (r = e.values[0][0], a = e.values[e.values.length - 1][0], r = h.roundTimeDown(r), a = h.roundTimeUp(a + 1), null == n && (n = null !== i.from ? Math.min(i.from, r) : r), null == o && (o = null !== i.to ? Math.max(i.to, a) : a)) : (null == n && (n = i.from), null == o && (o = i.to), null != e.from && null != e.to ? (r = e.from, a = e.to) : (r = i.from, a = i.to, null !== i.from || null !== i.to || void 0 !== n && null !== n || void 0 !== o && null !== o || null != e.dataLimitFrom || null != e.dataLimitTo || (this.noData = !0, e.dataLimitFrom = 0, e.dataLimitTo = 0, e.from = 0, e.to = 0))), this.updateDataLimit(r, a, e.dataLimitFrom, e.dataLimitTo, h), null !== i.from && null != e.to) {
                        var l = h.roundTimeDown(e.to);
                        l <= i.from && this.updateDataLimit(null, null, null, e.to, h)
                    }
                    if (null !== i.to && null != e.from) {
                        var u = h.roundTimeUp(e.from);
                        u >= i.to && this.updateDataLimit(null, null, e.from, null, h)
                    }
                    null == e.from && null == e.dataLimitFrom && (null !== this.dataLimitFrom && (null === i.from || i.from <= this.dataLimitFrom && r > this.dataLimitFrom) || null === this.dataLimitFrom && (void 0 === i.from || null === i.from)) && (this.updateDataLimit(null, null, r, null, h), n = r), null == e.to && null == e.dataLimitTo && (null !== this.dataLimitTo && (null === i.to || i.to >= this.dataLimitTo && a < this.dataLimitTo) || null === this.dataLimitTo && (void 0 === i.to || null === i.to)) && (this.updateDataLimit(null, null, null, a, h), o = a);
                    var c = new s(e.unit, n, o, e.values);
                    return e.error && (c.error = e.error), c
                }, e.prototype.getBiggerDataUnit = function (e) {
                    for (; e;) {
                        e = t.Base.TimeStep.toBiggerUnit[e];
                        var i = this.dataSettings.units;
                        if (i.indexOf(e) > -1)return e
                    }
                    return null
                }, e.prototype.getDataFunction = function () {
                    var e = this, i = this.dataSettings;
                    return i.dataFunction ? i.dataFunction : i.url || t.Base.Helpers.hasProperties(i.urlByUnit) ? function (n, s, o, r, a) {
                                var h;
                                if (t.Base.Helpers.hasProperties(i.urlByUnit)) {
                                    if (h = i.urlByUnit[o], !h)return '{"error":"no-unit", "errormessage":"no data url for this time unit: ' + o + '"}'
                                } else h = i.url;
                                if (!o)throw"No step";
                                var l = [];
                                null !== n && l.push(["from", n]), null !== s && l.push(["to", s]), l.push(["unit", o]), t.Base.Data.doRequest(h, e.dataSettings, l, r, a)
                            } : null
                }, e.prototype.hasPendingRequests = function () {
                    return t.Base.Helpers.hasProperties(this.requests)
                }, e.prototype.convertTimestampToInternal = function (t) {
                    if (null == t)return null;
                    var e = this.dataSettings, i = this.chart.settings.timeAxis;
                    return e.timestampInSeconds && (t *= 1e3), t -= 6e4 * e._computedTimeZoneOffset, t += 6e4 * i._computedTimeZoneOffset
                }, e.prototype.convertTimestampFromInternal = function (t) {
                    if (null == t)return null;
                    var e = this.dataSettings, i = this.chart.settings.timeAxis;
                    return t += 6e4 * e._computedTimeZoneOffset, t -= 6e4 * i._computedTimeZoneOffset, e.timestampInSeconds && (t /= 1e3), t
                }, e
            }();
            e.Data = n;
            var s = function () {
                function t(t, e, i, n) {
                    this.unit = "m", this.from = 0, this.to = 1e3, this.lastTimestamp = 0, this.values = null, this.error = null, this.values = n, this.to = i, this.from = e, this.unit = t, this.updateLastTimestamp()
                }

                return t.prototype.updateLastTimestamp = function () {
                    this.lastTimestamp = this.values.length > 0 ? this.values[this.values.length - 1][0] : 0
                }, t.prototype.merge = function (t, e, i, n) {
                    if (!n && (this.from > t.to || this.to < t.from))return this.values = t.values, this.from = t.from, void(this.to = t.to);
                    t.values.length > 0 && t.from > t.values[0][0] && i.error("Data merge - oldest data before from"), t.values.length > 0 && t.to < t.values[t.values.length - 1][0] && i.error("Data merge - newest data after to");
                    for (var s = 0; s < this.values.length && this.values[s][0] < t.from;)s += 1;
                    for (var o = this.values.length; o > 0 && this.values[o - 1][0] >= t.to;)o -= 1;
                    var r = t.values;
                    if (this.from = Math.min(this.from, t.from), this.to = Math.max(this.to, t.to), s > 0) {
                        var a = Math.max(0, r.length + s - e);
                        r = this.values.slice(a, s - 1 + 1).concat(r), a > 0 && (this.from = this.values[a - 1][0] + 1)
                    }
                    if (o < this.values.length) {
                        var h = this.values.length - o;
                        h = Math.min(h, e - r.length), r = r.concat(this.values.slice(o, o + h + 1)), h < this.values.length - o && (this.to = this.values[o + h][0])
                    }
                    this.values = r, this.updateLastTimestamp()
                }, t
            }();
            e.TimeData = s;
            var o = function () {
                function t(t, e, i, n, s) {
                    this.from = null, this.to = null, this.time = 0, this.unit = "y", this.callback = null, this.time = s, this.callback = n, this.to = i, this.from = e, this.unit = t
                }

                return t
            }();
            e.RequestData = o
        }(e = t.TimeChart || (t.TimeChart = {}))
    }(e = t.Internal || (t.Internal = {}))
}(ZoomCharts || (ZoomCharts = {}));
var ZoomCharts;
!function (t) {
    var e;
    !function (t) {
        var e;
        !function (e) {
            var i = function (e) {
                function i(i) {
                    e.call(this), this.animationOrder = 1e3, this.chart = null, this.scene = null, this.events = null, this._minDisplayRange = 0, this.pointer1 = null, this.pointer2 = null, this.t1 = 0, this.t2 = 0, this.x1 = 0, this.x2 = 0, this.scaleOrigin = null, this.initialZoom = null, this.dragStartFrom = null, this.dragStartTo = null, this.active = !1, this.lastScrollingY = 0, this.scrollingActive = !1, this.scalingActive = !1, this.highlight = null, this.highlightRemoveWhenDone = !1, this._animationsDone = !0, this.chart = i, this.scene = this.chart.scene, this.events = this.chart.events, this.inertiaF = new t.Base.Inertia(1, 0, !0), this.inertiaT = new t.Base.Inertia(1, 0, !0)
                }

                return __extends(i, e), i.prototype.xyInArea = function () {
                    return !1
                }, i.prototype.xyToPosition = function () {
                    return 0
                }, i.prototype.getVisibleRange = function () {
                    return this._currentTo - this._currentFrom
                }, i.prototype.onStartDragging = function () {
                }, i.prototype.onSnapWhileDragging = function (t, e) {
                    return {from: t, to: e}
                }, i.prototype.onSnapAfterDragging = function (t, e) {
                    return {from: t, to: e}
                }, i.prototype.onZoomOut = function (t, e, i, n) {
                    return null == n && (n = 2), {
                        from: i - (i - t) * n,
                        to: i + (e - i) * n,
                        center: i
                    }
                }, i.prototype.onZoomIn = function (t, e, i, n) {
                    return void 0 === n && (n = .5), null == n && (n = .5), {
                        from: i - (i - t) * n,
                        to: i + (e - i) * n,
                        center: i
                    }
                }, i.prototype.onScroll = function (t, e, i) {
                    return "<" === i ? {from: 2 * t - e, to: t} : {from: e, to: 2 * e - t}
                }, i.prototype.onGoHome = function (t, e) {
                    return {from: t, to: e, origin: e}
                }, i.prototype.onPositionChanged = function () {
                }, i.prototype.onAnimationDone = function () {
                }, i.prototype.getFrom = function (t) {
                    return this.inertiaF.getValue(t)
                }, i.prototype.getTo = function (t) {
                    return this.inertiaT.getValue(t)
                }, i.prototype.setFrom = function (t, e, i) {
                    void 0 === e && (e = !1), this._currentFrom = t, e ? (this.inertiaF.setTarget(t, i), this._animationsDone = !1) : this.inertiaF.jump(t)
                }, i.prototype.setTo = function (t, e, i) {
                    void 0 === e && (e = !1), this._currentTo = t, e ? (this.inertiaT.setTarget(t, i), this._animationsDone = !1) : this.inertiaT.jump(t)
                }, i.prototype.onWheel = function (e) {
                    var i = t.Base.Helpers.performanceNow(), n = this.getFrom(i), s = this.getTo(i);
                    if (s > n && this.xyInArea(e.x, e.y) && this.scene.settings.interaction.zooming.wheel && this.scene.settings.interaction.zooming.enabled) {
                        this.active = !0;
                        var o = null !== this.scaleOrigin ? this.scaleOrigin : this.xyToPosition(e.x, e.y), r = Math.pow(1 + this.scene.settings.interaction.zooming.sensitivity, .004 * e.wheely);
                        n = (n - o) * r + o, s = (s - o) * r + o;
                        var a = this.onSnapAfterDragging(n, s, o, !1, !0);
                        a && (this.goToPosition(a.from, a.to, !0, i), null !== this.pointer1 && (this.scalingActive = !0)), e.consumed = !0, this.active = !1
                    }
                }, i.prototype.onPointerDown = function (e) {
                    var i = t.Base.Helpers.performanceNow();
                    if (this.xyInArea(e.x, e.y) && (this.scene.settings.interaction.scrolling.enabled || this.scene.settings.interaction.zooming.enabled)) {
                        var n = this.xyToPosition(e.x, e.y), s = this.getFrom(i), o = this.getTo(i);
                        if (s > o) {
                            var r = o;
                            o = s, s = r
                        }
                        null === this.pointer1 ? (this.pointer1 = e.identifier, this.x1 = e.x, this.t1 = n, this.scaleOrigin = n, this.onStartDragging(s, o, n), this.lastScrollingY = e.y, this.dragStartFrom = s, this.dragStartTo = o, this.dragCurFrom = s, this.dragCurTo = o, e.consumed = !0, this.inertiaF.finished(i) && this.inertiaT.finished(i) || (this.setFrom(s), this.setTo(o), this.stopAnimations(), this.scrollingActive = !0), this.chart.cancelChartUpdateNotify(), e.noDefault = !0) : null === this.pointer2 ? (this.pointer2 = e.identifier, this.x2 = e.x, this.t2 = n, this.initialZoom = o - s, this.scaleOrigin = (this.t1 + this.t2) / 2, e.consumed = !0) : (this.scalingActive || this.scrollingActive) && (e.consumed = !0)
                    }
                }, i.prototype.xyToDragPosition = function (t) {
                    return this.dragCurFrom + (t - this.scene.x0) / this.scene.width * (this.dragCurTo - this.dragCurFrom)
                }, i.prototype.onPointerDrag = function (t) {
                    var e = this.dragCurFrom, i = this.dragCurTo;
                    if (t.identifier === this.pointer1 && null === this.pointer2) {
                        if (this.scaleOrigin = this.t1, this.x1 = t.x, Math.abs(t.dx) > Math.abs(t.dy) ? (this.lastScrollingY = t.y, Math.abs(t.dx) > 4 * Math.abs(t.dy) && this.scene.settings.interaction.scrolling.enabled && (this.scrollingActive = !0)) : this.scene.settings.interaction.zooming.enabled && this.scene.settings.interaction.zooming.swipe && Math.abs(this.lastScrollingY - t.y) > this.scene.settings.interaction.zooming.upDownTreshold && (this.scalingActive = !0), this.scalingActive) {
                            this.clearZoomHighlight();
                            var n = Math.pow(1 + this.scene.settings.interaction.zooming.sensitivity, -t.dy / this.scene.height);
                            e = (e - this.scaleOrigin) * n + this.scaleOrigin, i = (i - this.scaleOrigin) * n + this.scaleOrigin, t.consumed = !0
                        }
                        if (this.scrollingActive) {
                            var s = this.xyToDragPosition(t.x, t.y), o = this.t1 - s;
                            e += o, i += o
                        }
                    } else if (t.identifier === this.pointer1 && this.scene.settings.interaction.scrolling.enabled) {
                        this.x1 = t.x, this.clearZoomHighlight();
                        var r = this.twoPointerDrag();
                        e = r.from, i = r.to
                    } else {
                        if (t.identifier !== this.pointer2 || !this.scene.settings.interaction.scrolling.enabled)return void((this.scalingActive || this.scrollingActive) && (t.consumed = !0));
                        this.x2 = t.x, this.clearZoomHighlight();
                        var r = this.twoPointerDrag();
                        e = r.from, i = r.to
                    }
                    this.dragCurFrom = e, this.dragCurTo = i;
                    var a = this.onSnapWhileDragging(e, i, this.scaleOrigin, this.scrollingActive, this.scalingActive);
                    e = a.from, i = a.to, this.goToPositionDragging(e, i), t.consumed = !0
                }, i.prototype.twoPointerDrag = function () {
                    var t = this.scene.settings.interaction.zooming.fingersMaxZoom;
                    this.scaleOrigin = (this.t1 + this.t2) / 2;
                    var e = this.t2 - this.t1, i = this.dragCurFrom, n = this.dragCurTo, s = this.xyToDragPosition(this.x1, 0), o = this.xyToDragPosition(this.x2, 0);
                    if (this.scene.settings.interaction.scrolling.enabled && this.scene.settings.interaction.zooming.enabled && this.scene.settings.interaction.zooming.fingers && 0 !== e) {
                        var r, a = (this.t1 + this.t2) / 2, h = ((s + o) / 2 - this._currentFrom) / (this._currentTo - this._currentFrom), l = (o - s) / (this._currentTo - this._currentFrom);
                        r = e * l > 0 ? e / l : 1 / 0;
                        var u = this.initialZoom * t, c = Math.max(this.initialZoom / t, this._minDisplayRange);
                        r = Math.max(c, Math.min(u, r)), i = a - h * r, n = a + (1 - h) * r, this.scalingActive = !0, this.scrollingActive = !0
                    } else if (this.scene.settings.interaction.scrolling.enabled) {
                        var p = (this.t1 + this.t2) / 2, d = (s + o) / 2, f = p - d;
                        i += f, n += f, this.scrollingActive = !0
                    }
                    return {from: i, to: n}
                }, i.prototype.onPointerUp = function (e) {
                    var i = this.scene.settings.interaction, n = t.Base.Helpers.performanceNow();
                    if (e.identifier === this.pointer2) this.pointer2 = null, e.consumed = !0, this.scaleOrigin = this.t1; else if (e.identifier === this.pointer1 && null !== this.pointer2) this.pointer1 = this.pointer2, this.pointer2 = null, this.t1 = this.t2, this.scaleOrigin = this.t1, e.consumed = !0; else if (e.identifier === this.pointer1) {
                        this.pointer1 = null, this.active = !0;
                        var s, o, r;
                        if (i.scrolling.enabled) {
                            r = -e.vx, r = r > 0 ? Math.min(r, .002 * this.scene.width) : Math.max(r, .002 * -this.scene.width);
                            var a = this.getVisibleRange();
                            r = r * a / this.scene.width
                        } else r = 0;
                        if (this.updateFriction(n), this.inertiaF.jump(this._currentFrom, r, n), this.inertiaT.jump(this._currentTo, r, n), this._animationsDone = !1, i.scrolling.swipePageFlipping && e.swipeUp && this.scalingActive && e.swipeSpeed > this.scene.height / i.swipeSensitivity) {
                            var h = this.onZoomOut(this.dragStartFrom, this.dragStartTo, this.scaleOrigin);
                            s = h.from, o = h.to
                        } else if (i.scrolling.swipePageFlipping && e.swipeDown && this.scalingActive && e.swipeSpeed > this.scene.height / i.swipeSensitivity) {
                            var l = this.onZoomIn(this.dragStartFrom, this.dragStartTo, this.scaleOrigin);
                            s = l.from, o = l.to
                        } else if (this.scrollingActive || this.scalingActive) {
                            if (this.scrollingActive && !this.scalingActive && i.scrolling.swipePageFlipping && (e.swipeLeft || e.swipeRight) && e.swipeSpeed > this.scene.width / i.swipeSensitivity * .7) {
                                var u = e.swipeLeft ? "<" : ">", c = this.onScroll(this.dragStartFrom, this.dragStartTo, u);
                                s = c.from, o = c.to
                            } else s = this._currentFrom, o = this._currentTo;
                            this.scaleOrigin = (s + o) / 2
                        }
                        if (s || o) {
                            var p = this.onSnapAfterDragging(this.inertiaF.getTargetValue(), this.inertiaT.getTargetValue(), this.scaleOrigin, this.scrollingActive, this.scalingActive);
                            p && this.goToPosition(p.from, p.to, !0, n), e.consumed = !0, this.scaleOrigin = null
                        }
                        this.active = !1, this.dragStartFrom = null, this.dragStartTo = null, this.scalingActive = !1, this.scrollingActive = !1
                    } else(this.scalingActive || this.scrollingActive) && (e.consumed = !0)
                }, i.prototype.onPointerCancel = function (t) {
                    t.identifier === this.pointer2 ? (this.pointer2 = null, this.scaleOrigin = this.t1) : t.identifier === this.pointer1 && null !== this.pointer2 ? (this.pointer1 = this.pointer2, this.t1 = this.t2, this.scaleOrigin = this.t1, this.pointer2 = null, this.t2 = null) : t.identifier === this.pointer1 && (this.active = !0, this.pointer1 = null, this.t1 = null, this.scaleOrigin = null, this.dragStartFrom = null, this.dragStartTo = null, this.scalingActive = !1, this.scrollingActive = !1, this.active = !1)
                }, i.prototype.onKeyDown = function (t) {
                    var e = t.timeStamp;
                    this.active = !0;
                    var i = this.getFrom(e), n = this.getTo(e);
                    if (n > i) {
                        var s = (i + n) / 2, o = !1, r = !1;
                        if (37 === t.keyCode) {
                            o = !0;
                            var a = this.onScroll(i, n, "<");
                            i = a.from, n = a.to, s = (i + n) / 2
                        } else if (39 === t.keyCode) {
                            o = !0;
                            var a = this.onScroll(i, n, ">");
                            i = a.from, n = a.to, s = (i + n) / 2
                        } else if (36 === t.keyCode) {
                            r = !0, o = !0;
                            var h = this.onGoHome(i, n);
                            i = h.from, n = h.to, s = h.origin
                        } else if (38 === t.keyCode) {
                            var l = this.scene.settings.interaction.zooming.keyboardFactor;
                            r = !0;
                            var u = this.onZoomOut(i, n, s, l);
                            i = u.from, n = u.to, s = u.center
                        } else if (40 === t.keyCode) {
                            var l = 1 / this.scene.settings.interaction.zooming.keyboardFactor;
                            r = !0;
                            var c = this.onZoomIn(i, n, s, l);
                            i = c.from, n = c.to
                        }
                        if (r || o) {
                            var p = this.onSnapAfterDragging(i, n, s, o, r);
                            p && this.goToPosition(p.from, p.to, !0, e), t.consumed = !0
                        }
                        this.active = !1
                    }
                }, i.prototype.goToPositionDragging = function (t, e) {
                    this.setFrom(t), this.setTo(e), this.clearZoomHighlight(), this.onPositionChanged(t, e)
                }, i.prototype.goToPosition = function (t, e, i, n) {
                    if (e > t)if (this._currentFrom < this._currentTo || (i = !1), this.stopAnimations(), i) {
                        var s = this._currentFrom, o = this._currentTo;
                        this.updateFriction(n, t, e), this.setFrom(t, !0, n), this.setTo(e, !0, n);
                        var r = Math.abs((t - e) / (s - o + 1));
                        if (r < 1 / this.scene.settings.interaction.zooming.zoomHighlightThreshold) this.setZoomHighlight(t, e, !0); else if (r > this.scene.settings.interaction.zooming.zoomHighlightThreshold) {
                            var a = null !== this.dragStartFrom ? this.dragStartFrom : s, h = null !== this.dragStartTo ? this.dragStartTo : o;
                            this.setZoomHighlight(a, h, !1)
                        }
                        this.events.notifySceneChanges({animation: !0})
                    } else this.setFrom(t), this.setTo(e), this.clearZoomHighlight(), this.onPositionChanged(t, e), this.onAnimationDone(t, e)
                }, i.prototype.doAnimations = function (t) {
                    if (!this._animationsDone) {
                        var e = t.timeStamp, i = this.inertiaF.finished(e), n = this.inertiaT.finished(e);
                        this._animationsDone = i && n;
                        var s = this._currentFrom = this.getFrom(e), o = this._currentTo = this.getTo(e);
                        this._animationsDone || isNaN(s + o) ? (this.stopAnimations(), this.onPositionChanged(s, o), this.onAnimationDone(s, o)) : (this.onPositionChanged(s, o), t.animating = !0)
                    }
                }, i.prototype.stopAnimations = function () {
                    this.highlight && (this.highlightRemoveWhenDone ? this.clearZoomHighlight() : (this.highlight.style.fillColor = this.scene.settings.area.style.zoomHighlightInactive.fillColor, this.events.notifySceneChanges({highlight: !0})))
                }, i.prototype.isActive = function () {
                    return this.active || this.pointer1
                }, i.prototype.clearZoomHighlight = function () {
                    this.highlight && (this.scene.removeHighlight("zoomTrace"), this.highlight = null, this.events.notifySceneChanges({highlight: !0}))
                }, i.prototype.setZoomHighlight = function (t, e, i) {
                    this.highlight = this.scene.setHighlight("zoomTrace", t, e, this.scene.settings.area.style.zoomHighlight), this.highlightRemoveWhenDone = i, this.events.notifySceneChanges({highlight: !0})
                }, i.prototype.updateFriction = function (t, e, i) {
                    var n = this.getVisibleRange();
                    if (null != e && null != i) {
                        var s = i - e, o = .3, r = n * (1 - o) > s, a = s > n * (1 + o);
                        a && (n = s), (r || a) && (n *= 2)
                    }
                    var h = n * this.scene.settings.interaction.scrolling.kineticFriction;
                    this.inertiaF.setAcceleration(h, t), this.inertiaT.setAcceleration(h, t)
                }, i
            }(t.Base.ChartElement);
            e.Scrolling = i
        }(e = t.LinearChart || (t.LinearChart = {}))
    }(e = t.Internal || (t.Internal = {}))
}(ZoomCharts || (ZoomCharts = {}));
var ZoomCharts;
!function (t) {
    var e;
    !function (t) {
        var e;
        !function (e) {
            var i = function (t) {
                function e() {
                    t.apply(this, arguments), this.limitMode = "snapBack", this.limitFrom = "oldestData", this.limitTo = "newestData", this.overscrollProportion = 0
                }

                return __extends(e, t), e
            }(t.LinearChart.SettingsInteractionScrolling);
            e.SettingsInteractionScrolling = i;
            var n = function (i) {
                function n(t) {
                    i.call(this, t), this.animationOrder = 600, this.paintOrder = 10, this.updateOrder = 1400, this.animationUnit = null, this.targetUnit = null, this.dragStartBar0 = null, this.dragStartBar1 = null, this.dragStartUnit = null, this.s = new e.TimeSetup(this.scene.settings)
                }

                return __extends(n, i), n.prototype.setTimeRangeSnap = function (t, e, i, n, s, o, r, a) {
                    var h = this.snap(t, e, i, n, r, a);
                    t = h.from, e = h.to;
                    var l = h.unit, u = h.period, c = h.anchor;
                    this.setTimeRange(t, e, l, s, o, c, u)
                }, n.prototype.computeDisplayPeriod = function (t, e, i, n, s) {
                    var o = this.s.tryComputeDisplayPeriod(t, e, i, n, s, this.scene, this.scene.getCurTime()), r = o.from, a = o.to, h = o.unit;
                    return null === r || null === a ? {
                            from: null,
                            to: null,
                            unit: null
                        } : this.computeTimeRangeExtend(r, a, h)
                }, n.prototype.computeTimeRangeExtend = function (t, e, i) {
                    i || (i = this.s.computeDisplayUnit(this.scene.timeStart, this.scene.timeEnd, this.scene.displayUnit, t, e, this.scene)), t = i.roundTimeDown(t), e = i.roundTimeUp(e), e === t && (e = i.add(e, 1));
                    var n = this._preventOverscroll(t, e, i, !0);
                    return t = n.from, e = n.to, {from: t, to: e, unit: i}
                }, n.prototype.computeDisplayUnit = function (t, e) {
                    var i = null !== this.dragStartFrom ? this.dragStartFrom : this.scene.timeStart, n = null !== this.dragStartTo ? this.dragStartTo : this.scene.timeEnd, s = this.dragStartUnit ? this.dragStartUnit : this.scene.displayUnit;
                    return this.s.computeDisplayUnit(i, n, s, t, e, this.scene)
                }, n.prototype.setTimeRange = function (e, i, n, s, o, r, a) {
                    void 0 === r && (r = null), void 0 === a && (a = null), (i > e || n) && (e = Math.round(e), i = Math.round(i), !n && i > e && (n = this.computeDisplayUnit(e, i)), e === this.getFrom(1 / 0) && i === this.getTo(1 / 0) && n.isEqual(this.scene.displayUnit) || (this.scene.anchor = r, this.scene.period = a, this.targetUnit = n, this.animationUnit = !n || this.scene.displayUnit && n.toString() !== this.scene.displayUnit.toString() ? null : n, this.goToPosition(e, i, s, t.Base.Helpers.performanceNow()), this.events.notifySceneChanges({time: !0}), o && this.chart.notifyTimeChanged(e, i, n, o)))
                }, n.prototype.zoomOut = function (t, e, i, n, s) {
                    var o = (e + i) / 2, r = this.computeZoomOut(e, i, t);
                    e = r.from, i = r.to, this.setTimeRangeSnap(e, i, o, null, n, s, !1, !0)
                }, n.prototype.zoomIn = function (t, e, i, n, s, o) {
                    null === e && (e = (i + n) / 2);
                    var r = this.onZoomIn(i, n, e, .5);
                    i = r.from, n = r.to, this.setTimeRangeSnap(i, n, e, t, s, o, !1, !0)
                }, n.prototype.xyInArea = function (t, e) {
                    return this.scene.xyInChart(t, e)
                }, n.prototype.xyToPosition = function (t) {
                    return this.scene.xToTime(t)
                }, n.prototype.onZoomOut = function (t, e, n, s) {
                    return void 0 === s && (s = null), s ? i.prototype.onZoomOut.call(this, t, e, n, s) : this.computeZoomOut(t, e, null)
                }, n.prototype.onZoomIn = function (t, e, n, s) {
                    if (void 0 === s && (s = null), s)return i.prototype.onZoomIn.call(this, t, e, n, s);
                    if (this.dragStartBar0 && (t = this.dragStartBar0, e = this.dragStartBar1, e - t > this.scene.timeEnd - this.scene.timeStart)) {
                        var o = this.scene.getClickBar(n);
                        t = o.time0, e = o.time1
                    }
                    return {from: t, to: e, center: (t + e) / 2}
                }, n.prototype.onScroll = function (t, e, i) {
                    return this.s.scroll(t, e, this.scene.displayUnit, i, 1, "page")
                }, n.prototype.onGoHome = function (t, e) {
                    var i = this.scene.getDisplayLimits().to;
                    if (null === i)return {from: t, to: e, origin: null};
                    this.scene.anchor = "newestData";
                    var n = e - t;
                    return {from: i - n, to: i, origin: i}
                }, n.prototype.onStartDragging = function (t, e, i) {
                    this.scene.anchor = null, this.animationUnit = null, this.scene.anchor = null, this.dragStartUnit = this.scene.displayUnit;
                    var n = this.scene.getClickBar(i);
                    this.dragStartBar0 = n.time0, this.dragStartBar1 = n.time1
                }, n.prototype.onSnapWhileDragging = function (t, e, i) {
                    this._minDisplayRange = this.scene.settings._minDisplayRange;
                    var n = this._preventOverscale(t, e, null, i, !1);
                    t = n.from, e = n.to;
                    var s = this.computeDisplayUnit(t, e), o = this._preventOverscroll(t, e, s, !1);
                    return t = o.from, e = o.to, this.events.notifySceneChanges({time: !0}), {
                        from: t,
                        to: e
                    }
                }, n.prototype.onSnapAfterDragging = function (t, e, i, n, s) {
                    var o = this.snap(t, e, i, null, n, s);
                    t = o.from, e = o.to;
                    var r = o.unit, a = o.period, h = o.anchor;
                    return this.targetUnit = r, this.animationUnit = !s || r && this.scene.displayUnit.isEqual(r) ? this.scene.displayUnit : null, this.scene.period = a, this.scene.anchor = h, this.dragStartBar0 = null, this.dragStartBar1 = null, this.dragStartFrom = null, this.dragStartTo = null, this.dragStartUnit = null, this.events.notifySceneChanges({time: !0}), this.chart.notifyTimeChanged(t, e, r, "user"), {
                        from: t,
                        to: e
                    }
                }, n.prototype.onPositionChanged = function (t, e) {
                    if (!isNaN(t) || !isNaN(e)) {
                        var i;
                        i = this.animationUnit ? this.animationUnit : this.computeDisplayUnit(t, e), this.scene.setTimeRange(t, e, i), this.chart.timeStart = t, this.chart.timeEnd = e, this.chart.displayUnit = i, this.events.notifySceneChanges({
                            position: !0,
                            time: !0
                        })
                    }
                }, n.prototype.onAnimationDone = function (t, e) {
                    if (this.targetUnit) {
                        var i = this.targetUnit ? this.targetUnit : this.computeDisplayUnit(t, e);
                        this.chart.displayUnit = i, this.scene.setTimeRange(t, e, i)
                    }
                    this.targetUnit = null, this.animationUnit = null, this.chart.notifyAnimationDone()
                }, n.prototype.computeZoomOut = function (t, e, i) {
                    return i || (i = this.s.getBiggerDisplayPeriod(this.scene.timeStart, this.scene.timeEnd)), i ? (t = i.roundTimeDown(t), e = i.roundTimeUp(e), {
                            from: t,
                            to: e,
                            center: (t + e) / 2
                        }) : {from: t, to: e, center: (t + e) / 2}
                }, n.prototype.snap = function (t, e, i, n, s, o) {
                    if ((o || s) && this.scene.settings.interaction.scrolling.limitMode) {
                        var r = this._preventOverscale(t, e, n, i, !0);
                        t = r.from, e = r.to
                    }
                    var a;
                    if (a = n ? n : o ? this.computeDisplayUnit(t, e) : this.scene.displayUnit, s || o) {
                        var h = e - t, l = this._preventOverscroll(t, e, a, !1);
                        t = l.from, e = l.to, l = this._preventOverscroll(t, e, a, !0), t = l.from, e = l.to, o = o || e - t !== h
                    }
                    if (!n && o)return a = this.computeDisplayUnit(t, e), this.snap(t, e, i, a, s, o);
                    var u = o ? null : this.scene.period, c = this.scene.anchor, p = this.scene.settings.interaction.snapMode;
                    if (p) {
                        var d, f = "y" === this.scene.majorTimeUnit.unit;
                        if ("displayUnit" === p) d = a; else if ("multiperiod" === p || "period" === p) {
                            var m = e - t, g = this.scene.getDisplayLimits(), y = g.from, v = g.to;
                            null !== y && (m = Math.min(m, v - y));
                            var S = this.s.getClosestDisplayPeriod(m, this.scene.majorTimeUnit, "multiperiod" === p || f);
                            a = S, d = S, u = S.toString()
                        }
                        if ("period" !== p || f)if (o) t = d.roundTimeRound(t), e = d.roundTimeRound(e); else {
                            var C = Math.max(d.numberOfUnits(t, e), 1), b = Math.abs(d.roundTimeRound(t) - t), x = Math.abs(d.roundTimeRound(e) - e);
                            x > b ? (t = d.roundTimeRound(t), e = d.add(t, C)) : (e = d.roundTimeRound(e), t = d.sub(e, C))
                        } else t = d.roundTimeDown(i), e = d.add(t, 1)
                    } else t = Math.round(t), e = Math.round(e);
                    return {from: t, to: e, unit: a, period: u, anchor: c}
                }, n.prototype._snapToAnchor = function (t, e, i) {
                    var n, s;
                    if ("now" === this.scene.anchor ? (n = this.scene.getCurTime(), s = -1) : "newestData" === this.scene.anchor && (n = this.scene.mainData.dataTo, s = -1), null !== n && -1 === s && e > n) {
                        var o = n - e;
                        e = i.roundTimeUp(e + o), t = i.roundTimeUp(t + o)
                    }
                    return {from: t, to: e}
                }, n.prototype._preventOverscroll = function (t, e, i, n) {
                    var s = this.scene.getDisplayLimits(), o = s.from, r = s.to;
                    return this.s.preventOverscroll(i, t, e, o, r, this.scene.getCurTime(), n)
                }, n.prototype._preventOverscale = function (t, e, i, n, s) {
                    var o, r = this.scene.getDisplayLimits(), a = r.from, h = r.to;
                    return i ? o = [i] : (i = this.scene.displayUnit, o = this.scene.settings._displayUnitsParsed), this.s.preventOverscale(this.scene, o, n, t, e, i, a, h, this.scene.getCurTime(), s)
                }, n
            }(t.LinearChart.Scrolling);
            e.Scrolling = n
        }(e = t.TimeChart || (t.TimeChart = {}))
    }(e = t.Internal || (t.Internal = {}))
}(ZoomCharts || (ZoomCharts = {}));
var ZoomCharts;
!function (t) {
    var e;
    !function (t) {
        var e;
        !function (e) {
            var i = function () {
                function t() {
                    this.enabled = !0, this.tolerance = 6
                }

                return t
            }();
            e.SettingsInteractionSelection = i;
            var n = function (e) {
                function i(t) {
                    e.call(this), this.animationOrder = 500, this.paintOrder = 15, this.updateOrder = 1300, this.chart = t, this.scene = t.scene, this.selectStart = null, this.selectingPointer = null, this.isSelecting = !1, this.lastX = 0, this.lastY = 0, this.roundAround = !1, this.selectionRemoved = !1
                }

                return __extends(i, e), i.prototype.onSceneChange = function (t) {
                    (t.changes.time || t.changes.bounds) && null !== this.selectStart && this.dragPointer(this.lastX, this.lastY, t.changes)
                }, i.prototype.paintScene = function (e) {
                    if (this.scene.selectionStart && this.scene.selectionEnd) {
                        var i = Math.round(this.scene.x0), n = Math.round(i + this.scene.width), s = Math.round(this.scene.y0), o = Math.round(s + this.scene.height + this.scene.bottomAxisSize), r = Math.round(this.scene.timeToX(this.scene.selectionStart)), a = Math.round(this.scene.timeToX(this.scene.selectionEnd)), h = this.scene.height + this.scene.bottomAxisSize, l = t.moment(this.scene.selectionStart).utc().format(this.scene.minorTimeFormat), u = t.moment(Math.max(this.scene.selectionStart, this.scene.selectionEnd - 1)).utc().format(this.scene.minorTimeFormat), c = e.context;
                        t.Base.Graphics.pushClip(c, i, s, this.scene.width, h), t.Base.Graphics.rectStyle(c, this.scene.settings.area.style.selection), c.fillRect(r, s, a - r, h), c.beginPath(), c.moveTo(r, s), c.lineTo(r, o), c.moveTo(a, s), c.lineTo(a, o), t.Base.Graphics.stroke(c, this.scene.settings.area.style.selection);
                        var p = e.labelRenderer, d = c.measureText(l).width, f = c.measureText(u).width, m = new t.Base.Label, g = new t.Base.Label;
                        m.text = l, g.text = u, m.textStyle = g.textStyle = this.scene.settings.area.style.selectionLabel;
                        var y = 10, v = 5;
                        i > r && (r = i), a > n && (a = n), a - r > d + f + 20 ? (r += v, a = a - f - v) : (r = r - d - v, a += v);
                        var S = this.chart.shell.getChartInnerArea(), C = S.findTopPosition(r, r + d), b = S.findTopPosition(a, a + f);
                        p.paintWithStyle(c, r + d / 2, C + y, 1, m, m), p.paintWithStyle(c, a + f / 2, b + y, 1, g, g), t.Base.Graphics.popClip(c)
                    }
                }, i.prototype.onPointerMove = function (t) {
                    if (this.scene.settings.interaction.selection.enabled && (this.scene.xyInBottom(t.x, t.y) && (t.cursor = "text"), this.scene.selectionStart && this.scene.selectionEnd && this.scene.xyInChartOrBottom(t.x, t.y) && this.scene.timeStart < this.scene.timeEnd)) {
                        var e = this.scene.timeToX(this.scene.selectionStart), i = this.scene.timeToX(this.scene.selectionEnd);
                        if (Math.abs(i - t.x) <= this.scene.settings.interaction.selection.tolerance)return t.cursor = "e-resize", t.consumed = !0;
                        if (Math.abs(e - t.x) <= this.scene.settings.interaction.selection.tolerance)return t.cursor = "w-resize", t.consumed = !0
                    }
                }, i.prototype.onPointerDown = function (t) {
                    if (this.scene.xyInChartOrBottom(t.x, t.y) && null === this.selectingPointer && this.scene.settings.interaction.selection.enabled) {
                        this.selectionRemoved = !1, this.lastX = t.x, this.lastY = t.y;
                        var e = null, i = null;
                        if (null !== this.scene.selectionStart || null !== this.scene.selectionEnd) {
                            e = this.scene.timeToX(this.scene.selectionStart), i = this.scene.timeToX(this.scene.selectionEnd);
                            var n = Math.abs(e - t.x), s = Math.abs(i - t.x);
                            if (n < this.scene.settings.interaction.selection.tolerance && s >= n)return this.selectingPointer = t.identifier, this.selectStart = this.scene.selectionEnd, this.selectingPointer = t.identifier, t.consumed = !0, this.roundAround = !0, void(this.isSelecting = !0);
                            if (s < this.scene.settings.interaction.selection.tolerance && n >= s)return this.selectStart = this.scene.selectionStart, this.selectingPointer = t.identifier, t.consumed = !0, this.roundAround = !0, void(this.isSelecting = !0)
                        }
                        if (this.scene.xyInBottom(t.x, t.y)) {
                            if (this.selectingPointer = t.identifier, this.selectStart = this.scene.xToTime(t.x), t.capture = !0, this.roundAround = !0, t.x >= e && t.x <= i)return this.isSelecting = !1;
                            null !== this.scene.selectionStart && (this.selectionRemoved = !0, this.scene.selectionStart = null, this.scene.selectionEnd = null, t.changes.selection = !0), this.isSelecting = !1
                        }
                    }
                }, i.prototype.onPointerDrag = function (t) {
                    null !== this.selectStart && this.selectingPointer === t.identifier && (this.dragPointer(t.x, t.y, t.changes), t.consumed = !0)
                }, i.prototype.dragPointer = function (e, i, n) {
                    this.isSelecting = !0, this.lastX = e, this.lastY = i;
                    var s = this.scene.xToTime(e), o = Math.abs(this.selectStart - s), r = this.scene.snapTimeRound(this.selectStart), a = r - this.selectStart, h = t.Base.Helpers.sign(a);
                    r = this.selectStart + Math.min(a * h, .9 * o) * h;
                    var l, u;
                    this.selectStart < s ? (l = r, u = s) : (l = s, u = r), this.scene.selectionStart = l, this.scene.selectionEnd = u, n.selection = !0
                }, i.prototype.onPointerUp = function (t) {
                    if (null !== this.selectStart && this.selectingPointer === t.identifier) {
                        if (this.isSelecting) {
                            var e = this.snapSelection(), i = e.st, n = e.en;
                            i === n && (i = null, n = null), this.scene.selectionStart = i, this.scene.selectionEnd = n, this.chart.notifySelectionChanged("user"), t.changes.selection = !0
                        }
                        return (this.isSelecting || this.selectionRemoved) && (t.consumed = !0), this.isSelecting = !1, this.selectStart = null, this.selectingPointer = null
                    }
                }, i.prototype.onPointerCancel = function (t) {
                    return this.onPointerUp(t)
                }, i.prototype.snapSelection = function () {
                    var t, e;
                    return this.scene.selectionStart ? this.roundAround ? (t = this.scene.snapTimeRound(this.scene.selectionStart), e = this.scene.snapTimeRound(this.scene.selectionEnd)) : (t = this.scene.snapTimeDown(this.scene.selectionStart), e = this.scene.snapTimeUp(this.scene.selectionEnd)) : (t = null, e = null), {
                        st: t,
                        en: e
                    }
                }, i
            }(t.Base.ChartElement);
            e.Selection = n
        }(e = t.TimeChart || (t.TimeChart = {}))
    }(e = t.Internal || (t.Internal = {}))
}(ZoomCharts || (ZoomCharts = {}));
var ZoomCharts;
!function (t) {
    var e;
    !function (t) {
        var e;
        !function (e) {
            var i = function (t) {
                function e() {
                    t.apply(this, arguments), this.highlights = {}, this.bottomAxisSize = 0, this.hoverSeriesItem = null
                }

                return __extends(e, t), e.prototype.xyInChart = function (t, e) {
                    return t >= this.x0 && t < this.x0 + this.width && e >= this.y0 && e < this.y0 + this.height
                }, e.prototype.xyInChartOrBottom = function (t, e) {
                    return t >= this.x0 && t < this.x0 + this.width && e >= this.y0 && e < this.y0 + this.height + this.bottomAxisSize
                }, e.prototype.xyInBottom = function (t, e) {
                    return t >= this.x0 && t < this.x0 + this.width && e >= this.y0 + this.height && e < this.y0 + this.height + this.bottomAxisSize
                }, e.prototype.timeToX = function () {
                    throw"Need to implement timeToX"
                }, e.prototype.xToTime = function () {
                    throw"Need to implement xToTime"
                }, e.prototype.setHighlight = function (t, e, i, n) {
                    var s = this.highlights[t];
                    return s ? (s.from = e, s.to = i, s.style = n, s.removed = !1) : (s = {
                            from: e,
                            to: i,
                            style: n,
                            removed: !1
                        }, this.highlights[t] = s), s
                }, e.prototype.removeHighlight = function (t) {
                    var e = this.highlights[t];
                    e && (e.removed = !0, delete this.highlights[t])
                }, e
            }(t.Base.Scene);
            e.Scene = i
        }(e = t.LinearChart || (t.LinearChart = {}))
    }(e = t.Internal || (t.Internal = {}))
}(ZoomCharts || (ZoomCharts = {}));
var ZoomCharts;
!function (t) {
    var e;
    !function (t) {
        var e;
        !function (e) {
            var i = function (e) {
                function i() {
                    e.apply(this, arguments), this.timeStart = 0, this.timeEnd = 0, this.anchor = null, this.period = null, this.displayUnit = null, this.data = {}, this.markers = [], this.mainData = null, this.selectionStart = null, this.selectionEnd = null, this.minorTimeFormat = null, this.minorTimeUnit = null, this.majorTimeFormat = null, this.majorTimeUnit = null, this.hoverFrom = null, this.hoverTo = null
                }

                return __extends(i, e), i.prototype.setTimeRange = function (e, i, n) {
                    n || t.Base.Helpers.error("Scene.setTimeRange: no display unit"), this.timeStart = e, this.timeEnd = i, this.displayUnit = n
                }, i.prototype.pixelsPerTime = function () {
                    return this.width / (this.timeEnd - this.timeStart)
                }, i.prototype.getScale = function () {
                    return (this.timeEnd - this.timeStart) / this.width
                }, i.prototype.timeToX = function (t) {
                    return this.x0 + this.width * (t - this.timeStart) / (this.timeEnd - this.timeStart)
                }, i.prototype.timeToXCoefs = function () {
                    return {
                        tadd: this.x0 - this.timeStart * this.width / (this.timeEnd - this.timeStart),
                        tmul: this.width / (this.timeEnd - this.timeStart)
                    }
                }, i.prototype.xToTime = function (t) {
                    return this.timeStart + (this.timeEnd - this.timeStart) * (t - this.x0) / this.width
                }, i.prototype.xToFraction = function (t) {
                    return (t - this.x0) / this.width
                }, i.prototype.dTimeToDx = function (t) {
                    return this.width * t / (this.timeEnd - this.timeStart)
                }, i.prototype.dxToDtime = function (t) {
                    return t / this.width * (this.timeEnd - this.timeStart)
                }, i.prototype.snapTimeDown = function (t) {
                    return this.displayUnit.roundTimeDown(t)
                }, i.prototype.snapTimeUp = function (t) {
                    return this.displayUnit.roundTimeUp(t)
                }, i.prototype.snapTimeRound = function (t) {
                    return this.displayUnit.roundTimeRound(t)
                }, i.prototype.getDataLimits = function () {
                    var t = this.mainData.dataLimitFrom, e = this.mainData.dataLimitTo;
                    return null === t || null === e ? {
                            from: null,
                            to: null
                        } : (this.displayUnit && (t = this.displayUnit.roundTimeDown(t), e = this.displayUnit.roundTimeUp(e)), {
                            from: t,
                            to: e
                        })
                }, i.prototype.getDisplayLimits = function () {
                    var t = this.getDataLimits(), e = t.from, i = t.to;
                    if (null === e)return {from: null, to: null};
                    for (var n = 0; n < this.markers.length; n++) {
                        var s = this.markers[n];
                        s.overridesLimits && (e = Math.min(e, s.time), i = Math.max(i, s.time))
                    }
                    return {from: e, to: i}
                }, i.prototype.getClickBar = function (t) {
                    var e = this.displayUnit;
                    return e ? {
                            time0: e.roundTimeDown(t),
                            time1: e.roundTimeUp(t + 1)
                        } : {time0: null, time1: null}
                }, i.prototype.getCurTime = function () {
                    var t, e = this.settings.currentTime, i = this.settings.timeAxis;
                    return t = e.overrideCurTime ? e.overrideCurTime : (new Date).getTime(), t += 6e4 * i._computedTimeZoneOffset
                }, i
            }(t.LinearChart.Scene);
            e.Scene = i
        }(e = t.TimeChart || (t.TimeChart = {}))
    }(e = t.Internal || (t.Internal = {}))
}(ZoomCharts || (ZoomCharts = {}));
var ZoomCharts;
!function (t) {
    var e;
    !function (t) {
        var e;
        !function (e) {
            var i = function () {
                function e(t, e, i, n, s, o, r) {
                    void 0 === i && (i = []), void 0 === n && (n = null), void 0 === s && (s = null), void 0 === o && (o = !0), void 0 === r && (r = 2), this.scene = null, this.step = null, this.uniform = !1, this.currentFrom = 0, this.currentTo = 0, this.fromBar = null, this.toBar = null, this.fromIndex = 0, this.toIndex = 0, this.times = [], this.xes = [], this.oldMul = 0, this.oldAdd = 0, this.values = [], this.counts = [], this.arrays = [], this.extraArrays = [], this.bufExpandSize = 100, this.extraSteps = 2, this.uniformTolerance = 0, this.approxExtraTime = 0, this.extraSteps = r, this.uniform = o, this.step = e, this.scene = t, n = n || this.scene.timeStart, s = s || this.scene.timeEnd, this.extraArrays = i.slice(0), this.arrays = i.slice(0), this.arrays.push("xes"), this.arrays.push("times"), this.uniformTolerance = Math.min(1, this.step.count - 2), this.approxExtraTime = this.extraSteps * e.approxTime(), this.init(n - this.approxExtraTime, s + this.approxExtraTime)
                }

                return e.prototype._getOrigin = function (t) {
                    if (1 === this.step.count || this.uniform)return this.step.roundTimeDown(t);
                    var e = this.step.getBigger().roundTimeDown(t), i = this.step.numberOfUnits(e, t);
                    return this.step.add(e, i)
                }, e.prototype._add = function (t) {
                    if (this.uniform || 1 === this.step.count || "d" !== this.step.unit)return t.add(this.step.count, this.step.unit);
                    var e = t.daysInMonth(), i = t.date();
                    return i + 2 * this.step.count > e + 1 + this.uniformTolerance ? t.add(e - i + 1, "d") : t.add(this.step.count, this.step.unit)
                }, e.prototype._sub = function (t) {
                    if (this.uniform || 1 === this.step.count || "d" !== this.step.unit)return t.subtract(this.step.count, this.step.unit);
                    var e = t.date();
                    if (e <= this.step.count) {
                        t.subtract(1, "M");
                        var i = t.daysInMonth() - 1, n = i + 1 - this.step.count + this.uniformTolerance;
                        return t.date(1 + n - (n % this.step.count | 0))
                    }
                    return t.subtract(this.step.count, this.step.unit)
                }, e.prototype.init = function (e, i) {
                    for (var n = this, s = 0; s < this.arrays.length; s++) {
                        var o = this.arrays[s];
                        this[o] = []
                    }
                    if (e >= i)return this.fromIndex = 0, this.toIndex = 0, this.fromBar = null, void(this.toBar = null);
                    this.fromBar = t.moment(this._getOrigin(e)).utc(), this.fromIndex = 0;
                    var r = t.moment(this.fromBar).utc();
                    for (this.times.push(r.valueOf()); r.valueOf() < i;)this._add(r), this.times.push(r.valueOf());
                    this.toIndex = this.times.length, this.toBar = r, this.currentFrom = e, this.currentTo = i, this.xes = this.times.map(function (t) {
                        return n.scene.timeToX(t)
                    });
                    for (var a = 0; a < this.extraArrays.length; a++) {
                        var h = this.extraArrays[a], l = [];
                        l.length = this.times.length, this[h] = l
                    }
                }, e.prototype.makeMiniSlice = function (e) {
                    var i = this.scene.timeToXCoefs(), n = i.tadd, s = i.tmul, o = t.moment(this._getOrigin(e)).utc(), r = o.valueOf(), a = n + r * s;
                    this._add(o);
                    var h = o.valueOf(), l = n + h * s;
                    return {t0: r, x0: a, t1: h, x1: l}
                }, e.prototype.update = function (t, e) {
                    if (void 0 === t && (t = this.scene.timeStart), void 0 === e && (e = this.scene.timeEnd), null == e && (e = this.scene.timeEnd), null == t && (t = this.scene.timeStart), t -= this.approxExtraTime, e += this.approxExtraTime, t === this.currentFrom && e === this.currentTo)return this.updateXes(this.fromIndex, this.toIndex), {
                        offset: 0,
                        newBefore: this.fromIndex,
                        newAfter: this.toIndex
                    };
                    if (null === this.fromBar || t > this.toBar.valueOf() || e < this.fromBar.valueOf())return this.init(t, e), {
                        offset: 0,
                        newBefore: this.toIndex,
                        newAfter: this.toIndex
                    };
                    var i = 0, n = this.fromIndex, s = this.toIndex, o = this.scene.timeToXCoefs(), r = o.tadd, a = o.tmul, h = this.fromBar.valueOf() - t;
                    if (h > 0) {
                        var l = (h / this.step.approxTime() | 0) + 2;
                        if (this.fromIndex < l) {
                            var u = [];
                            u.length = l + this.bufExpandSize;
                            for (var c = 0; c < this.arrays.length; c++) {
                                var p = this.arrays[c];
                                this[p] = u.concat(this[p])
                            }
                            i += u.length, n += u.length, s += u.length, this.fromIndex += u.length, this.toIndex += u.length
                        }
                        for (var d = this.fromBar.valueOf(); d > t;)this._sub(this.fromBar), this.fromIndex -= 1, d = this.fromBar.valueOf(), this.times[this.fromIndex] = d, this.xes[this.fromIndex] = r + d * a
                    }
                    var f = e - this.toBar.valueOf();
                    if (f > 0) {
                        var l = (f / this.step.approxTime() | 0) + 2;
                        if (this.times.length < this.toIndex + l)for (var m = this.toIndex + l + this.bufExpandSize, c = 0; c < this.arrays.length; c++) {
                            var p = this.arrays[c];
                            this[p].length = m
                        }
                        for (var d = this.toBar.valueOf(); e > d;)this._add(this.toBar), d = this.toBar.valueOf(), this.times[this.toIndex] = d, this.xes[this.toIndex] = r + d * a, this.toIndex += 1
                    }
                    for (this._add(this.fromBar); this.fromBar.valueOf() < t;)this.fromIndex += 1, this._add(this.fromBar);
                    for (this._sub(this.fromBar), this._sub(this.toBar); this.toBar.valueOf() >= e;)this.toIndex -= 1, this._sub(this.toBar);
                    this._add(this.toBar);
                    var g = this.toIndex - this.fromIndex + this.bufExpandSize;
                    if (this.fromIndex > g) {
                        for (var y = this.fromIndex - this.bufExpandSize, c = 0; c < this.arrays.length; c++) {
                            var p = this.arrays[c];
                            this[p].splice(0, y)
                        }
                        i -= y, n -= y, s -= y, this.fromIndex -= y, this.toIndex -= y
                    }
                    if (this.toIndex < this.times.length - g)for (var c = 0; c < this.arrays.length; c++) {
                        var p = this.arrays[c];
                        this[p].length = this.toIndex + this.bufExpandSize
                    }
                    return this.updateXes(n, s), this.currentFrom = t, this.currentTo = e, {
                        offset: i,
                        newBefore: n,
                        newAfter: s
                    }
                }, e.prototype.updateXes = function (t, e) {
                    var i = this.scene.timeToXCoefs(), n = i.tadd, s = i.tmul;
                    if (this.oldAdd !== n || this.oldMul !== s) {
                        this.oldAdd = n, this.oldMul = s;
                        for (var o = t; e - 1 >= o; o++)this.xes[o] = n + this.times[o] * s
                    }
                }, e
            }();
            e.TimeSlicer = i
        }(e = t.TimeChart || (t.TimeChart = {}))
    }(e = t.Internal || (t.Internal = {}))
}(ZoomCharts || (ZoomCharts = {}));
var ZoomCharts;
!function (t) {
    var e;
    !function (t) {
        var e;
        !function (e) {
            var i = function () {
                function t() {
                    this.enabled = !0, this.vgrid = !0, this.minUnitWidth = 12, this.maxUnitWidth = 200, this.showHolidays = !0, this.miniTimeRuler = !0, this.unitSizePolicy = "auto", this.timeZoneOffset = "local", this._computedTimeZoneOffset = null, this.style = {
                        showMinorTimeBalloons: !1,
                        showMajorTimeBalloons: !0,
                        minorTimeBalloonStyle: {fillColor: "#FFF"},
                        majorTimeBalloonStyle: {fillColor: "AAA"},
                        minorTimeLabel: {fillColor: "#000000", font: "12px Arial"},
                        majorTimeLabel: {fillColor: "#FFF", font: "11px Arial"},
                        dateLighten: {fillColor: "rgba(255,255,255,0.2)"},
                        dateHolidays: {fillColor: "rgba(230,230,230,0.2)"},
                        minorTimeRuler: {lineColor: "rgba(0,0,0,0.2)"},
                        vgrid: {lineColor: "rgba(0,0,0,0.1)"}
                    }
                }

                return t
            }();
            e.SettingsTimeAxis = i;
            var n = function (i) {
                function n(n) {
                    var s = this;
                    i.call(this), this.curSceneScale = 0, this.minorFormat = null, this.majorFormat = null, this.minorTimeUnit = null, this.majorTimeUnit = null, this.minorLabelHeight = null, this.majorLabelHeight = null, this.minorLabelWidths = null, this.minorLabelBallonWidths = null, this.majorLabelWidths = null, this.fullLabelWidths = null, this.multiYearWidth = 0, this.majorSlices = null, this.minorSlices = null, this.animationOrder = 610, this.paintOrder = 30, this.updateOrder = 1e3, this.multiples = {
                        s: [1, 2, 5, 15, 30],
                        m: [1, 2, 5, 15, 30],
                        h: [1, 3, 6, 12, 24],
                        d: [1, 2, 5, 10],
                        w: [1, 5, 10, 20],
                        M: [1, 3, 6],
                        y: [1, 10, 100, 1e3]
                    }, this.chart = n, this.scene = this.chart.scene, this.tt = new e.TimeSetup(this.scene.settings), this.options = this.scene.settings.timeAxis, this.panel = new t.Base.ChartPanel, this.panel.side = "bottom", this.panel.packingOrder = 100, this.panel.computeSize = function (t, e, i, n) {
                        return s.computeSize(t, e, i, n)
                    }
                }

                return __extends(n, i), n.prototype.computeSize = function (e, i, n) {
                    if (!this.options.enabled)return this.scene.bottomAxisSize = 0, {
                        width: e,
                        height: 0
                    };
                    var s = t.moment(0xc694d6e77ef8).utc();
                    n.save(), t.Base.Graphics.textStyle(n, this.options.style.minorTimeLabel), this.minorLabelHeight = .8 * t.Base.Graphics.getTextHeight(n, this.options.style.minorTimeLabel.font), this.minorLabelWidths = {}, this.minorLabelBallonWidths = {};
                    var o;
                    for (o = 0; o < t.Base.TimeStep.knownUnits.length; o++) {
                        var r = t.Base.TimeStep.knownUnits[o], a = n.measureText(s.format(this.scene.settings.localization.timeAxisDates.minorLabelTimeFormats[r])).width;
                        this.minorLabelWidths[r] = a, this.minorLabelBallonWidths[r] = a + this.minorLabelHeight
                    }
                    for (t.Base.Graphics.textStyle(n, this.options.style.majorTimeLabel), this.majorLabelHeight = .8 * t.Base.Graphics.getTextHeight(n, this.options.style.majorTimeLabel.font), this.majorLabelWidths = {}, this.fullLabelWidths = {}, o = 0; o < t.Base.TimeStep.knownUnits.length; o++) {
                        var r = t.Base.TimeStep.knownUnits[o];
                        this.majorLabelWidths[r] = this.majorLabelHeight + n.measureText(s.format(this.scene.settings.localization.timeAxisDates.majorLabelTimeFormats[r])).width, this.fullLabelWidths[r] = this.majorLabelHeight + n.measureText(s.format(this.scene.settings.localization.timeAxisDates.majorLabelFullTimeFormats[r])).width
                    }
                    if (this.multiYearWidth = n.measureText("8888 - 8888").width + this.majorLabelHeight, n.restore(), this.options.enabled) {
                        var h = Math.round(Math.min(2.3913043 * (this.minorLabelHeight + this.majorLabelHeight), i));
                        return this.scene.bottomAxisSize = h, {width: e, height: h}
                    }
                    return this.scene.bottomAxisSize = 0, {width: e, height: 0}
                }, n.prototype.onSceneChange = function (t) {
                    return t.changes.settings && t.changes.settingsChanges.timeAxis ? t.changes.bounds = !0 : void 0
                }, n.prototype.getPanels = function () {
                    return [this.panel]
                }, n.prototype.getMajorLabelWidth = function (t, e) {
                    return "y" === t.unit && t.count > 1 ? this.multiYearWidth : e ? this.majorLabelWidths[t.unit] : null !== this.fullLabelWidths ? null !== this.fullLabelWidths ? this.fullLabelWidths[t.unit] : null : void 0
                }, n.prototype.computeLabels = function (i) {
                    var n, s, o = new e.TimeSetup(this.scene.settings), r = this.scene.timeEnd - this.scene.timeStart, a = o.toBiggerDisplayPeriod(i);
                    if (a) {
                        var h = new t.Base.TimeStep("s", 1);
                        for (n = a.isSmaller(h) ? h : a, s = this.computeMinorUnit(n), a = o.toBiggerDisplayPeriod(n); a && (a.approxTime() <= .5 * r || n.approxTime() < this.scene.dxToDtime(this.getMajorLabelWidth(n, s)));)n = a, s = this.computeMinorUnit(n), a = o.toBiggerDisplayPeriod(a)
                    }
                    if (!a) {
                        n = "y" === i.unit ? i : new t.Base.TimeStep("y", 1);
                        for (var l = 0; l < this.multiples.y.length; l++) {
                            var u = this.multiples.y[l];
                            if (n = new t.Base.TimeStep("y", u), s = this.computeMinorUnit(n), n.approxTime() > this.scene.dxToDtime(this.getMajorLabelWidth(n, s)))break
                        }
                    }
                    return {minorUnit: s, majorUnit: n}
                }, n.prototype.computeMinorUnit = function (e) {
                    var i = this.scene.displayUnit.clone(), n = new t.Base.TimeStep(t.Base.TimeStep.toSmallerUnit[e.unit], 1);
                    n.unit && n.isBigger(i) && (i = n);
                    var s = i.approxTime(), o = null;
                    if (null === this.minorLabelWidths)return null;
                    for (var r = 1.5 * this.scene.dxToDtime(this.minorLabelWidths[i.unit]), a = 0; a < this.multiples[i.unit].length; a++) {
                        var h = this.multiples[i.unit][a];
                        if (h < i.count && (h = i.count), i.count = h, s = i.approxTime(), s >= r) {
                            o = i;
                            break
                        }
                    }
                    return o && o.isEqual(e) && (o = null), o
                }, n.prototype.doAnimations = function () {
                    if (this.scene.displayUnit && this.scene.timeStart < this.scene.timeEnd) {
                        var t = this.scene.getScale();
                        if (!(Math.abs(1 - this.curSceneScale / t) < .001)) {
                            this.curSceneScale = t;
                            var i = this.computeLabels(this.scene.displayUnit), n = i.minorUnit, s = i.majorUnit;
                            n ? (this.minorFormat = this.scene.settings.localization.timeAxisDates.minorLabelTimeFormats[n.unit], this.majorFormat = this.scene.settings.localization.timeAxisDates.majorLabelTimeFormats[s.unit]) : (this.minorFormat = null, this.majorFormat = this.scene.settings.localization.timeAxisDates.majorLabelFullTimeFormats[s.unit]), this.minorTimeUnit = n, this.majorTimeUnit = s, (null === this.majorSlices || s.approxTime() !== this.majorSlices.step.approxTime()) && (this.majorSlices = new e.TimeSlicer(this.scene, s)), !n || null !== this.minorSlices && n.approxTime() === this.minorSlices.step.approxTime() ? null === n && (this.minorSlices = null) : this.minorSlices = new e.TimeSlicer(this.scene, n, [], null, null, !1)
                        }
                        this.majorSlices.update(), this.minorSlices && this.minorSlices.update(), this.minorTimeUnit ? (this.scene.minorTimeFormat = this.minorFormat, this.scene.minorTimeUnit = this.minorTimeUnit) : this.scene.displayUnit && (this.scene.minorTimeUnit = this.scene.displayUnit, this.scene.minorTimeFormat = this.scene.settings.localization.timeAxisDates.minorLabelTimeFormats[this.scene.displayUnit.unit]), this.scene.majorTimeFormat = this.majorFormat, this.scene.majorTimeUnit = this.majorTimeUnit
                    }
                }, n.prototype.paintScene = function (e) {
                    if (this.scene.displayUnit && this.options.enabled && this.scene.timeStart < this.scene.timeEnd) {
                        var i = e.context, n = e.labelRenderer, s = this.scene.x0, o = s + this.scene.width, r = this.panel.top + 1, a = this.panel.bottom, h = a - r, l = this.scene.y0, u = this.scene.height, c = a - 1.8 * this.majorLabelHeight;
                        t.Base.Graphics.pushClip(i, s, l, this.scene.width, h + u);
                        var p = this.majorSlices.xes, d = this.majorSlices.times, f = this.majorSlices.fromIndex, m = this.majorSlices.toIndex, g = this.majorSlices.step.numberOfUnits(0, d[f]), y = (0 | g) % 2 === 0;
                        i.beginPath();
                        for (var v = f; m - 2 >= v; v++)if (y = !y, !y) {
                            var S = (0 | Math.max(p[v], s)) + 1, C = 0 | Math.min(p[v + 1], o);
                            i.rect(S, r, C - S, h)
                        }
                        if (t.Base.Graphics.fill(i, this.scene.settings.timeAxis.style.dateLighten), this.options.showHolidays && this.minorSlices && ("w" === this.minorSlices.step.unit || "d" === this.minorSlices.step.unit || "h" === this.minorSlices.step.unit)) {
                            var b = this.scene.timeToXCoefs(), x = b.tadd, _ = b.tmul, w = 864e5, L = this.scene.timeStart;
                            L = Math.round(L - L % w);
                            var T = t.moment(L).utc().isoWeekday(), M = this.scene.settings.localization.holidayWeekdays;
                            i.beginPath();
                            for (var S = L * _ + x; o >= S;) {
                                var C = S + _ * w;
                                M.indexOf(T) > -1 && i.rect(S, l, C - S, Math.min(5, h) + u), T = T % 7 + 1, S = C
                            }
                            t.Base.Graphics.fill(i, this.scene.settings.timeAxis.style.dateHolidays)
                        }
                        if (this.options.vgrid) {
                            for (var P = t.Base.Graphics.beginStrokeAndFill(i, this.options.style.vgrid), v = f + 1; m - 2 >= v; v++) {
                                var k = (0 | p[v]) + .5;
                                if (k >= o)break;
                                P.moveTo(k, l), P.lineTo(k, a)
                            }
                            t.Base.Graphics.endStrokeAndFill(i, P, this.options.style.vgrid)
                        }
                        var D = "y" === this.majorSlices.step.unit && this.majorSlices.step.count > 1, I = this.getMajorLabelWidth(this.majorSlices.step, this.minorFormat);
                        if (!this.minorSlices || this.majorSlices.step.unit !== this.minorSlices.step.unit) {
                            if (this.scene.settings.timeAxis.style.showMajorTimeBalloons) {
                                i.beginPath();
                                for (var v = f; m - 2 >= v; v++) {
                                    var A = p[v], B = p[v + 1];
                                    if (!(A >= o || s >= B)) {
                                        var E = (A + B) / 2;
                                        s > A && (A = s, E = Math.min((A + B) / 2, B - I)), B > o && (B = o, E = Math.max((A + B) / 2, A + I)), t.Base.Graphics.strokeBalloon2(i, E, c + 1, I, this.majorLabelHeight)
                                    }
                                }
                                t.Base.Graphics.paint(i, this.scene.settings.timeAxis.style.majorTimeBalloonStyle)
                            }
                            for (var v = f; m - 2 >= v; v++) {
                                var A = p[v], B = p[v + 1];
                                if (!(A >= o || s >= B)) {
                                    var L = d[v], O = void 0;
                                    if (D) {
                                        var F = d[v + 1] - 1;
                                        O = t.moment(L).utc().format(this.majorFormat) + " - " + t.moment(F).utc().format(this.majorFormat)
                                    } else O = t.moment(L).utc().format(this.majorFormat);
                                    var E = (A + B) / 2;
                                    s > A && (A = s, E = Math.min((A + B) / 2, B - I)), B > o && (B = o, E = Math.max((A + B) / 2, A + I));
                                    var N = new t.Base.Label;
                                    N.text = O, N.textStyle = this.scene.settings.timeAxis.style.majorTimeLabel, N.aspectRatio = 0, n.paintWithStyle(i, E, c, 1, N, N)
                                }
                            }
                        }
                        var z = this.scene.settings.timeAxis, R = z.style.minorTimeRuler;
                        if (this.minorSlices) {
                            d = this.minorSlices.times, p = this.minorSlices.xes, f = this.minorSlices.fromIndex, m = this.minorSlices.toIndex, I = this.minorLabelWidths[this.minorSlices.step.unit];
                            var H = r + .4 * this.minorLabelHeight | 0, Z = r - 1, U = H + 1.6 * this.minorLabelHeight | 0;
                            if (this.scene.settings.timeAxis.style.showMinorTimeBalloons) {
                                i.beginPath();
                                for (var v = f; m - 1 >= v; v++) {
                                    var k = p[v];
                                    t.Base.Graphics.strokeBalloon(i, k, r - 5, I, this.minorLabelHeight)
                                }
                                t.Base.Graphics.paint(i, this.scene.settings.timeAxis.style.minorTimeBalloonStyle)
                            } else {
                                var W = this.majorSlices.fromIndex, V = this.majorSlices.xes;
                                i.beginPath();
                                for (var G = W, v = f; m - 1 >= v; v++) {
                                    for (var k = p[v]; k > V[G];)G += 1;
                                    if (V[G] !== k) {
                                        if (k >= o)break;
                                        k = (0 | k) - .5, i.moveTo(k, Z), i.lineTo(k, U)
                                    }
                                }
                                t.Base.Graphics.stroke(i, R)
                            }
                            for (var Y = this.scene.settings.timeAxis.style.showMinorTimeBalloons ? "center" : "left", j = this.scene.settings.timeAxis.style.showMinorTimeBalloons ? 0 : 3, v = f; m - 1 >= v; v++) {
                                var k = p[v], L = d[v], O = t.moment(L).utc().format(this.minorFormat), N = new t.Base.Label;
                                N.text = O, N.textStyle = this.scene.settings.timeAxis.style.minorTimeLabel, N.align = Y, n.measure(i, N, N);
                                var q = k + j + N.hwidth;
                                n.paintWithStyle(i, q, H + N.hheight, 1, N, N)
                            }
                        }
                        var X = this.chart.dataWarehouse.getDisplayUnitsSlicer();
                        if (z.miniTimeRuler && R && X && X.xes[X.fromIndex + 1] - X.xes[X.fromIndex] > 4) {
                            var J = r - 1, K = r + 3;
                            p = X.xes;
                            var Q = this.majorSlices.fromIndex, $ = this.minorSlices ? this.minorSlices.fromIndex : Q, te = this.majorSlices.xes, ee = this.minorSlices ? this.minorSlices.xes : te;
                            i.beginPath();
                            for (var ie = Q, ne = $, se = 0, v = X.fromIndex; v <= X.toIndex - 2; v++) {
                                for (var k = p[v]; k > te[ie];)ie += 1;
                                if (te[ie] !== k) {
                                    for (; k > ee[ne];)ne += 1;
                                    if (ee[ne] !== k) {
                                        if (k >= o)break;
                                        k = (0 | k) - .5, i.moveTo(k, J), i.lineTo(k, K), se++
                                    }
                                }
                            }
                            if (se && t.Base.Graphics.stroke(i, R), -1 !== this.scene.settings.advanced.themeCSSClass.indexOf("gradient")) {
                                var oe = t.Base.Graphics.colorTone(R.lineColor, 2, 2);
                                se = 0, i.beginPath(), ie = Q, ne = $;
                                for (var v = X.fromIndex; v <= X.toIndex - 2; v++) {
                                    for (var k = p[v]; k > te[ie];)ie += 1;
                                    if (te[ie] !== k) {
                                        for (; k > ee[ne];)ne += 1;
                                        if (ee[ne] !== k) {
                                            if (k >= o)break;
                                            k = (0 | k) + .5, i.moveTo(k, J), i.lineTo(k, K), se++
                                        }
                                    }
                                }
                                se && t.Base.Graphics.stroke(i, {lineColor: oe.color})
                            }
                        }
                        t.Base.Graphics.popClip(i)
                    }
                }, n
            }(t.Base.ChartElement);
            e.TimeAxis = n
        }(e = t.TimeChart || (t.TimeChart = {}))
    }(e = t.Internal || (t.Internal = {}))
}(ZoomCharts || (ZoomCharts = {}));
var ZoomCharts;
!function (t) {
    var e;
    !function (t) {
        var e;
        !function (e) {
            var i = function () {
                function t() {
                    this.enabled = !0, this.label = "", this.style = {
                        lineColor: "red",
                        fillColor: "red"
                    }, this.textStyle = null, this.overrideCurTime = null, this.overridesLimits = !1
                }

                return t
            }();
            e.SettingsCurrentTime = i;
            var n = function (t) {
                function i(e) {
                    t.call(this), this.animationOrder = 100, this.paintOrder = 35, this.updateOrder = 900, this.marker = null, this.timeTimerUnit = null, this.timeTimer = null, this.timeTimerTarget = -1 / 0, this.timeTickerEnabled = !1, this.timeTimerCheckAlways = !1, this.chart = e, this.settings = this.chart.settings, this.scene = this.chart.scene, this.events = this.chart.events, this.createMarker(), this.updateTimers()
                }

                return __extends(i, t), i.prototype.updateTimers = function () {
                    var t = this, e = this.settings.advanced;
                    this.timeTickerEnabled = e.timeUpdateInterval && this.settings.currentTime.enabled, this.timeTickerEnabled ? this.updateCurTime() : this.timeTimer && (clearTimeout(this.timeTimer), this.timeTimer = null), e.dataUpdateInterval ? this.dataTimer = setInterval(function () {
                            return t.dataTick()
                        }, e.dataUpdateInterval) : this.dataTimer && (clearInterval(this.dataTimer), this.dataTimer = null)
                }, i.prototype.createMarker = function () {
                    var t = this.settings.currentTime;
                    if (t.enabled) {
                        var i = this.marker || (this.marker = new e.Marker);
                        i.label = t.label, i.style = t.style, i.textStyle = t.textStyle || {fillColor: i.style.fillColor}, i.overridesLimits = t.overridesLimits, this.scene.markers.push(i)
                    } else this.marker && (this.scene.markers.splice(this.scene.markers.indexOf(this.marker)), this.marker = null)
                }, i.prototype.onSceneChange = function (t) {
                    var e = t.changes.settingsChanges;
                    e && ((e.advanced || e.currentTime) && this.updateTimers(), e.currentTime && this.createMarker()), this.marker && (t.changes.timeMarker || t.changes.time && (this.timeTimerCheckAlways || !this.timeTimer || this.scene.getScale() < this.timeTimerUnit)) && (this.timeTimerUnit = this.scene.getScale(), this.updateCurTime())
                }, i.prototype.timerTick = function () {
                    this.timeTimer = null, this.chart.removed || (this.updateCurTime(), this.updateVisiblePeriod())
                }, i.prototype.dataTick = function () {
                    var t = this;
                    if (this.dataTimer = null, !this.chart.removed && this.scene.displayUnit) {
                        var e = this.scene.getCurTime(), i = function () {
                            t.updateVisiblePeriod()
                        };
                        for (var n in this.chart.data) {
                            var s = this.chart.data[n];
                            s.updateData(this.scene.displayUnit.unit, e, i)
                        }
                    }
                }, i.prototype.doAnimations = function (t) {
                    t.changes.data && this.updateVisiblePeriod()
                }, i.prototype.updateCurTime = function (t) {
                    var e = this, i = this.scene.getCurTime();
                    this.marker.time = i;
                    var n = this.scene.timeToX(i);
                    if (!isNaN(n)) {
                        var s = n + 200 > this.scene.x0 && n - 160 < this.scene.x0 + this.scene.width, o = this.settings.advanced.timeUpdateInterval, r = 0;
                        if (s) this.timeTimerCheckAlways = !1, void 0 === t && this.events.notifySceneChanges({requestPaint: !0}), this.scene.displayUnit.approxTime() >= 36e5 && (r = (this.scene.xToTime(n + 1 | 0) - i) / 2, o = Math.max(o, r), r /= 4); else {
                            if (n > 0)return;
                            o = Math.max(o, this.scene.dxToDtime(-n - 160) / 2), this.timeTimerCheckAlways = !0
                        }
                        var a = +new Date;
                        if (this.timeTimer) {
                            var h = this.timeTimerTarget - a;
                            if (o + r > h)return;
                            window.clearTimeout(this.timeTimer)
                        }
                        s && this.scene.dTimeToDx(o) > 1 ? this.events.notifySceneChanges({timeMarker: !0}) : (this.timeTimerTarget = a + o, this.timeTimer = setTimeout(function () {
                                return e.timerTick()
                            }, o))
                    }
                }, i.prototype.updateVisiblePeriod = function () {
                    var t = this.scene;
                    if (this.scene.displayUnit && this.settings.navigation.followAnchor) {
                        var e = t.getCurTime(), i = t.getDataLimits()[1], n = t.timeEnd, s = t.timeStart;
                        if ("now" === this.scene.anchor && e > n) {
                            var o = t.displayUnit, r = o.roundTimeUp(e) - n;
                            this.chart.scrolling.setTimeRangeSnap(s + r, n + r, n + r, t.displayUnit, !0, "timer", !0, !1)
                        }
                        if ("newestData" === this.scene.anchor && i > n) {
                            var o = this.scene.displayUnit, r = o.roundTimeUp(i) - n;
                            this.chart.scrolling.setTimeRangeSnap(s + r, n + r, n + r, t.displayUnit, !0, "timer", !0, !1)
                        }
                    }
                }, i
            }(t.Base.ChartElement);
            e.TimeUpdater = n
        }(e = t.TimeChart || (t.TimeChart = {}))
    }(e = t.Internal || (t.Internal = {}))
}(ZoomCharts || (ZoomCharts = {}));
var ZoomCharts;
!function (t) {
    var e;
    !function (t) {
        var e;
        !function (e) {
            var i = function (i) {
                function s(n) {
                    i.call(this, t.Base.SettingsMapping.TimeChartSettings), this._minUnit = null, this._minDisplayRange = 10, this._displayUnitsParsed = [], this._displayPeriodsParsed = [], this._computedDataMap = {}, this.theme = s.FlatTheme, this.navigation = {
                        initialDisplayAnchor: "newestData",
                        initialDisplayPeriod: "max",
                        initialDisplayUnit: "auto",
                        followAnchor: !1
                    }, this.area = new f, this.chartTypes = {
                        columns: {type: "columns"},
                        line: {type: "line"},
                        candlestick: {type: "candlestick"}
                    }, this.currentTime = new e.SettingsCurrentTime, this.timeAxis = new e.SettingsTimeAxis, this.data = [], this.toolbar = new e.SettingsToolbar, this.localization = new c, this.interaction = new d, this.advanced = new u, this.events = new l, this.apply(n), this._initializing = !1
                }

                return __extends(s, i), s.prototype.apply = function (t) {
                    this.applyCompatibility(t, [{
                        from: "toolbars",
                        to: "toolbar"
                    }, {
                        from: "toolbar.periodSelection",
                        to: "toolbar.displayPeriod"
                    }, {
                        from: "toolbar.zoomOutButton",
                        to: "toolbar.zoomOut"
                    }, {
                        from: "toolbar.backButton",
                        to: "toolbar.back"
                    }, {
                        from: "interaction.scrolling.noData",
                        to: "interaction.scrolling.limitMode"
                    }, {
                        from: "interaction.scrolling.noDataSnapBackProportion",
                        to: "interaction.scrolling.overscrollProportion",
                        transform: function (t) {
                            return 1 - t
                        }
                    }, {
                        from: "area.initialDisplayPeriod",
                        to: "navigation.initialDisplayPeriod"
                    }, {
                        from: "area.initialDisplayAnchor",
                        to: "navigation.initialDisplayAnchor"
                    }, {
                        from: "area.initialDisplayUnit",
                        to: "navigation.initialDisplayUnit"
                    }, {
                        from: "area.followAnchor",
                        to: "navigation.followAnchor"
                    }, {
                        from: "timeAxis.style.vgrid",
                        to: "timeAxis.style.vgrid.lineColor",
                        filter: function (t) {
                            return "string" == typeof t
                        }
                    }, {
                        from: "currentTime.serverTime",
                        alternative: "currentTime.overrideCurTime",
                        alternativeAsWarning: !0
                    }]), t.currentTime && t.currentTime.serverTime && (t.currentTime.overrideCurTime = t.currentTime.serverTime, delete t.currentTime.serverTime, t.timeAxis || (t.timeAxis = {}), t.timeAxis.timeZoneOffset = -(new Date).getTimezoneOffset());
                    var e = i.prototype.apply.call(this, t, n);
                    if (e.data)for (var s = 0; s < this.data.length; s++) {
                        var o = this.data[s];
                        o._computedTimeZoneOffset = "local" === o.timeZoneOffset || void 0 === o.timeZoneOffset || null === o.timeZoneOffset ? -(new Date).getTimezoneOffset() : o.timeZoneOffset
                    }
                    return e.timeAxis ? this.timeAxis._computedTimeZoneOffset = "local" === this.timeAxis.timeZoneOffset || void 0 === this.timeAxis.timeZoneOffset || null === this.timeAxis.timeZoneOffset ? -(new Date).getTimezoneOffset() : this.timeAxis.timeZoneOffset : null === this.timeAxis._computedTimeZoneOffset && (this.timeAxis._computedTimeZoneOffset = -(new Date).getTimezoneOffset()), this._calcMinUnit(), this._displayUnitsParsed = this._parseUnits(this.area.displayUnits), this._displayPeriodsParsed = this._parsePeriods(this.area.displayPeriods), e
                }, s.prototype._parseUnits = function (e) {
                    for (var i = [], n = 0; n < e.length; n++) {
                        var s = e[n], o = t.Base.TimeStep.parse(s.unit, s.name);
                        this._minUnit.isSmallerOrEqual(o) && i.push(o)
                    }
                    return i
                }, s.prototype._parsePeriods = function (e) {
                    for (var i = [], n = 0; n < e.length; n++) {
                        var s = t.Base.TimeStep.parse(e[n].unit);
                        s && this._minUnit.isSmallerOrEqual(s) && i.push(s)
                    }
                    return i
                }, s.prototype._calcMinUnit = function () {
                    for (var e = new t.Base.TimeStep("y", 1e6), i = 0; i < this.area.displayUnits.length; i++) {
                        var n = this.area.displayUnits[i], s = t.Base.TimeStep.parse(n.unit, n.name);
                        s.isSmaller(e) && (e = s)
                    }
                    for (var o = new t.Base.TimeStep("y", 1e6), i = 0; i < this._computedSeries.length; i++) {
                        var r = this._computedSeries[i], a = this._computedDataMap[r.data.source];
                        if (!a)throw new Error("Data source for series not found!");
                        for (var h = 0; h < a.units.length; h++) {
                            var l = a.units[h], u = new t.Base.TimeStep(l, 1);
                            u.isSmaller(o) && (o = u)
                        }
                    }
                    o.isBigger(e) && (e = o), this._minUnit = e, this._minDisplayRange = 10 * e.approxTime()
                }, s.StaticChart = {
                    interaction: {
                        zooming: {enabled: !1},
                        selection: {enabled: !1},
                        scrolling: {enabled: !1}
                    }
                }, s.DarkTheme = {
                    advanced: {
                        themeCSSClass: "DVSL-flat DVSL-dark",
                        assets: []
                    },
                    area: {
                        style: {
                            fillColor: "rgba(28,26,28,1)",
                            noData: {
                                fillColor: "#DDD",
                                image: "builtin://linearchart-no-data-light"
                            },
                            selection: {lineColor: "#838283"},
                            selectionLabel: {fillColor: "#BFBBB9"},
                            zoomHighlight: {fillColor: "rgba(142,142,142,0.15)"},
                            zoomHighlightInactive: {fillColor: "rgba(142,142,142,0.15)"},
                            loadingData: {fillColor: "#EEE"}
                        }
                    },
                    title: {margin: 15, style: {fillColor: "#A8A7A8"}},
                    chartTypes: {columns: {style: {gradient: 1, depth: 0}}},
                    valueAxisDefault: {
                        style: {
                            valueLabel: {fillColor: "#A8A7A8"},
                            title: {fillColor: "#A8A7A8"}
                        }
                    },
                    timeAxis: {
                        style: {
                            majorTimeLabel: {
                                fillColor: "#A8A7A8",
                                shadowColor: null
                            },
                            minorTimeLabel: {fillColor: "#A8A7A8", shadowColor: null},
                            minorTimeRuler: {lineColor: "#838283"},
                            dateLighten: {fillColor: "rgba(142,142,142,0.15)"},
                            dateHolidays: {fillColor: "rgba(139,139,139,0.11)"}
                        }
                    },
                    info: {style: {highlight: {fillColor: "rgba(142,142,142,0.15)"}}},
                    currentTime: {style: {lineColor: "#D12E2B", fillColor: "#D12E2B"}},
                    legend: {
                        text: {fillColor: "#A8A7A8"},
                        advanced: {
                            disabledSeries: {
                                textColor: "rgba(168,167,168,0.5)",
                                lineColor: "rgba(117,117,117,0.8)"
                            }
                        }
                    }
                }, s.FlatTheme = {
                    advanced: {themeCSSClass: "DVSL-flat", assets: []},
                    area: {
                        style: {
                            noData: {
                                fillColor: "#DDD",
                                image: "builtin://linearchart-no-data-light"
                            }, loadingData: {fillColor: "#EEE"}
                        }
                    },
                    chartTypes: {columns: {style: {gradient: 1, depth: 0}}},
                    timeAxis: {
                        style: {
                            showMajorTimeBalloons: !1,
                            showMinorTimeBalloons: !1,
                            majorTimeLabel: {fillColor: "#000", shadowColor: null},
                            minorTimeLabel: {fillColor: "#000", shadowColor: null},
                            dateLighten: {fillColor: "rgba(0,0,0,0.05)"}
                        }
                    }
                }, s.RoundTheme = {
                    advanced: {themeCSSClass: "DVSL-round", assets: []},
                    valueAxisDefault: {
                        style: {
                            valueLabel: {
                                fillColor: "#000000",
                                font: "11px Arial",
                                shadowOffsetX: 0,
                                shadowOffsetY: 1,
                                shadowBlur: 0,
                                shadowColor: "rgba(255,255,255,0.5)"
                            }
                        }
                    },
                    timeAxis: {
                        style: {
                            showMinorTimeBalloons: !1,
                            showMajorTimeBalloons: !0,
                            minorTimeBalloonStyle: {
                                fillColor: "#FFF",
                                shadowOffsetX: 0,
                                shadowOffsetY: 2,
                                shadowBlur: 2,
                                shadowColor: "#888"
                            },
                            majorTimeBalloonStyle: {
                                fillColor: "AAA",
                                shadowOffsetX: 0,
                                shadowOffsetY: -1,
                                shadowBlur: 0,
                                shadowColor: "rgba(0,0,0,0.3)"
                            },
                            minorTimeLabel: {
                                fillColor: "#000000",
                                font: "12px Arial",
                                shadowOffsetX: 0,
                                shadowOffsetY: 1,
                                shadowBlur: 0,
                                shadowColor: "rgba(255,255,255,0.5)"
                            },
                            majorTimeLabel: {
                                fillColor: "#FFF",
                                font: "11px Arial",
                                shadowOffsetX: 0,
                                shadowOffsetY: 1,
                                shadowBlur: 1,
                                shadowColor: "#7c7c7c"
                            },
                            dateLighten: {fillColor: "rgba(0,0,0,0.05)"},
                            minorTimeRuler: {lineColor: "rgba(0,0,0,0.2)"}
                        }
                    },
                    chartTypes: {columns: {style: {gradient: .8, depth: 3}}},
                    area: {style: {noData: {image: "builtin://linearchart-no-data-dark"}}}
                }, s.GradientTheme = {
                    advanced: {
                        themeCSSClass: "DVSL-gradient",
                        assets: []
                    },
                    valueAxisDefault: {
                        style: {
                            valueLabel: {
                                fillColor: "#000000",
                                font: "11px Arial",
                                shadowOffsetX: 0,
                                shadowOffsetY: 1,
                                shadowBlur: 0,
                                shadowColor: "rgba(255,255,255,0.5)"
                            }
                        }
                    },
                    timeAxis: {
                        style: {
                            showMinorTimeBalloons: !1,
                            showMajorTimeBalloons: !0,
                            minorTimeBalloonStyle: {
                                fillColor: "#FFF",
                                shadowOffsetX: 0,
                                shadowOffsetY: 2,
                                shadowBlur: 2,
                                shadowColor: "#888"
                            },
                            majorTimeBalloonStyle: {
                                fillColor: "AAA",
                                shadowOffsetX: 0,
                                shadowOffsetY: -1,
                                shadowBlur: 0,
                                shadowColor: "rgba(0,0,0,0.3)"
                            },
                            minorTimeLabel: {
                                fillColor: "#000000",
                                font: "12px Arial",
                                shadowOffsetX: 0,
                                shadowOffsetY: 1,
                                shadowBlur: 0,
                                shadowColor: "rgba(255,255,255,0.5)"
                            },
                            majorTimeLabel: {
                                fillColor: "#FFF",
                                font: "11px Arial",
                                shadowOffsetX: 0,
                                shadowOffsetY: 1,
                                shadowBlur: 1,
                                shadowColor: "#7c7c7c"
                            },
                            dateLighten: {fillColor: "rgba(255,255,255,0.2)"},
                            minorTimeRuler: {lineColor: "rgba(0,0,0,0.2)"}
                        }
                    },
                    chartTypes: {columns: {style: {gradient: .8, depth: 3}}},
                    area: {style: {noData: {image: "builtin://linearchart-no-data-dark"}}}
                }, s
            }(t.LinearChart.Settings);
            e.Settings = i;
            var n = function (e) {
                function i() {
                    e.apply(this, arguments), this.data = new s
                }

                return __extends(i, e), i.getMapping = function (e, i) {
                    if (e && i.type && e.type !== i.type)throw new Error("It is not possible to change the value of `type` property for an existing layer.");
                    switch (e ? e.type : i.type) {
                        case"columns":
                        case void 0:
                            return t.Base.SettingsMapping.TimeChartSettingsSeriesColumns;
                        case"candlestick":
                            return t.Base.SettingsMapping.TimeChartSettingsSeriesCandleStick;
                        case"line":
                            return t.Base.SettingsMapping.TimeChartSettingsSeriesLines;
                        default:
                            throw new Error("The value '" + i.type + "' is not valid for the `type` property of a series. Valid values are: columns, candlestick, line.")
                    }
                }, i.createInstance = function (t, e) {
                    switch (e || t.type) {
                        case"columns":
                        case void 0:
                            return new o;
                        case"candlestick":
                            return new h;
                        case"line":
                            return new r;
                        default:
                            throw new Error("The value '" + (e || t.type) + "' is not valid for the `type` property of a series. Valid values are: columns, candlestick, line.")
                    }
                }, i
            }(t.LinearChart.SettingsSeries);
            e.SettingsSeries = n;
            var s = function (t) {
                function e() {
                    t.apply(this, arguments), this.index = 1, this.countIndex = null
                }

                return __extends(e, t), e
            }(t.LinearChart.SettingsSeriesData);
            e.SettingsSeriesData = s;
            var o = function (t) {
                function e() {
                    t.apply(this, arguments), this.data = new s
                }

                return __extends(e, t), e
            }(t.LinearChart.SettingsSeriesColumns);
            e.SettingsSeriesColumns = o;
            var r = function (t) {
                function e() {
                    t.apply(this, arguments), this.data = new s
                }

                return __extends(e, t), e
            }(t.LinearChart.SettingsSeriesLines);
            e.SettingsSeriesLines = r;
            var a = function (t) {
                function e() {
                    t.apply(this, arguments), this.high = null, this.open = null, this.close = null, this.low = null
                }

                return __extends(e, t), e
            }(s);
            e.SettingsSeriesCandleStickData = a;
            var h = function (t) {
                function e() {
                    t.apply(this, arguments), this.data = new a
                }

                return __extends(e, t), e
            }(t.LinearChart.SettingsSeriesCandleStick);
            e.SettingsSeriesCandleStick = h;
            var l = function (t) {
                function e() {
                    t.call(this), this.onTimeChange = null, this.chartUpdateDelay = 400
                }

                return __extends(e, t), e
            }(t.LinearChart.SettingsEvents);
            e.SettingsEvents = l;
            var u = function (t) {
                function e() {
                    t.apply(this, arguments), this.timeUpdateInterval = 900, this.dataUpdateInterval = null, this.maxUnitsToDisplay = 2e4
                }

                return __extends(e, t), e
            }(t.Base.SettingsAdvanced);
            e.SettingsAdvanced = u;
            var c = function (t) {
                function e() {
                    t.apply(this, arguments), this.calendar = {
                        months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
                        monthsShort: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
                        weekdays: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
                        weekdaysShort: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
                        weekdaysMin: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"],
                        week: {dow: 1, doy: 4}
                    }, this.holidayWeekdays = [6, 7], this.toolbar = new p, this.timeUnitsNames = {
                        ms: "millisecond",
                        s: "second",
                        m: "minute",
                        h: "hour",
                        d: "day",
                        w: "week",
                        M: "month",
                        y: "year"
                    }, this.timeUnitsNamesPlural = {
                        ms: "milliseconds",
                        s: "seconds",
                        m: "minutes",
                        h: "hours",
                        d: "days",
                        w: "weeks",
                        M: "months",
                        y: "years"
                    }, this.markerDates = {
                        timeFormats: {
                            ms: "HH:mm:ss",
                            s: "HH:mm:ss",
                            m: "HH:mm:ss",
                            h: "HH:mm",
                            d: "D, HH:mm",
                            w: "MMM D",
                            M: "MMM D",
                            y: "YYYY, MMM D"
                        }
                    }, this.infoDates = {
                        majorTimeFormats: {
                            y: null,
                            M: "YYYY",
                            w: "YYYY",
                            d: "YYYY",
                            h: "MMM D, YYYY",
                            m: "MMM D, YYYY",
                            s: "MMM D, YYYY",
                            ms: "MMM D, YYYY"
                        },
                        minorTimeFormats: {
                            y: "YYYY",
                            M: "MMM",
                            w: "[Week] W",
                            d: "MMM D",
                            h: "HH:mm",
                            m: "HH:mm",
                            s: "HH:mm:ss",
                            ms: "ss.SSS"
                        },
                        fullTimeFormats: {
                            ms: "MMM D, YYYY HH:mm:ss",
                            s: "MMM D, YYYY HH:mm:ss",
                            m: "MMM D, YYYY, HH:mm",
                            h: "MMM D, YYYY HH:00",
                            d: "MMM D, YYYY",
                            w: "[Week] W, YYYY",
                            M: "MMM YYYY",
                            y: "YYYY"
                        }
                    }, this.timeAxisDates = {
                        minorLabelTimeFormats: {
                            ms: "ss.SSS",
                            s: "HH:mm:ss",
                            m: "HH:mm",
                            h: "HH:00",
                            d: "MMM D",
                            w: "MMM D",
                            M: "MMM",
                            y: "YYYY"
                        },
                        majorLabelTimeFormats: {
                            ms: "MMM D, YYYY HH:mm:ss",
                            s: "MMM D, YYYY HH:mm:ss",
                            m: "MMM D, YYYY",
                            h: "MMM D, YYYY HH:00",
                            d: "MMM D, YYYY",
                            w: "[Week] W, YYYY",
                            M: "MMM YYYY",
                            y: "YYYY"
                        },
                        majorLabelFullTimeFormats: {
                            ms: "MMM D, YYYY HH:mm:ss",
                            s: "MMM D, YYYY HH:mm:ss",
                            m: "MMM D, YYYY",
                            h: "MMM D, YYYY HH:00",
                            d: "MMM D, YYYY",
                            w: "[Week] W, YYYY",
                            M: "MMM YYYY",
                            y: "YYYY"
                        }
                    }, this.determiningDataBounds = "Determining data bounds", this.loadingLabel = "Loading..."
                }

                return __extends(e, t), e
            }(t.LinearChart.SettingsLocalization);
            e.SettingsLocalization = c;
            var p = function (t) {
                function e() {
                    t.apply(this, arguments), this.customPeriod = "Custom", this.periodDropdownTitle = "Select units in which to show the data", this.unitDropdownTitle = "Select units in which to show the data", this.zoomoutButton = "Zoom-out", this.zoomoutTitle = "Zoom out"
                }

                return __extends(e, t), e
            }(t.LinearChart.SettingsLocalizationToolbar);
            e.SettingsLocalizationToolbar = p;
            var d = function (t) {
                function i() {
                    t.apply(this, arguments), this.snapMode = "displayUnit", this.selection = new e.SettingsInteractionSelection, this.scrolling = new e.SettingsInteractionScrolling
                }

                return __extends(i, t), i
            }(t.LinearChart.SettingsInteraction);
            e.SettingsInteraction = d;
            var f = function (t) {
                function e() {
                    t.apply(this, arguments), this.displayUnits = [{
                        unit: "1 s",
                        name: "second"
                    }, {unit: "5 s", name: "5 seconds"}, {
                        unit: "1 m",
                        name: "minute"
                    }, {unit: "5 m", name: "5 minutes"}, {
                        unit: "1 h",
                        name: "hour"
                    }, {unit: "6 h", name: "6 hours"}, {
                        unit: "1 d",
                        name: "day"
                    }, {unit: "1 M", name: "month"}, {
                        unit: "1 y",
                        name: "year"
                    }], this.displayPeriods = [{unit: "10 ms"}, {unit: "100 ms"}, {unit: "s"}, {unit: "m"}, {unit: "h"}, {unit: "d"}, {unit: "M"}, {unit: "y"}, {unit: "10 y"}, {unit: "100 y"}], this.style = new m
                }

                return __extends(e, t), e
            }(t.LinearChart.SettingsArea);
            e.SettingsArea = f;
            var m = function (t) {
                function e() {
                    t.apply(this, arguments), this.loadingData = {fillColor: "#BBB"}, this.markerText = {font: "12px Arial"}, this.selection = {
                        lineColor: "#000000",
                        lineWidth: 1,
                        fillColor: "rgba(30,160,220,0.15)"
                    }, this.selectionLabel = {fillColor: "#000000", font: "12px Arial"}
                }

                return __extends(e, t), e
            }(t.LinearChart.SettingsAreaStyle);
            e.SettingsAreaStyle = m
        }(e = t.TimeChart || (t.TimeChart = {}))
    }(e = t.Internal || (t.Internal = {}))
}(ZoomCharts || (ZoomCharts = {}));
var ZoomCharts;
!function (t) {
    var e;
    !function (t) {
        var e;
        !function (e) {
            var i = function (e) {
                function i(t) {
                    e.call(this), this.animationOrder = 2e3, this.paintOrder = 45, this.updateOrder = 700, this.scene = null, this.customId = 0, this.animating = !1, this.highlights = {}, this.chart = t, this.scene = t.scene
                }

                return __extends(i, e), i.prototype.doAnimations = function (e) {
                    if (e.changes.highlight) {
                        var i = [];
                        for (var n in this.highlights) {
                            var s = this.highlights[n];
                            s.exiting = !0, s.origin.removed && (delete this.highlights[n], s.animator = null, i.push(s))
                        }
                        for (var o = 0; o < i.length; o++) {
                            var s = i[o];
                            this.highlights["__" + ++this.customId] = s
                        }
                        for (var n in this.scene.highlights) {
                            var r = this.scene.highlights[n];
                            if (this.highlights[n]) {
                                var s = this.highlights[n];
                                s.exiting = !1, s.from = r.from, s.to = r.to, s.style = t.Base.Helpers.clone(r.style)
                            } else {
                                var s = {
                                    from: r.from,
                                    to: r.to,
                                    style: t.Base.Helpers.clone(r.style),
                                    animator: null,
                                    exiting: !1,
                                    origin: r
                                };
                                this.highlights[n] = s, r.style.fadeIn > 0 && (this.animating = !0, s.animator = new t.Base.Animator(t.Base.Graphics.deriveColor(s.style.fillColor, 1, 0), s.style.fillColor, s.style.fadeIn, "=", e.timeStamp))
                            }
                        }
                        for (var n in this.highlights) {
                            var s = this.highlights[n];
                            if (s.exiting && !s.animator) {
                                var a = s.style;
                                a.fadeOut > 0 ? (this.animating = !0, s.animator = new t.Base.Animator(a.fillColor, t.Base.Graphics.deriveColor(a.fillColor, 1, 0), a.fadeOut, "=", e.timeStamp)) : delete this.highlights[n]
                            }
                        }
                    }
                    if (this.animating) {
                        var h = !1, l = e.timeStamp;
                        for (var n in this.highlights) {
                            var s = this.highlights[n];
                            s.animator && (s.style.fillColor = s.animator.getColor(l), s.animator.finished(l) ? (s.animator = null, s.exiting && delete this.highlights[n]) : h = !0)
                        }
                        this.animating = h, e.animating = e.animating || h
                    }
                }, i.prototype.paintScene = function (e) {
                    var i = this.scene.x0, n = i + this.scene.width, s = Math.round(this.scene.y0), o = this.scene.height, r = e.context;
                    for (var a in this.highlights) {
                        var h = this.highlights[a], l = Math.max(this.scene.timeToX(h.from), i), u = Math.min(this.scene.timeToX(h.to), n);
                        i > u || l > n || (t.Base.Graphics.rectStyle(r, h.style), r.fillRect(l, s, u - l, o))
                    }
                }, i
            }(t.Base.ChartElement);
            e.Highlights = i
        }(e = t.LinearChart || (t.LinearChart = {}))
    }(e = t.Internal || (t.Internal = {}))
}(ZoomCharts || (ZoomCharts = {}));
var ZoomCharts;
!function (t) {
    var e;
    !function (t) {
        var e;
        !function (e) {
            var i = function (e) {
                function i(t) {
                    e.call(this, t), this.rightAxis = null, this.leftAxis = null, this.timeAxisPanel = null
                }

                return __extends(i, e), i.prototype.createDom = function (i) {
                    e.prototype.createDom.call(this, i), this.timeAxisPanel = t.Base.Helpers.createDom("div", "DVSL-TC-timeAxis", null, this.backgroundContainer), t.Base.DomLayer.setContainerStyle(this.timeAxisPanel), this.leftAxis = t.Base.Helpers.createDom("div", "DVSL-valueAxis", null, this.backgroundContainer), t.Base.DomLayer.setContainerStyle(this.leftAxis), this.rightAxis = t.Base.Helpers.createDom("div", "DVSL-valueAxis", null, this.backgroundContainer), t.Base.DomLayer.setContainerStyle(this.rightAxis)
                }, i.prototype.doAnimations = function (t) {
                    e.prototype.doAnimations.call(this, t), t.changes.bounds && (this.background.style.left = this.scene.x0 + "px", this.background.style.right = this.scene.chartWidth - (this.scene.x0 + this.scene.width) + "px", this.leftAxis.style.width = this.scene.leftMargin + "px", this.leftAxis.style.bottom = this.scene.bottomMargin + "px", this.rightAxis.style.width = this.scene.rightMargin + "px", this.rightAxis.style.bottom = this.scene.bottomMargin + "px", this.timeAxisPanel.style.top = this.scene.y0 + this.scene.height + "px", this.timeAxisPanel.style.left = this.scene.x0 + "px", this.timeAxisPanel.style.width = this.scene.width + "px", this.outerBorder.style.left = this.scene.x0 + "px", this.outerBorder.style.width = this.scene.width + "px")
                }, i
            }(t.Base.DomLayer);
            e.DomLayer = i
        }(e = t.LinearChart || (t.LinearChart = {}))
    }(e = t.Internal || (t.Internal = {}))
}(ZoomCharts || (ZoomCharts = {}));
var ZoomCharts;
!function (t) {
    var e;
    !function (t) {
        var e;
        !function (e) {
            var i = function (t) {
                function i(e, i, n) {
                    t.call(this, e, i, n), this.scrolling = null, this.renderer = null
                }

                return __extends(i, t), i.prototype.createDomLayer = function () {
                    return new e.DomLayer(this)
                }, i.prototype.notifyAnimationDone = function () {
                    var t = this;
                    window.setTimeout(function () {
                        t.dispatchEventParams("animationDone", t.extendEventParams({}), null)
                    }, 0)
                }, i.prototype.replaceSeries = function (t) {
                    return this.settings.series = [], this.updateSettings({series: t})
                }, i.prototype.setLogScale = function (t, e) {
                    var i = {};
                    for (var n in this.settings.valueAxis)i[n] = {logScale: t};
                    return this.updateSettings({
                        valueAxisDefault: {logScale: t},
                        valueAxis: i
                    }, e)
                }, i.prototype.finalInitialize = function () {
                    return t.prototype.finalInitialize.call(this), this.legend = this.events.addElement(new e.Legend(this))
                }, i
            }(t.Base.Impl);
            e.Impl = i
        }(e = t.LinearChart || (t.LinearChart = {}))
    }(e = t.Internal || (t.Internal = {}))
}(ZoomCharts || (ZoomCharts = {}));
var ZoomCharts;
!function (t) {
    var e;
    !function (t) {
        var e;
        !function (e) {
            var i = function (i) {
                function n(e) {
                    i.call(this), this.animationOrder = 10, this.t0 = 0, this.t1 = 0, this.object = null, this.visible = !1, this.activePointer = null, this.pointerX = 0, this.pointerY = 0, this.chart = e, this.container = e.shell.interactiveContainer, this.scene = e.scene, this.events = e.events, this.popup = new t.Base.InfoPopup(this.chart)
                }

                return __extends(n, i), n.prototype.getPopupAreaMouseMoved = function () {
                    return null
                }, n.prototype.buildHeader = function () {
                    return ""
                }, n.prototype.popupHidden = function () {
                    return null
                }, n.prototype.show = function (t) {
                    this.scene.settings.info.enabled && (this.pointerX = t.x, this.pointerY = t.y, this.updatePopup(t))
                }, n.prototype.previewPointerMove = function (t) {
                    !this.scene.settings.info.enabled || null !== this.activePointer && this.activePointer !== t.identifier || (this.pointerX = t.x, this.pointerY = t.y, this.updatePopup(t))
                }, n.prototype.previewPointerDrag = function (t) {
                    !this.scene.settings.info.enabled || null !== this.activePointer && this.activePointer !== t.identifier || (this.activePointer = t.identifier, this.pointerX = t.x, this.pointerY = t.y)
                }, n.prototype.previewPointerCancel = function (t) {
                    null !== this.activePointer && this.activePointer === t.identifier && (this.activePointer = null)
                }, n.prototype.previewPointerUp = function (t) {
                    null !== this.activePointer && this.activePointer === t.identifier && (this.activePointer = null)
                }, n.prototype.previewPointerOut = function (e) {
                    null !== this.activePointer && this.activePointer !== e.identifier || e.touch || (this.activePointer = null, this.pointerX = null, this.pointerY = null, t.Base.Helpers.isParentOf(this.popup.popup, e.target) || this.hideInfoPopup(e))
                }, n.prototype.previewPointerDown = function (t) {
                    null === this.activePointer && (this.activePointer = t.identifier, t.touch ? this.previewPointerMove(t) : this.hideInfoPopup(t))
                }, n.prototype.updatePopup = function (t) {
                    if (!this.pointerX && !this.pointerY)return void this.hideInfoPopup(t);
                    var e = this.getPopupMouseMoved(this.pointerX, this.pointerY, this.t0, this.t1, this.object, this.contents);
                    e ? this.showInfoPopup(e.t0, e.t1, e.obj, e.contents, t) : this.hideInfoPopup(t)
                }, n.prototype.showInfoPopup = function (t, e, i, n, s) {
                    if (!this.popup.visible || t !== this.t0 || e !== this.t1 || i !== this.object) {
                        this.t0 = t, this.t1 = e, this.object = i, this.contents = n, this.scene.setHighlight("infoRange", t, e, this.scene.settings.info.style.highlight);
                        var o = this.scene.y0;
                        this.popup.show(this.scene.timeToX(this.t0), this.scene.timeToX(this.t1), o, n), s.changes.infoLabel = !0, s.changes.highlight = !0
                    }
                }, n.prototype.hideInfoPopup = function (t) {
                    this.popup.visible && (this.popupHidden(t), this.popup.hide(), this.t0 = 0, this.t1 = 0, this.scene.removeHighlight("infoRange"), t.changes.infoLabel = !0, t.changes.highlight = !0)
                }, n.prototype.paintScene = function () {
                    this.popup.visible && this.updateXY()
                }, n.prototype.updateXY = function () {
                    var t = this.scene.y0;
                    return this.t0 > this.chart.scrolling.getTo(1 / 0) || this.t1 < this.chart.scrolling.getFrom(1 / 0) ? void this.popup.hide() : void this.popup.updateXY(this.scene.timeToX(this.t0), this.scene.timeToX(this.t1), t)
                }, n.prototype.getPopupMouseMoved = function (t, e, i, n, s, o) {
                    if (this.scene.displayUnit && !this.scene.xyInChartOrBottom(t, e))return null;
                    var r = this.getPopupAreaMouseMoved(t, e);
                    if (!r)return null;
                    var a = r.t0, h = r.t1, l = null, u = null, c = this.scene.hoverSeriesItem, p = this.scene.settings.info.advanced.scope, d = a, f = h;
                    if (c && (u = c.seriesIndex, ("stack" === p || "value" === p || "auto" === p && void 0 !== u && null !== u) && (d = this.scene.xToTime(c.x0), f = this.scene.xToTime(c.x1)), l = c.stack), null === d)return null;
                    if (d === i && f === n && u === s)return {
                        t0: i,
                        t1: n,
                        obj: s,
                        contents: o
                    };
                    var m = this.buildContent(a, h, u, l);
                    return {t0: d, t1: f, obj: u, contents: m}
                }, n.prototype.buildContent = function (t, e, i, n) {
                    var s, o = this.scene.settings.info.advanced, r = this.chart.renderer.exportData(t, e);
                    if (o.contentsFunction) {
                        var a = null;
                        null !== i && this.scene.settings.series.length > i && (a = this.scene.settings.series[i]), s = o.contentsFunction.call(this.chart.api, r, a, [t, e])
                    } else s = this.buildValues(r, i, n);
                    if (!o.showHeader)return s;
                    var h = this.buildHeader(t, e);
                    return h + s
                }, n.prototype.buildValues = function (i, n, s) {
                    for (var o = this.chart.settings, r = o.localization.noDataLabel, a = o.info.valueFormatterFunction, h = o.info.advanced.showOnlyHoveredSeries ? o.info.advanced.scope : null, l = s && ("stack" === h || "value" === h) || "auto" === h && void 0 !== n && null !== n, u = "value" === h, c = "", p = !1, d = 0; d < i.length; d++) {
                        var f = i[d];
                        if (l) {
                            for (var m = !1, g = 0; g < f.data.length; g++) {
                                var y = f.data[g];
                                y.config.showInLegend && (y.values || o.info.showNoData) && (m = m || null !== n && y.config === o._computedSeries[n] || s === f.stack)
                            }
                            if (!m)continue
                        }
                        var v = i.length + f.data.length === 2 ? "" : o.localization.unnamedSeries;
                        f.name && (p && (c += "</table>", p = !1), f.data.length > 1 ? c += "<h3>" + f.name + "</h3>" : v = f.name), p || (c += '<table cellspacing="0">', p = !0);
                        for (var g = 0; g < f.data.length; g++) {
                            var y = f.data[g], S = null !== n && y.config === this.scene.settings._computedSeries[n];
                            if (y.config.showInLegend && (y.values || o.info.showNoData) && (!u || S)) {
                                c += '<tr><td style="';
                                var C = void 0, b = y.config;
                                if (C = o instanceof e.SettingsSeriesColumns ? b.style.fillColor || b.style.lineColor : b.style.lineColor || b.style.fillColor, C && (c += "color: " + C + ";"), S && (c += "border-color: " + C + ";"), c += '">', c += y.name || v, c += "</td><td>", a) c += a.call(this.chart.api, y.values, y.config); else if (y.values)if (y.values.count > 1 && o.info.aggregations && o.info.aggregations.length > 0)for (var x = 0; x < o.info.aggregations.length; x++) {
                                    var _ = o.info.aggregations[x];
                                    c += "" + t.Base.Helpers.numberFormat(y.values[_]) + ("&nbsp;(" + _ + ")")
                                } else c += t.Base.Helpers.numberFormat(b.data.aggregation ? y.values[b.data.aggregation] : y.values.sum); else c += r;
                                c += "</td></tr>"
                            }
                        }
                    }
                    return p && (c += "</table>"), c
                }, n
            }(t.Base.ChartElement);
            e.InfoPopup = i
        }(e = t.LinearChart || (t.LinearChart = {}))
    }(e = t.Internal || (t.Internal = {}))
}(ZoomCharts || (ZoomCharts = {}));
var ZoomCharts;
!function (t) {
    var e;
    !function (t) {
        var e;
        !function (e) {
            var i = function (e) {
                function i(t) {
                    e.call(this, t), this.animationOrder = 700, this.paintOrder = 25, this.updateOrder = 1100
                }

                return __extends(i, e), i.prototype.doAnimations = function (t) {
                    if (this.chart.selection.isSelecting && this.scene.selectionStart) {
                        var e = this.scene.selectionStart, i = this.scene.selectionEnd;
                        this.showInfoPopup(e, i, null, this.buildContent(e, i, null, null), t)
                    }
                }, i.prototype.getPopupAreaMouseMoved = function (t, e) {
                    if (!this.scene.displayUnit || !this.scene.xyInChartOrBottom(t, e))return null;
                    var i = this.scene.hoverFrom, n = this.scene.hoverTo;
                    return {t0: i, t1: n}
                }, i.prototype.buildHeader = function (e, i) {
                    var n, s = this.scene.displayUnit, o = Math.ceil(s.numberOfUnits(e, i)), r = 1 === (o * s.count | 0) ? this.scene.settings.localization.timeUnitsNames[s.unit] : this.scene.settings.localization.timeUnitsNamesPlural[s.unit];
                    if (1 === o) {
                        var a = t.moment(e).utc(), h = a.format(this.scene.settings.localization.infoDates.fullTimeFormats[s.unit]);
                        n = "" + h
                    } else {
                        ("d" === s.unit || "M" === s.unit || "y" === s.unit || "ms" === s.unit) && (i -= 1);
                        var a = t.moment(e).utc(), l = t.moment(i).utc(), u = s.getBigger() || s;
                        if ("y" !== s.unit && u.roundTimeDown(e) === u.roundTimeDown(i)) {
                            var c = a.format(this.scene.settings.localization.infoDates.majorTimeFormats[s.unit]), p = a.format(this.scene.settings.localization.infoDates.minorTimeFormats[s.unit]), d = l.format(this.scene.settings.localization.infoDates.minorTimeFormats[s.unit]);
                            n = p + " - " + d + " " + c
                        } else {
                            var p = a.format(this.scene.settings.localization.infoDates.fullTimeFormats[s.unit]), d = l.format(this.scene.settings.localization.infoDates.fullTimeFormats[s.unit]);
                            n = p + " - " + d
                        }
                    }
                    return "<em></em><strong>" + n + ("<small>(" + o * s.count + " " + r + ")</small></strong>")
                }, i
            }(t.LinearChart.InfoPopup);
            e.InfoPopup = i
        }(e = t.TimeChart || (t.TimeChart = {}))
    }(e = t.Internal || (t.Internal = {}))
}(ZoomCharts || (ZoomCharts = {}));
var ZoomCharts;
!function (t) {
    var e;
    !function (t) {
        var e;
        !function (e) {
            var i = function (t) {
                function e(e) {
                    t.call(this), this.animationOrder = 600, this.paintOrder = 20, this.updateOrder = 1200, this.chart = null, this.scene = null, this.pointer = null, this.chart = e, this.scene = this.chart.scene
                }

                return __extends(e, t), e.prototype.previewPointerMove = function (t) {
                    this.pointer = null, this.updateHover(t)
                }, e.prototype.onPointerOut = function (t) {
                    this.scene.hoverSeriesItem = null, this.hoverEvent = null, t.changes.hover = !0, this.chart.notifyHoverChanged(t)
                }, e.prototype.previewPointerDown = function (t) {
                    this.pointer = t.identifier, this.updateHover(t)
                }, e.prototype.updateHover = function (t) {
                    var e = this.getClickRange(t.x, t.y), i = null, n = null, s = null;
                    if (e && (i = e.t0, n = e.t1, s = this.chart.renderer.hitTest(t.x, t.y)), this.chart.legend && !s)for (var o = this.chart.legend.findItemAt(t.x, t.y), r = this.scene.settings._computedSeries, a = 0; a < r.length; a++)o === r[a] && (s = {seriesIndex: a}, t.cursor = "pointer", t.hovered = !0);
                    (i !== this.scene.hoverFrom || n !== this.scene.hoverTo || !s != !this.scene.hoverSeriesItem || s && (s.seriesIndex !== this.scene.hoverSeriesItem.seriesIndex || s.x0 !== this.scene.hoverSeriesItem.x0)) && (this.scene.hoverFrom = i, this.scene.hoverTo = n, this.scene.hoverSeriesItem = s, t.changes.hover = !0, this.chart.notifyHoverChanged(t))
                }, e.prototype.onClick = function (t) {
                    if (t.identifier === this.pointer && null !== this.scene.hoverFrom) {
                        var e = this.scene.xToTime(t.x);
                        return null !== this.scene.selectionStart && (this.scene.selectionStart > e || this.scene.selectionEnd < e) ? this.clearSelection(t, "user") : (this.buildClickEvent(t), this.chart.notifyClick(t), t.consumed = !0)
                    }
                }, e.prototype.onRightClick = function (t) {
                    if (null !== this.scene.selectionStart && this.clearSelection(t, "user"), null !== this.scene.hoverFrom) {
                        this.buildClickEvent(t);
                        var e = this.chart.notifyRightClick(t);
                        if (e.defaultPrevented)return t.consumed = !0
                    }
                }, e.prototype.onDoubleClick = function (t) {
                    return null !== this.scene.hoverFrom ? (this.buildClickEvent(t), this.chart.notifyDoubleClick(t), t.consumed = !0) : void 0
                }, e.prototype.clearSelection = function (t, e) {
                    return this.scene.selectionStart = null, this.scene.selectionEnd = null, this.chart.notifySelectionChanged(e), t.changes.selection = !0, t.consumed = !0
                }, e.prototype.onTripleClick = function (t) {
                    return void 0 !== this.scene.hoverFrom && null !== this.scene.hoverFrom ? (this.buildClickEvent(t), this.chart.notifyTripleClick(t), t.consumed = !0) : void 0
                }, e.prototype.getClickRange = function (t, e) {
                    if (!this.scene.xyInChartOrBottom(t, e))return null;
                    var i, n, s, o = this.scene.xToTime(t);
                    if (null !== this.scene.selectionStart && o >= this.scene.selectionStart && o < this.scene.selectionEnd) i = this.scene.selectionStart, n = this.scene.selectionEnd, s = Math.max(2, this.scene.displayUnit.numberOfUnits(i, n)); else if (this.scene.displayUnit) {
                        var r = !0;
                        if (this.scene.majorTimeUnit) {
                            var a = this.scene.majorTimeUnit.roundTimeDown(o), h = this.scene.majorTimeUnit.roundTimeUp(o + 1);
                            e > this.scene.y0 + this.scene.height && (a > this.scene.timeStart || h < this.scene.timeEnd) && (i = a, n = h, s = this.scene.displayUnit.numberOfUnits(i, n), r = !1)
                        }
                        r && (i = this.scene.displayUnit.roundTimeDown(o), n = this.scene.displayUnit.roundTimeUp(o + 1), s = 1)
                    } else i = null, n = null, s = null;
                    return {t0: i, t1: n, numBars: s}
                }, e.prototype.buildClickEvent = function (t) {
                    return t.clickStart = this.scene.hoverFrom, t.clickEnd = this.scene.hoverTo, null !== this.scene.hoverSeriesItem ? (t.clickSeries = this.scene.settings.series[this.scene.hoverSeriesItem.seriesIndex], t.clickMarker = this.scene.hoverSeriesItem.isMarker) : void 0
                }, e
            }(t.Base.ChartElement);
            e.ClickNotifier = i
        }(e = t.TimeChart || (t.TimeChart = {}))
    }(e = t.Internal || (t.Internal = {}))
}(ZoomCharts || (ZoomCharts = {}));
var ZoomCharts;
!function (t) {
    var e;
    !function (t) {
        var e;
        !function (t) {
            var e = function () {
                function e(t) {
                    this.requests = {}, this.results = {}, this.dataSlicesCache = {}, this.nextRequestId = 0, this.hasNewRequests = !1, this.lastSlicer = null, this.chart = t, this.scene = this.chart.scene
                }

                return e.prototype.registerDataProcessingRequest = function (t) {
                    return this.requests[this.nextRequestId] = t, this.results[this.nextRequestId] = {
                        leadIn: null,
                        leadOut: null,
                        times: [],
                        xes: [],
                        values: [],
                        counts: [],
                        fromIndex: 0,
                        toIndex: 0,
                        data: [],
                        from: 0,
                        to: 0,
                        slicer: null,
                        dataExistsFrom: null,
                        dataExistsTo: null
                    }, this.hasNewRequests = !0, this.nextRequestId++
                }, e.prototype.removeDataProcessingRequest = function (t) {
                    delete this.requests[t], delete this.results[t]
                }, e.prototype.getDisplayUnitsSlicer = function () {
                    return this.lastSlicer
                }, e.prototype.getData = function (t) {
                    return this.results[t]
                }, e.prototype.clear = function () {
                    this.requests = {}, this.results = {}
                }, e.prototype.process = function (t) {
                    var e = t.changes;
                    if (e.time || e.data || e.displayUnit || e.bounds || e.settings || this.hasNewRequests)if (this.scene.timeStart >= this.scene.timeEnd)for (var i in this.requests) {
                        var n = this.results[i];
                        n.dataExistsFrom = null, n.dataExistsTo = null
                    } else {
                        this.hasNewRequests = !1, this.loading = !1, this.hasSomeData = !1;
                        var s = !!e.data || e.time;
                        for (var i in this.requests) {
                            var o = this.requests[i], n = this.results[i], r = this.updateData(s, o, n);
                            this.updateSlices(r, i, o, n)
                        }
                        this.scene.loading = this.loading, this.loading ? this.scene.setMessage("noData", this.scene.settings.localization.loadingLabel, 10) : this.hasSomeData ? this.scene.setMessage("noData", null) : this.scene.setMessage("noData", this.scene.settings.localization.noDataLabel, 999)
                    }
                }, e.prototype.exportData = function (e, i, n, s) {
                    for (var o = new t.TimeSlicer(this.scene, n, [], e, i, !0, 0), r = o.times, a = [], h = 0; h < s.length; h++) {
                        var l = s[h], u = l.data, c = this.chart.getData(u.source), p = c.getDataForRange(e, i, n, null), d = new Array(r.length - 1);
                        this.fillValues(p.values, o.times, d, o.counts, o.fromIndex, o.toIndex, u, n), a.push(d)
                    }
                    return {
                        timestamps: o.times.slice(o.fromIndex, o.toIndex - 1),
                        values: a
                    }
                }, e.prototype.updateData = function (t, e, i) {
                    var n = this, s = e.source, o = this.chart.getData(s), r = this.getUnitToUse(e), a = (this.scene.timeEnd - this.scene.timeStart) * o.dataSettings.prefetchRatio;
                    if (t || !i.from && this.scene.timeStart || !i.to && this.scene.timeEnd || i.from >= i.to || this.scene.timeStart - a < i.from || this.scene.timeEnd + a > i.to || null !== i.dataExistsFrom && i.dataExistsFrom > this.scene.timeEnd || null !== i.dataExistsTo && i.dataExistsTo < this.scene.timeStart) {
                        t = !0;
                        var h = this.scene.timeStart - 2 * a, l = this.scene.timeEnd + 2 * a, u = o.getDataForRange(h, l, r, function () {
                            return n._newDataArrived(s)
                        });
                        o.noData || (this.hasSomeData = !0), u.from > this.scene.timeEnd || u.to < this.scene.timeStart ? (i.data = [], i.from = 0, i.to = 0, i.dataExistsFrom = null, i.dataExistsTo = null, this.loading = this.loading || u.loading) : (this.loading = this.loading || u.loading && (u.from > this.scene.timeStart || u.to < this.scene.timeEnd), i.data = u.values, i.from = h, i.to = l, i.dataExistsFrom = u.from, i.dataExistsTo = u.to)
                    }
                    return t
                }, e.prototype.updateSlices = function (t, e, i, n) {
                    var s = this.getUnitToUse(i), o = i.index, r = i.valueFunction, a = n.data, h = n.slicer = this.getSlice(e, i, s), l = h.update(this.scene.timeStart, this.scene.timeEnd), u = l.newBefore, c = l.newAfter, p = n.times = h.times, d = n.counts = h.counts;
                    n.xes = h.xes;
                    var f = n.values = h.values;
                    if (a = n.data, n.fromIndex = h.fromIndex, n.toIndex = h.toIndex, a) a.length > 0 && !r && o >= a[0].length ? this.chart.error("No data for this DataIndex: " + o + ", only " + (a[0].length - 1) + " values present") : (t ? this.fillValues(a, p, f, d, h.fromIndex, h.toIndex, i, s) : (this.fillValues(a, p, f, d, h.fromIndex, u + 1, i, s), this.fillValues(a, p, f, d, c - 1, h.toIndex, i, s)), this.setLeads(i, n, s)); else {
                        f = n.values = new Array(p.length);
                        for (var m = 0; m < f.length; m++)f[m] = null;
                        n.leadIn = null, n.leadOut = null
                    }
                }, e.prototype.getSlice = function (e, i, n) {
                    var s, o = e + "-" + n.toString();
                    return s = this.dataSlicesCache.hasOwnProperty(o) ? this.dataSlicesCache[o] : this.dataSlicesCache[o] = new t.TimeSlicer(this.scene, n, ["values", "counts"]), this.lastSlicer = s, s
                }, e.prototype.getUnitToUse = function () {
                    return this.scene.displayUnit
                }, e.prototype.setLeads = function (e, i, n) {
                    var s = e.noDataPolicy, o = e.index, r = e.valueFunction, a = i.data, h = i.values, l = i.times, u = null, c = null;
                    if ("join" === s && a) {
                        var p = i.fromIndex;
                        if (null === h[p]) {
                            var d = t.Data.binSearch(a, l[p]);
                            if (d = t.Data.linSearchDown(a, d, o, r), -1 !== d) {
                                var f = a[d][0], m = i.slicer.makeMiniSlice(f), g = [m.t0, m.t1], y = [m.x0, m.x1], v = [null, null], S = [null, null];
                                this.fillValues(a, g, v, S, 0, 2, e, n), u = {
                                    times: g,
                                    xes: y,
                                    values: v,
                                    counts: S,
                                    fromIndex: 0,
                                    toIndex: 2
                                }
                            }
                        }
                        var C = i.toIndex;
                        if (null === h[C - 2]) {
                            var d = t.Data.binSearch(a, l[C - 1]);
                            if (d = t.Data.linSearchUp(a, d, o, r), -1 !== d) {
                                var f = a[d][0], m = i.slicer.makeMiniSlice(f), g = [m.t0, m.t1], y = [m.x0, m.x1], v = [null, null], S = [null, null];
                                this.fillValues(a, g, v, S, 0, 2, e, n), c = {
                                    times: g,
                                    xes: y,
                                    values: v,
                                    counts: S,
                                    fromIndex: 0,
                                    toIndex: 2
                                }
                            }
                        }
                    }
                    i.leadIn = u, i.leadOut = c
                }, e.prototype.fillValues = function (t, e, i, n, s, o, r, a) {
                    var h = r.aggregation, l = 0 | r.index, u = 0 | r.countIndex, c = r.valueFunction, p = r.aggregatedValueFunction;
                    if (!(s + 1 >= o) && ("sum" === h ? this.fillValueSum(t, e, i, n, s, o, l, u, c) : "min" === h ? this.fillValueMin(t, e, i, n, s, o, l, u, c) : "max" === h ? this.fillValueMax(t, e, i, n, s, o, l, u, c) : "avg" === h ? this.fillValueAvg(t, e, i, n, s, o, l, u, c) : "count" === h ? this.fillValueCount(t, e, i, n, s, o, l, u, c) : "first" === h ? this.fillValueFirst(t, e, i, n, s, o, l, u, c) : "last" === h ? this.fillValueLast(t, e, i, n, s, o, l, u, c) : this.chart.error("Unrecognized aggregation function: " + h), p))for (var d = s; o - 2 >= d; d++)i[d] = p(i[d], e[d], a)
                }, e.prototype.fillValueSum = function (e, i, n, s, o, r, a, h, l) {
                    for (var u = e.length, c = t.Data.binSearch(e, i[o]), p = o; r - 2 >= p; p++) {
                        for (var d = i[p + 1], f = 0, m = 0, g = void 0; u > c && e[c][0] < d;)g = l ? l(e[c]) : e[c][a], null != g && (f += g, m += 0 === h ? 1 : e[c][h]), c += 1;
                        s[p] = m, n[p] = 0 === m ? null : f
                    }
                }, e.prototype.fillValueMin = function (e, i, n, s, o, r, a, h, l) {
                    for (var u = e.length, c = t.Data.binSearch(e, i[o]), p = o; r - 2 >= p; p++) {
                        for (var d = i[p + 1], f = 1 / 0, m = 0, g = void 0; u > c && e[c][0] < d;)g = l ? l(e[c]) : e[c][a], null != g && (f = Math.min(f, g), m += 0 === h ? 1 : e[c][h]), c += 1;
                        s[p] = m, n[p] = 0 === m ? null : f
                    }
                }, e.prototype.fillValueMax = function (e, i, n, s, o, r, a, h, l) {
                    for (var u = e.length, c = t.Data.binSearch(e, i[o]), p = o; r - 2 >= p; p++) {
                        for (var d = i[p + 1], f = -1 / 0, m = 0, g = void 0; u > c && e[c][0] < d;)g = l ? l(e[c]) : e[c][a], null != g && (f = Math.max(f, g), m += 0 === h ? 1 : e[c][h]), c += 1;
                        s[p] = m, n[p] = 0 === m ? null : f
                    }
                }, e.prototype.fillValueCount = function (e, i, n, s, o, r, a, h, l) {
                    for (var u = e.length, c = t.Data.binSearch(e, i[o]), p = o; r - 2 >= p; p++) {
                        for (var d = i[p + 1], f = 0, m = void 0; u > c && e[c][0] < d;)m = l ? l(e[c]) : e[c][a], null != m && (f += h ? e[c][h] : 1), c += 1;
                        s[p] = f, n[p] = f
                    }
                }, e.prototype.fillValueAvg = function (e, i, n, s, o, r, a, h, l) {
                    for (var u = e.length, c = t.Data.binSearch(e, i[o]), p = o; r - 2 >= p; p++) {
                        for (var d = i[p + 1], f = 0, m = 0, g = void 0; u > c && e[c][0] < d;)g = l ? l(e[c]) : e[c][a], null != g && (f += g, m += h ? e[c][h] : 1), c += 1;
                        s[p] = m, n[p] = 0 === m ? null : f / m
                    }
                }, e.prototype.fillValueFirst = function (e, i, n, s, o, r, a, h, l) {
                    for (var u = e.length, c = t.Data.binSearch(e, i[o]), p = o; r - 2 >= p; p++) {
                        for (var d = i[p + 1], f = null, m = 0, g = void 0; u > c && e[c][0] < d;)g = l ? l(e[c]) : e[c][a], null != g && (null === f && (f = g), m += h ? e[c][h] : 1), c += 1;
                        s[p] = m, n[p] = f
                    }
                }, e.prototype.fillValueLast = function (e, i, n, s, o, r, a, h, l) {
                    for (var u = e.length, c = t.Data.binSearch(e, i[o]), p = o; r - 2 >= p; p++) {
                        for (var d = i[p + 1], f = null, m = 0, g = void 0; u > c && e[c][0] < d;)g = l ? l(e[c]) : e[c][a], null != g && (f = g, m += h ? e[c][h] : 1), c += 1;
                        s[p] = m, n[p] = f
                    }
                }, e.prototype._newDataArrived = function (t) {
                    var e = {};
                    e[t] = !0, this.chart.events.notifySceneChanges({data: e})
                }, e
            }();
            t.DataWarehouse = e
        }(e = t.TimeChart || (t.TimeChart = {}))
    }(e = t.Internal || (t.Internal = {}))
}(ZoomCharts || (ZoomCharts = {}));
var ZoomCharts;
!function (t) {
    var e;
    !function (t) {
        var e;
        !function (t) {
            var e = function () {
                function e(e, i) {
                    if (this.axisConfigList = i, this.chart = e, this.axis = {}, this.baseConfig = this.chart.settings.valueAxisDefault, 0 !== this.axisConfigList.length)for (var n = !1, s = 0; s < this.axisConfigList.length; s++) {
                        var o = this.axisConfigList[s];
                        this.axis[o.id] = new t.ValueAxis(e, o), !n && o.enabled && (n = !0, this.axis[o.id].isPrimary = !0)
                    }
                }

                return e.prototype.getAxis = function (t) {
                    return this.axis[t]
                }, e.prototype.getPanels = function () {
                    for (var t = [], e = 0; e < this.axisConfigList.length; e++) {
                        var i = this.axisConfigList[e], n = this.axis[i.id].getPanel();
                        n && t.push(n)
                    }
                    return t
                }, e.prototype.setPanels = function (t) {
                    for (var e = 0; e < this.axisConfigList.length; e++) {
                        var i = this.axisConfigList[e];
                        this.axis[i.id].setPanel(t[e])
                    }
                }, e.prototype.updateMinMax = function (t) {
                    if (this.axisConfigList.length > 0)for (var e in this.axis) {
                        var i = this.axis[e];
                        i.updateMinMax(t)
                    }
                }, e.prototype.doAnimations = function (t) {
                    for (var e in this.axis) {
                        var i = this.axis[e];
                        i.doAnimations(t)
                    }
                }, e.prototype.paintUnder = function (t) {
                    for (var e in this.axis) {
                        var i = this.axis[e];
                        i.paintUnder(t)
                    }
                }, e.prototype.paint = function (t) {
                    for (var e in this.axis) {
                        var i = this.axis[e];
                        i.paint(t)
                    }
                }, e
            }();
            t.ValueAxisSet = e
        }(e = t.LinearChart || (t.LinearChart = {}))
    }(e = t.Internal || (t.Internal = {}))
}(ZoomCharts || (ZoomCharts = {}));
var ZoomCharts;
!function (t) {
    var e;
    !function (t) {
        var e;
        !function (t) {
            var e;
            !function (t) {
                var e = function () {
                    function e(t) {
                        this.stacks = [], this.idToStack = {}, this.paddingSum = 0, this.scene = t
                    }

                    return e.prototype.addSeries = function (e, i, n, s) {
                        var o;
                        if (i.stack) {
                            var r = i.stack + "#" + i.type;
                            o = this.idToStack[r], o || (o = this.idToStack[r] = new t.Stack(this.scene, this, n, s), this.stacks.push(o))
                        } else o = new t.Stack(this.scene, this, n, s), this.stacks.push(o);
                        o.addSeries(e, i)
                    }, e.prototype.afterInit = function () {
                        for (var t = 0; t < this.stacks.length; t++) {
                            var e = this.stacks[t];
                            e.afterInit()
                        }
                    }, e.prototype.process = function (t) {
                        for (var e = 0; e < this.stacks.length; e++) {
                            var i = this.stacks[e];
                            i.process(t)
                        }
                    }, e.prototype.afterProcess = function () {
                        for (var t = 0; t < this.stacks.length; t++) {
                            var e = this.stacks[t];
                            e.afterProcess()
                        }
                    }, e.prototype.paint = function (t) {
                        for (var e = 0; e < this.stacks.length; e++) {
                            var i = this.stacks[e];
                            i.paint(t)
                        }
                    }, e.prototype.hitTestStack = function (t, e) {
                        for (var i = null, n = 1 / 0, s = 0; s < this.stacks.length; s++) {
                            var o = this.stacks[s], r = o.hitTestStack(t, e), a = r.result, h = r.distance;
                            n > h && (n = h, i = a)
                        }
                        return {result: i, distance: n}
                    }, e.prototype.hitTest = function (t, e, i) {
                        for (var n = null, s = 1 / 0, o = 0; o < this.stacks.length; o++) {
                            var r = this.stacks[o], a = r.hitTest(t, e, i), h = a.result, l = a.distance;
                            s > l && (s = l, n = h)
                        }
                        return {result: n, distance: s}
                    }, e.prototype.exportData = function (t, e, i) {
                        for (var n = 0; n < this.stacks.length; n++) {
                            var s = this.stacks[n];
                            i.push(s.exportData(t, e))
                        }
                    }, e.prototype.computeStackCenterRadius = function (t, e, i, n) {
                        if (!(e.length < 2)) {
                            for (var s = this.stacks.length, o = this.stacks.indexOf(t), r = (o + .5) / s, a = .5 / s, h = 0, l = 0, u = 0; u < this.stacks.length; u++) {
                                var c = this.stacks[u];
                                h += c.paddingLeft + c.paddingRight
                            }
                            for (var u = 0; u < this.stacks.length; u++) {
                                var c = this.stacks[u];
                                if (l += c.paddingLeft, c === t)break;
                                l += c.paddingRight
                            }
                            var p = e[1] - e[0];
                            h > p / 2 && (h = p / 2, l = l / p * (p - h));
                            for (var u = 0; u < e.length - 1; u++) {
                                var d = e[u], f = e[u + 1] - d - h;
                                i[u] = d + f * r + l, n[u] = f * a
                            }
                        }
                    }, e
                }();
                t.Cluster = e
            }(e = t.Series || (t.Series = {}))
        }(e = t.LinearChart || (t.LinearChart = {}))
    }(e = t.Internal || (t.Internal = {}))
}(ZoomCharts || (ZoomCharts = {}));
var ZoomCharts;
!function (t) {
    var e;
    !function (t) {
        var e;
        !function (t) {
            var e = function () {
                function e(t, e) {
                    this.valueAxisSet = e, this.chart = t, this.scene = this.chart.scene, this.clusters = [], this.buildSeries()
                }

                return e.prototype.buildSeries = function () {
                    this.clusters = [];
                    for (var e = {}, i = null, n = {}, s = new t.SettingsStack, o = 0; o < this.scene.settings._computedSeries.length; o++) {
                        var r = this.scene.settings._computedSeries[o];
                        if (r.enabled) {
                            var a = void 0;
                            r.cluster ? (a = e[r.cluster], a || (a = e[r.cluster] = new t.Series.Cluster(this.scene), this.clusters.push(a))) : "line" === r.type ? r.stack ? n.hasOwnProperty(r.stack) ? a = n[r.stack] : (a = n[r.stack] = new t.Series.Cluster(this.scene), this.clusters.push(a)) : (a = new t.Series.Cluster(this.scene), this.clusters.push(a)) : (i || (i = new t.Series.Cluster(this.scene), this.clusters.push(i)), a = i);
                            var h = this.scene.settings._computedStacks[r.stack] || s;
                            a.addSeries(o, r, h, this.valueAxisSet.getAxis(r.valueAxis))
                        }
                    }
                    for (var l = 0; l < this.clusters.length; l++) {
                        var u = this.clusters[l];
                        u.afterInit()
                    }
                }, e.prototype.process = function (t) {
                    for (var e = 0; e < this.clusters.length; e++) {
                        var i = this.clusters[e];
                        i.process(t)
                    }
                }, e.prototype.afterProcess = function () {
                    for (var t = 0; t < this.clusters.length; t++) {
                        var e = this.clusters[t];
                        e.afterProcess()
                    }
                }, e.prototype.paint = function (t) {
                    for (var e = t.context, i = 0; i < this.clusters.length; i++) {
                        var n = this.clusters[i];
                        n.paint(e)
                    }
                }, e.prototype.hitTest = function (t, e, i) {
                    void 0 === i && (i = 4), null == i && (i = 4);
                    for (var n = null, s = 1 / 0, o = 0; o < this.clusters.length; o++) {
                        var r = this.clusters[o], a = r.hitTest(t, e, i), h = a.result, l = a.distance;
                        s > l && (n = h, s = l)
                    }
                    if (s > i) {
                        s = 1 / 0, n = null;
                        for (var o = 0; o < this.clusters.length; o++) {
                            var r = this.clusters[o], u = r.hitTestStack(t, e), h = u.result, l = u.distance;
                            s > l && (n = h, s = l)
                        }
                    }
                    return n
                }, e.prototype.exportData = function (t, e) {
                    for (var i = [], n = 0; n < this.clusters.length; n++) {
                        var s = this.clusters[n];
                        s.exportData(t, e, i)
                    }
                    return i
                }, e
            }();
            t.Renderer = e
        }(e = t.LinearChart || (t.LinearChart = {}))
    }(e = t.Internal || (t.Internal = {}))
}(ZoomCharts || (ZoomCharts = {}));
var ZoomCharts;
!function (t) {
    var e;
    !function (t) {
        var e;
        !function (e) {
            var i = function () {
                function e(t) {
                    this.r = t, this.scene = t.scene, this.bars = null
                }

                return e.prototype.paint = function () {
                }, e.prototype.paintFancyRect = function (e, i, n, s, o, r, a, h) {
                    if (!(s >= n || i >= o)) {
                        var l = Math.max(s, i), u = Math.min(o, n);
                        if (e.beginPath(), e.rect(l, r, u - l, a), t.Base.Graphics.paint(e, h), h.image) {
                            var c = this.r.getImage(h.image);
                            if (c) {
                                var p = c.width, d = c.height, f = (l + u) / 2, m = r + (a - d) / 2, g = p / 2 + 2;
                                if (f + g - 2 > o) {
                                    f = o - p - 2;
                                    var y = l - f;
                                    if ((p - y | 0) > 0 && (0 | p) > (0 | y))return e.drawImage(c, 0 | y, 0, p - y | 0, d, f + y | 0, 0 | m, p - y | 0, 0 | d)
                                } else {
                                    if (!(s > f - g))return e.drawImage(c, f - p / 2 | 0, 0 | m);
                                    f = s + 2;
                                    var v = Math.min(u - f, p);
                                    if ((0 | v) > 0)return e.drawImage(c, 0, 0, 0 | v, d, 0 | f, 0 | m, 0 | v, 0 | d)
                                }
                            }
                        }
                    }
                }, e
            }();
            e.DataLimitRenderer = i
        }(e = t.LinearChart || (t.LinearChart = {}))
    }(e = t.Internal || (t.Internal = {}))
}(ZoomCharts || (ZoomCharts = {}));
var ZoomCharts;
!function (t) {
    var e;
    !function (t) {
        var e;
        !function (e) {
            var i = function (e) {
                function i(i, n) {
                    e.call(this), this.animationOrder = 400, this.paintOrder = 5, this.updateOrder = 1500, this.dataWarehouse = n, this.chart = i, this.scene = this.chart.scene, this.events = this.chart.events, this.buildSeries(), this.shades = new t.LinearChart.DataLimitRenderer(this)
                }

                return __extends(i, e), i.prototype.buildSeries = function () {
                    this.valueAxis = new t.LinearChart.ValueAxisSet(this.chart, this.scene.settings._computedValueAxisList), this.r = new t.LinearChart.Renderer(this.chart, this.valueAxis), this.dataWarehouse.clear(), this.requestIds = [];
                    for (var e = 0; e < this.scene.settings._computedSeries.length; e++) {
                        var i = this.scene.settings._computedSeries[e];
                        this.requestIds.push(this.dataWarehouse.registerDataProcessingRequest(i.data))
                    }
                }, i.prototype.onSceneChange = function (e) {
                    var i = e.changes;
                    i.settings && ((i.settingsChanges._computedSeries || i.settingsChanges._computedValueAxis) && this.buildSeries(), i.settingsChanges._computedValueAxis && (i.bounds = !0)), (i.bounds || i.settings) && (i.time = !0), i.data && t.Base.Helpers.hasProperties(i.data) && this.chart.notifyChartUpdate("data", !0)
                }, i.prototype.getPanels = function () {
                    return this.valueAxis.getPanels()
                }, i.prototype.doAnimations = function (t) {
                    var e = t.changes;
                    if (this.dataWarehouse.process(t), this.scene.displayUnit) {
                        if (this.displayUnit !== this.scene.displayUnit && (this.displayUnit = this.scene.displayUnit, e.displayUnit = !0), e.time || e.data || e.displayUnit || e.bounds) {
                            for (var i = [], n = 0; n < this.requestIds.length; n++)i.push(this.dataWarehouse.getData(this.requestIds[n]));
                            this.r.process(i)
                        }
                        this.valueAxis.updateMinMax(t), this.r.afterProcess(), this.valueAxis.doAnimations(t)
                    }
                }, i.prototype.paintScene = function (e) {
                    var i = e.context;
                    this.valueAxis.paintUnder(e), t.Base.Graphics.pushClip(i, this.scene.x0, this.scene.y0, this.scene.width, this.scene.height), this.r.paint(e), this.shades.paint(i, null, null), t.Base.Graphics.popClip(i), this.valueAxis.paint(e)
                }, i.prototype.hitTest = function (t, e) {
                    return this.scene.xyInChart(t, e) ? this.r.hitTest(t, e, this.scene.settings.interaction.selection.tolerance) : null
                }, i.prototype.exportData = function (t, e) {
                    return this.r.exportData(t, e)
                }, i
            }(t.Base.ChartElement);
            e.Renderer = i
        }(e = t.TimeChart || (t.TimeChart = {}))
    }(e = t.Internal || (t.Internal = {}))
}(ZoomCharts || (ZoomCharts = {}));
var ZoomCharts;
!function (t) {
    var e;
    !function (t) {
        var e;
        !function (e) {
            var i = function (t) {
                function i(e) {
                    t.call(this), this.chart = e, this.scene = e.scene, this.settings = e.settings, this.reinitializePeriod = !0
                }

                return __extends(i, t), i.prototype.onSceneChange = function (t) {
                    var e = t.changes;
                    return e.settings && e.settingsChanges.navigation && (this.reinitializePeriod = !0), this.reinitializePeriod ? this.setupInitialDisplayPeriod() : void 0
                }, i.prototype.onNewDataObject = function () {
                    return 1
                }, i.prototype.setupInitialDisplayPeriod = function () {
                    var t = this;
                    if (this.scene.width) {
                        this.reinitializePeriod = !1;
                        var e = this.settings.navigation.initialDisplayAnchor, i = this.settings.navigation.initialDisplayPeriod, n = this.settings.navigation.initialDisplayUnit;
                        return this.computeDisplayPeriod(i, e, n, function (n, s, o) {
                            return t.scene.setMessage("impl", null, 0), t.scene.loading = !1, t.scene.displayUnit && (o = t.scene.displayUnit), t.scene.timeStart || t.scene.timeEnd ? void 0 : t.chart.scrolling.setTimeRange(n, s, o, !1, "init", e, i)
                        })
                    }
                }, i.prototype.computeDisplayPeriod = function (t, i, n, s) {
                    var o = this, r = this.chart.scrolling.computeDisplayPeriod(t, i, n, this.scene.mainData.dataFrom, this.scene.mainData.dataTo), a = r.from, h = r.to, l = r.unit;
                    if (null !== a && null !== h && l && null !== a && null !== h)return s(a, h, l);
                    if (!(this.scene.mainData.dataSettings.dataFunction || this.scene.mainData.dataSettings.url || this.scene.mainData.dataSettings.urlByUnit || this.scene.mainData.dataSettings.preloaded))return void this.chart.error("Cannot compute data dependant display period, no data given. DisplayPeriod = " + t + ", DisplayAnchor = " + i);
                    var u = function (l, c, p, d, f, m) {
                        if (!o.chart.removed) {
                            if (null === l || null === c || 0 === l && 0 === c && o.scene.mainData.noData)return void s(d, f, m);
                            r = o.chart.scrolling.computeDisplayPeriod(t, i, n, l, c), a = r.from, h = r.to;
                            var g = r.unit;
                            return null === a || null === h ? void o.chart.error("Could not setup display time interval. Check your configuration.") : void(e.TimeSetup.isSmallerOrEqualUnit(p, g.unit) ? s(a, h, g) : o.scene.mainData.determineDataLimits(g.unit, !0, !0, function (t, e, i) {
                                        return u(t, e, i, l, c, g)
                                    }))
                        }
                    };
                    this.scene.mainData.determineDataLimits(null, !0, !0, function (t, e, i) {
                        return u(t, e, i, 0, 0, null)
                    })
                }, i
            }(t.Base.ChartElement);
            e.Navigator = i
        }(e = t.TimeChart || (t.TimeChart = {}))
    }(e = t.Internal || (t.Internal = {}))
}(ZoomCharts || (ZoomCharts = {}));
var ZoomCharts;
!function (t) {
    var e;
    !function (t) {
        var e;
        !function (e) {
            var i = function () {
                function t() {
                    this.time = 0, this.label = null, this.style = null, this.textStyle = null, this.overridesLimits = !1
                }

                return t
            }();
            e.Marker = i;
            var n = function (e) {
                function i(t) {
                    e.call(this), this.animationOrder = 2e3, this.paintOrder = 40, this.updateOrder = 800, this.scene = null, this.chart = t, this.scene = this.chart.scene
                }

                return __extends(i, e), i.prototype.paintScene = function (e) {
                    if (0 !== this.scene.markers.length && this.scene.displayUnit) {
                        var i = this.scene.x0, n = i + this.scene.width, s = Math.round(this.scene.y0), o = this.scene.height, r = Math.round(s + o + .5 * this.scene.bottomAxisSize), a = Math.round(s + o + this.scene.bottomAxisSize), h = e.context;
                        t.Base.Graphics.pushClip(h, i, s, this.scene.width, this.scene.height + this.scene.bottomAxisSize), h.textBaseline = "middle";
                        var l = this.scene.settings.localization.markerDates.timeFormats[this.scene.displayUnit.unit];
                        t.Base.Graphics.textStyle(h, this.scene.settings.area.style.markerText);
                        for (var u = 0; u < this.scene.markers.length; u++) {
                            var c = this.scene.markers[u], p = this.scene.timeToX(c.time);
                            if (p = Math.floor(p) + .5, p + 200 >= i - 1 && n + 1 >= p - 160) {
                                var d = t.Base.Graphics.beginStrokeAndFill(h, c.style);
                                d.moveTo(p, s), d.lineTo(p, a), t.Base.Graphics.endStrokeAndFill(h, d, c.style), t.Base.Graphics.textStyle(h, c.textStyle);
                                var f = t.moment(c.time).utc().format(l);
                                c.label && (f = c.label + " " + f);
                                var m = h.measureText(f).width;
                                p + m >= n ? (h.textAlign = "end", p -= 2) : (h.textAlign = "start", p += 2), h.fillText(f, p, r)
                            }
                        }
                        t.Base.Graphics.popClip(h)
                    }
                }, i
            }(t.Base.ChartElement);
            e.Markers = n
        }(e = t.TimeChart || (t.TimeChart = {}))
    }(e = t.Internal || (t.Internal = {}))
}(ZoomCharts || (ZoomCharts = {}));
var ZoomCharts;
!function (t) {
    var e;
    !function (t) {
        var e;
        !function (e) {
            var i = function (i) {
                function n(n, s) {
                    i.call(this, new e.Settings(n), new e.Scene, s), this.timeStart = 0, this.timeEnd = 0, this.displayUnit = null, this.selectionStart = 0, this.selectionEnd = 0, this.dataWarehouse = new e.DataWarehouse(this), this.renderer = this.events.addElement(new e.Renderer(this, this.dataWarehouse)), this.scrolling = this.events.addElement(new e.Scrolling(this)), this.selection = this.events.addElement(new e.Selection(this)), this.navigator = this.events.addElement(new e.Navigator(this)), this.events.addElement(new e.ClickNotifier(this)), this.infoPopup = this.events.addElement(new e.InfoPopup(this)), this.timeAxis = this.events.addElement(new e.TimeAxis(this)), this.events.addElement(new e.TimeUpdater(this)), this.events.addElement(new e.Markers(this)), this.events.addElement(new t.LinearChart.Highlights(this)), t.moment.locale("zc", this.settings.localization.calendar), this.finalInitialize()
                }

                return __extends(n, i), n.prototype.createDataObj = function (t) {
                    return new e.Data(this, t)
                }, n.prototype.getData = function (t) {
                    return i.prototype.getData.call(this, t)
                }, n.prototype.onSettingsChanged = function (i) {
                    if (i.data) i.toolbars = !0; else if (t.Base.Helpers.hasProp(i, "area.displayUnits")) {
                        var n = new e.TimeSetup(this.settings);
                        if (this.scene.displayUnit && !n.isAllowedDisplayUnit(this.scene.displayUnit)) {
                            var s = n.computeDisplayUnit(this.scene.timeStart, this.scene.timeEnd, this.scene.displayUnit, this.scene.timeStart, this.scene.timeEnd, this.scene);
                            this.scrolling.setTimeRangeSnap(this.scene.timeStart, this.scene.timeEnd, null, s, !0, "api", !0, !0)
                        }
                    }
                    i.localization && i.localization.calendar && t.moment.locale("zc", this.settings.localization.calendar), this.events.notifySceneChanges({time: !0})
                }, n.prototype.save = function () {
                    return JSON.stringify({
                        from: this.timeStart,
                        to: this.timeEnd,
                        unit: this.displayUnit.toString(),
                        selFrom: this.scene.selectionStart,
                        selTo: this.scene.selectionEnd,
                        anchor: this.scene.anchor,
                        period: this.scene.period
                    })
                }, n.prototype.restore = function (e, i) {
                    if (e) {
                        var n = JSON.parse(e), s = t.Base.TimeStep.parse(n.unit);
                        if (!s)return void this.error("Restore state: illegal display  unit: " + n.unit);
                        this.scrolling.setTimeRange(n.from, n.to, s, i, "api", n.anchor, n.period), this.setSelection(n.selFrom, n.selTo)
                    }
                }, n.prototype.setSelection = function (t, e, i) {
                    void 0 === i && (i = "api"), null == i && (i = "api"), (this.scene.selectionStart !== t || this.scene.selectionEnd !== e) && (this.scene.selectionStart = t, this.scene.selectionEnd = e, this.events.notifySceneChanges({selection: !0}), this.notifySelectionChanged(i))
                }, n.prototype.setTimeRange = function (t, e, i, n, s) {
                    void 0 === s && (s = "api"), null == s && (s = "api"), this.setSelection(null, null, s), this.scrolling.setTimeRange(t, e, i, n, s)
                }, n.prototype.setDisplayPeriod = function (t, e, i, n, s) {
                    var o = this;
                    return void 0 === e && (e = null), void 0 === i && (i = null), void 0 === n && (n = !0), void 0 === s && (s = "api"), null == s && (s = "api"), null == n && (n = !0), null === e && (e = this.scene.anchor), this.setSelection(null, null), "string" == typeof e && (e = e.trim()), "string" == typeof t && (t = t.trim()), this.navigator.computeDisplayPeriod(t, e, i, function (i, r, a) {
                        return o.scrolling.setTimeRange(i, r, a, n, s, e, t)
                    })
                }, n.prototype.scrollIntoView = function (t, e) {
                    void 0 === e && (e = .2), null == e && (e = .2), this.error("ScrollIntoView: not implemented")
                }, n.prototype.scroll = function (t, i) {
                    var n = t.trim().split(" ");
                    if (3 !== n.length)return void this.error("Incorrect scroll format: " + t);
                    var s = n[0], o = parseInt(n[1], 10), r = n[2];
                    if ("<" !== s && ">" !== s || "number" != typeof o)return void this.error("Scroll:Incorrect scroll format: " + t);
                    var a = new e.TimeSetup(this.settings), h = a.scroll(this.timeStart, this.timeEnd, this.displayUnit, s, o, r), l = h.from, u = h.to;
                    this.scrolling.setTimeRange(l, u, this.displayUnit, i, "api", null, this.scene.period)
                }, n.prototype.zoomOut = function (t, e, i) {
                    void 0 === e && (e = !0), void 0 === i && (i = "api"), this.setSelection(null, null), this.scrolling.zoomOut(t, this.scene.timeStart, this.scene.timeEnd, e, i), this.scene.period = null
                }, n.prototype.zoomIn = function (t, e, i, n) {
                    void 0 === e && (e = null), void 0 === i && (i = !0), void 0 === n && (n = "api"), this.setSelection(null, null), this.scrolling.zoomIn(t, e, this.scene.timeStart, this.scene.timeEnd, i, n), this.scene.period = null
                }, n.prototype.getMinSelectableUnit = function () {
                    var t = this.settings.advanced.maxUnitsToDisplay, i = (this.timeEnd - this.timeStart) / t;
                    return new e.TimeSetup(this.settings).getMinUnitForTime(i)
                }, n.prototype.setDisplayUnit = function (e, i, n, s) {
                    void 0 === n && (n = !1), void 0 === s && (s = "api"), null == s && (s = "api"), null == n && (n = !1);
                    var o = t.Base.TimeStep.parse(e);
                    if (o) {
                        var r = !1;
                        if (n) {
                            var a = this.getMinSelectableUnit();
                            a.approxTime() > o.approxTime() && (o = a);
                            var h = this.scrolling.snap(this.timeStart, this.timeEnd, null, o, !1, !0), l = h.from, u = h.to, c = h.period, p = h.anchor;
                            u - l > this.timeEnd - this.timeStart && (r = !0, this.scrolling.setTimeRange(l, u, o, i, s, p, c))
                        }
                        r || this.scrolling.setTimeRange(this.timeStart, this.timeEnd, o, !1, s, this.scene.anchor, this.scene.period)
                    }
                }, n.prototype.exportVisibleData = function () {
                    if (!this.displayUnit)return [];
                    for (var e = this.settings._computedSeries, i = this.dataWarehouse.exportData(this.timeStart, this.timeEnd, this.displayUnit, e), n = this.settings.localization.infoDates.fullTimeFormats[this.displayUnit.unit], s = i.timestamps, o = i.values, r = ["timestamp", "time"], a = 0; a < e.length; a++) {
                        var h = e[a];
                        r.push(h.name || h.id || "")
                    }
                    for (var l = [r], u = 0; u < s.length; u++) {
                        for (var c = s[u], p = [c, t.moment(c).utc().format(n)], d = 0; d < e.length; d++)p.push(o[d][u]);
                        l.push(p)
                    }
                    return l
                }, n.prototype.isThisDisplayPeriod = function (t, e) {
                    if (!this.displayUnit)return !1;
                    var i = this.scene.mainData.dataFrom, n = this.scene.mainData.dataTo, s = this.scrolling.computeDisplayPeriod(t, e, this.displayUnit.toString(), i, n);
                    return i = s.from, n = s.to, i === this.timeStart && n === this.timeEnd
                }, n.prototype.notifyTimeChanged = function (t, e, i, n) {
                    this.timeStart = t, this.timeEnd = e, this.displayUnit = i, this.notifyChartUpdate(n)
                }, n.prototype.saveNavigation = function () {
                    return this.displayUnit ? {
                            timeStart: this.timeStart,
                            timeEnd: this.timeEnd,
                            displayUnit: this.displayUnit,
                            anchor: this.scene.anchor,
                            period: this.scene.period
                        } : null
                }, n.prototype.restoreNavigation = function (t, e, i) {
                    this.timeStart = t.timeStart, this.timeEnd = t.timeEnd, this.displayUnit = t.displayUnit, this.scrolling.setTimeRange(this.timeStart, this.timeEnd, this.displayUnit, e, i, t.anchor, t.period)
                }, n.prototype.doChartUpdateNotify = function (t) {
                    i.prototype.doChartUpdateNotify.call(this, t), this.dispatchEventParams("timeChange", this.extendEventParams({origin: t}), null)
                }, n.prototype.extendEventParams = function (t) {
                    return t.timeStart = this.timeStart, t.timeEnd = this.timeEnd, t.displayUnit = this.displayUnit ? this.displayUnit.toString() : null, t.selectionStart = this.scene.selectionStart, t.selectionEnd = this.scene.selectionEnd, t.hoverStart = this.scene.hoverFrom, t.hoverEnd = this.scene.hoverTo, null !== this.scene.hoverSeriesItem && (t.hoverSeries = this.scene.settings.series[this.scene.hoverSeriesItem.seriesIndex], t.hoverMarker = this.scene.hoverSeriesItem.isMarker), t
                }, n.prototype.defaultClick = function (t) {
                    this.setSelection(null, null, "user"), this.scrolling.setTimeRangeSnap(t.clickStart, t.clickEnd, null, null, !0, "user", !1, !0)
                }, n.prototype.defaultRightClick = function (t) {
                    this.infoPopup.show(t), t.preventDefault()
                }, n
            }(t.LinearChart.Impl);
            e.Impl = i
        }(e = t.TimeChart || (t.TimeChart = {}))
    }(e = t.Internal || (t.Internal = {}))
}(ZoomCharts || (ZoomCharts = {}));
var ZoomCharts;
!function (t) {
    var e = function (e) {
        function i(n) {
            var s = this;
            e.call(this), this.typeName = "TimeChart", this._impl = i.chartFactoryMethod ? i.chartFactoryMethod(function (e) {
                    return new t.Internal.TimeChart.Impl(e, s)
                }, n) : new t.Internal.TimeChart.Impl(n, this)
        }

        return __extends(i, e), i.prototype.createEmptySettings = function () {
            return t.Internal.Base.SettingsHelper.createEmptySettings(t.Internal.Base.SettingsMapping.TimeChartSettings)
        }, i.prototype.updateSettings = function (i) {
            return t.Internal.Base.SettingsHelper.cleanupEmptySettings(i), e.prototype.updateSettings.call(this, i), this
        }, i.prototype.time = function (t, e, i) {
            return void 0 === i && (i = !0), null != t && null != e && this._impl.setTimeRange(t, e, null, i), [this._impl.timeStart, this._impl.timeEnd]
        }, i.prototype.setDisplayPeriod = function (t, e, i) {
            return this._impl.setDisplayPeriod(t, e, null, i)
        }, i.prototype.displayUnit = function (t, e, i, n) {
            return void 0 === e && (e = !0), void 0 === i && (i = !1), void 0 === n && (n = null), null == i && (i = !1), null == e && (e = !0), t && this._impl.setDisplayUnit(t, e, i, n), this._impl.displayUnit ? this._impl.displayUnit.toString() : null
        }, i.prototype.selection = function (t, e) {
            return void 0 !== t && void 0 !== e && this._impl.setSelection(t, e), [this._impl.scene.selectionStart, this._impl.scene.selectionEnd]
        }, i.prototype.scroll = function (t, e) {
            return void 0 === e && (e = !0), null == e && (e = !0), this._impl.scroll(t, e)
        }, i.prototype.zoomOut = function (t, e) {
            return void 0 === t && (t = null), void 0 === e && (e = !0), null == e && (e = !0), this._impl.zoomOut(t, e, "api")
        }, i.prototype.zoomIn = function (t, e, i) {
            return void 0 === t && (t = null), void 0 === e && (e = null), void 0 === i && (i = !0), null == i && (i = !0), this._impl.zoomIn(t, e, i, "api")
        }, i.prototype.replaceSeries = function (t) {
            return this._impl.replaceSeries(t)
        }, i.prototype.exportVisibleData = function () {
            return this._impl.exportVisibleData()
        }, i.themes = {
            flat: t.Internal.TimeChart.Settings.FlatTheme,
            round: t.Internal.TimeChart.Settings.RoundTheme,
            gradient: t.Internal.TimeChart.Settings.GradientTheme,
            "static": t.Internal.TimeChart.Settings.StaticChart,
            dark: t.Internal.TimeChart.Settings.DarkTheme
        }, i.chartFactoryMethod = null, i
    }(t.Internal.Base.Api);
    t.TimeChart = e, t.Internal.Base.Helpers.exportSymbol("TimeChart", t.TimeChart)
}(ZoomCharts || (ZoomCharts = {}));
var ZoomCharts;
!function (t) {
    var e;
    !function (t) {
        var e;
        !function (t) {
            t.PiechartBack = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAC8AAAA1CAMAAADmtEJjAAAAYFBMVEVMaXEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADIAgUIAAAAH3RSTlMACbeu3XUBgH/vy+gqMRghOfqXYUpWwkDGihCfgmebkGEUkgAAAQVJREFUeNqV0ttugzAURNEx2BADBMItTXqZ///Lyi0qrXOkZvajtcbyg2F1gtSJIqfIKXKKnCKnyClyipwip8gpcmo8FaNvitewdtV/PB8WYRD4V83sBJ5q50rgqW2QOBlHiZOXUeJkewZQ8/kKiIOrOCigDS5ncbBCG9ygDUqYgxhpt8EcALh3Syjb3L/AHAB7/a3N7jcHOHIhZu83BvjduTj8BHOAP1XTjw8wB8gG5fGBzAGynN//g4M5QN7y7Rs8VJu+8ky9wR7gocBUD2tg+TFxD7Pa8C75GnbWeSQ54Pk8WULzV8VHNgp35Kr4nk2l+JkLlD42SPle4t0Eqfe75jvsfQLbYGzTrP2yIAAAAABJRU5ErkJggg=="
        }(e = t.Resources || (t.Resources = {}))
    }(e = t.Internal || (t.Internal = {}))
}(ZoomCharts || (ZoomCharts = {}));
var ZoomCharts;
!function (t) {
    var e;
    !function (t) {
        var e;
        !function (e) {
            var i = function (t) {
                function e() {
                    t.apply(this, arguments), this.itemsToLoad = 50, this.partialLoad = !0, this.autoCategories = null, this.sortField = null, this.dataFunction = null, this.preloaded = null
                }

                return __extends(e, t), e
            }(t.Base.SettingsData);
            e.SettingsData = i;
            var n = function () {
                function e() {
                    this.values = [], this.offset = 0, this.totalCount = null, this.total = 0, this.valuesSum = 0, this.beforeSum = 0, this.afterSum = 0, this.done = !1
                }

                return e.prototype.addData = function (e, i, n, s, o, r, a) {
                    var h = e.length;
                    if (0 === this.values.length && (this.offset = i), i < this.offset) {
                        if (i + h < this.offset)return void a.error("Data cannot be merged");
                        for (; i < this.offset;) {
                            this.offset--;
                            var l = e[this.offset - i];
                            this.values.unshift(l), this.valuesSum += l.value, this.beforeSum -= l.value
                        }
                    }
                    if (i + h > this.offset + this.values.length) {
                        if (this.offset + this.values.length < i)return void a.error("Data cannot be merged");
                        for (; this.offset + this.values.length < i + h;) {
                            var l = e[this.offset + this.values.length - i];
                            this.values.push(l), this.valuesSum += l.value, this.afterSum -= l.value
                        }
                    }
                    (!n || e.length < n) && (this.done = !0), this.beforeSum = (i = 0) ? 0 : s ? t.Base.Helpers.tryParseFloat(s, 0) : Math.max(0, this.beforeSum), this.done ? (this.afterSum = 0, this.totalCount = this.values.length + this.offset) : this.afterSum = o ? t.Base.Helpers.tryParseFloat(o, 0) : Math.max(0, this.afterSum), r ? (this.total = t.Base.Helpers.tryParseFloat(r, 0), o || !this.beforeSum && 0 !== this.offset || (this.afterSum = this.total - this.valuesSum - this.beforeSum), s || !this.afterSum && !this.done || (this.beforeSum = this.total - this.valuesSum - this.afterSum)) : this.total = this.beforeSum + this.valuesSum + this.afterSum
                }, e.prototype.markDone = function () {
                    this.done || (this.done = !0, this.afterSum = 0, this.totalCount = this.offset + this.values.length)
                }, e
            }();
            e.PieData = n;
            var s = function (e) {
                function i(t, i) {
                    if (e.call(this, t, i), this.pies = {}, this.pendingPies = {}, this.requestedPies = {}, this.nextId = 0, this.applyPreloadedData(), !this.hasDataFunc()) {
                        for (var n in this.pies)this.pies[n].markDone();
                        this.chart.scene.loading = !1
                    }
                }

                return __extends(i, e), i.prototype.hasDataFunc = function () {
                    return !!this.dataSettings.dataFunction || !!this.dataSettings.url
                }, i.prototype.getRootId = function () {
                    return this.settings.navigation.initialDrilldown[0]
                }, i.prototype.canExpand = function (e) {
                    return this.pies.hasOwnProperty(e) ? !0 : this.hasDataFunc() && e && e[0] !== t.Base.Helpers.SeparatorChar ? !0 : !1
                }, i.prototype.getPieData = function (t) {
                    if (!this.pies.hasOwnProperty(t))return null;
                    var e = this.pies[t];
                    return this.needPostprocessing() && (e = this.filterAndSortData(e)), e
                }, i.prototype.requestMorePieData = function (t, e) {
                    return void 0 === e && (e = this.dataSettings.itemsToLoad), null == e && (e = this.dataSettings.itemsToLoad), !this.pies.hasOwnProperty(t) || this.pies[t].done ? !1 : (this.requestPieData(t, this.pies[t].offset + this.pies[t].values.length, e), !0)
                }, i.prototype.requestLessPieData = function (t, e) {
                    return void 0 === e && (e = this.dataSettings.itemsToLoad), this.pies.hasOwnProperty(t) && !this.pies[t].done && this.pies[t].offset > 0 ? (this.requestPieData(t, Math.max(this.pies[t].offset - this.dataSettings.itemsToLoad, 0), e), !0) : !1
                }, i.prototype.pieRemoved = function (t) {
                    delete this.pendingPies[t], delete this.requestedPies[t]
                }, i.prototype.requestPieData = function (e, i, n) {
                    if (void 0 === n && (n = this.dataSettings.itemsToLoad), e[0] === t.Base.Helpers.SeparatorChar)throw new Error("Invalid Id: " + e);
                    if (this.pies.hasOwnProperty(e)) {
                        var s = this.pies[e], o = s.offset, r = o + s.values.length;
                        if (o > i) n = o - i; else {
                            if (!(i + n > r))return;
                            n = i + n - r, i = r
                        }
                    } else(this.needPostprocessing() || !this.dataSettings.partialLoad || this.dataSettings.autoCategories) && (n = 2147483647, i = 0);
                    if (!this.requestedPies.hasOwnProperty(e))if (this.pendingPies.hasOwnProperty(e)) {
                        var a = this.pendingPies[e], h = Math.min(a.offset, i), l = Math.max(a.offset + a.limit, i + n);
                        a.offset = h, a.limit = l - h
                    } else this.dataFunc && (this.pendingPies[e] = {
                        id: e,
                        offset: i,
                        limit: n
                    }, this.scheduleRequests())
                }, i.prototype.autoCategorize = function (e, i) {
                    if (e.offset || e.afterSum > 0 || e.total > e.subvalues.length)return this.chart.error("Cannot auto categorize partial data"), e;
                    if (0 === i.length)return e;
                    for (var n = t.Base.Helpers.clone(e), s = [n], o = 0; o < i.length; o++) {
                        for (var r = i[o], a = [], h = 0; h < s.length; h++) {
                            for (var l = s[h], u = [], c = {}, p = 0; p < l.subvalues.length; p++) {
                                var d = l.subvalues[p], f = void 0;
                                f = t.Base.Helpers.isFunction(r) ? r(d) : d[r], f = void 0 === f || null === f ? "None" : f.toString();
                                var m = void 0;
                                c.hasOwnProperty(f) ? m = c[f] : (m = {
                                        id: void 0,
                                        value: 0,
                                        subvalues: [],
                                        name: f,
                                        __category: r
                                    }, c[f] = m, u.push(m), a.push(m)), m.subvalues.push(d), m.value += t.Base.Helpers.tryParseFloat(d.value, 0)
                            }
                            l.subvalues = u
                        }
                        s = a
                    }
                    return n
                }, i.prototype.addDataInt = function (e, i, s, o, r, a, h, l, u) {
                    for (var c = {}, p = 0; p < i.length; p++) {
                        var d = i[p];
                        t.Base.Helpers.isObjectOrArray(d) ? d.value = t.Base.Helpers.tryParseFloat(d.value, 0) : i[p] = d = {
                                value: t.Base.Helpers.tryParseFloat(d, 0),
                                id: p.toString(10)
                            }, d.id ? (d.__id = "" + d.id, c.hasOwnProperty(d.__id) && this.chart.error("Data response: Multiple slices with the same ID: " + d.__id), c[d.__id] = !0) : (d.__id = t.Base.Helpers.SeparatorChar + this.nextId, this.nextId++), d.subvalues && (u[d.__id] = !0, this.addDataInt(d.__id, d.subvalues, 0, 1 / 0, 0, 0, 0, null, u), this.markDone(d.__id))
                    }
                    var f;
                    if (f = this.pies.hasOwnProperty(e) ? this.pies[e] : this.pies[e] = new n, f.addData(i, s, o, r, a, h, this.chart), l) {
                        var m = {
                            values: 1,
                            id: 1,
                            offset: 1,
                            limit: 1,
                            afterSum: 1,
                            beforeSum: 1,
                            subvalues: 1,
                            sum: 1
                        };
                        for (var g in l)m[g] || (f[g] = l[g])
                    }
                }, i.prototype.markDone = function (t) {
                    return this.pies.hasOwnProperty(t) ? this.pies[t].markDone() : void 0
                }, i.prototype.needPostprocessing = function () {
                    return !!this.chart.settings.filters.sliceFilter || !!this.dataSettings.sortField
                }, i.prototype.filterAndSortData = function (t) {
                    var e = this.chart.settings.filters.sliceFilter;
                    if (e) {
                        for (var i = t.total || 0, s = t.totalCount || 0, o = [], r = 0; r < t.values.length; r++) {
                            var a = t.values[r];
                            e(a) ? o.push(a) : (i -= a.value, s -= 1)
                        }
                        var h = new n;
                        h.values = o, h.done = t.done, h.beforeSum = t.beforeSum, h.afterSum = t.afterSum, h.total = t.total || null, h.totalCount = t.totalCount || null, t = h
                    }
                    if (this.dataSettings.sortField) {
                        var l = this.dataSettings.sortField;
                        t.values.sort(function (t, e) {
                            var i = t[l], n = e[l], s = n - i;
                            return isNaN(s) && (s = ("" + n).localeCompare(i)), s
                        })
                    }
                    return t
                }, i.prototype.buildRequest = function () {
                    if (!t.Base.Helpers.hasProperties(this.pendingPies))return null;
                    var e = t.Base.Helpers.removePropertyValue(this.pendingPies), i = e.key, n = e.value;
                    return this.requestedPies[i] = n, n
                }, i.prototype.dataFunc = function (e, i, n) {
                    var s = this.dataSettings;
                    if (s.dataFunction) s.dataFunction(e.id, e.limit, e.offset, i, n); else if (s.url) {
                        var o = [];
                        e.id && o.push(["id", e.id]), o.push(["limit", e.limit.toString(10)]), o.push(["offset", e.offset.toString(10)]), t.Base.Data.doRequest(s.url, s, o, i, n)
                    } else n({error: "Chart configuration does not define data retrieval function"})
                }, i.prototype.verifyData = function (e, i) {
                    var n = i.id = i.hasOwnProperty("id") ? i.id : e ? e.id : this.getRootId();
                    delete this.requestedPies[n];
                    var s = !0;
                    if (i.hasOwnProperty("subvalues") || (i.hasOwnProperty("values") ? (t.Base.Helpers.warn("Use of property `values` within PieChart data object is being deprecated. Please use `subvalues` instead.", null, !0), i.subvalues = i.values) : (s = !1, this.chart.error("Field `subvalues` not set in root data object"))), i.hasOwnProperty("offset")) {
                        var o = t.Base.Helpers.tryParseInt(i.offset, null);
                        e && e.offset !== i.offset ? (s = !1, this.chart.error("Response Offset " + i.offset + " does not match request offset: " + e.offset), this.markDone(n)) : i.offset = o
                    } else i.offset = e ? e.offset : 0;
                    return i.limit = t.Base.Helpers.tryParseInt(i.limit, null), s
                }, i.prototype.addVerifiedData = function (t, e) {
                    this.chart.scene.loading = this.hasPendingRequests();
                    var i = e.id, n = {};
                    return n[i] = !0, this.chart.log(t ? "Data arrived, id=" + i + ", offset=" + t.offset + ", len=" + e.subvalues.length + " of " + (t.limit || "unset") : "Data arrived, id=" + i + ", offset=" + e.offset + ", len=" + e.subvalues.length + " of " + (e.limit || "unset")), this.dataSettings.autoCategories && (e = this.autoCategorize(e, this.dataSettings.autoCategories)), this.addDataInt(i, e.subvalues, e.offset, e.limit, e.afterSum, e.beforeSum, e.sum, e, n), {dataArrivedIds: n}
                }, i.prototype.requestFailedPermanently = function (t) {
                    if (this.chart.scene.loading = this.hasPendingRequests(), t) {
                        var e = new n;
                        e.done = !0, this.pies[t.id] = e, this.chart.error("Data request failed for pie: " + t.id), delete this.requestedPies[t.id]
                    } else this.chart.error("Data request failed")
                }, i.prototype.removeData = function () {
                }, i.prototype.exportData = function () {
                }, i
            }(t.Base.Data);
            e.Data = s
        }(e = t.PieChart || (t.PieChart = {}))
    }(e = t.Internal || (t.Internal = {}))
}(ZoomCharts || (ZoomCharts = {}));
var ZoomCharts;
!function (t) {
    var e;
    !function (t) {
        var e;
        !function (e) {
            var i = function (t) {
                function e() {
                    t.apply(this, arguments), this.marker = new n
                }

                return __extends(e, t), e
            }(t.Base.SettingsLegend);
            e.SettingsLegend = i;
            var n = function (t) {
                function e() {
                    t.apply(this, arguments), this.shape = "square"
                }

                return __extends(e, t), e
            }(t.Base.SettingsLegendMarker);
            e.SettingsLegendMarker = n;
            var s = function (e) {
                function i(t) {
                    e.call(this, t), this.paintOrder = 20, this.updateOrder = 1e3
                }

                return __extends(i, e), i.prototype.onSceneChange = function (t) {
                    e.prototype.onSceneChange.call(this, t);
                    var i = t.changes;
                    i.pie && (this.rebuildItems(), i.bounds = !0)
                }, i.prototype.doAnimations = function () {
                    this.hoverObject = this.scene.hoverSlice, this.selectedObjects = this.scene.selection
                }, i.prototype.paintMarker = function (e, i, n, s, o) {
                    var r = o.data, a = {
                        fillColor: r.currentFillColor,
                        lineColor: this.settings.marker.lineColor
                    }, h = e.context;
                    h.beginPath(), t.Base.Graphics.strokeMarker(h, this.settings.marker.shape, i, n, s), t.Base.Graphics.paint(h, a)
                }, i.prototype.rebuildItems = function () {
                    var t = [], e = this.scene.peek();
                    if (e)for (var i = e.slices, n = 0; n < i.length; n++) {
                        var s = i[n];
                        t.push({
                            textColor: this.settings.text.fillColor,
                            label: s.label.text || s.data.name,
                            data: s
                        })
                    }
                    this.setItems(t)
                }, i
            }(t.Base.Legend);
            e.Legend = s
        }(e = t.PieChart || (t.PieChart = {}))
    }(e = t.Internal || (t.Internal = {}))
}(ZoomCharts || (ZoomCharts = {}));
var ZoomCharts;
!function (t) {
    var e;
    !function (t) {
        var e;
        !function (e) {
            var i = function () {
                function t() {
                    this.hwidth = 0, this.hheight = 0, this.x = null, this.y = null, this.userPlaced = !1, this.inside = !0
                }

                return t
            }();
            e.Icon = i;
            var n = function () {
                function e(t, e) {
                    this.id = null, this.pie = null, this.data = null, this.index = 0, this.value = 0, this.percent = null, this.fraction = 0, this.cutoutDistance = 0, this.selectDistance = 15, this.selection = 0, this.brightness = 1, this.expandable = !0, this.selected = !1, this.active = !1, this.removed = !1, this.icon = null, this.iconOffset = null, this.url = null, this.userPlaced = !1, this.inside = !0, this.x = 0, this.y = 0, this.currentCutoutDistance = null, this.currentFraction = null, this.currentInsideLabel = null, this.currentLabel = null, this.currentIcon = null, this.currentLineColor = null, this.currentFillColor = null, this.targetFillColor = null, this.targetLineColor = null, this._resetLabelText = !1, this._label = {}, this._insideLabel = {}, this.lineColor = null, this.fillColor = null, this.fillColor2 = null, this.lineWidth = 1, this.lineDash = null, this.lineBrightness = 0, this._animatorF = null, this._animatorLineColor = null, this._animatorFillColor = null, this._animatorCutout = null, this._renderParams = null, this.index = e, this.pie = t
                }

                return Object.defineProperty(e.prototype, "label", {
                    get: function () {
                        return this._label
                    }, set: function (e) {
                        t.Base.Helpers.isObjectOrArray(e) ? this._label = e : (t.Base.Helpers.warn("Slice.label should no longer be set to the text value - instead use Slice.label.text."), this._label.text = e ? "" + e : null, this._resetLabelText = !1)
                    }, enumerable: !0, configurable: !0
                }), Object.defineProperty(e.prototype, "insideLabel", {
                    get: function () {
                        return this._insideLabel
                    }, set: function (e) {
                        t.Base.Helpers.isObjectOrArray(e) ? this._insideLabel = e : (t.Base.Helpers.warn("Slice.insideLabel should no longer be set to the text value - instead use Slice.insideLabel.text."), this._insideLabel.text = e ? "" + e : null, this._resetLabelText && (this._resetLabelText = !1, this._label.text = null))
                    }, enumerable: !0, configurable: !0
                }), Object.defineProperty(e.prototype, "labelStyle", {
                    get: function () {
                        return t.Base.Helpers.warn("Slice.labelStyle is deprecated - use Slice.label instead."), this._label
                    }, set: function (e) {
                        t.Base.Helpers.warn("Slice.labelStyle is deprecated - use Slice.label instead."), e = t.Base.Helpers.extend(this._label, e), e.text || (e.text = this._label.text), this._label = e
                    }, enumerable: !0, configurable: !0
                }), Object.defineProperty(e.prototype, "insideLabelStyle", {
                    get: function () {
                        return t.Base.Helpers.warn("Slice.insideLabelStyle is deprecated - use Slice.insideLabel instead."), this._insideLabel
                    }, set: function (e) {
                        t.Base.Helpers.warn("Slice.insideLabelStyle is deprecated - use Slice.insideLabel instead."), e = t.Base.Helpers.extend(this._insideLabel, e), e.text || (e.text = this._insideLabel.text), this._insideLabel = e
                    }, enumerable: !0, configurable: !0
                }), e
            }();
            e.Slice = n;
            var s = function () {
                function t() {
                    this.id = null, this.data = null, this.total = 1, this.parentSlice = null, this.othersSlice = null, this.previousSlice = null, this.slices = [], this.allSlices = [], this.offset = 0, this.count = 0, this.background = !1, this.activeSliceId = null, this.brightness = 1, this.loading = !1, this.scrollOffset = 0, this.fillColor = null, this.x = 0, this.y = 0, this.startAngle = 0, this.endAngle = 0, this.currentStartAngle = null, this.currentEndAngle = null, this.currentRadius = 0, this.innerRadius = 0, this.radius = 0, this.currentInnerRadius = 0, this.colorDistribution = null, this.sliceColors = null, this.removed = !1, this.visibleFraction = 1, this.removeTime = null, this._animatorA0 = null, this._animatorA1 = null, this._animatorR0 = null, this._animatorR1 = null
                }

                return t.prototype.getActiveSlice = function () {
                    if (!this.activeSliceId)return null;
                    for (var t = 0; t < this.slices.length; t++) {
                        var e = this.slices[t];
                        if (e.id === this.activeSliceId)return e
                    }
                    return null
                }, t
            }();
            e.Pie = s;
            var o = function (e) {
                function i() {
                    e.apply(this, arguments), this.radius = 100, this.innerRadius = 0, this.currentRadius = null, this.currentInnerRadius = null, this.pies = [], this.stack = [], this.selectionIds = [], this.hoverBack = !1, this.hoverSlice = null, this.hoverLabel = null, this.hoverPie = null, this.view = null, this.pendingAction = null, this.pendingOffset = null
                }

                return __extends(i, e), i.prototype.addPie = function (t) {
                    return this.pies.push(t), this.stack.push(t), t
                }, i.prototype.removePie = function (e) {
                    if (null !== e) {
                        e.removed = !0, e.removeTime = null, t.Base.Helpers.removeFromArray(this.stack, e);
                        for (var i = 0; i < this.selection.length;) {
                            var n = this.selection[i];
                            n.pie === e ? t.Base.Helpers.removeFromArray(this.selection, n) : i++
                        }
                    }
                }, i.prototype.deletePie = function (e) {
                    return t.Base.Helpers.removeFromArray(this.pies, e), t.Base.Helpers.removeFromArray(this.stack, e)
                }, i.prototype.length = function () {
                    return this.stack.length
                }, i.prototype.peek = function () {
                    return 0 === this.stack.length ? null : this.stack[this.stack.length - 1]
                }, i.prototype.push = function (t, e) {
                    void 0 === e && (e = null);
                    var i = this.peek();
                    if (i && !e)for (var n = 0; n < i.slices.length; n++) {
                        var s = i.slices[n];
                        if (s.id === t.id) {
                            e = s;
                            break
                        }
                    }
                    if (e) {
                        t.parentSlice = e;
                        var o = e.pie, r = this.getSliceAngles(e);
                        t.currentStartAngle = r.a0, t.currentEndAngle = r.a1, t.currentRadius = o.currentRadius, t.currentInnerRadius = o.currentInnerRadius, i.activeSliceId = e.id;
                        for (var n = 0; n < t.allSlices.length; n++) {
                            var s = t.allSlices[n];
                            s.currentFillColor = e.currentFillColor, s.currentLineColor = e.currentLineColor
                        }
                    } else i && (i.activeSliceId = null);
                    return i && (i.background = !0), this.addPie(t)
                }, i.prototype.pop = function () {
                    if (0 !== this.stack.length) {
                        this.removePie(this.peek());
                        var t = this.peek();
                        t.background = !1, t.brightness = 1
                    }
                }, i.prototype.getParent = function (t) {
                    for (var e = null, i = 0; i < this.stack.length; i++) {
                        var n = this.stack[i];
                        if (n === t)return e;
                        e = n
                    }
                    return null
                }, i.prototype.getChild = function (t) {
                    for (var e = null, i = 0; i < this.stack.length; i++) {
                        var n = this.stack[i];
                        if (e === t)return n;
                        e = n
                    }
                    return null
                }, i.prototype.updateOnPieChanged = function (t) {
                    var e = this.getParent(t), i = this.getChild(t);
                    if (e && !t.parentSlice)for (var n = 0; n < e.slices.length; n++) {
                        var s = e.slices[n];
                        if (s.id === t.id) {
                            t.parentSlice = s, e.activeSliceId = s.id;
                            break
                        }
                    }
                    if (i && !i.parentSlice)for (var n = 0; n < t.slices.length; n++) {
                        var s = t.slices[n];
                        if (s.id === i.id) {
                            i.parentSlice = s, t.activeSliceId = s.id;
                            break
                        }
                    }
                }, i.prototype.findPieAt = function (t, e, i) {
                    return this.view.findPieAt(t, e, i)
                }, i.prototype.findSliceAt = function (t, e, i, n) {
                    return this.view.findSliceAt(t, e, i, n)
                }, i.prototype.findLabelAt = function (t, e, i) {
                    return this.view.findLabelAt(t, e, i)
                }, i.prototype.getSliceAngles = function (t) {
                    for (var e = 0, i = t.pie, n = 0, s = 0; s < i.allSlices.length; s++) {
                        var o = i.allSlices[s];
                        if (n = e, e += o.currentFraction, o.id === t.id)break
                    }
                    var r = i.currentEndAngle - i.currentStartAngle, a = i.currentStartAngle;
                    return {a0: a + r * n, a1: a + r * e}
                }, i.prototype.getSliceTargetAngles = function (t) {
                    for (var e = 0, i = t.pie, n = 0, s = 0; s < i.allSlices.length; s++) {
                        var o = i.allSlices[s];
                        if (n = e, e += o.currentFraction, o.id === t.id)break
                    }
                    var r = i.currentEndAngle - i.currentStartAngle, a = i.currentStartAngle;
                    return {a0: a + r * n, a1: a + r * e}
                }, i
            }(t.Base.Scene);
            e.Scene = o
        }(e = t.PieChart || (t.PieChart = {}))
    }(e = t.Internal || (t.Internal = {}))
}(ZoomCharts || (ZoomCharts = {}));
var ZoomCharts;
!function (t) {
    var e;
    !function (t) {
        var e;
        !function (e) {
            var i = function (i) {
                function h(l) {
                    i.call(this, t.Base.SettingsMapping.PieChartSettings), this.theme = h.FlatTheme, this.data = [], this.legend = new e.SettingsLegend, this.navigation = {
                        initialDrilldown: [""],
                        initialOffset: 0
                    }, this.pie = {
                        radius: null,
                        adaptiveRadius: !0,
                        outerMargin: 1,
                        margin: 2,
                        centerMargin: 5,
                        showInnerPiesExport: !0,
                        showInnerPies: !0,
                        innerRadius: .3,
                        innerRadiusWhenDrilldown: .2,
                        startAngle: -Math.PI / 2,
                        endAngle: 1.5 * Math.PI,
                        theme: "flat",
                        depth: 0,
                        x: null,
                        y: null,
                        style: {
                            fillColor: "transparent",
                            sliceColors: ["#2fc32f", "#b0dc0b", "#eab404", "#de672c", "#ec2e2e", "#d5429b", "#6f52b8", "#1c7cd5", "#56b9f7", "#0ae8eb"],
                            colorDistribution: "list",
                            brightness: 1
                        },
                        noDataStyle: {fillColor: "#ddd"},
                        backgroundStyle: {},
                        backgroundHoveredStyle: {brightness: .7},
                        styleFunction: null
                    }, this.slice = {
                        margin: 2,
                        minFraction: 0,
                        style: {
                            lineBrightness: 0,
                            brightness: 1,
                            lineWidth: 1,
                            label: {
                                backgroundStyle: null,
                                textStyle: {fillColor: "#000", font: "12px Arial"},
                                lineSpacing: .2,
                                margin: 4,
                                padding: 0,
                                borderRadius: 999,
                                text: null
                            },
                            insideLabel: {
                                textStyle: {
                                    fillColor: "#fff",
                                    font: "12px Arial"
                                },
                                lineSpacing: .2,
                                margin: 4,
                                padding: 0,
                                borderRadius: 0,
                                text: null
                            }
                        },
                        hoverStyle: {brightness: 1.2, lineBrightness: 2, lineWidth: .35},
                        selectedStyle: null,
                        backgroundStyle: {fillColor: "#e2e2e2", fillColor2: "#e0e0e0"},
                        backgroundActiveStyle: {brightness: 1.3},
                        othersStyle: {fillColor: "#ccc", lineDecoration: "zigzag"},
                        previousStyle: {fillColor: "#ccc", lineDecoration: "zigzag"},
                        connectorStyle: {lineColor: "#333", lineWidth: 1},
                        expandableMarkStyle: {
                            lineWidth: 1,
                            lineColor: "rgba(255,255,255,0.8)",
                            distance: 4,
                            lineDash: null
                        },
                        styleFunction: null
                    }, this.filters = {sliceFilter: null}, this.labels = new n, this.icons = {
                        sizeExtent: [16, 64],
                        placement: "auto",
                        autohideWhenTooSmall: !0
                    }, this.advanced = new a, this.interaction = new r, this.info = {
                        enabled: !0,
                        contentsFunction: null
                    }, this.events = new s, this.toolbar = new t.Base.SettingsToolbar(!1, [new t.Base.SettingsToolbarItem("back"), new t.Base.SettingsToolbarItem("export")]), this.localization = new o, this.apply(l), this._initializing = !1
                }

                return __extends(h, i), h.prototype.apply = function (t) {
                    this.applyCompatibility(t, [{
                        from: "slice.labelStyle",
                        to: "slice.style.label"
                    }, {
                        from: "slice.insideLabelStyle",
                        to: "slice.style.insideLabel"
                    }, {
                        from: "labels.connectorStyle",
                        to: "slice.connectorStyle"
                    }, {
                        from: "labels.textStyle",
                        to: "slice.style.label.textStyle"
                    }, {
                        from: "labels.backgroundStyle",
                        to: "slice.style.label.backgroundStyle"
                    }, {
                        from: "labels.insideTextStyle",
                        to: "slice.style.insideLabel.textStyle"
                    }, {
                        from: "labels.padding",
                        to: "slice.style.label.padding"
                    }, {
                        from: "labels.borderRadius",
                        to: "slice.style.label.borderRadius"
                    }, {
                        from: "area.initialPieId",
                        to: "navigation.initialDrilldown"
                    }, {
                        from: "area.initialPieOffset",
                        to: "navigation.initialOffset"
                    }, {
                        from: "area.initialAnimation",
                        to: "advanced.initialAnimation"
                    }, {
                        from: "advanced.iconMinSize",
                        alternative: "icons.sizeExtent[0]"
                    }, {
                        from: "advanced.pointer.dragSensitivity",
                        to: "interaction.selection.swipeSensitivity"
                    }]);
                    var e = i.prototype.apply.call(this, t);
                    return e
                }, h.FlatTheme = {
                    advanced: {themeCSSClass: "DVSL-flat", assets: []},
                    pie: {theme: "flat", depth: 0}
                }, h.DarkTheme = {
                    advanced: {themeCSSClass: "DVSL-dark", assets: []},
                    area: {style: {fillColor: "rgba(28,26,28,1)"}},
                    title: {margin: 15, style: {fillColor: "#A8A7A8"}},
                    pie: {
                        theme: "flat",
                        depth: 0,
                        style: {sliceColors: ["#32CD32", "#36BEFF", "#FBBD30", "#EE3431", "#894BBC", "#0EC9AC", "#524BBC", "#0b83ea", "#3ca20d", "#BC438F"]}
                    },
                    slice: {
                        connectorStyle: {lineColor: "#4C4C4C"},
                        style: {label: {textStyle: {fillColor: "#A8A7A8"}}}
                    },
                    legend: {text: {fillColor: "#A8A7A8"}, marker: {lineColor: null}}
                }, h.BevelTheme = {
                    advanced: {themeCSSClass: "DVSL-flat", assets: []},
                    pie: {theme: "bevel", depth: 0}
                }, h.GradientTheme = {
                    advanced: {themeCSSClass: "DVSL-flat", assets: []},
                    pie: {theme: "smoothy", depth: 0}
                }, h.CanTheme = {
                    advanced: {themeCSSClass: "DVSL-flat", assets: []},
                    pie: {theme: "can", depth: 10}
                }, h
            }(t.Base.Settings);
            e.Settings = i;
            var n = function () {
                function t() {
                    this.enabled = !0, this.connectors = !0, this.connectorLength = 20, this.angle = 0, this.insideLabel = "append", this.insideLabelVisibilityFraction = .8, this.interLabelSpacing = .6, this.placement = "aligned"
                }

                return t
            }();
            e.SettingsLabels = n;
            var s = function (t) {
                function e() {
                    t.apply(this, arguments), this.onPieChange = null, this.onPieReadyStateChanged = null
                }

                return __extends(e, t), e
            }(t.Base.SettingsEvents);
            e.SettingsEvents = s;
            var o = function (t) {
                function e() {
                    t.apply(this, arguments), this.othersLabel = "Others", this.previousLabel = "Previous"
                }

                return __extends(e, t), e
            }(t.Base.SettingsLocalization);
            e.SettingsLocalization = o;
            var r = function (t) {
                function e() {
                    t.apply(this, arguments), this.mode = "drilldown", this.coverCenter = !1, this.selection = {
                        enabled: !0,
                        tolerance: 2,
                        swipe: !1,
                        swipeSensitivity: 10,
                        partialSwipe: !1,
                        maxSwipeDistance: 45
                    }, this.animation = {
                        scrollDuration: 500,
                        hoverDuration: 200
                    }, this.others = {
                        enabled: !0,
                        centerGoesToPrevious: !1,
                        navigationFraction: .15,
                        maxSlicesVisible: 15,
                        maxOthersFraction: .6,
                        minSliceFraction: .01
                    }, this.scrolling = {enabled: !1}
                }

                return __extends(e, t), e
            }(t.Base.SettingsInteraction);
            e.SettingsInteraction = r;
            var a = function (e) {
                function i() {
                    e.call(this), this.iconMinSize = null, this.initialAnimation = !0, this.renderQuality = 1, this.backImage = "builtin://piechart-back", this.backAlwaysVisible = !1, this.labelInsideTreshold = 1, this.builtinAssets["piechart-back"] = t.Resources.PiechartBack, this.pointer.noClickOnDoubleClick = !1
                }

                return __extends(i, e), i
            }(t.Base.SettingsAdvanced);
            e.SettingsAdvanced = a
        }(e = t.PieChart || (t.PieChart = {}))
    }(e = t.Internal || (t.Internal = {}))
}(ZoomCharts || (ZoomCharts = {}));
var ZoomCharts;
!function (t) {
    var e;
    !function (t) {
        var e;
        !function (e) {
            var i = function (i) {
                function n(t) {
                    i.call(this), this.dragPointers = {}, this.animationOrder = 1100, this.paintOrder = 10, this.updateOrder = 1200, this.currentSlice = null, this.currentLabel = null, this.currentPie = null, this.draggedLabelSlice = null, this.draggedLabel = null, this.hoverEvent = null, this.dragStartConditions = {
                        angle: 1 / 0,
                        distance: 1 / 0,
                        slice: null,
                        pie: null
                    }, this.isScrolling = !1, this.px = 0, this.py = 0, this.chart = t, this.scene = t.scene, this.events = t.events, this.scrolling = new e.Scrolling(t)
                }

                return __extends(n, i), n.prototype.doAnimations = function () {
                    return this.hoverEvent ? this.onPointerMove(this.hoverEvent) : void 0
                }, n.prototype.previewPointerDrag = function (t) {
                    this.hoverEvent = t
                }, n.prototype.onPointerMove = function (t) {
                    this.hoverEvent = t, this.updateCurrentObject(t)
                }, n.prototype.onPointerOut = function (t) {
                    this.switchCurrentSlice(null, null, t), this.hoverEvent = null
                }, n.prototype.onPointerDown = function (t) {
                    this.handlePointerDown(t), this.scrolling.handlePointerDown(t)
                }, n.prototype.handlePointerDown = function (t) {
                    this.updateCurrentObject(t);
                    var e = this.currentSlice;
                    (e || this.currentPie) && (t.consumed = !0), this.px = t.x, this.py = t.y;
                    var i = this.scene.settings.interaction.selection;
                    if (i.swipe || i.partialSwipe) {
                        var n = this.scene.settings.interaction, s = this.scene.pies[0], o = s && n.others.centerGoesToPrevious && s.previousSlice, r = !(!n.coverCenter || o || s && s.background), a = this.scene.findSliceAt(t.x, t.y, n.selection.tolerance, r);
                        if (this.dragStartConditions.slice = null, this.dragStartConditions.pie = null, this.dragStartConditions.distance = 1 / 0, this.dragStartConditions.angle = 0, a && null !== a.id) {
                            this.dragStartConditions.slice = e, this.dragStartConditions.pie = s;
                            var h = t.x - s.x, l = t.y - s.y, u = Math.sqrt(h * h + l * l);
                            this.dragStartConditions.distance = u - e.currentCutoutDistance, this.dragStartConditions.angle = 180 * Math.atan2(l, h) / Math.PI
                        }
                    }
                    var c = this.scene.findLabelAt(t.x, t.y, this.scene.settings.interaction.selection.tolerance);
                    this.draggedLabelSlice = c.slice, this.draggedLabel = c.label, this.draggedLabel = null, this.draggedLabelSlice = null
                }, n.prototype.onPointerDrag = function (t) {
                    this.handlePointerDrag(t), this.scrolling.handlePointerDrag(t)
                }, n.prototype.handlePointerDrag = function (t) {
                    var e = this.scene.settings.interaction.selection;
                    if (!this.isScrolling) {
                        if (t.distance({
                                x: this.px,
                                y: this.py
                            }) < e.swipeSensitivity)return;
                        this.isScrolling = !0
                    }
                    if ((e.swipe || e.partialSwipe) && (this.currentSlice || this.dragStartConditions.slice)) {
                        var i = this.dragStartConditions.slice;
                        if (null !== i) {
                            var n = this.dragStartConditions.pie, s = this.dragStartConditions.distance, o = this.dragStartConditions.angle;
                            1 / 0 === o && (o = 180 * Math.atan2(t.y - n.y, t.x - n.x) / Math.PI);
                            var r = t.x - n.x, a = t.y - n.y, h = 180 * Math.atan2(a, r) / Math.PI, l = Math.abs(o - h);
                            if (90 >= l) {
                                var u = Math.sqrt(r * r + a * a);
                                1 / 0 === this.dragStartConditions.distance && (s = u - i.currentCutoutDistance);
                                var c = this.scene.innerRadius >= i.selectDistance / 2 ? -i.selectDistance / 2 : 0, p = u * Math.cos(l * Math.PI / 180), d = p - s > e.maxSwipeDistance, f = p - s > c;
                                i.userPlaced = !0, d ? i.currentCutoutDistance = e.maxSwipeDistance : f && (i.currentCutoutDistance = p - s > c ? p - s | 0 : 0), i.selection = i.currentCutoutDistance > 0 ? i.currentCutoutDistance / e.maxSwipeDistance * 100 : 0, t.changes.pie = !0
                            }
                        }
                    }
                    if (this.draggedLabel) {
                        var m = this.draggedLabel;
                        m.userPlaced = !0, m.x += t.dx, m.y += t.dy, t.consumed = !0, t.changes.pie = !0
                    }
                }, n.prototype.onPointerUp = function (t) {
                    this.handlePointerUp(t), this.scrolling.handlePointerUp(t)
                }, n.prototype.handlePointerUp = function (t) {
                    this.isScrolling = !1;
                    var e = this.scene.settings.interaction.selection;
                    if (e.swipe || e.partialSwipe) {
                        var i = this.dragStartConditions.slice;
                        if (i) {
                            var n = i.currentCutoutDistance >= i.selectDistance / 2 && !i.selected, s = i.currentCutoutDistance < i.selectDistance / 2 && i.selected;
                            e.swipe || i.currentCutoutDistance <= 0 && e.partialSwipe ? i.userPlaced = !1 : e.partialSwipe && (i.userPlaced = !0), s || n ? this.updateSelection(t, i, !1) : i.currentCutoutDistance >= i.selectDistance / 2 && i.selected && this.setSelection([i], [], !0)
                        }
                    }
                    this.draggedLabel && (this.draggedLabel = null, t.consumed = !0)
                }, n.prototype.onPointerCancel = function (t) {
                    this.onPointerUp(t)
                }, n.prototype.onClick = function (t) {
                    this.onPointerMove(t), this.fillClickParams(t);
                    var e = this.chart.notifyClick(t);
                    (this.currentSlice || this.currentPie) && (t.consumed = !0), e.defaultPrevented || this.updateSelection(t, this.currentSlice, !1)
                }, n.prototype.onRightClick = function (t) {
                    this.onPointerMove(t), this.fillClickParams(t), (this.currentSlice || this.currentPie) && (t.consumed = !0);
                    var e = this.chart.notifyRightClick(t);
                    e.defaultPrevented && (t.consumed = !0)
                }, n.prototype.onDoubleClick = function (t) {
                    this.onPointerMove(t), this.fillClickParams(t), this.chart.notifyDoubleClick(t), t.consumed = !0
                }, n.prototype.onTripleClick = function (t) {
                    this.onPointerMove(t), this.fillClickParams(t), this.chart.notifyTripleClick(t), t.consumed = !0
                }, n.prototype.fillClickParams = function (t) {
                    var e = this.scene.hoverSlice, i = this.scene.hoverPie, n = t;
                    return n.clickPie = e ? e.pie : i, e ? t.cursor = "pointer" : void 0
                }, n.prototype.updateSelection = function (e, i, n) {
                    if (this.scene.settings.interaction.selection.enabled) {
                        var s = e.shiftKey, o = "toggle" === this.scene.settings.interaction.mode || e.ctrlKey;
                        if (i) {
                            if (!(s || n && i.selected || o && !i.selected))return o && i.selected ? (t.Base.Helpers.removeFromArray(this.scene.selection, i), i.selected = !1, this.setSelection(this.scene.selection, this.scene.selectionIds, !0)) : this.setSelection(!i.selected || this.scene.selection.length > 1 ? [i] : []);
                            if (!i.selected)return this.scene.selection.push(i), i.selected = !0, this.setSelection(this.scene.selection, this.scene.selectionIds, !0)
                        } else if (!s && !o)return this.setSelection([])
                    }
                }, n.prototype.switchCurrentSlice = function (t, e, i) {
                    if (t !== this.currentSlice || e !== this.currentLabel) {
                        if (i.changes.current = !0, this.scene.hoverSlice && (this.scene.hoverSlice.active = !1), this.scene.hoverPie && (this.scene.hoverPie.active = !1), this.scene.hoverSlice = t, this.scene.hoverPie = null, this.scene.hoverLabel = e, this.currentSlice = t, this.currentLabel = e, this.currentPie = null, this.currentSlice) {
                            this.scene.hoverSlice.active = !0;
                            var n = i;
                            n.hoverSlice = this.currentSlice
                        }
                        this.events.notifySceneChanges({pie: !0}), this.chart.notifyHoverChanged(i)
                    }
                }, n.prototype.switchCurrentPie = function (t, e) {
                    t !== this.currentPie && (e.changes.current = !0, this.scene.hoverSlice && (this.scene.hoverSlice.active = !1), this.scene.hoverPie && (this.scene.hoverPie.active = !1), this.scene.hoverPie = t, this.scene.hoverSlice = null, this.currentSlice = null, this.currentPie = t, this.currentPie && (this.scene.hoverPie.active = !0, e.hoverPie = this.currentPie), this.events.notifySceneChanges({pie: !0}), this.chart.notifyHoverChanged(e))
                }, n.prototype.onSceneChange = function (t) {
                    return t.changes.pie && this.updateSelectionIds() ? (this.events.notifySceneChanges({selection: !0}), this.chart.notifySelectionChanged("")) : void 0
                }, n.prototype.updateSelectionIds = function () {
                    for (var e = [], i = 0; i < this.scene.selectionIds.length; i++)for (var n = this.scene.selectionIds[i], s = 0; s < this.scene.pies.length; s++) {
                        var o = this.scene.pies[s];
                        if (!o.background)for (var r = 0; r < o.slices.length; r++) {
                            var a = o.slices[r];
                            if (a.id === n) {
                                e.push(a);
                                break
                            }
                        }
                    }
                    if (e.length > 0)for (var r = 0; r < e.length; r++) {
                        var a = e[r];
                        a.selected || (a.selected = !0, this.scene.selection.push(a)), t.Base.Helpers.removeFromArray(this.scene.selectionIds, a.id)
                    }
                    return e.length > 0
                }, n.prototype.setSelection = function (t, e, i, n) {
                    void 0 === e && (e = []), void 0 === i && (i = !1), void 0 === n && (n = "user"), this.scene.selectionIds = e;
                    var s;
                    if (i) s = !0; else {
                        for (var o = 0; o < this.scene.selection.length; o++) {
                            var r = this.scene.selection[o];
                            t.indexOf(r) < 0 && (r.selected = !1, s = !0)
                        }
                        for (var o = 0; o < t.length; o++) {
                            var r = t[o];
                            r.selected || (r.selected = !0, s = !0)
                        }
                        this.scene.selection = t
                    }
                    var a = this.updateSelectionIds();
                    s = s || a, s && (this.events.notifySceneChanges({selection: !0}), this.chart.notifySelectionChanged(n))
                }, n.prototype.updateCurrentObject = function (t) {
                    var e = this.scene.settings.interaction, i = this.scene.findPieAt(t.x, t.y, e.selection.tolerance), n = i && e.others.centerGoesToPrevious && i.previousSlice, s = !(!e.coverCenter || n || i && i.background), o = this.findSliceAt(t.x, t.y, s), r = this.scene.findLabelAt(t.x, t.y, e.selection.tolerance);
                    o && (t.cursor = "pointer", t.hovered = !0), this.switchCurrentSlice(o, r.label, t), i && (i.background || n) && !o ? (t.cursor = "pointer", t.hovered = !0, i.background ? this.switchCurrentPie(i, t) : (this.switchCurrentSlice(i.previousSlice, null, t), this.switchCurrentPie(null, t)), this.scene.hoverBack = !0) : (this.switchCurrentPie(null, t), this.scene.hoverBack = !1)
                }, n.prototype.findSliceAt = function (t, e, i) {
                    var n = this.scene.findSliceAt(t, e, this.scene.settings.interaction.selection.tolerance, i);
                    return !n && this.chart.legend && (n = this.chart.legend.findItemAt(t, e)), n
                }, n
            }(t.Base.ChartElement);
            e.Selection = i
        }(e = t.PieChart || (t.PieChart = {}))
    }(e = t.Internal || (t.Internal = {}))
}(ZoomCharts || (ZoomCharts = {}));
var ZoomCharts;
!function (t) {
    var e;
    !function (t) {
        var e;
        !function (e) {
            var i = function (e) {
                function i(t) {
                    e.call(this), this.animationOrder = 100, this.paintOrder = 25, this.updateOrder = 900, this.chart = t, this.scene = t.scene
                }

                return __extends(i, e), i.prototype.onSceneChange = function (t) {
                    if (t.changes.settings || t.changes.pie || t.changes.selection || t.changes.style)for (var e = 0; e < this.scene.pies.length; e++) {
                        var i = this.scene.pies[e];
                        this.updatePie(i), this.computePieColors(i);
                        for (var n = 0; n < i.allSlices.length; n++) {
                            var s = i.allSlices[n];
                            this.updateSlice(s, n)
                        }
                    }
                }, i.prototype.updatePie = function (e) {
                    t.Base.Helpers.extendStyle(e, this.scene.settings.pie.style), 0 === e.slices.length && t.Base.Helpers.extendStyle(e, this.scene.settings.pie.noDataStyle), e.background && t.Base.Helpers.extendStyle(e, this.scene.settings.pie.backgroundStyle), this.scene.hoverPie === e && t.Base.Helpers.extendStyle(e, this.scene.settings.pie.backgroundHoveredStyle), this.scene.settings.pie.styleFunction && this.scene.settings.pie.styleFunction.call(this.chart.api, e, e.data)
                }, i.prototype.computePieColors = function (e) {
                    for (var i = e.sliceColors, n = e.colorDistribution, s = 0, o = 0; o < e.slices.length; o++) {
                        var r = e.slices[o];
                        r.removed || (s += 1)
                    }
                    if (1 === s)return void(e.slices[0].fillColor = i[0]);
                    if (1 === i.length) {
                        var a = i[0];
                        i = [a, t.Base.Graphics.blendColors(a, "#fff", .8)]
                    }
                    var h = i.length;
                    if ("gradient" === n)for (var l = 0, o = 0; o < e.slices.length; o++) {
                        var r = e.slices[o];
                        if (!r.removed) {
                            var u = i[l * (h - 1) | 0], c = i[l * (h - 1) + 1 | 0], p = l * (h - 1);
                            p -= Math.floor(p);
                            var a = t.Base.Graphics.blendColors(u, c, p);
                            r.fillColor = a, l += 1 / (s - .9)
                        }
                    } else if ("gradientProportional" === n)for (var l = 0, o = 0; o < e.slices.length; o++) {
                        var r = e.slices[o];
                        if (!r.removed) {
                            var u = i[l * (h - 1) | 0], c = i[l * (h - 1) + 1 | 0], p = l * (h - 1);
                            p -= Math.floor(p);
                            var a = t.Base.Graphics.blendColors(u, c, p);
                            r.fillColor = a, l += r.fraction
                        }
                    } else for (var d = 0; d < e.slices.length; d++) {
                        var r = e.slices[d];
                        if (!r.removed) {
                            var a = i[(e.offset + d) % h], f = d / h | 0;
                            1 === f ? a = t.Base.Graphics.deriveColor(a, 1.5, 1) : f >= 2 && (a = t.Base.Graphics.deriveColor(a, .5, 1)), r.fillColor = a
                        }
                    }
                }, i.prototype.updateSlice = function (e, i) {
                    if (!e.removed) {
                        var n = e.pie, s = this.scene.settings.slice, o = s.styleFunction;
                        e.expandable = this.scene.mainData.canExpand(e.id), t.Base.Helpers.extendDeep(e, s.style), e === n.othersSlice ? t.Base.Helpers.extendDeep(e, s.othersStyle) : e === n.previousSlice && t.Base.Helpers.extendDeep(e, s.previousStyle), e.percent = n.total > 0 ? e.value / n.total * 100 : 0;
                        var r = e.label;
                        r.text ? r.text += " " : r.text = "", e.data.name && (r.text += e.data.name + " "), r.text += e.percent.toFixed(1) + "%", e.cutoutDistance = e.selected ? e.selectDistance : 0, this.scene.hoverSlice === e && t.Base.Helpers.extendDeep(e, s.hoverStyle), e.data.style && t.Base.Helpers.extendDeep(e, e.data.style), o && (e._resetLabelText = !0, o.call(this.chart.api, e, e.data)), n.background && (n.activeSliceId !== e.id ? (t.Base.Helpers.extendDeep(e, s.backgroundStyle), i % 2 === 1 && (e.fillColor = e.fillColor2)) : t.Base.Helpers.extendDeep(e, s.backgroundActiveStyle));
                        var a = "rgba(255,255,255,0)";
                        e.fillColor && (a = e.fillColor);
                        var h = "rgba(255,255,255,0)";
                        e.lineColor ? h = e.lineColor : e.lineBrightness && (h = t.Base.Graphics.deriveColor(a, e.lineBrightness, 1));
                        var l = e.brightness * n.brightness;
                        1 !== l && (a = t.Base.Graphics.deriveColor(a, l, 1), h = t.Base.Graphics.deriveColor(h, l, 1), -1 !== a.indexOf("rgba(255,255,255") && -1 !== h.indexOf("rgba(255,255,255") && (h = "rgba(200,200,200,1.000)")), n.removed && n.parentSlice ? (e.targetFillColor = n.parentSlice.targetFillColor, e.targetLineColor = n.parentSlice.targetLineColor) : (e.targetFillColor = t.Base.Graphics.normalizeColor(a), e.targetLineColor = t.Base.Graphics.normalizeColor(h))
                    }
                }, i
            }(t.Base.ChartElement);
            e.Styles = i
        }(e = t.PieChart || (t.PieChart = {}))
    }(e = t.Internal || (t.Internal = {}))
}(ZoomCharts || (ZoomCharts = {}));
var ZoomCharts;
!function (t) {
    var e;
    !function (t) {
        var e;
        !function (e) {
            var i = function (t) {
                function e(e) {
                    t.call(this, e)
                }

                return __extends(e, t), e.prototype.createDom = function (e) {
                    t.prototype.createDom.call(this, e), this.backgroundImage.className += " DVSL-PC-background-image", this.backgroundImage.style.display = "none"
                }, e.prototype.doAnimations = function (e) {
                    if (t.prototype.doAnimations.call(this, e), this.scene.settings.area.style.image && this.scene.pies.length > 0) {
                        var i = this.scene.currentInnerRadius - this.scene.settings.pie.margin, n = this.scene.pies[0].x, s = this.scene.pies[0].y;
                        (0 !== n || 0 !== s) && i > 0 ? (this.backgroundImage.style.left = Math.round(n - i) + "px", this.backgroundImage.style.top = Math.round(s - i) + "px", this.backgroundImage.style.width = Math.round(2 * i) + "px", this.backgroundImage.style.height = Math.round(2 * i) + "px", this.backgroundImage.style.display = "") : this.backgroundImage.style.display = "none"
                    }
                }, e
            }(t.Base.DomLayer);
            e.DomLayer = i
        }(e = t.PieChart || (t.PieChart = {}))
    }(e = t.Internal || (t.Internal = {}))
}(ZoomCharts || (ZoomCharts = {}));
var ZoomCharts;
!function (t) {
    var e;
    !function (t) {
        var e;
        !function (t) {
            var e = function () {
                function t(t) {
                    this.pie = null, this.chart = t, this.scene = t.scene, this.events = t.events
                }

                return t.prototype.handlePointerDown = function (t) {
                    this.scene.settings.interaction.scrolling.enabled && (this.pointer || (this.pointer = t.identifier, this.pie = this.scene.peek()))
                }, t.prototype.handlePointerDrag = function (t) {
                    this.pie && this.scene.settings.interaction.scrolling.enabled && (t.consumed = !0, t.identifier === this.pointer && (this.pie.scrollOffset += this.scene.view.getMovement(this.pie, t).dfraction, this.updatePieScrolling(this.pie), t.changes.pie = !0))
                }, t.prototype.handlePointerUp = function (t) {
                    this.scene.settings.interaction.scrolling.enabled && t.identifier === this.pointer && (this.updatePieAfterScroll(this.pie), this.pie = null, this.pointer = null)
                }, t.prototype.updatePieScrolling = function (t) {
                    return t.scrollOffset > 0 && 0 === t.offset && (t.scrollOffset = 0), 0 !== t.scrollOffset ? this.scene.view.updatePie(this.pie, !1) : void 0
                }, t.prototype.updatePieAfterScroll = function (t) {
                    return t.scrollOffset = 0, this.scene.view.updatePie(t, !0)
                }, t
            }();
            t.Scrolling = e
        }(e = t.PieChart || (t.PieChart = {}))
    }(e = t.Internal || (t.Internal = {}))
}(ZoomCharts || (ZoomCharts = {}));
var ZoomCharts;
!function (t) {
    var e;
    !function (t) {
        var e;
        !function (e) {
            var i = function (i) {
                function n(t) {
                    i.call(this), this.animationOrder = 250, this.paintOrder = 30, this.updateOrder = 650, this.chart = t, this.scene = t.scene, this.events = t.events
                }

                return __extends(n, i), n.prototype.onNewDataObject = function () {
                    return 1
                }, n.prototype.setPie = function (i, n, s) {
                    t.Base.Helpers.isArray(i) || (i = [i]), this.scene.pendingAction = null;
                    for (var o = 0; this.scene.length() > i.length;)this.scene.pop(), o++;
                    for (; this.scene.length() > 0 && this.scene.peek().id !== i[this.scene.length() - 1];)this.scene.pop(), o++;
                    for (; this.scene.length() < i.length;) {
                        var r = new e.Pie;
                        r.id = i[this.scene.length()], r.offset = this.scene.length() + 1 === i.length ? n : 0, this.scene.push(r), this.scene.view.updatePie(r), o++
                    }
                    var a = this.scene.peek();
                    a && a.offset !== n ? (this.scroll(a, n), o++) : o && a && this.scene.view.updatePie(a), o && (this.chart.notifyChartUpdate(s), this.events.notifySceneChanges({pie: !0}))
                }, n.prototype.getPie = function () {
                    return this.scene.stack.map(function (t) {
                        return t.id
                    })
                }, n.prototype.getPieOffset = function () {
                    return this.scene.peek().offset
                }, n.prototype.goBack = function (t) {
                    this.scene.length() > 1 && (this.scene.pop(), this.scene.pendingAction = null, this.updateAndNotifyCurrent(t))
                }, n.prototype.goCenter = function (t) {
                    var e = this.scene.peek();
                    e.offset > 0 && this.scene.settings.interaction.others.centerGoesToPrevious ? this.goPrevious(e, t) : this.scene.length() > 1 && (this.scene.pop(), this.scene.pendingAction = null, this.updateAndNotifyCurrent(t))
                }, n.prototype.drillDown = function (t, i) {
                    this.scene.pendingAction = null;
                    var n = new e.Pie;
                    n.id = t, n.offset = 0, this.scene.push(n), this.updateAndNotifyCurrent(i)
                }, n.prototype.goOthers = function (t, e) {
                    var i = this.scene.view.scrollForward(t, t.offset + t.count);
                    i || (this.scene.pendingAction = "forward", this.scene.pendingOffset = null), this.events.notifySceneChanges({pie: !0}), this.chart.notifyChartUpdate(e)
                }, n.prototype.goPrevious = function (t, e) {
                    if (!(t.offset <= 0)) {
                        var i = this.scene.view.scrollBackward(t, null);
                        i || (this.scene.pendingAction = "back", this.scene.pendingOffset = null), this.chart.notifyChartUpdate(e), this.events.notifySceneChanges({pie: !0})
                    }
                }, n.prototype.scroll = function (t, e) {
                    var i = !0;
                    t.offset > e ? (i = this.scene.view.scrollBackward(t, e), i || (this.scene.pendingAction = "back", this.scene.pendingOffset = e)) : t.offset < e && (i = this.scene.view.scrollForward(t, e), i || (this.scene.pendingAction = "forward", this.scene.pendingOffset = e))
                }, n.prototype.updateAndNotifyCurrent = function (t) {
                    var e = this.scene.peek();
                    this.scene.view.updatePie(e), this.chart.notifyChartUpdate(t), this.events.notifySceneChanges({pie: !0})
                }, n.prototype.expandSlice = function (t, e) {
                    var i = t.pie;
                    if (i !== this.scene.peek())return this.chart.setSelection([]), this.goBack(e), !0;
                    if (t === i.othersSlice)return this.chart.setSelection([]), this.goOthers(i, e), !0;
                    if (t === i.previousSlice)return this.chart.setSelection([]), this.goPrevious(i, e), !0;
                    var n = t.id;
                    return t.expandable && this.scene.mainData.canExpand(n) ? (this.chart.setSelection([]), this.drillDown(n, e), !0) : !1
                }, n.prototype.onSceneChange = function (t) {
                    var e = !1, i = this.scene.peek();
                    if (t.changes.dataArrived)for (var n = t.changes.dataArrivedIds, s = 0; s < this.scene.pies.length; s++) {
                        var o = this.scene.pies[s];
                        if (n.hasOwnProperty(o.id)) {
                            if (o === i) {
                                var r = void 0;
                                r = "forward" === this.scene.pendingAction ? this.scene.view.scrollForward(o, this.scene.pendingOffset) : "back" === this.scene.pendingAction ? this.scene.view.scrollBackward(o, this.scene.pendingOffset) : this.scene.view.updatePie(o), r && (this.scene.pendingAction = null, this.scene.pendingOffset = null), e = r
                            } else this.scene.view.updatePie(o);
                            t.changes.pie = !0
                        }
                    }
                    if (t.changes.data)for (var s = 0; s < this.scene.stack.length; s++) {
                        var o = this.scene.stack[s];
                        if (!o.data || o === i || t.changes.dataDeep) {
                            if (o === i) {
                                var r = void 0;
                                r = "forward" === this.scene.pendingAction ? this.scene.view.scrollForward(o, this.scene.pendingOffset) : "back" === this.scene.pendingAction ? this.scene.view.scrollBackward(o, this.scene.pendingOffset) : this.scene.view.updatePie(o), r && (this.scene.pendingAction = null, this.scene.pendingOffset = null), e = r
                            } else this.scene.view.updatePie(o);
                            t.changes.pie = !0
                        }
                    }
                    e && this.chart.notifyChartUpdate("data", !0)
                }, n
            }(t.Base.ChartElement);
            e.Navigator = i
        }(e = t.PieChart || (t.PieChart = {}))
    }(e = t.Internal || (t.Internal = {}))
}(ZoomCharts || (ZoomCharts = {}));
var ZoomCharts;
!function (t) {
    var e;
    !function (t) {
        var e;
        !function (e) {
            var i = function (e) {
                function i(i) {
                    e.call(this), this.currentSlice = null, this.x = null, this.y = null, this.animationOrder = 500, this.paintOrder = 15, this.updateOrder = 1100, this.chart = i, this.scene = i.scene, this.options = this.scene.settings, this.events = i.events, this.popup = new t.Base.InfoPopup(i)
                }

                return __extends(i, e), i.prototype.previewPointerMove = function (t) {
                    this.onMove(t.x, t.y)
                }, i.prototype.doAnimations = function () {
                    null !== this.x && null !== this.y && this.onMove(this.x, this.y)
                }, i.prototype.previewPointerDown = function () {
                    this.x = this.y = null, this.setCurrentObject(0, 0, null)
                }, i.prototype.previewPointerDrag = function () {
                    this.x = this.y = null, this.setCurrentObject(0, 0, null)
                }, i.prototype.onPointerOut = function () {
                    this.x = this.y = null, this.setCurrentObject(0, 0, null)
                }, i.prototype.onMove = function (t, e) {
                    if (this.y = e, this.x = t, this.options.info.enabled && (!this.chart.legend || !this.chart.legend.containsCoordinate(t, e))) {
                        var i = this.scene.hoverSlice, n = this.scene.hoverPie;
                        n && !i && (i = n.getActiveSlice()), this.setCurrentObject(t, e, i)
                    }
                }, i.prototype.setCurrentObject = function (t, e, i) {
                    if (i) {
                        if (i !== this.currentSlice) {
                            var n = this.buildContents(i);
                            this.popup.show(t, t, e, n)
                        } else this.popup.updateXY(t, t, e);
                        this.currentSlice = i
                    } else this.currentSlice = null, this.popup.hide()
                }, i.prototype.buildContents = function (t) {
                    var e = this;
                    if (this.options.info.contentsFunction) {
                        var i = function (i) {
                            return t === e.currentSlice ? e.popup.updateContents(i) : void 0
                        };
                        return this.options.info.contentsFunction.call(this.chart.api, t.data, t, i)
                    }
                    return t.label.text
                }, i
            }(t.Base.ChartElement);
            e.InfoPopup = i
        }(e = t.PieChart || (t.PieChart = {}))
    }(e = t.Internal || (t.Internal = {}))
}(ZoomCharts || (ZoomCharts = {}));
var ZoomCharts;
!function (t) {
    var e;
    !function (t) {
        var e;
        !function (e) {
            var i = function (t) {
                function e(e) {
                    t.call(this), this.chart = e, this.animationOrder = 1007
                }

                return __extends(e, t), e.prototype.updatePie = function (t, e) {
                    return void 0 === e && (e = !0), !0
                }, e.prototype.scrollForward = function () {
                    return !0
                }, e.prototype.scrollBackward = function () {
                    return !1
                }, e.prototype.onSceneChange = function () {
                }, e.prototype.doAnimations = function () {
                }, e.prototype.paintScene = function () {
                }, e.prototype.getMovement = function () {
                    return {dfraction: 0, doffset: 0}
                }, e.prototype.findSliceAt = function () {
                    throw new Error("Not implemented in base class")
                }, e.prototype.findPieAt = function () {
                    throw new Error("Not implemented in base class")
                }, e.prototype.findLabelAt = function () {
                    throw new Error("Not implemented in base class")
                }, e
            }(t.Base.ChartElement);
            e.View = i
        }(e = t.PieChart || (t.PieChart = {}))
    }(e = t.Internal || (t.Internal = {}))
}(ZoomCharts || (ZoomCharts = {}));
var ZoomCharts;
!function (t) {
    var e;
    !function (t) {
        var e;
        !function (e) {
            var i = function () {
                function e(t) {
                    this.prevTime = 0, this.radiusAnimator = null, this.innerRadiusAnimator = null, this.chart = t, this.scene = t.scene, this.events = t.events
                }

                return e.prototype.doAnimations = function (e) {
                    var i = 0;
                    this.prevTime && (i = Math.min(30, e.timeStamp - this.prevTime));
                    var n = this.scene.settings.interaction.animation.scrollDuration, s = this.scene.settings.interaction.animation.hoverDuration, o = e.timeStamp, r = [], a = [], h = !1;
                    if (this.scene.settings.pie.adaptiveRadius) {
                        this.innerRadiusAnimator || (this.innerRadiusAnimator = new t.Base.Animator(0, this.scene.innerRadius, n, "<>", o), this.radiusAnimator = new t.Base.Animator(0, this.scene.radius, n, "<>", o));
                        var l = this.radiusAnimator.updateAndGet(this.scene.radius, o);
                        this.scene.currentRadius = l.value;
                        var u = l.changes;
                        l = this.innerRadiusAnimator.updateAndGet(this.scene.innerRadius, o), this.scene.currentInnerRadius = l.value;
                        var c = l.changes;
                        h = h || u || c, e.animating = e.animating || h
                    } else(this.scene.currentRadius !== this.scene.radius || this.scene.currentInnerRadius !== this.scene.innerRadius) && (h = !0, this.scene.currentRadius = this.scene.radius, this.scene.currentInnerRadius = this.scene.innerRadius);
                    for (var p = 0; p < this.scene.pies.length; p++) {
                        var d = this.scene.pies[p], f = !1;
                        (e.changes.pie || e.changes.bounds) && (f = !0);
                        var m = !1;
                        if (d.removed === !0 && null === d.removeTime && (d.removeTime = o + n), d.removed && (e.animating = !0, m = d.removeTime < o), m) r.push(d); else {
                            d._animatorA0 || (f = !0, d._animatorA0 = new t.Base.Animator(d.currentStartAngle, d.startAngle, n, "<>", o), d._animatorA1 = new t.Base.Animator(d.currentEndAngle, d.endAngle, n, "<>", o), d._animatorR0 = new t.Base.Animator(d.currentInnerRadius, d.innerRadius, n, "<>", o), d._animatorR1 = new t.Base.Animator(d.currentRadius, d.radius, n, "<>", o), this.scene.settings.advanced.initialAnimation || (d._animatorA0.jump(d.startAngle), d._animatorA1.jump(d.endAngle), d._animatorR0.jump(d.innerRadius), d._animatorR1.jump(d.radius)));
                            var g = d._animatorA0, y = d._animatorA1, v = d._animatorR0, S = d._animatorR1, l = g.updateAndGet(d.startAngle, o);
                            d.currentStartAngle = l.value;
                            var u = l.changes;
                            l = y.updateAndGet(d.endAngle, o), d.currentEndAngle = l.value;
                            var c = l.changes;
                            l = S.updateAndGet(d.radius, o), d.currentRadius = l.value;
                            var C = l.changes;
                            l = v.updateAndGet(d.innerRadius, o), d.currentInnerRadius = l.value;
                            var b = l.changes;
                            d.currentInnerRadius = Math.min(d.currentInnerRadius, d.currentRadius), f = f || u || c || C || b;
                            for (var x = [], _ = !1, w = 0; w < d.allSlices.length; w++) {
                                var L = d.allSlices[w];
                                L._animatorF || (f = !0, L._animatorF = new t.Base.Animator(L.currentFraction, L.fraction, n, "<>", o));
                                var T = L._animatorF.updateAndGetFixed(L.fraction, o);
                                L.currentFraction = T.value;
                                var M = T.changes;
                                _ = _ || M, L.removed && 0 === L.currentFraction && x.push(L)
                            }
                            if (f = f || _, x.length > 0) {
                                f = !0;
                                for (var w = 0; w < x.length; w++) {
                                    var L = x[w];
                                    t.Base.Helpers.removeFromArray(d.slices, L), t.Base.Helpers.removeFromArray(d.allSlices, L), L === d.othersSlice && (d.othersSlice = null), L === d.previousSlice && (d.previousSlice = null)
                                }
                            }
                            for (var w = 0; w < d.allSlices.length; w++) {
                                var L = d.allSlices[w];
                                L._animatorLineColor || (f = !0, L._animatorLineColor = new t.Base.Animator(L.currentLineColor, L.targetLineColor, s, "<>", o), L._animatorFillColor = new t.Base.Animator(L.currentFillColor, L.targetFillColor, s, "<>", o), L._animatorCutout = new t.Base.Animator(L.currentCutoutDistance, L.cutoutDistance, s, "<>", o));
                                var P = L._animatorLineColor, k = L._animatorFillColor, D = L._animatorCutout, I = P.updateColorAndGet(L.targetLineColor, o);
                                L.currentLineColor = I.value, u = I.changes, I = k.updateColorAndGet(L.targetFillColor, o), L.currentFillColor = I.value, c = I.changes, L.userPlaced ? D.jump(L.currentCutoutDistance) : (l = D.updateAndGet(L.cutoutDistance, o), L.currentCutoutDistance = l.value, C = l.changes), f = f || u || c || C
                            }
                            (f || h) && a.push(d), e.animating = e.animating || f
                        }
                    }
                    for (var p = 0; p < r.length; p++) {
                        var d = r[p];
                        this.scene.deletePie(d)
                    }
                    return this.prevTime = o, a
                }, e
            }();
            e.Animations = i
        }(e = t.PieChart || (t.PieChart = {}))
    }(e = t.Internal || (t.Internal = {}))
}(ZoomCharts || (ZoomCharts = {}));
var ZoomCharts;
!function (t) {
    var e;
    !function (t) {
        var e;
        !function (e) {
            var i = function () {
                function i(t, e) {
                    this.view = e, this.chart = t, this.scene = t.scene, this.events = t.events
                }

                return i.prototype.placeStack = function (t, e) {
                    var i = this.scene.settings, n = i.pie.depth, s = !1, o = this.scene.height - 2 * n;
                    o = Math.max(2, o);
                    var r = i.pie.x, a = i.pie.y;
                    null === r ? r = this.scene.x0 + this.scene.width / 2 : r >= 0 && 1 >= r && (r = this.scene.x0 + this.scene.width * r), null === a ? a = this.scene.y0 + o / 2 : a >= 0 && 1 >= a && (a = this.scene.y0 + this.scene.height * a);
                    var h = Math.min(o / 2, this.scene.width / 2);
                    h -= i.pie.outerMargin;
                    var l = i.pie.radius;
                    if (l) 1 >= l && (l = h * l); else if (i.labels.enabled && i.pie.adaptiveRadius) {
                        var u = this.computeDesiredRadiusFromLabels(t, e);
                        u = Math.min(h, u), u -= i.labels.connectorLength, u = Math.max(u, h / 3), l = u
                    } else l = h;
                    var c = i.pie.innerRadius;
                    if (1 > c && (c = l * c), this.scene.stack.length > 1) {
                        var p = i.pie.innerRadiusWhenDrilldown;
                        1 > p && (p = l * p), c = Math.max(c, p)
                    }
                    var d = i.pie.startAngle, f = i.pie.endAngle, m = 0, g = 0;
                    l !== c && (m = 1 / (l - c), g = -c * m), (t.x !== r || t.y !== a || this.scene.radius !== l || this.scene.innerRadius !== c || d !== t.startAngle || f !== t.endAngle) && (s = !0), this.scene.radius = l, this.scene.innerRadius = c, t.x = r, t.y = a, t.radius = 1, t.innerRadius = c * m + g, t.startAngle = d, t.endAngle = f;
                    var y = this.scene.stack, v = y.length - 1;
                    if (v > 0) {
                        c -= i.pie.margin;
                        for (var S = v, C = Math.max(0, Math.min(l - c, (c - i.pie.centerMargin) / S)), b = v - 1; b >= 0; b--)l = c, c -= C, t = y[b], a += n, t.x = r, t.y = a, t.radius = l * m + g, t.innerRadius = (c + i.pie.margin) * m + g, t.brightness = .8 - .8 * (S - b - 1) / S, t.startAngle = i.pie.startAngle, t.endAngle = i.pie.endAngle
                    }
                    for (v = 0; v < this.scene.pies.length; v++)if (t = this.scene.pies[v], t.removed && t.parentSlice) {
                        var x = this.scene.getSliceTargetAngles(t.parentSlice);
                        t.startAngle = x.a0, t.endAngle = x.a1
                    }
                    return s
                }, i.prototype.computeDesiredRadiusFromLabels = function (e, i) {
                    var s = this.scene.settings.slice.style.label, o = new n(i, 1, 0, 100, 0, 100, s, this.scene.settings.labels), r = 2 * s.padding, a = o.lineHeightC + o.lineHeightM + r, h = 0, l = 0, u = 0, c = 0, p = 0, d = e.startAngle, f = e.endAngle, m = f - d, g = e.startAngle, y = g;
                    t.Base.Graphics.textStyle(i, s.textStyle);
                    for (var v = 0; v < e.slices.length; v++) {
                        var S = e.slices[v], C = y;
                        p = Math.min(1, p + S.fraction), y = g + p * m;
                        var b = Math.max(C, d), x = Math.min(y, f);
                        if (!(b >= f || d >= x) && S.label.text) {
                            for (var _ = "", w = 0, L = S.label.text.split(" "); w < L.length; w++) {
                                var T = L[w];
                                T.length > _.length && (_ = T)
                            }
                            var M = i.measureText(_).width + r, P = i.measureText(S.label.text).width + r, k = a * P * 1.2, D = ((b + x) / 2 + Math.PI / 2) % (2 * Math.PI) <= Math.PI;
                            D ? (c += k, l = Math.max(l, M)) : (u += k, h = Math.max(h, M))
                        }
                    }
                    var I = Math.min(this.scene.width, this.scene.height), A = this.scene.width * I, B = Math.max(1, A - 2 * Math.max(u, c) * 1.2), E = Math.sqrt(B / Math.PI), O = Math.max(h, l), F = this.scene.width / 2 - 1.1 * O;
                    return Math.min(E, F)
                }, i.prototype.placeLabels = function (i, s) {
                    var o = this.scene.settings.icons, r = this.scene.settings.labels, a = this.scene.settings.slice, h = r.enabled, l = o.sizeExtent[0], u = o.sizeExtent[1], c = o.placement, p = o.autohideWhenTooSmall;
                    this.scene.settings.advanced.iconMinSize && (l = this.scene.settings.advanced.iconMinSize);
                    for (var d = a.margin, f = i.x, m = i.y, g = this.scene.currentInnerRadius, y = this.scene.currentRadius - g, v = i.currentInnerRadius * y + g, S = i.currentRadius * y + g, C = 0, b = i.currentStartAngle, x = i.currentEndAngle, _ = x - b, w = i.currentStartAngle, L = this.scene.x0 - f, T = L + this.scene.width, M = this.scene.y0 - m, P = M + this.scene.height, k = new n(s, S, L, T, M, P, a.style.insideLabel, this.scene.settings.labels), D = new n(s, S, L, T, M, P, a.style.label, this.scene.settings.labels), I = [], A = [], B = w, E = 0; E < i.allSlices.length; E++) {
                        var O = i.allSlices[E], F = B;
                        C = Math.min(1, C + O.currentFraction), B = w + C * _;
                        var N = Math.max(F, b), z = Math.min(B, x), R = v + O.currentCutoutDistance, H = S + O.currentCutoutDistance;
                        if (N >= x || b >= z) O.currentLabel = null, O.currentInsideLabel = null, O.currentIcon = null; else {
                            var Z = (N + z) / 2;
                            if (O.removed || i.background) O.currentLabel = null, O.currentInsideLabel = null; else {
                                if (O.insideLabel.text && h) {
                                    var U = O.insideLabel.text, W = void 0;
                                    O.currentInsideLabel ? W = O.currentInsideLabel : (W = O.currentInsideLabel = new t.Base.Label, W.align = "center"), O.currentInsideLabel.text !== U && (W.text = U, W.measureDone = !1);
                                    var V = k.fitLabelInSlice(W, R, H, N, z);
                                    W.shouldBeVisible = "always" === r.insideLabel || V >= r.insideLabelVisibilityFraction, W.shouldBeVisible || O === this.scene.hoverSlice || W.userPlaced || (W.visible = !1)
                                } else O.currentInsideLabel = null;
                                var G = O.label.text && h ? O.label.text : "";
                                if ("append" === r.insideLabel && O.insideLabel.text && h && !O.currentInsideLabel.userPlaced && !O.currentInsideLabel.shouldBeVisible && (G ? (f = Math.cos(Z), G = f > 0 ? O.insideLabel.text + ", " + G : G + ", " + O.insideLabel.text) : G = O.insideLabel.text), G) {
                                    var W = null;
                                    W = O.currentLabel ? O.currentLabel : O.currentLabel = new t.Base.Label, O.currentLabel.text !== G && (W.text = G, W.measureDone = !1), W.userPlaced || D.placeOutsideLabelInitial(W, Z), W.x > 0 ? (W.align = "left", A.push(W)) : (W.align = "right", I.push(W))
                                } else O.currentLabel = null
                            }
                            var Y = null;
                            if (O.icon && (!i.background || O.id === i.activeSliceId)) {
                                var j = k.fitBoxInSlice(1, 1, R, H, N, z);
                                f = j.x, m = j.y;
                                var q = j.prop;
                                q -= d, (!p || 2 * q >= l) && (q = Math.max(Math.min(q, u / 2), l / 2), Y = new e.Icon, Y.hwidth = q, Y.hheight = q, Y.inside = !0, O.iconOffset ? (Y.x = 0, Y.y = 0, this.applyOffset(Y, O.iconOffset, R, H, N, z)) : "center" === c ? (Y.x = 0, Y.y = 0, this.applyOffset(Y, [0, 0, 0, 0], R, H, N, z)) : (Y.x = f, Y.y = m))
                            }
                            O.currentIcon = Y
                        }
                    }
                    D.computeOutsideLabelLocations(I, A)
                }, i.prototype.applyOffset = function (t, e, i, n, s, o) {
                    var r = 0, a = 0;
                    e.length >= 2 && (r = e[0], a = e[1]);
                    var h = 0, l = 0;
                    e.length >= 4 && (h = e[2], l = e[3]);
                    var u = i + (n - i) * (h + 1) / 2, c = s + (o - s) * (l + 1) / 2;
                    r += Math.cos(c) * u, a += Math.sin(c) * u, t.x += r, t.y += a
                }, i
            }();
            e.PieLayout = i;
            var n = function (e) {
                function i(t, i, n, s, o, r, a, h) {
                    e.call(this, t, a), this.config = h, this.bottom = r, this.top = o, this.right = s, this.left = n, this.rr = i + h.connectorLength, this.interLabelSpacing = Math.max(h.interLabelSpacing * this.lineHeight, this.margin)
                }

                return __extends(i, e), i.prototype.placeOutsideLabelInitial = function (t, e) {
                    var i = this.rr * Math.cos(e), n = this.rr * Math.sin(e), s = 1;
                    n < this.top && (s = Math.min(s, this.top / n)), n > this.bottom && (s = Math.min(s, this.bottom / n)), i < this.left && (s = Math.min(s, this.left / i)), i > this.right && (s = Math.min(s, this.right / i)), t.x = i * s, t.y = n * s
                }, i.prototype.computeOutsideLabelLocations = function (t, e) {
                    var i = this.bottom - this.margin, n = this.top + this.margin, s = this.interLabelSpacing;
                    t.sort(function (t, e) {
                        return e.y - t.y
                    }), e.sort(function (t, e) {
                        return t.y - e.y
                    });
                    for (var o = 0; o < t.length; o++) {
                        var r = t[o];
                        r.originX = r.x
                    }
                    for (var o = 0; o < e.length; o++) {
                        var r = e[o];
                        r.originX = r.x
                    }
                    for (var a = "wrap" === this.config.placement ? [!1] : [!0, !1], h = 0; h < a.length; h++) {
                        for (var l = a[h], u = 100, c = !1, p = 0; 2 > p; p++) {
                            for (var d = 0 === p ? t : e, o = 0; o < d.length; o++) {
                                var r = d[o];
                                r.prop = this.fitLabelOutside(r, l)
                            }
                            for (var f = i - n, m = [], g = 0, o = 0; o < d.length; o++) {
                                var r = d[o];
                                if (r.visible) {
                                    var y = 2 * r.hheight + s;
                                    f > g + y ? (m.push(r), g += y) : (r.visible = r.userPlaced, u = .5)
                                }
                            }
                            var v = i, S = n;
                            d === t ? S += g : v -= g;
                            for (var o = 0; o < m.length; o++) {
                                var r = m[o];
                                if (d === t ? S -= 2 * r.hheight + s : v += 2 * r.hheight + s, !r.userPlaced && (r.y + r.hheight > v || r.y - r.hheight < S)) {
                                    r.y = Math.min(Math.max(r.y, S + r.hheight), v - r.hheight);
                                    var C = this.fitLabelOutside(r, l);
                                    u = Math.min(C, u), c = c || r.rows && r.rows.subLines[r.rows.subLines.length - 1].row > 0
                                } else u = Math.min(u, r.prop);
                                d === t ? v = r.y - r.hheight - s : S = r.y + r.hheight + s
                            }
                        }
                        if (u >= 1 || !c)break
                    }
                }, i.prototype.fitLabelOutside = function (t, e) {
                    var i = this;
                    void 0 === e && (e = !1), null == e && (e = !1);
                    var n = function (n) {
                        return t.userPlaced ? i.getOutsideMaxWidth(t.x, t.y, n, !1) : i.placeOutsideMaxWidth(t.originX, t.y, n, e)
                    };
                    return this.fitLabelInRect(t, t.align, t.align, n)
                }, i.prototype.fitLabelInSlice = function (t, e, i, n, s) {
                    var o, r = this, a = Math.cos(n), h = Math.cos(s), l = Math.min(a, h), u = Math.max(a, h);
                    o = 0 > l && 0 > u || -l > 2 * u ? "right" : l > 0 && u > 0 || u > 2 * -l ? "left" : "center";
                    var c, p;
                    if (t.userPlaced) c = t.x, p = t.y; else {
                        var d;
                        d = 2 * e >= i ? .5 : .5 + (i - 2 * e) / i / 4;
                        var f = e + (i - e) * d, m = (n + s) / 2, g = Math.cos(m), y = Math.sin(m);
                        c = f * g, p = f * y
                    }
                    var v = p - this.rayIntersectsSlice(c, p, 0, -1, e, i, n, s), S = p + this.rayIntersectsSlice(c, p, 0, 1, e, i, n, s), C = function (t, o) {
                        if (!(i > 0) || v >= o || o >= S)return [1e-5, 1e-5];
                        var a = r.rayIntersectsSlice(t, o, -1, 0, e, i, n, s), h = r.rayIntersectsSlice(t, o, 1, 0, e, i, n, s);
                        return [a, h]
                    };
                    return this.fitLabelInLines(t, c, p, "center", o, C)
                }, i.prototype.placeOutsideMaxWidth = function (t, e, i, n) {
                    var s = this.rr, o = e - i / 2, r = o + i;
                    if (o < this.top) {
                        var a = this.top - o;
                        o += a, r += a
                    }
                    if (r > this.bottom) {
                        var a = this.bottom - r;
                        o += a, r += a
                    }
                    var h, l = this.left, u = this.right;
                    return h = n ? s : o > s || -s > r ? 0 : o > 0 ? Math.sqrt(s * s - o * o) : 0 > r ? Math.sqrt(s * s - r * r) : s, t > 0 ? l = Math.max(h, t) : u = Math.min(t, -h), {
                        x: (l + u) / 2,
                        y: (o + r) / 2,
                        dx: 1,
                        dy: 0,
                        width: u - l
                    }
                }, i.prototype.getOutsideMaxWidth = function (t, e, i, n) {
                    var s, o = e - i / 2, r = o + i, a = this.left, h = this.right, l = this.rr;
                    s = n ? l : o > l || -l > r ? 0 : o > 0 ? Math.sqrt(l * l - o * o) : 0 > r ? Math.sqrt(l * l - r * r) : l, t > 0 ? a = s : h = -s;
                    var u = Math.min(Math.abs(t - a), Math.abs(t - h));
                    return {x: t, y: e, dx: 1, dy: 0, width: 2 * u}
                }, i.prototype.fitBoxInSlice = function (t, e, i, n, s, o) {
                    var r = .5 + (n - i) / n / 4, a = i + (n - i) * r, h = (s + o) / 2, l = Math.cos(h), u = Math.sin(h), c = a * l, p = a * u, d = t, f = e, m = this.rayIntersectsSlice(c, p, d, f, i, n, s, o), g = this.rayIntersectsSlice(c, p, -d, f, i, n, s, o), y = this.rayIntersectsSlice(c, p, -d, -f, i, n, s, o), v = this.rayIntersectsSlice(c, p, d, -f, i, n, s, o), S = Math.min(m, g, y, v);
                    return {x: c, y: p, prop: S}
                }, i.prototype.rayIntersectsSlice = function (e, i, n, s, o, r, a, h) {
                    var l = t.Base.Geometry.rayIntersectsCircle(e, i, n, s, o);
                    l = Math.min(l, t.Base.Geometry.rayIntersectsCircle(e, i, n, s, r));
                    var u = Math.cos(a), c = Math.sin(a);
                    return l = Math.min(l, t.Base.Geometry.rayIntersectsSegment(e, i, n, s, o * u, o * c, r * u, r * c)), u = Math.cos(h), c = Math.sin(h), l = Math.min(l, t.Base.Geometry.rayIntersectsSegment(e, i, n, s, o * u, o * c, r * u, r * c))
                }, i
            }(t.Base.LabelLayoutBase);
            e.LabelLayout = n
        }(e = t.PieChart || (t.PieChart = {}))
    }(e = t.Internal || (t.Internal = {}))
}(ZoomCharts || (ZoomCharts = {}));
var ZoomCharts;
!function (t) {
    var e;
    !function (t) {
        var e;
        !function (e) {
            var i;
            !function (e) {
                var i = function () {
                    function e(t) {
                        this.renderer = t, this.settings = this.renderer.settings
                    }

                    return e.prototype.paintPie = function (e, i, n, s, o, r, a, h) {
                        h.fillColor && (e.beginPath(), e.arc(i, n, o, r, a, !1), e.arc(i, n, s, a, r, !0), e.closePath(), t.Base.Graphics.fill(e, h))
                    }, e.prototype.paintSlices = function () {
                        throw"paintSlices not implemented"
                    }, e.prototype.paintExpandableHilights = function (e, i, n, s) {
                        for (var o = this.settings.slice.expandableMarkStyle.distance, r = 0; r < s.length; r++) {
                            var a = s[r];
                            if (a.expandable) {
                                var h = a._renderParams, l = i + a.x, u = n + a.y, c = h[0], p = h[1], d = Math.max((c + p) / 2, p - o), f = h[2], m = h[3];
                                e.beginPath(), e.arc(l, u, d, f, m), t.Base.Graphics.paint(e, this.settings.slice.expandableMarkStyle)
                            }
                        }
                    }, e.prototype.strokeSlice = function (t, e, i, n) {
                        var s = n._renderParams;
                        e += n.x, i += n.y;
                        var o = s[0], r = s[1], a = s[2], h = s[3], l = s[4], u = s[5], c = r * Math.abs(h - a), p = r - o, d = Math.min(.1 * Math.min(c, p), 3);
                        o + r === -2 && (o = 0, r = 0), t.beginPath(), "zigzag" === n.lineDecoration ? this.strokeZigZag(t, e, i, r, d, a, h) : t.arc(e, i, r, a, h, !1), l === u ? t.lineTo(e + Math.cos(u) * o, i + Math.sin(l) * o) : t.arc(e, i, o, u, l, !0), t.closePath()
                    }, e.prototype.strokeZigZag = function (t, e, i, n, s, o, r) {
                        var a = 5 / n, h = o;
                        for (t.moveTo(e + n * Math.cos(o), i + n * Math.sin(o)); r > h + a;)h += a, t.lineTo(e + (n + s) * Math.cos(h), i + (n + s) * Math.sin(h)), s = -s;
                        t.lineTo(e + n * Math.cos(r), i + n * Math.sin(r))
                    }, e.prototype.strokeAndPaint = function (e, i, n, s) {
                        var o = t.Base.Graphics.beginStrokeAndFill(e, s);
                        this.strokeSlice(o, i, n, s), t.Base.Graphics.endStrokeAndFill(e, o, s)
                    }, e
                }();
                e.CommonBase = i
            }(i = e.Renderers || (e.Renderers = {}))
        }(e = t.PieChart || (t.PieChart = {}))
    }(e = t.Internal || (t.Internal = {}))
}(ZoomCharts || (ZoomCharts = {}));
var ZoomCharts;
!function (t) {
    var e;
    !function (t) {
        var e;
        !function (t) {
            var e;
            !function (t) {
                var e = function (t) {
                    function e() {
                        t.apply(this, arguments)
                    }

                    return __extends(e, t), e.prototype.paintSlices = function (t, e, i, n) {
                        for (var s = 0; s < n.length; s++) {
                            var o = n[s];
                            this.strokeAndPaint(t, e, i, o)
                        }
                    }, e
                }(t.CommonBase);
                t.Flat = e
            }(e = t.Renderers || (t.Renderers = {}))
        }(e = t.PieChart || (t.PieChart = {}))
    }(e = t.Internal || (t.Internal = {}))
}(ZoomCharts || (ZoomCharts = {}));
var ZoomCharts;
!function (t) {
    var e;
    !function (t) {
        var e;
        !function (e) {
            var i;
            !function (e) {
                var i = function (e) {
                    function i() {
                        e.apply(this, arguments)
                    }

                    return __extends(i, e), i.prototype.paintPie = function (t, i, n, s, o, r, a, h) {
                        e.prototype.paintPie.call(this, t, i, n, s, o, r, a, h);
                        var l = this.settings.pie.depth;
                        if (l > 0 && h.allSlices.length > 0) {
                            t.fillStyle = "rgba(0,0,0,0.05)";
                            for (var u = 0; u < [5, 10, 18].length; u++) {
                                var c = [5, 10, 18][u];
                                t.beginPath(), t.arc(i, n + c + l, o, r, a, !1), t.arc(i, n + c + l, s, a, r, !0), t.closePath(), t.fill()
                            }
                        }
                    }, i.prototype.paintSlices = function (e, i, n, s) {
                        var o = this.settings.pie.depth, r = 2 * this.settings.advanced.renderQuality, a = 1 / r, h = o * r;
                        e.shadowOffsetX = 0, e.shadowOffsetY = 0, e.shadowBlur = 1.5 * o, e.shadowColor = "black", e.fillStyle = "black";
                        for (var l = 0; l < s.length; l++) {
                            var u = s[l];
                            this.strokeSlice(e, i, n + o, u), e.fill()
                        }
                        e.shadowColor = null, e.shadowBlur = 0, e.lineWidth = 1;
                        for (var c = 0; h >= c; c++)for (var l = 0; l < s.length; l++) {
                            var u = s[l];
                            u.fillColor instanceof CanvasGradient ? t.Base.Helpers.error("slice.fillColor cannot be gradient if `can` renderer is used") : (this.strokeSlice(e, i, n + o - c * a, u), e.strokeStyle = c >= h - 1 ? t.Base.Graphics.deriveColor(u.fillColor, 1.35, 1) : t.Base.Graphics.deriveColor(u.fillColor, .5 + c / h * .2, 1), e.stroke())
                        }
                        var p = Math.PI;
                        e.shadowBlur = o, e.shadowColor = "rgba(0,0,0,0.1)", e.fillStyle = "black";
                        for (var l = 0; l < s.length; l++) {
                            var u = s[l], d = u._renderParams, f = d[4], m = d[5];
                            if (f !== m) {
                                for (; f > p;)f -= 2 * p, m -= 2 * p;
                                0 > f ? m > 0 && (m = Math.min(m, p), this.strokeInnerShadowSlice(e, i, n, u, 0, m) && e.fill()) : p > m ? this.strokeInnerShadowSlice(e, i, n, u, f, m) && e.fill() : (p > f && this.strokeInnerShadowSlice(e, i, n, u, f, p) && e.fill(), m > 2 * p && this.strokeInnerShadowSlice(e, i, n, u, 2 * p, m) && e.fill())
                            }
                        }
                        for (var l = 0; l < s.length; l++) {
                            var u = s[l];
                            this.strokeAndPaint(e, i, n, u)
                        }
                    }, i.prototype.strokeInnerShadowSlice = function (t, e, i, n, s, o) {
                        var r = n._renderParams, a = r[0] + 1, h = Math.min(r[1] - 1, a + 10);
                        return a >= r[1] || h <= r[0] ? !1 : (s += 1 / a, o -= 1 / a, s >= o ? void 0 : (t.beginPath(), t.arc(e, i, h, s, o, !1), t.arc(e, i, a, o, s, !0), t.closePath(), !0))
                    }, i
                }(e.CommonBase);
                e.Can = i
            }(i = e.Renderers || (e.Renderers = {}))
        }(e = t.PieChart || (t.PieChart = {}))
    }(e = t.Internal || (t.Internal = {}))
}(ZoomCharts || (ZoomCharts = {}));
var ZoomCharts;
!function (t) {
    var e;
    !function (t) {
        var e;
        !function (e) {
            var i;
            !function (e) {
                var i = function (e) {
                    function i() {
                        e.apply(this, arguments)
                    }

                    return __extends(i, e), i.prototype.paintSlices = function (t, e, i, n) {
                        this.g = t;
                        for (var s = 0; s < n.length; s++) {
                            var o = n[s];
                            this.strokeAndPaint(t, e, i, o), this.elegantGradient(e, i, o)
                        }
                    }, i.prototype.getRadialGradient = function (t, e, i, n, s, o, r) {
                        var a = Math.abs(Math.sin(r)), h = this.g.createRadialGradient(t, e, i, n, s, o);
                        return this.addColorStops(h, a, r), h
                    }, i.prototype.getLinearGradient = function (t, e, i, n, s, o, r, a) {
                        var h = r - n, l = Math.sin(a), u = Math.cos(a), c = e + u * n, p = i + l * n, d = c + u * h, f = p + l * h, m = Math.abs(l), g = this.g.createLinearGradient(c, p, d, f);
                        return this.addColorStops(g, m, a), g
                    }, i.prototype.addColorStops = function (t, e, i) {
                        var n = "0,0,0", s = "255,255,255", o = s, r = n;
                        (0 >= i || i > Math.PI) && (o = n, r = s);
                        var a = .4 * e, h = .2 * e, l = .1 * e, u = .3 * e, c = .5 * e;
                        t.addColorStop(0, "rgba(" + o + "," + a.toFixed(3) + ")"), t.addColorStop(.1, "rgba(" + o + "," + h.toFixed(3) + ")"), t.addColorStop(.1, "rgba(" + o + "," + l.toFixed(3) + ")"), t.addColorStop(.4, "rgba(" + n + ",0.1)"), t.addColorStop(.9, "rgba(" + r + "," + l.toFixed(3) + ")"), t.addColorStop(.95, "rgba(" + r + "," + u.toFixed(3) + ")"), t.addColorStop(1, "rgba(" + r + "," + c.toFixed(3) + ")")
                    }, i.prototype.elegantGradient = function (e, i, n) {
                        for (var s = n._renderParams[0], o = n._renderParams[1], r = n._renderParams[2], a = n._renderParams[3], h = this.settings.advanced.renderQuality, l = Math.PI / Math.max(1, 180 * h), u = r; a > u;) {
                            var c = Math.min(u + l, a);
                            this.g.beginPath(), this.g.arc(e, i, o, u, c), this.g.arc(e, i, s, c, u, !0), this.g.closePath(), t.Base.Graphics.paint(this.g, {fillColor: this.getRadialGradient(e, i, s, e, i, o, u)}), u = c
                        }
                    }, i
                }(e.CommonBase);
                e.Smoothy = i
            }(i = e.Renderers || (e.Renderers = {}))
        }(e = t.PieChart || (t.PieChart = {}))
    }(e = t.Internal || (t.Internal = {}))
}(ZoomCharts || (ZoomCharts = {}));
var ZoomCharts;
!function (t) {
    var e;
    !function (t) {
        var e;
        !function (t) {
            var e;
            !function (t) {
                var e = function (t) {
                    function e() {
                        t.apply(this, arguments)
                    }

                    return __extends(e, t), e.prototype.paintSlices = function (t, e, i, n) {
                        this.g = t;
                        for (var s = 0; s < n.length; s++) {
                            var o = n[s];
                            this.strokeAndPaint(t, e, i, o), this.smartGradient(e, i, o)
                        }
                    }, e.prototype.getSmartGradient = function (t, e, i, n, s, o) {
                        var r, a, h = 0, l = 0, u = 0, c = 0;
                        "inside" === s ? "top" === o ? (u = n - i, c = e, r = "rgba(0,0,0,0.3)", a = "rgba(0,0,0,0)") : (u = e, c = e + i, r = "rgba(255,255,255,0)", a = "rgba(255,255,255,0.3)") : "top" === o ? (c = e, r = "rgba(255,255,255,0.3)", a = "rgba(255,255,255,0)") : (u = e, c = e + n, r = "rgba(0,0,0,0)", a = "rgba(0,0,0,0.3)");
                        try {
                            var p = this.g.createLinearGradient(h, u, l, c);
                            return p.addColorStop(0, r), p.addColorStop(1, a), p
                        } catch (d) {
                            throw"Could not create linear gradient: " + d
                        }
                    }, e.prototype.smartOuterShineTop = function (t, e, i, n, s, o, r, a) {
                        if (!(s > 0 && o < Math.PI)) {
                            o > 0 && 0 > s && (o = 0, a = 0), s > 0 && s < Math.PI && (s = Math.PI, r = Math.PI);
                            var h = {
                                _renderParams: [n - .1 * (n - i), n, s, o, r, a, null, null],
                                x: 0,
                                y: 0,
                                fillColor: this.getSmartGradient(t, e, i, n, "outside", "top")
                            };
                            this.strokeAndPaint(this.g, t, e, h)
                        }
                    }, e.prototype.smartOuterShineBottom = function (t, e, i, n, s, o, r, a) {
                        if (!(0 > o || s > Math.PI)) {
                            0 > s && (s = 0, r = 0), o > Math.PI && (o = Math.PI, a = Math.PI);
                            var h = {
                                _renderParams: [n - .1 * (n - i), n, s, o, r, a, null, null],
                                x: 0,
                                y: 0,
                                fillColor: this.getSmartGradient(t, e, i, n, "outside", "bottom")
                            };
                            this.strokeAndPaint(this.g, t, e, h)
                        }
                    }, e.prototype.smartInnerShineTop = function (t, e, i, n, s, o, r, a) {
                        if (!(s > 0 && o < Math.PI)) {
                            o > 0 && 0 > s && (o = 0, a = 0), s > 0 && s < Math.PI && (s = Math.PI, r = Math.PI);
                            var h = {
                                _renderParams: [i, i + .1 * (n - i), s, o, r, a, null, null],
                                x: 0,
                                y: 0,
                                fillColor: this.getSmartGradient(t, e, i, n, "inside", "top")
                            };
                            this.strokeAndPaint(this.g, t, e, h)
                        }
                    }, e.prototype.smartInnerShineBottom = function (t, e, i, n, s, o, r, a) {
                        if (!(0 > o || s > Math.PI)) {
                            0 > s && (s = 0, r = 0), o > Math.PI && (o = Math.PI, a = Math.PI);
                            var h = {
                                _renderParams: [i, i + .1 * (n - i), s, o, r, a, null, null],
                                x: 0,
                                y: 0,
                                fillColor: this.getSmartGradient(t, e, i, n, "inside", "bottom")
                            };
                            this.strokeAndPaint(this.g, t, e, h)
                        }
                    }, e.prototype.smartGradient = function (t, e, i) {
                        t += i.x, e += i.y;
                        var n = i._renderParams[0], s = i._renderParams[1], o = i._renderParams[2], r = i._renderParams[3], a = i._renderParams[4], h = i._renderParams[5];
                        this.smartOuterShineTop(t, e, n, s, o, r, a, h), this.smartOuterShineBottom(t, e, n, s, o, r, a, h), this.smartInnerShineTop(t, e, n, s, o, r, a, h), this.smartInnerShineBottom(t, e, n, s, o, r, a, h)
                    }, e
                }(t.CommonBase);
                t.Bevel = e
            }(e = t.Renderers || (t.Renderers = {}))
        }(e = t.PieChart || (t.PieChart = {}))
    }(e = t.Internal || (t.Internal = {}))
}(ZoomCharts || (ZoomCharts = {}));
var ZoomCharts;
!function (t) {
    var e;
    !function (t) {
        var e;
        !function (e) {
            var i = function () {
                function i(t) {
                    this.renderer = null, this.chart = t, this.settings = t.settings, this.scene = t.scene
                }

                return i.prototype.onSceneChange = function (t) {
                    t.changes.settings && this.buildSeries()
                }, i.prototype.buildSeries = function () {
                    var t = this.settings.pie.theme, i = t.charAt(0).toUpperCase() + t.slice(1);
                    try {
                        this.renderer = new e.Renderers[i](this)
                    } catch (n) {
                        throw"Renderer " + t + " is not available: " + n
                    }
                }, i.prototype.paintScene = function (t) {
                    for (var e = t.context, i = t.labelRenderer, n = t.isExport ? this.settings.pie.showInnerPiesExport : this.settings.pie.showInnerPies, s = 0; s < this.scene.pies.length; s++) {
                        var o = this.scene.pies[s];
                        (n || !o.background) && this.paintPie(e, i, o)
                    }
                    t.isExport || !this.scene.hoverBack && !this.scene.settings.advanced.backAlwaysVisible || this.paintBackArrow(t)
                }, i.prototype.paintBackArrow = function (t) {
                    var e = this.scene.assetsLoader.getAssetImage(this.scene.settings.advanced.backImage);
                    if (e) {
                        var i = this.scene.pies[this.scene.pies.length - 1], n = .707106781186547, s = i.x, o = i.y, r = this.settings.pie.depth;
                        o += (this.scene.pies.length - 1) * r;
                        var a = e.width / 2, h = e.height / 2, l = i.innerRadius * n, u = Math.min(a, Math.max(l, a / 2)) / a, c = Math.min(h, Math.max(l, h / 2)) / h, p = Math.min(u, c), d = t.context;
                        d.globalAlpha = .5, d.drawImage(e, s - a * p, o - h * p, 2 * a * p, 2 * h * p), d.globalAlpha = 1
                    }
                }, i.prototype.paintPie = function (e, i, n) {
                    var s = this.settings.slice.margin;
                    n.allSlices.length < 2 && (s = 0);
                    var o = n.x, r = n.y, a = this.scene.currentInnerRadius, h = this.scene.currentRadius - a, l = Math.max(n.currentInnerRadius * h + a, s / 2), u = n.currentRadius * h + a, c = n.currentStartAngle, p = n.currentEndAngle, d = p - c, f = c;
                    if (u > 0 && d > 0) {
                        for (var m = l > 0 ? 1 / l : 0, g = 1 / u, y = s / 2 * m, v = s / 2 * g, S = [], C = 0; C < n.allSlices.length; C++) {
                            var b = n.allSlices[C], x = b.currentFraction * d;
                            if (x > 0) {
                                var _ = f;
                                f += x;
                                var w = l + b.currentCutoutDistance, L = u + b.currentCutoutDistance, T = void 0, M = void 0;
                                if (4 * v >= x) {
                                    var P = (_ + f) / 2, k = x / 4;
                                    T = P - k, M = P + k
                                } else T = _ + v, M = f - v;
                                var D = _ + y, I = f - y;
                                D > I && (D = I = (D + I) / 2), c > M || T > p || (T = Math.max(T, c), M = Math.min(M, p), D = Math.max(D, c), I = Math.min(I, p), D > I && (D = I = (D + I) / 2), b._renderParams = [w, L, T, M, D, I, b.fillColor, b.lineColor], b.fillColor = b.currentFillColor, b.lineColor = b.currentLineColor, S.push(b))
                            }
                        }
                        o = n.x, r = n.y, this.renderer.paintPie(e, o, r, l, u, n.currentStartAngle, n.currentEndAngle, n), this.renderer.paintSlices(e, o, r, S), n === this.scene.peek() && this.renderer.paintExpandableHilights(e, o, r, S);
                        for (var A = 0; A < S.length; A++) {
                            var B = S[A];
                            B.fillColor = B._renderParams[6], B.lineColor = B._renderParams[7]
                        }
                        if (!n.removed) {
                            t.Base.Graphics.clearShadow(e);
                            for (var C = 0; C < n.allSlices.length; C++) {
                                var b = n.allSlices[C];
                                if (b.currentIcon) {
                                    var E = this.scene.assetsLoader.getAssetImage(b.icon);
                                    if (E) {
                                        var O = b.currentIcon, F = o + O.x, N = r + O.y, z = Math.min(E.width / 2, O.hwidth), R = Math.min(E.height / 2, O.hheight);
                                        e.drawImage(E, F - z, N - R, 2 * z, 2 * R)
                                    }
                                }
                            }
                            f = c;
                            for (var C = 0; C < n.allSlices.length; C++) {
                                var b = n.allSlices[C], x = b.currentFraction * d, _ = f;
                                f = _ + x;
                                var H = Math.max(_, c), Z = Math.min(f, p), U = (H + Z) / 2, W = b === this.scene.hoverSlice, V = u + b.currentCutoutDistance;
                                b.currentInsideLabel && b.currentInsideLabel.visible && (b.currentInsideLabel.id = null, this.paintLabel(e, i, o, r, V, U, b.currentInsideLabel, b.insideLabel, W)), b.currentLabel && b.currentLabel.visible && (b.currentLabel.id = null, this.paintLabel(e, i, o, r, V, U, b.currentLabel, b.label, W))
                            }
                        }
                    }
                }, i.prototype.paintLabel = function (e, i, n, s, o, r, a, h, l) {
                    var u, c, p = this.scene.y0 + 3, d = p + this.scene.height - 6, f = this.settings.labels, m = a.x, g = a.y, y = a.hwidth, v = a.hheight, S = o + f.connectorLength;
                    if (0 > m + y ? (u = m + y, c = g) : m + y >= 0 ? (u = m - y, c = g) : (u = m, c = g > 0 ? g - v : g + v), f.connectors && u * u + c * c > o * o) {
                        var C = Math.sin(r), b = Math.cos(r);
                        e.beginPath();
                        var x = n + o * b, _ = s + o * C;
                        e.moveTo(x, _);
                        var w = n + S * b, L = s + S * C;
                        L = Math.min(Math.max(L, p), d), u += n, c += s, c = Math.min(Math.max(c, p), d);
                        var T = (o + S) / 2, M = t.Base.Geometry.rayIntersectsCircle(u - n, c - s, x - u, _ - c, o), P = t.Base.Geometry.lineTouchingCircle(u - n, c - s, w - n, L - s, S);
                        if (.9 > M && P) {
                            for (var k = P.x, D = P.y, I = Math.atan2(D, k); I - r > Math.PI;)I -= 2 * Math.PI;
                            for (; I - r < -Math.PI;)I += 2 * Math.PI;
                            var A = I - r;
                            k += n, D += s, w = n + T * b, L = s + T * C, L = Math.min(Math.max(L, p), d);
                            var B = n + T * Math.cos(r + .2 * A), E = s + T * Math.sin(r + .2 * A);
                            E = Math.min(Math.max(E, p), d), e.quadraticCurveTo(w, L, B, E);
                            var O = n + S * Math.cos(I), F = s + S * Math.sin(I);
                            F = Math.min(Math.max(F, p), d), t.Base.Graphics.arcBetweenTwoPoints(e, n, s, T, B, E, O, F), e.lineTo(u, c)
                        } else e.quadraticCurveTo(w, L, u, c);
                        var N = this.settings.slice.connectorStyle, z = N.lineWidth;
                        l && (N.lineWidth += 2), t.Base.Graphics.stroke(e, N), N.lineWidth = z
                    }
                    i.paintWithStyle(e, n + a.x, s + a.y, 1, a, h), t.Base.Graphics.clearShadow(e)
                }, i
            }();
            e.PieRenderer = i
        }(e = t.PieChart || (t.PieChart = {}))
    }(e = t.Internal || (t.Internal = {}))
}(ZoomCharts || (ZoomCharts = {}));
var ZoomCharts;
!function (t) {
    var e;
    !function (t) {
        var e;
        !function (e) {
            var i = function () {
                function i(t) {
                    this.chart = t, this.scene = t.scene, this.loading = !1
                }

                return i.prototype.updatePie = function (t, e) {
                    var i = this.getPieData(t);
                    this.rectifyScrollOffsets(t, i);
                    var n = this.getForwardCount(t.id, i, t.offset), s = n.numberOfSlices, o = n.isReady;
                    if (t.data = i, t.loading = !o, o) {
                        var r = this.buildSlices(t, t.offset, s), a = r.slices, h = r.othersSlice, l = r.previousSlice;
                        this.applyNewSlices(t, a, h, l, e)
                    }
                    return o
                }, i.prototype.scrollForward = function (t, e) {
                    var i = this.getPieData(t);
                    t.data = i;
                    var n, s = !0;
                    if (null === e || void 0 === e) {
                        var o = this.getForwardCount(t.id, i, t.offset);
                        n = o.numberOfSlices, s = o.isReady, e = t.offset + n
                    }
                    if (s) {
                        var o = this.getForwardCount(t.id, i, e);
                        n = o.numberOfSlices, s = o.isReady
                    }
                    if (s) {
                        var r = this.buildSlices(t, e, n), a = r.slices, h = r.othersSlice, l = r.previousSlice;
                        if (t.othersSlice) {
                            var u = Math.min(a.length, Math.max(0, t.offset + t.count - e));
                            this.fitSlicesInOrigin(t.othersSlice, a.slice(u), h), h || (h = t.othersSlice, h.fraction = 0, h.currentFraction = 0, h.removed = !0)
                        }
                        return t.offset = e, this.applyNewSlices(t, a, h, l), t.loading = !1, !0
                    }
                    return t.loading = !0, !1
                }, i.prototype.scrollBackward = function (t, e) {
                    var i = this.getPieData(t);
                    t.data = i;
                    var n = !0, s = 0;
                    if (null === e || void 0 === e) {
                        var o = this.getBackOffset(t.id, i, t.offset);
                        e = o.newOffset, n = o.isReady
                    }
                    if (n) {
                        var r = this.getForwardCount(t.id, i, e);
                        s = r.numberOfSlices, n = r.isReady
                    }
                    if (n) {
                        var a = this.buildSlices(t, e, s), h = a.slices, l = a.othersSlice, u = a.previousSlice;
                        if (t.previousSlice) {
                            var c = Math.min(h.length, Math.max(0, t.offset - e));
                            this.fitSlicesInOrigin(t.previousSlice, h.slice(0, c), u), u || (u = t.previousSlice, u.fraction = 0, u.currentFraction = 0, u.removed = !0)
                        }
                        return t.offset = e, this.applyNewSlices(t, h, l, u), t.loading = !1, !0
                    }
                    return t.loading = !0, !1
                }, i.prototype.fitSlicesInOrigin = function (t, e, i) {
                    for (var n = Math.max(1e-6, t.currentFraction), s = 0, o = 0; o < e.length; o++) {
                        var r = e[o];
                        s += r.fraction
                    }
                    i && (s += i.fraction);
                    for (var a = n / s, o = 0; o < e.length; o++) {
                        var r = e[o];
                        r.currentFraction = r.fraction * a, r.currentFillColor = t.currentFillColor, r.currentLineColor = t.currentLineColor
                    }
                    i && (i.currentFraction = i.fraction * a, i.currentFillColor = t.currentFillColor, i.currentLineColor = t.currentLineColor)
                }, i.prototype.rectifyScrollOffsets = function (t, e) {
                    if (null == e)return void(t.scrollOffset = 0);
                    var i, n = t.offset;
                    if (t.scrollOffset < 0) {
                        for (0 === n && (t.scrollOffset -= this.scene.settings.interaction.others.navigationFraction); t.scrollOffset < 0 && n - e.offset < e.values.length && !(e.values.length - 1 < n - e.offset);)i = e.values[n - e.offset], t.scrollOffset += i.fraction / t.visibleFraction, n++;
                        var s = this.scene.settings.interaction.others.maxSlicesVisible + 1;
                        n + s > e.values.length && (t.scrollOffset = 0, n = Math.max(e.values.length - s, 0))
                    } else if (t.scrollOffset > 0) {
                        var o = 0;
                        for (1 === n && (o = this.scene.settings.interaction.others.navigationFraction); n > 0 && t.scrollOffset + o > e.values[n - e.offset - 1].fraction / t.visibleFraction;)i = e.values[n - e.offset - 1], t.scrollOffset -= i.fraction / t.visibleFraction, n--;
                        0 === n && (t.scrollOffset = 0)
                    }
                    t.offset = n
                }, i.prototype.getForwardCount = function (t, e, i) {
                    if (!e || e.offset > i || e.offset + e.values.length <= i)return !e || !e.done || e.offset > i ? (this.scene.mainData.requestPieData(t, i), {
                            numberOfSlices: 0,
                            isReady: !1
                        }) : {numberOfSlices: 0, isReady: !0};
                    var n = e.offset, s = n + e.values.length, o = this.scene.settings.interaction.others;
                    if (!o.enabled)return e.done || this.scene.mainData.requestMorePieData(t), {
                        numberOfSlices: Math.max(s - i, 0),
                        isReady: e.done
                    };
                    for (var r = e.afterFraction, a = i; s - 1 >= a; a++)r += e.values[a - n].fraction;
                    for (var h = o.minSliceFraction, l = o.maxOthersFraction, u = o.maxSlicesVisible, c = 0, p = 0, d = e.done; s > c + i;) {
                        c++;
                        var f = e.values[i + c - n - 1].fraction;
                        p += f, r -= f;
                        var m = r / (r + p), g = Math.min(m, l), y = f / p * (1 - g);
                        if (c > u || h > y) {
                            e.done && c + i !== s && c--, d = !0;
                            break
                        }
                    }
                    return d || this.scene.mainData.requestMorePieData(t), {
                        numberOfSlices: c,
                        isReady: d
                    }
                }, i.prototype.getBackOffset = function (t, e, i) {
                    if (!e || e.offset >= i || !e.done && e.offset + e.values.length < i)return this.scene.mainData.requestPieData(t, Math.max(0, i - this.scene.mainData.dataSettings.itemsToLoad), this.scene.mainData.dataSettings.itemsToLoad), {
                        newOffset: 0,
                        isReady: !1
                    };
                    if (e.done && i > e.offset + e.values.length && (i = e.offset + e.values.length), 0 === i)return {
                        newOffset: 0,
                        isReady: !0
                    };
                    for (var n = this.scene.settings.interaction.others, s = e.offset, o = s + e.values.length, r = e.afterFraction, a = i; o - 1 >= a; a++)r += e.values[a - s].fraction;
                    for (var h = n.minSliceFraction, l = n.maxOthersFraction, u = n.maxSlicesVisible, c = i, p = e.values[i - s - 1].fraction, d = 0, f = 0 === e.offset; c > e.offset;) {
                        c--;
                        var m = i - c, g = e.values[c - s].fraction;
                        d += g;
                        var y = Math.min(r / (r + d), l), v = p / d * (1 - y);
                        if (0 === c || m > u || h > v) {
                            0 !== c && c++, f = !0;
                            break
                        }
                    }
                    return f || this.scene.mainData.requestLessPieData(t), {
                        newOffset: c,
                        isReady: f
                    }
                }, i.prototype.buildSlices = function (t, i, n) {
                    var s = t.data;
                    if (!s)throw new Error("Internal error");
                    for (var o = 0 === t.scrollOffset, r = 0, a = [], h = i; i + n - 1 >= h; h++) {
                        var l = new e.Slice(t, h);
                        l.data = s.values[h - s.offset], l.id = l.data.__id, r += l.data.fraction, a.push(l)
                    }
                    for (var u = this.scene.settings.interaction.others, c = s.afterFraction, p = s.afterSum, h = i + n; h <= s.offset + s.values.length - 1; h++)p += s.values[h - s.offset].value, c += s.values[h - s.offset].fraction;
                    var d;
                    c > 0 ? (d = new e.Slice(t, 1 / 0), d.data = {
                            value: p,
                            fraction: c,
                            name: this.scene.settings.localization.othersLabel
                        }) : d = null;
                    var f = null, m = 0;
                    if (i > 0) {
                        for (var g = s.beforeSum, h = s.offset; h <= Math.min(i, s.offset + s.values.length) - 1; h++)g += Math.abs(s.values[h - s.offset].value);
                        f = new e.Slice(t, -1), m = u.navigationFraction, m += t.scrollOffset, f.data = {
                            value: g,
                            name: this.scene.settings.localization.previousLabel
                        }, f.fraction = m, o || (f.currentFraction = m)
                    }
                    var y = (1 - m) / (r + c);
                    t.visibleFraction = (r + c) * (1 + m / (1 - m)), c *= y, (i > 0 || c > u.maxOthersFraction) && (c = Math.min(c, u.navigationFraction)), d && (d.fraction = c, o || (d.currentFraction = c)), y = (1 - m - c) / r, r = 1 - m - c;
                    for (var v = 0; v < a.length; v++) {
                        var S = a[v];
                        S.fraction = S.data.fraction * y, o || (S.currentFraction = S.fraction)
                    }
                    var C = this.scene.settings.slice.minFraction;
                    if (C > 0)for (var b = 0; ;) {
                        for (var x = 0, _ = 0, v = 0; v < a.length; v++) {
                            var S = a[v];
                            S.fraction <= C && (x += 1, _ += S.fraction)
                        }
                        if (x === a.length) {
                            for (var w = r / a.length, v = 0; v < a.length; v++) {
                                var S = a[v];
                                S.fraction = w
                            }
                            break
                        }
                        y = (r - x * C) / (r - _);
                        for (var v = 0; v < a.length; v++) {
                            var S = a[v];
                            S.fraction = S.fraction <= C ? C : S.fraction * y
                        }
                        if (x === b)break;
                        b = x
                    }
                    return {slices: a, othersSlice: d, previousSlice: f}
                }, i.prototype.applyNewSlices = function (t, e, i, n, s) {
                    void 0 === s && (s = !0);
                    for (var o = t.slices, r = 0 === o.length, a = [], h = [], l = 0, u = 0; l < o.length || u < e.length;) {
                        var c = o[l], p = e[u];
                        c && p && c.id === p.id ? (c.removed = !1, c.fraction = p.fraction, c.data = p.data, p.currentFraction && s && (c.currentFraction = p.currentFraction, c._animatorF = null), s || this.jumpSliceToAnimationEnd(c), a.push(c), h.push(c), l++, u++) : !p || c && c.index < p.index ? (c.removed = !0, c.fraction = 0, s && h.push(c), l++) : (p.currentFraction || r || (p.currentFraction = 0), s || this.jumpSliceToAnimationEnd(p), a.push(p), h.push(p), u++)
                    }
                    t.total = t.data ? t.data.total : 0, t.count = e.length, t.slices = a, t.allSlices = h, i ? (t.othersSlice ? (t.othersSlice.removed = i.removed, t.othersSlice.data = i.data, t.othersSlice.fraction = i.fraction, t.othersSlice.value = i.value, null !== i.currentFraction && s && (t.othersSlice.currentFraction = i.currentFraction, t.othersSlice._animatorF = null)) : (r || (i.currentFraction = 0), t.othersSlice = i), t.allSlices.push(t.othersSlice)) : t.othersSlice && (t.allSlices.push(t.othersSlice), t.othersSlice.removed = !0, t.othersSlice.fraction = 0), !s && t.othersSlice && this.jumpSliceToAnimationEnd(t.othersSlice), n ? (t.previousSlice ? (t.previousSlice.removed = n.removed, t.previousSlice.data = n.data, t.previousSlice.fraction = n.fraction, t.previousSlice.value = n.value, null !== n.currentFraction && s && (t.previousSlice.currentFraction = n.currentFraction, t.previousSlice._animatorF = null)) : (r || (n.currentFraction = 0), t.previousSlice = n), t.allSlices.unshift(t.previousSlice)) : t.previousSlice && (t.previousSlice.removed = !0, t.previousSlice.fraction = 0, t.allSlices.unshift(t.previousSlice));
                    for (var d = 0; d < t.allSlices.length; d++) {
                        var f = t.allSlices[d];
                        f.value = f.data.value, s || this.jumpSliceToAnimationEnd(f)
                    }
                    this.scene.updateOnPieChanged(t)
                }, i.prototype.jumpSliceToAnimationEnd = function (e) {
                    e._animatorF ? e._animatorF.jump(e.fraction) : e._animatorF = new t.Base.Animator(e.fraction, e.fraction, this.scene.settings.interaction.animation.scrollDuration, "<>", 0), e.currentFraction = e.fraction
                }, i.prototype.getPieData = function (t) {
                    var e = this.scene.mainData.getPieData(t.id);
                    if (!e)return null;
                    var i = e.total;
                    if (i > 0)for (var n = 0; n < e.values.length; n++) {
                        var s = e.values[n];
                        s.fraction = s.value / i
                    } else {
                        i = e.values.length;
                        for (var n = 0; n < e.values.length; n++) {
                            var s = e.values[n];
                            s.fraction = 1 / i
                        }
                    }
                    return e.afterFraction = e.afterSum > 0 ? e.afterSum / i : 0, e.beforeFraction = e.beforeSum > 0 ? e.beforeSum / i : 0, e
                }, i
            }();
            e.PieBuilder = i
        }(e = t.PieChart || (t.PieChart = {}))
    }(e = t.Internal || (t.Internal = {}))
}(ZoomCharts || (ZoomCharts = {}));
var ZoomCharts;
!function (t) {
    var e;
    !function (t) {
        var e;
        !function (e) {
            var i = function (i) {
                function n(t) {
                    i.call(this, t), this.animationOrder = 500, this.paintOrder = 30, this.updateOrder = 700, this.scene = this.chart.scene, this.renderer = new e.PieRenderer(t), this.animator = new e.Animations(t), this.layout = new e.PieLayout(t, this), this.builder = new e.PieBuilder(t)
                }

                return __extends(n, i), n.prototype.updatePie = function (t, e) {
                    return void 0 === e && (e = !0), this.builder.updatePie(t, e)
                }, n.prototype.scrollForward = function (t, e) {
                    return this.builder.scrollForward(t, e)
                }, n.prototype.scrollBackward = function (t, e) {
                    return this.builder.scrollBackward(t, e)
                }, n.prototype.onSceneChange = function (t) {
                    this.renderer.onSceneChange(t)
                }, n.prototype.doAnimations = function (t) {
                    var e = !1;
                    if (t.changes.settings || t.changes.pie || t.changes.bounds) {
                        var i = this.scene.peek();
                        i && (e = this.layout.placeStack(i, t.context))
                    }
                    for (var n = this.animator.doAnimations(t), s = 0; s < n.length; s++) {
                        var i = n[s];
                        this.layout.placeLabels(i, t.context)
                    }
                    (e || n) && (t.changes.position = !0)
                }, n.prototype.paintScene = function (t) {
                    this.renderer.paintScene(t)
                }, n.prototype.getMovement = function (e, i) {
                    var n = i.x - i.dx - e.x, s = i.y - i.dy - e.y, o = i.x - e.x, r = i.y - e.y, a = t.Base.Geometry.normalizeAngle(Math.atan2(s, n)), h = t.Base.Geometry.normalizeAngle(Math.atan2(r, o)), l = t.Base.Geometry.subtractAngle(h, a) / (e.currentEndAngle - e.currentStartAngle), u = Math.sqrt(n * n + s * s), c = Math.sqrt(o * o + r * r), p = c - u;
                    return {dfraction: l, doffset: p}
                }, n.prototype.findPieAt = function (t, e, i) {
                    for (var n = this.scene.currentInnerRadius, s = this.scene.currentRadius - n, o = this.scene.pies.length - 1; o >= 0; o--) {
                        var r = this.scene.pies[o], a = r.x, h = r.y, l = r.currentInnerRadius * s + n, u = r.currentRadius * s + n, c = Math.max(0, l - i);
                        c = u + i;
                        var p = c * c, d = t - a, f = e - h, m = d * d + f * f;
                        if ((r.background || 1 === this.scene.pies.length) && p >= m)return r
                    }
                    return null
                }, n.prototype.findSliceAt = function (t, e, i, n) {
                    for (var s = this.scene.currentInnerRadius, o = this.scene.currentRadius - s, r = this.scene.pies.length - 1; r >= 0; r--) {
                        var a = this.scene.pies[r];
                        if (!a.background) {
                            var h = a.x, l = a.y, u = n ? 0 : a.currentInnerRadius * o + s, c = a.currentRadius * o + s, p = Math.max(0, u - i);
                            p = c + i;
                            var d = t - h, f = e - l, m = d * d + f * f, g = Math.sqrt(m);
                            d /= g, f /= g;
                            for (var y = a.currentStartAngle, v = a.currentEndAngle - y, S = Math.cos(y), C = Math.sin(y), b = 0; b < a.allSlices.length; b++) {
                                var x = a.allSlices[b], _ = S, w = C;
                                if (y += v * x.currentFraction, S = Math.cos(y), C = Math.sin(y), g >= u + x.currentCutoutDistance && g <= c + x.currentCutoutDistance) {
                                    var L = w * d - _ * f, T = C * d - S * f;
                                    if (0 > L && T > 0)return x;
                                    if (Math.abs(v * x.currentFraction) > Math.PI && (0 > L && 0 > T || L > 0 && T > 0))return x
                                }
                            }
                        }
                    }
                    return this.findLabelAt(t, e, i).slice
                }, n.prototype.findLabelAt = function (t, e) {
                    for (var i = this.scene.pies.length - 1; i >= 0; i--)for (var n = this.scene.pies[i], s = t - n.x, o = e - n.y, r = 0; r < n.allSlices.length; r++) {
                        var a = n.allSlices[r];
                        if (a.currentLabel) {
                            var h = a.currentLabel;
                            if (h.visible && h.x - h.hwidth <= s && h.x + h.hwidth >= s && h.y - h.hheight <= o && h.y + h.hheight >= o)return {
                                slice: a,
                                label: h
                            }
                        }
                        if (a.currentInsideLabel) {
                            var h = a.currentInsideLabel;
                            if (h.visible && h.x - h.hwidth <= s && h.x + h.hwidth >= s && h.y - h.hheight <= o && h.y + h.hheight >= o)return {
                                slice: a,
                                label: h
                            }
                        }
                    }
                    return {slice: null, label: null}
                }, n
            }(e.View);
            e.PieView = i
        }(e = t.PieChart || (t.PieChart = {}))
    }(e = t.Internal || (t.Internal = {}))
}(ZoomCharts || (ZoomCharts = {}));
var ZoomCharts;
!function (t) {
    var e;
    !function (t) {
        var e;
        !function (e) {
            var i = function (i) {
                function n(t, n) {
                    i.call(this, new e.Settings(t), new e.Scene, n), this.scene.loading = !1, this.selection = this.events.addElement(new e.Selection(this)), this.scene.view = new e.PieView(this), this.popup = this.events.addElement(new e.InfoPopup(this)), this.legend = this.events.addElement(new e.Legend(this)), this.events.addElement(new e.Styles(this)), this.navigator = this.events.addElement(new e.Navigator(this)), this.events.addElement(this.scene.view), this.finalInitialize(), this.navigator.setPie(this.settings.navigation.initialDrilldown, this.settings.navigation.initialOffset, "init")
                }

                return __extends(n, i), n.prototype.createDataObj = function (t) {
                    return new e.Data(this, t)
                }, n.prototype.createDomLayer = function () {
                    return new e.DomLayer(this)
                }, n.prototype.onSettingsChanged = function (t) {
                    t.navigation && this.navigator.setPie(this.settings.navigation.initialDrilldown, this.settings.navigation.initialOffset), (t.labels || t.icons || t.pie || t.slice || t.interaction) && this.events.notifySceneChanges({pie: !0})
                }, n.prototype.save = function () {
                    var t = this.saveSelection();
                    return JSON.stringify({
                        pie: this.navigator.getPie(),
                        offset: this.navigator.getPieOffset(),
                        selection: t
                    })
                }, n.prototype.restore = function (t, e) {
                    if (t) {
                        var i = JSON.parse(t);
                        this.setPie(i.pie, i.offset, e), this.setSelection(i.selection)
                    }
                }, n.prototype.updateFilters = function () {
                    this.updateFilter(!0)
                }, n.prototype.updateFilter = function (t) {
                    void 0 === t && (t = !1), this.log("Update filter");
                    var e = {};
                    for (var i in this.settings._computedDataMap)e[i] = !0;
                    this.events.notifySceneChanges({data: e, dataDeep: t})
                }, n.prototype.setSelection = function (i, n) {
                    void 0 === n && (n = "api"), this.log("Set selection");
                    for (var s = [], o = [], r = 0; r < i.length; r++) {
                        var a = i[r];
                        a instanceof e.Slice ? s.push(a) : t.Base.Helpers.isString(a) ? o.push(a) : this.error("SetSelection: Selection contents must be Piechart_Slice object or string, got " + a)
                    }
                    this.selection.setSelection(s, o, !1, n)
                }, n.prototype.saveSelection = function () {
                    for (var t = this.scene.selectionIds.splice(0), e = 0; e < this.scene.selection.length; e++) {
                        var i = this.scene.selection[e];
                        t.push(i.id)
                    }
                    return t
                }, n.prototype.setPie = function (t, e, i, n) {
                    void 0 === i && (i = !0), void 0 === n && (n = "api"), this.log("Set pie"), this.navigator.setPie(t, e, n)
                }, n.prototype.setPieOffset = function (t, e, i) {
                    void 0 === e && (e = !0), void 0 === i && (i = "api"), this.log("Set pie offset"), this.navigator.setPie(this.getPie(), t, i)
                }, n.prototype.getPie = function () {
                    return this.navigator.getPie()
                }, n.prototype.getActiveSlices = function () {
                    for (var t = [], e = 0; e < this.scene.stack.length; e++) {
                        var i = this.scene.stack[e];
                        i.parentSlice && t.push(i.parentSlice)
                    }
                    return t
                }, n.prototype.getActivePies = function () {
                    return this.scene.stack
                }, n.prototype.expandSlice = function (t, e) {
                    return void 0 === e && (e = "api"), this.navigator.expandSlice(t, e)
                }, n.prototype.getSliceDimensions = function (e, i) {
                    if (!t.Base.Helpers.isArray(e))return this.error("getSliceDimensions: slice Id must be an array"), null;
                    if (e.length < 2)return null;
                    if (!i && this.scene.stack.length + 1 < e.length)return null;
                    for (var n, s = 0, o = 0; o < this.scene.stack.length; o++) {
                        if (n = this.scene.stack[o], n.id !== e[s])return null;
                        if (s += 1, s === e.length - 1)break
                    }
                    for (var r = e[s], a = 0; a < n.slices.length; a++) {
                        var h = n.slices[a];
                        if (h.id === r) {
                            var l = h._renderParams;
                            return l ? {
                                    centerX: n.x,
                                    centerY: n.y,
                                    r0: l[0],
                                    r1: l[1],
                                    a0: l[2],
                                    a1: l[3]
                                } : null
                        }
                    }
                    return null
                }, n.prototype.saveNavigation = function () {
                    var t = this.scene.peek();
                    return !t || t.loading ? null : {
                            pie: this.navigator.getPie(),
                            offset: this.navigator.getPieOffset()
                        }
                }, n.prototype.restoreNavigation = function (t, e, i) {
                    this.navigator.setPie(t.pie, t.offset, i)
                }, n.prototype.doChartUpdateNotify = function (t) {
                    i.prototype.doChartUpdateNotify.call(this, t), this.dispatchEventParams("pieChange", this.extendEventParams({origin: t}), null), this.dispatchEventParams("pieReadyStateChanged", this.extendEventParams({origin: t}), null)
                }, n.prototype.extendEventParams = function (t) {
                    var e = this.scene.peek();
                    return t.pie = e, t.offset = e.offset, t.count = e.count, t.slice = this.scene.hoverSlice, t.label = this.scene.hoverLabel, t.clickSlice = t.slice, t.selection = this.scene.selection.slice(), t
                }, n.prototype.defaultClick = function (e) {
                    var i = e.slice, n = e.clickPie, s = "drilldown" === this.settings.interaction.mode;
                    (s || i && (i === i.pie.othersSlice || i === i.pie.previousSlice)) && (i ? i.url ? (t.Base.Helpers.openUrl(i.url), e.preventDefault()) : this.navigator.expandSlice(i, "user") && e.preventDefault() : n && (this.setSelection([], "user"), this.navigator.goCenter("user"), e.preventDefault()))
                }, n.prototype.defaultDoubleClick = function () {
                }, n
            }(t.Base.Impl);
            e.Impl = i
        }(e = t.PieChart || (t.PieChart = {}))
    }(e = t.Internal || (t.Internal = {}))
}(ZoomCharts || (ZoomCharts = {}));
var ZoomCharts;
!function (t) {
    var e = function (e) {
        function i(n) {
            var s = this;
            e.call(this), this.typeName = "PieChart", this._impl = i.chartFactoryMethod ? i.chartFactoryMethod(function (e) {
                    return new t.Internal.PieChart.Impl(e, s)
                }, n) : new t.Internal.PieChart.Impl(n, this)
        }

        return __extends(i, e), i.prototype.createEmptySettings = function () {
            return t.Internal.Base.SettingsHelper.createEmptySettings(t.Internal.Base.SettingsMapping.PieChartSettings)
        }, i.prototype.updateSettings = function (i) {
            return t.Internal.Base.SettingsHelper.cleanupEmptySettings(i), e.prototype.updateSettings.call(this, i), this
        }, i.prototype.updateFilter = function () {
            return this._impl.updateFilter(), this
        }, i.prototype.selection = function (e) {
            if (e)if (t.Internal.Base.Helpers.isArray(e)) {
                for (var i = e.slice(), n = 0; n < i.length; n++) {
                    var s = i[n];
                    s instanceof t.Internal.PieChart.Slice ? i[n] = s.id : t.Internal.Base.Helpers.isString(s) || this._impl.error("PieChart.selection() - the argument must be an array of Slice objects or strings.")
                }
                this._impl.setSelection(i)
            } else this._impl.error("PieChart.selection() - the argument must be an array of Slice objects or strings.");
            return this._impl.scene.selection.slice()
        }, i.prototype.getPie = function () {
            return this._impl.getPie()
        }, i.prototype.getPieOffset = function () {
            return this._impl.navigator.getPieOffset()
        }, i.prototype.setPie = function (t, e) {
            return void 0 === e && (e = 0), null == e && (e = 0), this._impl.setPie(t, e), this
        }, i.prototype.setPieOffset = function (t) {
            return this._impl.setPieOffset(t), this
        }, i.prototype.getActiveSlices = function () {
            return this._impl.getActiveSlices()
        }, i.prototype.getActivePies = function () {
            return this._impl.getActivePies()
        }, i.prototype.getActivePie = function () {
            var t = this._impl.getActivePies();
            return t[t.length - 1]
        }, i.prototype.expandSlice = function (t) {
            return this._impl.expandSlice(t, "api")
        }, i.prototype.getSliceDimensions = function (t, e) {
            return void 0 === e && (e = !1), null == e && (e = !1), this._impl.getSliceDimensions(t, e)
        }, i.themes = {
            dark: t.Internal.PieChart.Settings.DarkTheme,
            flat: t.Internal.PieChart.Settings.FlatTheme,
            bevel: t.Internal.PieChart.Settings.BevelTheme,
            gradient: t.Internal.PieChart.Settings.GradientTheme,
            raised: t.Internal.PieChart.Settings.CanTheme
        }, i.chartFactoryMethod = null, i
    }(t.Internal.Base.Api);
    t.PieChart = e, t.Internal.Base.Helpers.exportSymbol("PieChart", t.PieChart)
}(ZoomCharts || (ZoomCharts = {}));
var ZoomCharts;
!function (t) {
    var e;
    !function (t) {
        var e;
        !function (e) {
            var i = function () {
                function t() {
                    this.enabled = !0, this.size = 40, this.defaultUnitWidth = 50, this.maxUnitWidth = 400, this.labels = {
                        enabled: !0,
                        angle: 0,
                        lineSpacing: .2,
                        interLabelSpacing: .6,
                        textStyle: {fillColor: "#000000", font: "12px Arial"},
                        margin: 4,
                        padding: 0
                    }
                }

                return t
            }();
            e.SettingsFacetAxis = i;
            var n = function () {
                function e(e, i) {
                    this.facet = i, this.chart = e, this.scene = this.chart.scene, this.options = this.scene.settings.facetAxis, this.currentItemWidth = 1, this.currentItemHeight = 1, this.panel = new t.Base.ChartPanel, this.panel.side = "bottom", this.panel.packingOrder = 100
                }

                return e.prototype.getPanel = function () {
                    return this.options.enabled && this.options.size > 0 ? (this.panel.desiredHeight = this.options.size, this.panel.visible = !0, this.scene.bottomAxisSize = this.options.size) : (this.panel.desiredHeight = 0, this.panel.visible = !1, this.scene.bottomAxisSize = 0), this.panel
                }, e.prototype.paint = function (e, i, n, s) {
                    if (s.length > 1 && this.panel.visible) {
                        var o = e.context, r = e.labelRenderer, a = i + n, h = s[1] - s[0], l = this.panel.top, u = this.panel.bottom - this.panel.top, c = s[0];
                        if (this.options.labels.enabled) {
                            var p = !1;
                            (Math.abs(1 - this.currentItemWidth / h) > .01 || Math.abs(1 - this.currentItemHeight / u) > .01) && (this.currentItemWidth = h, this.currentItemHeight = u, p = !0), e.changes && e.changes.settings && (p = !0), this.layout = new t.Base.LabelLayoutBase(o, this.options.labels);
                            for (var d = this.facet.items, f = this.layout.angle, m = Math.abs(Math.sin(f)), g = 0; g < d.length; g++) {
                                var y = s[g];
                                if (!(c > y)) {
                                    var v = this.facet.items[g], S = v.currentLabel, C = v.label || v.data.name;
                                    if (v.currentLabel = null, C) {
                                        (null === v.currentLabel || p || v.currentLabel.text !== C) && (S = this.buildLabel(o, C, h, u), v.currentLabel = S);
                                        var b = Math.max.apply(Math, S.rows.rowWidths);
                                        if (c = y + S.x + b / 2, 0 !== f) {
                                            for (var x = 1, _ = m * (s[g + 1] - s[g]); _ < S.lineHeight + S.margin + S.padding;)x++, _ = m * (s[g + x] - s[g]);
                                            c = s[g + x], void 0 === s[g + x] && (c = 1 / 0)
                                        }
                                        var w = 0 !== S.angle && 0 === g, L = w ? this.chart.scene.chartWidth : Math.max(h, b), T = Math.min(y + L, a), M = Math.max(y + .1, i);
                                        0 === S.angle || w ? (t.Base.Graphics.pushClip(o, M, l, T - M, u), r.paintWithStyle(o, y + S.x, l + S.y, 1, S, this.options.labels), t.Base.Graphics.popClip(o)) : r.paintWithStyle(o, y + S.x, l + S.y, 1, S, this.options.labels)
                                    }
                                }
                            }
                        }
                    }
                }, e.prototype.buildLabel = function (e, i, n, s) {
                    var o = new t.Base.Label;
                    o.text = i;
                    var r = o.angle = this.layout.angle, a = this.options.labels.align;
                    o.align = a ? a : r > 0 ? "left" : 0 > r ? "right" : "center";
                    var h = function (t, e) {
                        e || (e = n);
                        var i, o, a, h = 0, l = 1;
                        0 !== r ? (h = Math.sin(r), l = Math.cos(r), i = n / 2, o = s - 2 * t * l, a = Math.max(0, o / Math.abs(h))) : (a = 0, i = e / 2, s >= 2 * t && (a = n));
                        var u, c;
                        return r > 0 ? (u = i + a / 2 * l, c = t * l + e / 2 * h) : 0 > r ? (u = i - a / 2 * l, c = t * l - e / 2 * h) : (u = i, c = t), {
                            x: u,
                            y: c,
                            dx: l,
                            dy: h,
                            width: a
                        }
                    };
                    return this.layout.shrinkLabelWithEllipsis(e, o, this.options.size, h), o
                }, e
            }();
            e.FacetAxis = n
        }(e = t.FacetChart || (t.FacetChart = {}))
    }(e = t.Internal || (t.Internal = {}))
}(ZoomCharts || (ZoomCharts = {}));
var ZoomCharts;
!function (t) {
    var e;
    !function (t) {
        var e;
        !function (e) {
            var i = function () {
                function t() {
                    this.enabled = !0, this.tolerance = 4
                }

                return t
            }();
            e.SettingsInteractionSelection = i;
            var n = function (e) {
                function i(t) {
                    e.call(this), this.animationOrder = 2e3, this.paintOrder = 15, this.updateOrder = 1e3, this.scene = null, this.events = null, this.currentItem = null, this.currentFacet = null, this.draggedLabelItem = null, this.draggedLabel = null, this.hoverEvent = null, this.chart = t, this.scene = t.scene, this.events = t.events, this.dragPointers = {}
                }

                return __extends(i, e), i.prototype.doAnimations = function () {
                    this.hoverEvent && this.onPointerMove(this.hoverEvent)
                }, i.prototype.previewPointerDrag = function (t) {
                    this.hoverEvent = t
                }, i.prototype.onPointerMove = function (t) {
                    this.hoverEvent = t;
                    var e = this.scene.findItemAt(t.x, t.y);
                    e && (t.cursor = "pointer");
                    var i = this.chart.renderer.hitTest(t.x, t.y);
                    if (!i && this.chart.legend) {
                        var n = this.chart.legend.findItemAt(t.x, t.y);
                        if (n)for (var s = this.scene.settings._computedSeries, o = 0; o < s.length; o++)n === s[o] && (i = {seriesIndex: o}, t.cursor = "pointer")
                    }
                    return (!i != !this.scene.hoverSeriesItem || i && (i.seriesIndex !== this.scene.hoverSeriesItem.seriesIndex || i.x0 !== this.scene.hoverSeriesItem.x0)) && (this.scene.hoverSeriesItem = i, t.changes.hover = !0), this.switchcurrentItem(e, t)
                }, i.prototype.onPointerOut = function (t) {
                    return this.hoverEvent = this.scene.hoverSeriesItem = null, this.events.notifySceneChanges({selection: !0}), this.switchcurrentItem(null, t)
                }, i.prototype.onPointerDown = function (t) {
                    this.onPointerMove(t);
                    var e = this.scene.findLabelAt(t.x, t.y);
                    return this.draggedLabelItem = e.slice, this.draggedLabel = e.label, this.draggedLabel ? t.consumed = !0 : void 0
                }, i.prototype.onPointerUp = function (t) {
                    return this.draggedLabel ? (this.draggedLabel = null, t.consumed = !0) : void 0
                }, i.prototype.onPointerCancel = function () {
                    return this.draggedLabel ? this.draggedLabel = null : void 0
                }, i.prototype.onPointerDrag = function (t) {
                    if (this.draggedLabel) {
                        var e = this.draggedLabel;
                        e.userPlaced = !0, e.x += t.dx, e.y += t.dy, t.consumed = !0, t.changes.label = !0
                    }
                }, i.prototype.onClick = function (t) {
                    var e = this.scene.findItemAt(t.x, t.y), i = t;
                    i.clickItem = e, i.clickFacet = e ? e.facet : null, t.consumed = !0, e && (t.cursor = "pointer");
                    var n = this.chart.notifyClick(i);
                    return n.defaultPrevented ? void 0 : this.updateSelection(t, e, !1)
                }, i.prototype.onRightClick = function (t) {
                    var e = this.scene.findItemAt(t.x, t.y), i = t;
                    i.clickItem = e, i.clickFacet = e ? e.facet : null;
                    var n = this.chart.notifyRightClick(t);
                    e && (t.cursor = "pointer"), n.defaultPrevented && (t.consumed = !0)
                }, i.prototype.onDoubleClick = function (t) {
                    var e = this.scene.findItemAt(t.x, t.y), i = t;
                    i.clickItem = e, e && (t.cursor = "pointer"), this.chart.notifyDoubleClick(t), t.consumed = !0
                }, i.prototype.onTripleClick = function (t) {
                    var e = this.scene.findItemAt(t.x, t.y), i = t;
                    i.clickItem = e, e && (t.cursor = "pointer"), this.chart.notifyTripleClick(t), t.consumed = !0
                }, i.prototype.updateSelection = function (t, e, i) {
                    if (this.scene.settings.interaction.selection.enabled) {
                        if (!(t.shiftKey || e && !e.selected))return this.setSelection([]);
                        if (e && t.shiftKey || i && e.selected) {
                            if (!e.selected)return this.scene.selection.push(e), e.selected = !0, this.setSelection(this.scene.selection, this.scene.selectionIds, !0)
                        } else if (e)return this.setSelection([e])
                    }
                }, i.prototype.switchcurrentItem = function (t, e) {
                    return t !== this.currentItem ? (e.changes.current = !0, this.scene.hoverItem && (this.scene.hoverItem.active = !1), this.scene.hoverItem = t, this.currentItem = t, this.currentFacet = null, this.currentItem && (this.scene.hoverItem.active = !0, e.hoverItem = this.currentItem), this.events.notifySceneChanges({items: !0}), this.chart.notifyHoverChanged(e)) : void 0
                }, i.prototype.onSceneChange = function (t) {
                    return t.changes.items && this.updateSelectionIds() ? (this.events.notifySceneChanges({selection: !0}), this.chart.notifySelectionChanged(null)) : void 0
                }, i.prototype.updateSelectionIds = function () {
                    for (var e = [], i = 0; i < this.scene.selectionIds.length; i++)for (var n = this.scene.selectionIds[i], s = 0; s < this.scene.stack.length; s++)for (var o = this.scene.stack[s], r = 0; r < o.items.length; r++) {
                        var a = o.items[r];
                        if (a.id === n) {
                            e.push(a);
                            break
                        }
                    }
                    if (e.length > 0)for (var h = 0; h < e.length; h++) {
                        var l = e[h];
                        l.selected || (l.selected = !0, this.scene.selection.push(l)), t.Base.Helpers.removeFromArray(this.scene.selectionIds, l.id)
                    }
                    return e.length > 0
                }, i.prototype.setSelection = function (t, e, i, n) {
                    void 0 === e && (e = []), void 0 === i && (i = !1), void 0 === n && (n = "user"), this.scene.selectionIds = e;
                    var s = !1;
                    if (i) s = !0; else {
                        for (var o = 0; o < this.scene.selection.length; o++) {
                            var r = this.scene.selection[o];
                            t.indexOf(r) < 0 && (r.selected = !1, s = !0)
                        }
                        for (var o = 0; o < t.length; o++) {
                            var r = t[o];
                            r.selected || (r.selected = !0, s = !0)
                        }
                        this.scene.selection = t
                    }
                    var a = this.updateSelectionIds();
                    s = s || a, s && (this.events.notifySceneChanges({selection: !0}), this.chart.notifySelectionChanged(n))
                }, i
            }(t.Base.ChartElement);
            e.Selection = n
        }(e = t.FacetChart || (t.FacetChart = {}))
    }(e = t.Internal || (t.Internal = {}))
}(ZoomCharts || (ZoomCharts = {}));
var ZoomCharts;
!function (t) {
    var e;
    !function (t) {
        var e;
        !function (e) {
            var i = function (t) {
                function e(e) {
                    t.call(this, e), this.animationOrder = 500, this.paintOrder = 25, this.updateOrder = 800
                }

                return __extends(e, t), e.prototype.doAnimations = function (t) {
                    (t.changes.position || t.changes.navigation) && this.updatePopup(t)
                }, e.prototype.getPopupAreaMouseMoved = function (t, e) {
                    if (!this.scene.xyInChartOrBottom(t, e) || !this.scene.activeFacet)return null;
                    var i = this.scene.activeFacet, n = this.scene.xToPosition(t), s = Math.floor(n), o = Math.ceil(n);
                    return s === o && (o = s + 1), s < i.offset || s >= i.items.length + i.offset ? null : {
                            t0: s,
                            t1: o
                        }
                }, e.prototype.buildHeader = function (t) {
                    var e = this.scene.activeFacet, i = e.items[t - e.offset], n = i.label || "";
                    return "<em></em><strong>" + n + "</strong>"
                }, e
            }(t.LinearChart.InfoPopup);
            e.InfoPopup = i
        }(e = t.FacetChart || (t.FacetChart = {}))
    }(e = t.Internal || (t.Internal = {}))
}(ZoomCharts || (ZoomCharts = {}));
var ZoomCharts;
!function (t) {
    var e;
    !function (t) {
        var e;
        !function (e) {
            var i = function () {
                function t() {
                    this.enabled = !0, this.enabledOnExport = !1, this.size = 28, this.style = {
                        fillColor: "rgba(255,255,255,0.5)",
                        lineColor: "rgba(0,0,0,0.5)",
                        hoverFillColor: "rgba(255,255,255,0.9)",
                        hoverLineColor: "rgba(0,0,0,0.9)"
                    }
                }

                return t
            }();
            e.SettingsScrollButtons = i;
            var n = function (e) {
                function i(i) {
                    e.call(this), this.paintOrder = 75, this.chart = i, this.scene = i.scene, this.settings = i.settings.scrollButtons, this.panels = [];
                    for (var n = 0; 2 > n; n++) {
                        var s = new t.Base.ChartPanel;
                        s.packingOrder = 115, s.side = 1 === n ? "left" : "right", s.location = "inside", s.align = "center", this.panels.push(s)
                    }
                }

                return __extends(i, e), i.prototype.onSceneChange = function () {
                    this.settings.enabled && (this.activeFacet = this.chart.scene.activeFacet, this.showLeft = Math.floor(this.activeFacet.from) > 0, this.showRight = Math.ceil(this.activeFacet.to) < this.activeFacet.totalCount)
                }, i.prototype.getPanels = function (t) {
                    for (var e = 0; 2 > e; e++) {
                        var i = this.panels[e];
                        i.visible = t ? this.settings.enabledOnExport : this.settings.enabled, i.desiredWidth = i.desiredHeight = this.settings.size
                    }
                    return this.panels
                }, i.prototype.paintScene = function (t) {
                    if (this.panels[0].visible) {
                        var e = this.settings.style, i = t.context;
                        i.fillStyle = e.fillColor, i.strokeStyle = e.lineColor;
                        for (var n = this.settings.size, s = n / 2, o = n / 4, r = this.scene.y0 + this.scene.height / 2 - n / 2, a = 0; a < this.panels.length; a++) {
                            var h = this.panels[a], l = h.left;
                            this.showRight && "right" === h.side && (this.rightActive && (i.fillStyle = e.hoverFillColor, i.strokeStyle = e.hoverLineColor), i.beginPath(), i.fillRect(l, r, n, n), i.moveTo(l + s - o / 2 + 2, r + o), i.lineTo(l + s + o - 3, r + s), i.lineTo(l + s - o / 2 + 2, r + n - o), i.stroke()), this.showLeft && "left" === h.side && (this.leftActive && (i.fillStyle = e.hoverFillColor, i.strokeStyle = e.hoverLineColor), i.beginPath(), i.fillRect(l, r, n, n), i.moveTo(l + s + o / 2 - 2, r + o), i.lineTo(l + s - o + 3, r + s), i.lineTo(l + s + o / 2 - 2, r + n - o), i.stroke()), i.fillStyle = e.fillColor, i.strokeStyle = e.lineColor
                        }
                    }
                }, i.prototype.findItemAt = function (t, e, i) {
                    if (!this.panels[0].visible)return null;
                    for (var n = i.touch ? 10 : 0, s = 0; 2 > s; s++) {
                        var o = this.panels[s];
                        if (t >= o.left - n && t <= o.right + n && e >= o.top - n && e <= o.bottom + n && ("left" === o.side && this.showLeft || "right" === o.side && this.showRight))return o.side
                    }
                    return null
                }, i.prototype.onClick = function (e) {
                    if (this.panels[0].visible) {
                        var i = t.Base.Helpers.performanceNow(), n = this.findItemAt(e.x, e.y, e);
                        if (null !== n) {
                            var s = this.activeFacet.from, o = this.activeFacet.to, r = this.activeFacet.totalCount, a = this.activeFacet.to - this.activeFacet.from;
                            "right" === n && (o + a > r ? (o = o - a + (r - o), this.chart.scrolling.goToPosition(o, r, !0, i)) : this.chart.scrolling.goToPosition(o, o + a, !0, i)), "left" === n && (0 > s - a ? this.chart.scrolling.goToPosition(0, a, !0, i) : this.chart.scrolling.goToPosition(s - a, s, !0, i)), e.consumed = !0
                        }
                    }
                }, i.prototype.onPointerMove = function (t) {
                    var e = this.findItemAt(t.x, t.y, t);
                    null !== e ? ("left" === e && (this.leftActive = !0), "right" === e && (this.rightActive = !0), t.changes.hover = !0, t.consumed = !0) : (this.leftActive = !1, this.rightActive = !1)
                }, i
            }(t.Base.ChartElement);
            e.ScrollButtons = n
        }(e = t.FacetChart || (t.FacetChart = {}))
    }(e = t.Internal || (t.Internal = {}))
}(ZoomCharts || (ZoomCharts = {}));
var ZoomCharts;
!function (t) {
    var e;
    !function (t) {
        var e;
        !function (e) {
            var i = function (i) {
                function o(s) {
                    i.call(this, t.Base.SettingsMapping.FacetChartSettings), this.data = [], this.filters = {sliceFilter: null}, this.navigation = {
                        initialDrilldown: [""],
                        initialOffset: 0
                    }, this.items = {
                        style: {label: null, expandable: !0},
                        styleFunction: null
                    }, this.chartTypes = {
                        columns: {type: "columns"},
                        line: {type: "line"},
                        candlestick: null
                    }, this.facetAxis = new e.SettingsFacetAxis, this.interaction = new n, this.toolbar = new t.Base.SettingsToolbar(!0, [new t.Base.SettingsToolbarItem("back", "left"), new t.Base.SettingsToolbarItem("zoomOut", "left"), new t.Base.SettingsToolbarItem("logScale", "right"), new t.Base.SettingsToolbarItem("export", "right")]), this.legend = new t.LinearChart.SettingsLegend, this.scrollButtons = new e.SettingsScrollButtons, this.localization.toolbar.zoomoutTitle = "Zoom-out to previous level", this.toolbar.zoomOut = !0, this.apply(s), this._initializing = !1
                }

                return __extends(o, i), o.prototype.apply = function (e) {
                    if (this.applyCompatibility(e, [{
                            from: "area.initialPieId",
                            to: "navigation.initialDrilldown"
                        }, {
                            from: "area.initialPieOffset",
                            to: "navigation.initialOffset"
                        }]), e.series)for (var n = 0; n < e.series.length; n++) {
                        var o = e.series[n];
                        o && void 0 !== o.styleFunction && t.Base.Helpers.error("Setting `series[" + n + "].styleFunction` is no longer supported. Consider using `items.styleFunction` instead. See the example: https://zoomcharts.com/developers/en/facet-chart/examples/series/stacked-colored.html")
                    }
                    return i.prototype.apply.call(this, e, s)
                }, o.DarkTheme = {
                    advanced: {themeCSSClass: "DVSL-dark"},
                    area: {style: {fillColor: "rgba(28,26,28,1)"}},
                    title: {margin: 15, style: {fillColor: "#A8A7A8"}},
                    valueAxisDefault: {
                        style: {
                            valueLabel: {fillColor: "#A8A7A8"},
                            title: {fillColor: "#A8A7A8"}
                        }
                    },
                    facetAxis: {labels: {textStyle: {fillColor: "#A8A7A8"}}},
                    legend: {
                        text: {fillColor: "#A8A7A8"},
                        advanced: {
                            disabledSeries: {
                                textColor: "rgba(168,167,168,0.5)",
                                lineColor: "rgba(117,117,117,0.3)"
                            }
                        }
                    }
                }, o
            }(t.LinearChart.Settings);
            e.Settings = i;
            var n = function (t) {
                function i() {
                    t.apply(this, arguments), this.selection = new e.SettingsInteractionSelection, this.animation = {scrollDuration: 500}
                }

                return __extends(i, t), i
            }(t.LinearChart.SettingsInteraction);
            e.SettingsInteraction = n;
            var s = function (e) {
                function i() {
                    e.apply(this, arguments), this.type = "columns", this.data = new o
                }

                return __extends(i, e), i.getMapping = function (e, i) {
                    if (e && i.type && e.type !== i.type)throw new Error("It is not possible to change the value of `type` property for an existing layer.");
                    switch (e ? e.type : i.type) {
                        case"columns":
                        case void 0:
                            return t.Base.SettingsMapping.FacetChartSettingsSeriesColumns;
                        case"line":
                            return t.Base.SettingsMapping.FacetChartSettingsSeriesLines;
                        default:
                            throw new Error("The value '" + i.type + "' is not valid for the `type` property of a series. Valid values are: columns, line.")
                    }
                }, i.createInstance = function (t, e) {
                    switch (e || t.type) {
                        case"columns":
                        case void 0:
                            return new r;
                        case"line":
                            return new a;
                        default:
                            throw new Error("The value '" + (e || t.type) + "' is not valid for the `type` property of a series. Valid values are: columns, line.")
                    }
                }, i
            }(t.LinearChart.SettingsSeries);
            e.SettingsSeries = s;
            var o = function (t) {
                function e() {
                    t.apply(this, arguments), this.field = null
                }

                return __extends(e, t), e
            }(t.LinearChart.SettingsSeriesData);
            e.SettingsSeriesData = o;
            var r = function (t) {
                function e() {
                    t.apply(this, arguments), this.style = new h, this.data = new o
                }

                return __extends(e, t), e
            }(t.LinearChart.SettingsSeriesColumns);
            e.SettingsSeriesColumns = r;
            var a = function (t) {
                function e() {
                    t.apply(this, arguments), this.data = new o
                }

                return __extends(e, t), e
            }(t.LinearChart.SettingsSeriesLines);
            e.SettingsSeriesLines = a;
            var h = function (t) {
                function e() {
                    t.apply(this, arguments), this.previewContents = !1, this.previewLineColor = "rgba(255,255,255,.5)"
                }

                return __extends(e, t), e
            }(t.LinearChart.SettingsSeriesColumnsStyle);
            e.SettingsSeriesColumnsStyle = h
        }(e = t.FacetChart || (t.FacetChart = {}))
    }(e = t.Internal || (t.Internal = {}))
}(ZoomCharts || (ZoomCharts = {}));
var ZoomCharts;
!function (t) {
    var e;
    !function (t) {
        var e;
        !function (e) {
            var i = function () {
                function t() {
                    this.id = null, this.data = null, this.items = [], this.parentItem = null, this.activeItemId = null, this.offset = 0, this.count = 0, this.totalCount = 0, this.from = 0, this.to = 0, this.left = 0, this.right = 1, this.opacity = 1, this.loading = null, this.rebuild = !0
                }

                return t.prototype.getActiveItem = function () {
                    if (!this.activeItemId)return null;
                    for (var t = 0; t < this.items.length; t++) {
                        var e = this.items[t];
                        if (e.id === this.activeItemId)return e
                    }
                    return null
                }, t
            }();
            e.Facet = i;
            var n = function () {
                function t(t, e, i, n) {
                    this.expandable = !0, this.selected = !1, this.active = !1, this.url = null, this.values = [], this.innerFacet = null, this.label = null, this.currentLabel = null, this.facet = t, this.id = e, this.index = i, this.data = n
                }

                return t
            }();
            e.Item = n;
            var s = function () {
                function t(t, e, i, n, s) {
                    this.value = 0, this.fillColor = null, this.lineColor = null, this.lineWidth = 1, this.label = null, this.previewContents = !1, this.previewData = null, this.currentLabel = null, this.data = n, this.index = i, this.id = e, this.facet = t, this.seriesId = s
                }

                return t
            }();
            e.ItemValue = s;
            var o = function (t) {
                function e() {
                    t.call(this), this.data = null, this.stack = [], this.activeFacet = null, this.hoverItem = null, this.selection = [], this.selectionIds = []
                }

                return __extends(e, t), e.prototype.xToPosition = function (t) {
                    var e = this.activeFacet, i = this.x0 + e.left * this.width, n = this.x0 + e.right * this.width, s = e.from + (t - i) / (n - i) * (e.to - e.from);
                    return s
                }, e.prototype.positionToX = function (t) {
                    var e = this.activeFacet, i = this.x0 + e.left * this.width, n = this.x0 + e.right * this.width;
                    return i + (t - e.from) * (n - i) / (e.to - e.from)
                }, e.prototype.timeToX = function (t) {
                    return this.positionToX(t)
                }, e.prototype.xToTime = function (t) {
                    return this.xToPosition(t)
                }, e.prototype.length = function () {
                    return this.stack.length
                }, e.prototype.peek = function () {
                    return 0 === this.stack.length ? null : this.stack[this.stack.length - 1]
                }, e.prototype.push = function (t, e) {
                    var i = this.peek();
                    if (i && !e)for (var n = 0; n < i.items.length; n++) {
                        var s = i.items[n];
                        if (s.data.__id === t.id) {
                            e = s;
                            break
                        }
                    }
                    if (e) {
                        t.parentItem = e, e.innerFacet = t;
                        var o = this.getItemPlacement(e);
                        t.left = o.left, t.right = o.right, i.activeItemId = e.id
                    } else i && (i.activeItemId = null);
                    this.stack.push(t), this.activeFacet = t
                }, e.prototype.pop = function () {
                    if (this.stack.length > 0) {
                        var t = this.stack.pop();
                        t.parentItem && (t.parentItem.facet.activeItemId = null)
                    }
                    return this.activeFacet = this.stack.length > 0 ? this.peek() : null, this.activeFacet
                }, e.prototype.getParent = function (t) {
                    for (var e = null, i = 0; i < this.stack.length; i++) {
                        var n = this.stack[i];
                        if (n === t)return e;
                        e = n
                    }
                    return null
                }, e.prototype.getChild = function (t) {
                    for (var e = null, i = 0; i < this.stack.length; i++) {
                        var n = this.stack[i];
                        if (e === t)return n;
                        e = n
                    }
                    return null
                }, e.prototype.updateLinks = function (t) {
                    var e = this.getParent(t), i = this.getChild(t);
                    if (e && !t.parentItem)for (var n = 0; n < e.items.length; n++) {
                        var s = e.items[n];
                        if (s.id === t.id) {
                            t.parentItem = s, e.activeItemId = s.id;
                            break
                        }
                    }
                    if (i && !i.parentItem)for (var n = 0; n < t.items.length; n++) {
                        var s = t.items[n];
                        if (s.id === i.id) {
                            i.parentItem = s, t.activeItemId = s.id;
                            break
                        }
                    }
                }, e.prototype.getItemPlacement = function (t) {
                    var e = t.facet, i = t.index, n = e.to - e.from, s = e.from, o = (i - s) / n, r = (i - s + 1) / n;
                    return {
                        left: e.left + o * (e.right - e.left),
                        right: e.left + r * (e.right - e.left)
                    }
                }, e.prototype.getFacetPlacementFromItem = function (t, e, i) {
                    var n = t.facet, s = t.index, o = s + 1, r = (s - n.from) / (n.to - n.from), a = (o - n.from) / (n.to - n.from), h = e - r * (e - i) / (r - a), l = h + (e - i) / (r - a);
                    return {left: h, right: l}
                }, e.prototype.findFacetAt = function () {
                    return null
                }, e.prototype.findItemAt = function (t, e) {
                    var i = this.activeFacet;
                    if (!i || !this.xyInChart(t, e))return null;
                    var n = Math.floor(this.xToPosition(t));
                    return n >= i.offset && n < i.offset + i.count ? i.items[n - i.offset] : null
                }, e.prototype.findLabelAt = function () {
                    return {slice: null, label: null}
                }, e
            }(t.LinearChart.Scene);
            e.Scene = o
        }(e = t.FacetChart || (t.FacetChart = {}))
    }(e = t.Internal || (t.Internal = {}))
}(ZoomCharts || (ZoomCharts = {}));
var ZoomCharts;
!function (t) {
    var e;
    !function (t) {
        var e;
        !function (e) {
            var i = function (i) {
                function n(t) {
                    i.call(this, t), this.animationOrder = 100, this.paintOrder = 10, this.updateOrder = 1100, this.animatingFacet = null, this.leftAnimator = null, this.rightAnimator = null, this.activePieReady = !1, this.opacityAnimator = null
                }

                return __extends(n, i), n.prototype.setState = function (e, i, n, s) {
                    if (0 === e.length)return void this.chart.error("setPie - array needs at least one item.");
                    for (var o = 0; this.scene.length() > e.length;)this.scene.pop(), o++;
                    for (; this.scene.length() > 0 && this.scene.peek().id !== e[this.scene.length() - 1];)this.scene.pop(), o++;
                    for (; this.scene.length() < e.length;) {
                        var r = e[this.scene.length()];
                        this.drillDown(r, null), o++
                    }
                    var a = this.scene.peek();
                    if (this.facet = a, o && this.goToPositionDragging(a.from, a.to), a.offset !== i || n && a.count !== n) {
                        var h, l = i;
                        h = n > 0 ? l + n : i + a.count, o ? (this.goToPositionDragging(l, h), this.animateFillChart()) : this.goToPosition(l, h, !0, t.Base.Helpers.performanceNow())
                    } else o && this.animateFillChart();
                    this.chart.notifyChartUpdate(s), o && this.events.notifySceneChanges({navigation: !0})
                }, n.prototype.getState = function () {
                    for (var t = [], e = 0; e < this.scene.stack.length; e++) {
                        var i = this.scene.stack[e];
                        t.push(i.id)
                    }
                    var n = this.scene.peek();
                    return {idArray: t, offset: n.offset, count: n.count}
                }, n.prototype.goUp = function (e) {
                    if (this.scene.length() > 1) {
                        this.scene.pop();
                        var i = this.facet = this.scene.peek();
                        this.goToPositionDragging(i.from, i.to), this.animateFillChart(), this.events.notifySceneChanges({navigation: !0}), this.updateAndNotifyCurrent(e)
                    } else this.goToPosition(0, this.getMaxItems(), !0, t.Base.Helpers.performanceNow())
                }, n.prototype.getMaxItems = function () {
                    var t = this.scene.width / this.scene.settings.facetAxis.defaultUnitWidth;
                    return this.facet.data.totalCount && (t = Math.min(t, this.facet.data.totalCount)), t
                }, n.prototype.drillDown = function (t, i) {
                    this.stopAnimations();
                    var n = new e.Facet;
                    n.id = t, this.scene.push(n, null), this.chart.builder.updateFacet(n), this.facet = n, this.setFrom(n.from), this.setTo(n.to), this.animateFillChart(), this.events.notifySceneChanges({navigation: !0}), this.updateAndNotifyCurrent(i)
                }, n.prototype.updateAndNotifyCurrent = function (t) {
                    this.chart.builder.updateFacet(this.facet), this.chart.notifyChartUpdate(t)
                }, n.prototype.onSceneChange = function (t) {
                    var e = this.facet, i = t.timeStamp;
                    if (t.changes.settings && t.changes.settingsChanges.series) {
                        t.changes.items = !0;
                        for (var n = 0; n < this.scene.stack.length; n++) {
                            var s = this.scene.stack[n];
                            this.chart.builder.rebuildValues(s)
                        }
                    }
                    if (t.changes.dataArrived || t.changes.data) {
                        if (this.activePieReady = !1, t.changes.dataArrived)for (var o = t.changes.dataArrivedIds, r = 0; r < this.scene.stack.length; r++) {
                            var a = this.scene.stack[r];
                            o.hasOwnProperty(a.id) && (this.chart.builder.updateFacet(a, t), t.changes.items = !0, this.activePieReady = this.activePieReady || a === e && !a.loading)
                        }
                        if (t.changes.data)for (var n = 0; n < this.scene.stack.length; n++) {
                            var s = this.scene.stack[n];
                            (!s.data || s === e || t.changes.dataDeep) && (s.rebuild = !0, this.chart.builder.updateFacet(s, t), t.changes.items = !0, this.activePieReady = this.activePieReady || s === e && !s.loading)
                        }
                    }
                    this.activePieReady && this.scene.width > 0 && (this.activePieReady = !1, this.getFrom(i) === this.getTo(i) && e.from < e.to && (this.setFrom(e.from), this.setTo(e.to), this.animateFillChart()), this.chart.notifyChartUpdate(null))
                }, n.prototype.doAnimations = function (t) {
                    var e = this.facet;
                    if (this.animatingFacet) {
                        e.left = this.leftAnimator.get(t.timeStamp), e.right = this.rightAnimator.get(t.timeStamp), e.opacity = this.opacityAnimator.get(t.timeStamp);
                        var n = this.leftAnimator.finished(t.timeStamp) || this.rightAnimator.finished(t.timeStamp);
                        n && (this.animatingFacet = null, this.leftAnimator = null, this.rightAnimator = null, this.opacityAnimator = null), this.events.notifySceneChanges({position: !0}), t.animating = !0
                    } else e.opacity = 1;
                    this.layoutFacets();
                    for (var s = 0; s < this.scene.stack.length; s++)e = this.scene.stack[s], this.chart.builder.updateFacet(e);
                    i.prototype.doAnimations.call(this, t)
                }, n.prototype.xyInArea = function (t, e) {
                    return this.scene.xyInChartOrBottom(t, e)
                }, n.prototype.xyToPosition = function (t) {
                    return this.scene.xToPosition(t)
                }, n.prototype.onGoHome = function (t, e) {
                    return {from: 0, to: e - t, origin: 0}
                }, n.prototype.onStartDragging = function () {
                    this.stopAnim()
                }, n.prototype.onSnapWhileDragging = function (t, e) {
                    var i = e - t, n = (t + e - (this.dragStartFrom + this.dragStartTo)) / 2, s = 0, o = 1, r = this.facet.totalCount;
                    if (this.dragStartFrom <= 0 && 0 > n)if (this.scene.stack.length > 1) s = Math.min(.19, -n / i / 3), o = 1 - 4 * s, t = this.dragStartFrom, e = this.dragStartTo; else {
                        var a = i * Math.pow(3, -n / i), h = -n / 5;
                        r > 0 && (a = Math.min(r, a)), t = -h, e = a + h
                    } else if (0 > t) {
                        var l = Math.max(-i, t / 2);
                        t = l, e = l + i
                    } else if (r > 0 && e > r) {
                        var u = r, c = u + Math.min(i, (e - u) / 2);
                        t = c - i, e = c
                    }
                    return 0 > t && (s -= t * (o - s) / (e - t), t = 0), this.facet.left = s, this.facet.right = o, {
                        from: t,
                        to: e
                    }
                }, n.prototype.onSnapAfterDragging = function (t, e, i, n, s) {
                    if (this.shouldZoomOut())return this.goUp("user"), null;
                    var o = this.snap(t, e, i, n, s);
                    return t = o.from, e = o.to, this.animateFillChart(), this.chart.notifyChartUpdate("user"), {
                        from: t,
                        to: e
                    }
                }, n.prototype.shouldZoomOut = function () {
                    return this.facet.right - this.facet.left < .5 && this.scene.stack.length > 1 && 0 === this.dragStartFrom
                }, n.prototype.onPositionChanged = function (t, e) {
                    var i = this.facet;
                    i.from = t, i.to = e, this.chart.builder.updateFacet(i), this.events.notifySceneChanges({position: !0})
                }, n.prototype.onAnimationDone = function () {
                    this.chart.notifyChartUpdate(null), this.chart.notifyAnimationDone()
                }, n.prototype.snap = function (t, e, i) {
                    var n = this.scene.width / (e - t), s = Math.min(this.scene.settings.facetAxis.maxUnitWidth, n);
                    this.facet.totalCount > 0 && (s = Math.max(s, this.scene.width / this.facet.totalCount));
                    var o = n / s;
                    if (t = i + (t - i) * o, e = i + (e - i) * o, t = Math.round(t), e = Math.round(e), 0 > t) e -= t, t = 0; else if (this.facet.totalCount > 0 && e > this.facet.totalCount) {
                        var r = Math.max(0, this.facet.totalCount - (e - t));
                        e = e - t + r, t = r
                    }
                    return {from: t, to: e}
                }, n.prototype.animateFillChart = function () {
                    (0 !== this.facet.left || 1 !== this.facet.right || this.animatingFacet !== this.facet) && (this.animatingFacet = this.facet, this.leftAnimator = new t.Base.Animator(this.facet.left, 0, this.scene.settings.interaction.animation.scrollDuration, "<>"), this.rightAnimator = new t.Base.Animator(this.facet.right, 1, this.scene.settings.interaction.animation.scrollDuration, "<>"), this.opacityAnimator = new t.Base.Animator(this.facet.opacity, 1, this.scene.settings.interaction.animation.scrollDuration, "<>"), this.events.notifySceneChanges({animating: !0}))
                }, n.prototype.stopAnim = function () {
                    this.animatingFacet = null, this.leftAnimator = null, this.rightAnimator = null
                }, n.prototype.layoutFacets = function () {
                    var t, e = this.facet;
                    t = e.left > 0 || e.right < 1 ? .5 : 0;
                    for (var i = this.scene.stack.length - 2; i >= 0; i--) {
                        var n = this.scene.stack[i];
                        if (e.parentItem) {
                            var s = this.scene.getFacetPlacementFromItem(e.parentItem, e.left, e.right);
                            n.left = s.left, n.right = s.right
                        }
                        n.opacity = t, t = n.left > 0 || n.right < 1 ? .2 : 0, e = n
                    }
                    this.shouldZoomOut() ? (this.facet.opacity = .5, this.facet.parentItem.facet.opacity = 1) : this.facet.opacity = 1
                }, n
            }(t.LinearChart.Scrolling);
            e.Scrolling = i
        }(e = t.FacetChart || (t.FacetChart = {}))
    }(e = t.Internal || (t.Internal = {}))
}(ZoomCharts || (ZoomCharts = {}));
var ZoomCharts;
!function (t) {
    var e;
    !function (t) {
        var e;
        !function (e) {
            var i = function () {
                function i(i, n, s) {
                    this.bounds = {
                        x0: 0,
                        y0: 0,
                        width: 0,
                        height: 0
                    }, this.facet = s, this.chart = n, this.scene = this.chart.scene, this.valueAxis = new t.LinearChart.ValueAxisSet(this.chart, this.scene.settings._computedValueAxisList), this.xes = [], this.facetAxis = new e.FacetAxis(n, s), this.r = new t.LinearChart.Renderer(this.chart, this.valueAxis)
                }

                return i.prototype.getPanels = function () {
                    var t = this.valueAxis.getPanels();
                    return t.push(this.facetAxis.getPanel()), t
                }, i.prototype.setPanels = function (t) {
                    this.valueAxis.setPanels(t), this.facetAxis.panel = t[t.length - 1]
                }, i.prototype.doAnimations = function (t, e) {
                    var i = e.x0, n = e.y0, s = e.width, o = e.height, r = this.facet.offset, a = this.facet.left, h = this.facet.right;
                    a = i + s * a, h = i + s * h;
                    var l = Math.max(i, a), u = Math.min(i + s, h);
                    this.bounds = {x0: l, y0: n, width: u - l, height: o};
                    var c = t.changes;
                    if (c.position || c.data || c.bounds || c.items) {
                        for (var p = (h - a) / (this.facet.to - this.facet.from), d = a - this.facet.from * p, f = [], m = [], g = Math.max(r, Math.floor(this.facet.from - 1)), y = Math.min(r + this.facet.count, Math.ceil(this.facet.to + 1)), v = g; y + 1 >= v; v++)f.push(v), m.push(v * p + d);
                        this.xes = m;
                        for (var S = [], C = 0; C < this.scene.settings._computedSeries.length; C++) {
                            for (var b = [], x = [], _ = [], v = g; y - 1 >= v; v++) {
                                var w = this.facet.items[v - r], L = w.values[C];
                                b.push(L.value), _.push(1), x.push(L)
                            }
                            S.push({
                                xes: m,
                                times: f,
                                counts: _,
                                fromIndex: 0,
                                toIndex: f.length,
                                values: b,
                                style: x
                            })
                        }
                        this.r.process(S)
                    }
                    this.valueAxis.updateMinMax(t), this.r.afterProcess(), this.valueAxis.doAnimations(t)
                }, i.prototype.paintScene = function (e) {
                    var i = e.context;
                    i.globalAlpha = this.facet.opacity, this.valueAxis.paintUnder(e), t.Base.Graphics.pushClip(i, this.bounds.x0, this.bounds.y0, this.bounds.width, this.bounds.height), this.r.paint(e), t.Base.Graphics.popClip(i), this.facetAxis.paint(e, this.bounds.x0, this.bounds.width, this.xes), this.valueAxis.paint(e), i.globalAlpha = 1
                }, i
            }();
            e.Layer = i;
            var n = function (t) {
                function n(e) {
                    t.call(this), this.animationOrder = 400, this.paintOrder = 5, this.updateOrder = 1200, this.chart = e, this.scene = this.chart.scene, this.events = this.chart.events, this.layers = [], this.panels = []
                }

                return __extends(n, t), n.prototype.onSceneChange = function (t) {
                    var n = t.changes;
                    if (n.settings || n.navigation) {
                        if (n.settings) {
                            var s = n.settingsChanges;
                            (s._computedValueAxis || s._computedSeries) && (this.layers = []), (s._computedValueAxis || s.facetAxis) && (n.bounds = !0), s._computedSeries && (this.layers = [])
                        }
                        for (var o = 0; o < this.layers.length; o++) {
                            var r = this.layers[o];
                            r.facet !== this.scene.stack[o] && (this.layers = this.layers.slice(0, o))
                        }
                        for (; this.layers.length < this.scene.stack.length;) {
                            var a = this.scene.stack[this.layers.length], h = new i(t, this.chart, a);
                            this.layers.push(h)
                        }
                        0 === this.layers.length && this.layers.push(new i(t, this.chart, new e.Facet)), this.panels = [], this.panels = this.layers[0].getPanels();
                        for (var l = 0; l < this.layers.length; l++) {
                            var h = this.layers[l];
                            h.setPanels(this.panels)
                        }
                    }
                }, n.prototype.getPanels = function () {
                    return this.panels
                }, n.prototype.doAnimations = function (t) {
                    for (var e = 0; e < this.layers.length; e++) {
                        var i = this.layers[e];
                        i.doAnimations(t, this.scene)
                    }
                }, n.prototype.paintScene = function (t) {
                    for (var e = 0; e < this.layers.length; e++) {
                        var i = this.layers[e];
                        i.paintScene(t)
                    }
                }, n.prototype.exportData = function (t, e) {
                    return this.layers[this.layers.length - 1].r.exportData(t, e)
                }, n.prototype.hitTest = function (t, e) {
                    return this.scene.xyInChart(t, e) && this.layers.length > 0 ? this.layers[this.layers.length - 1].r.hitTest(t, e, this.scene.settings.interaction.selection.tolerance) : null
                }, n
            }(t.Base.ChartElement);
            e.Renderer = n
        }(e = t.FacetChart || (t.FacetChart = {}))
    }(e = t.Internal || (t.Internal = {}))
}(ZoomCharts || (ZoomCharts = {}));
var ZoomCharts;
!function (t) {
    var e;
    !function (t) {
        var e;
        !function (e) {
            var i = function () {
                function i(t) {
                    this.chart = t, this.scene = t.scene, this.loading = !1
                }

                return i.prototype.updateFacet = function (t, e) {
                    void 0 === e && (e = null);
                    var i = this.chart.getData("default"), n = i.getPieData(t.id);
                    if (t.data = n, !n)return t.loading = !0, void i.requestPieData(t.id, Math.floor(t.from));
                    var s = !1;
                    if (this.scene.width && (!(t.from < t.to) || t.rebuild)) {
                        t.rebuild = !1;
                        var o, r = Math.max(1, Math.floor(this.scene.width / this.scene.settings.facetAxis.defaultUnitWidth));
                        o = n.totalCount ? Math.min(n.totalCount, r) : r, t.offset = Math.floor(t.from), t.count = 0, t.to = t.from + Math.round(o), t.items = []
                    }
                    n.totalCount && (t.totalCount = n.totalCount);
                    var a = Math.max(0, Math.floor(t.from)), h = Math.ceil(t.to), l = n.values.length + n.offset, u = n.offset;
                    t.loading = !1, u > a && (a = u, i.requestLessPieData(t.id), t.loading = !0), h > l && (h = l, n.done || (i.requestMorePieData(t.id), t.loading = !0));
                    var c = t.offset + t.items.length;
                    if ((h < t.offset || a > c) && (t.offset = a, t.items = [], c = a), a > t.offset) t.items = t.items.slice(a - t.offset), t.offset = a; else if (a < t.offset) {
                        for (var p = [], d = a; d <= t.offset - 1; d++)p.push(this.buildItem(t, n, d));
                        t.items = p.concat(t.items), t.offset = a, s = !0
                    }
                    if (c > h) t.items = t.items.slice(0, h - t.offset); else if (h > c) {
                        for (var d = c; h - 1 >= d; d++)t.items.push(this.buildItem(t, n, d));
                        s = !0
                    }
                    if (t.count = t.items.length, s)if (e) e.changes.items = !0, e.changes.changedItems || (e.changes.changedItems = {}), e.changes.changedItems[t.id] = !0; else {
                        var f = [];
                        f[t.id] = !0, this.chart.events.notifySceneChanges({
                            items: !0,
                            changedItems: f
                        })
                    }
                    return this.scene.updateLinks(t)
                }, i.prototype.rebuildValues = function (t) {
                    for (var e = 0; e < t.items.length; e++) {
                        var i = t.items[e];
                        this.updateItem(i)
                    }
                }, i.prototype.buildItem = function (t, i, n) {
                    i = i.values[n - i.offset];
                    var s = new e.Item(t, i.__id, n, i);
                    return this.updateItem(s), s
                }, i.prototype.updateItem = function (t) {
                    for (var i = [], n = 0; n < this.scene.settings._computedSeries.length; n++) {
                        var s = this.scene.settings._computedSeries[n], o = new e.ItemValue(t.facet, t.id, t.index, t.data, s.id);
                        o.value = t.data ? this.getSeriesValue(t.data, s) : null, i.push(o)
                    }
                    t.values = i
                }, i.prototype.getSeriesValue = function (e, i) {
                    var n = i.data.valueFunction, s = null;
                    if (n) s = n(e); else {
                        var o = i.data.field || "value";
                        s = e[o]
                    }
                    return t.Base.Helpers.tryParseFloat(s, null)
                }, i.prototype.buildPreviewData = function (t, e) {
                    var i = t.id, n = this.scene.mainData, s = n.getPieData(i), o = null;
                    if (s)if (s.offset > 0) n.requestLessPieData(t.id, 0, s.offset); else {
                        o = [];
                        for (var r = 0, a = 0; a < s.values.length; a++) {
                            var h = s.values[a], l = this.getSeriesValue(h, e);
                            o.push(l), r += l
                        }
                        if (r > 0) {
                            r = 1 / r;
                            for (var u = 0; u < o.length; u++)o[u] = o[u] * r
                        } else o = null
                    } else t.expandable && n.canExpand(i) && n.requestPieData(t.id, 0);
                    return o
                }, i
            }();
            e.Builder = i
        }(e = t.FacetChart || (t.FacetChart = {}))
    }(e = t.Internal || (t.Internal = {}))
}(ZoomCharts || (ZoomCharts = {}));
var ZoomCharts;
!function (t) {
    var e;
    !function (t) {
        var e;
        !function (e) {
            var i = function (e) {
                function i(t) {
                    e.call(this), this.animationOrder = 200, this.paintOrder = 20, this.updateOrder = 900, this.chart = t, this.scene = t.scene
                }

                return __extends(i, e), i.prototype.doAnimations = function (t) {
                    if (t.changes.settings || t.changes.items || t.changes.selection || t.changes.navigation) {
                        var e = this.scene.activeFacet;
                        if (e)for (this.computeFacetStyleRec(e); e && e.parentItem;)e = e.parentItem.facet, this.computeFacetStyleRec(e)
                    }
                }, i.prototype.computeFacetStyleRec = function (t) {
                    this.computeFacetStyle(t);
                    for (var e = 0; e < t.items.length; e++) {
                        var i = t.items[e];
                        this.computeItemStyle(t, i), i.innerFacet && this.computeFacetStyleRec(i.innerFacet)
                    }
                }, i.prototype.computeFacetStyle = function () {
                }, i.prototype.computeItemStyle = function (e, i) {
                    var n = this.scene.settings._computedSeries;
                    if (t.Base.Helpers.extendStyle(i, this.scene.settings.items.style), i.data.style && t.Base.Helpers.extendStyle(i, i.data.style), i.id === i.facet.activeItemId)for (var s = 0; s < i.values.length; s++) {
                        var o = i.values[s];
                        o.fillColor = null, o.lineColor = null
                    } else for (var s = 0; s < i.values.length; s++) {
                        var o = i.values[s];
                        t.Base.Helpers.extendStyle(o, n[s].style)
                    }
                    if (this.scene.settings.items.styleFunction ? (this.scene.settings.items.styleFunction(i, i.data), i.label && !t.Base.Helpers.isString(i.label) && (i.label = "" + i.label)) : i.data.name && (i.label = i.data.name), i.id !== i.facet.activeItemId)for (var s = 0; s < i.values.length; s++) {
                        var o = i.values[s], r = n[s];
                        o.previewData = o.previewContents ? this.chart.builder.buildPreviewData(i, r) : null
                    } else i.values[i.values.length - 1].previewData = null
                }, i
            }(t.Base.ChartElement);
            e.Styles = i
        }(e = t.FacetChart || (t.FacetChart = {}))
    }(e = t.Internal || (t.Internal = {}))
}(ZoomCharts || (ZoomCharts = {}));
var ZoomCharts;
!function (t) {
    var e;
    !function (t) {
        var e;
        !function (e) {
            var i = function (i) {
                function n(n, s) {
                    i.call(this, new e.Settings(n), new e.Scene, s), this.builder = new e.Builder(this), this.renderer = this.events.addElement(new e.Renderer(this)), this.scrolling = this.events.addElement(new e.Scrolling(this)), this.selection = this.events.addElement(new e.Selection(this)), this.events.addElement(new e.Styles(this)), this.events.addElement(new e.InfoPopup(this)), this.events.addElement(new t.LinearChart.Highlights(this)), this.scrollButtons = this.events.addElement(new e.ScrollButtons(this)), this.finalInitialize(), this.scrolling.setState(this.settings.navigation.initialDrilldown, this.settings.navigation.initialOffset, 0, "init")
                }

                return __extends(n, i), n.prototype.createDataObj = function (e) {
                    return new t.PieChart.Data(this, e)
                }, n.prototype.onSettingsChanged = function (t) {
                    var e = {settings: !0, settingsChanges: t, items: !1};
                    return t.navigation && t.navigation && this.scrolling.setState(this.settings.navigation.initialDrilldown, this.settings.navigation.initialOffset, null, "api"), (t.labels || t.series || t.interaction) && (e.items = !0), this.events.notifySceneChanges(e), t.data || t.facetAxis || t._computedValueAxis ? this.updateSize(!0) : void 0
                }, n.prototype.updateFilters = function () {
                    return this.updateFilter(!0)
                }, n.prototype.updateFilter = function (t) {
                    void 0 === t && (t = !1), this.log("Update filter");
                    var e = {};
                    for (var i in this.settings._computedDataMap)e[i] = !0;
                    this.events.notifySceneChanges({data: e, dataDeep: t})
                }, n.prototype.setSelection = function (i, n) {
                    void 0 === n && (n = "api"), this.log("Set selection");
                    for (var s = [], o = [], r = 0; r < i.length; r++) {
                        var a = i[r];
                        a instanceof e.Item ? s.push(a) : t.Base.Helpers.isString(a) ? o.push(a) : this.error("SetSelection: Selection contents must be FacetChart.Item object or string, got " + typeof a)
                    }
                    this.selection.setSelection(s, o, !1, n)
                }, n.prototype.setPie = function (t, e, i, n) {
                    void 0 === i && (i = null), void 0 === n && (n = !0), this.log("Set pie"), this.scrolling.setState(t, e, i, "api")
                }, n.prototype.getPie = function () {
                    return this.scrolling.getState().idArray
                }, n.prototype.getPieOffset = function () {
                    return this.scrolling.getState().offset
                }, n.prototype.getActiveItems = function () {
                    for (var t = [], e = 0; e < this.scene.stack.length; e++) {
                        var i = this.scene.stack[e];
                        i.parentItem && t.push(i.parentItem)
                    }
                    return t
                }, n.prototype.getActiveFacets = function () {
                    return this.scene.stack
                }, n.prototype.zoomOut = function (t, e, i) {
                    void 0 === e && (e = !0), void 0 === i && (i = "api"), this.scrolling.goUp(i)
                }, n.prototype.expandItem = function (t, e) {
                    var i = t.facet;
                    if (i === this.scene.peek()) {
                        var n = t.id;
                        if (t.expandable && this.scene.mainData.canExpand(n))return this.setSelection([]), this.scrolling.drillDown(n, e), !0
                    }
                    return !1
                }, n.prototype.saveNavigation = function () {
                    var t = this.scene.peek();
                    return !t || this.scrolling.isActive() ? null : this.scrolling.getState()
                }, n.prototype.restoreNavigation = function (t, e, i) {
                    return this.scrolling.setState(t.idArray, t.offset, t.count, i)
                }, n.prototype.save = function () {
                    for (var t = this.scene.selectionIds.splice(0), e = 0; e < this.scene.selection.length; e++) {
                        var i = this.scene.selection[e];
                        t.push(i.id)
                    }
                    var n = this.scrolling.getState();
                    return JSON.stringify({
                        pie: n.idArray,
                        offset: n.offset,
                        count: n.count,
                        selection: t
                    })
                }, n.prototype.restore = function (t, e) {
                    if (t) {
                        var i = JSON.parse(t);
                        return this.setPie(i.pie, i.offset, i.count, e), this.setSelection(i.selection)
                    }
                }, n.prototype.doChartUpdateNotify = function (t) {
                    return i.prototype.doChartUpdateNotify.call(this, t), this.dispatchEventParams("pieChange", this.extendEventParams({origin: t}), null), this.dispatchEventParams("pieReadyStateChanged", this.extendEventParams({origin: t}), null)
                }, n.prototype.extendEventParams = function (t) {
                    return t.facet = this.scene.peek(), t.offset = t.facet.offset, t.count = t.facet.count, t.hoverItem = this.scene.hoverItem, t.selection = this.scene.selection, t.pie = t.facet, t.slice = t.clickItem, t.clickSlice = t.clickItem, t.clickPie = t.clickFacet, t
                }, n.prototype.defaultClick = function (e) {
                    var i = e.slice;
                    i && (i.url ? (t.Base.Helpers.openUrl(i.url), e.preventDefault()) : this.expandItem(i, "user") && e.preventDefault())
                }, n.prototype.defaultDoubleClick = function () {
                }, n
            }(t.LinearChart.Impl);
            e.Impl = i
        }(e = t.FacetChart || (t.FacetChart = {}))
    }(e = t.Internal || (t.Internal = {}))
}(ZoomCharts || (ZoomCharts = {}));
var ZoomCharts;
!function (t) {
    var e = function (e) {
        function i(n) {
            var s = this;
            e.call(this), this.typeName = "FacetChart", this._impl = i.chartFactoryMethod ? i.chartFactoryMethod(function (e) {
                    return new t.Internal.FacetChart.Impl(e, s)
                }, n) : new t.Internal.FacetChart.Impl(n, this)
        }

        return __extends(i, e), i.prototype.createEmptySettings = function () {
            return t.Internal.Base.SettingsHelper.createEmptySettings(t.Internal.Base.SettingsMapping.FacetChartSettings)
        }, i.prototype.updateSettings = function (i) {
            return t.Internal.Base.SettingsHelper.cleanupEmptySettings(i), e.prototype.updateSettings.call(this, i), this
        }, i.prototype.updateFilter = function () {
            return this._impl.updateFilter(), this
        }, i.prototype.selection = function (e) {
            return t.Internal.Base.Helpers.isArray(e) && this._impl.setSelection(e), this._impl.scene.selection
        }, i.prototype.setPie = function (e, i, n) {
            return void 0 === i && (i = 0), void 0 === n && (n = null), t.Internal.Base.Helpers.isArray(e) || (e = [e]), this._impl.setPie(e, i, n), this
        }, i.prototype.getPie = function () {
            return this._impl.getPie()
        }, i.prototype.getPieOffset = function () {
            return this._impl.getPieOffset()
        }, i.prototype.getActiveItems = function () {
            return this._impl.getActiveItems()
        }, i.prototype.getActiveFacets = function () {
            return this._impl.getActiveFacets()
        }, i.prototype.getActiveFacet = function () {
            var t = this._impl.getActiveFacets();
            return t[t.length - 1]
        }, i.prototype.expandSlice = function (t) {
            return this._impl.expandItem(t, "api")
        }, i.prototype.replaceSeries = function (t) {
            return this._impl.replaceSeries(t)
        }, i.themes = {dark: t.Internal.FacetChart.Settings.DarkTheme}, i.chartFactoryMethod = null, i
    }(t.Internal.Base.Api);
    t.FacetChart = e, t.Internal.Base.Helpers.exportSymbol("FacetChart", t.FacetChart)
}(ZoomCharts || (ZoomCharts = {}));
var ZoomCharts;
!function (t) {
    var e;
    !function (t) {
        var e;
        !function (e) {
            var i = function () {
                function e(e, i, n) {
                    this.nodes = {}, this.links = {}, this.area = new t.Base.AreaCollection, this.requestedArea = new t.Base.AreaCollection, this.pendingArea = null, this.cacheId = n, this.id = i, this.level = e
                }

                return e
            }();
            e.DataLayer = i;
            var n = function (t) {
                function e() {
                    t.apply(this, arguments), this.format = "JSON", this.dataFunction = null, this.preloaded = null, this.prefetchRatio = 1, this.bounds = [-180, -85.0511287798, 180, 85.0511287798], this.wrapLng = !0, this.maxRequestRect = [256, 256], this.perBoundsData = !0, this.perZoomData = !1, this.perDrilldownData = !1, this.aggregationGridSize = 100, this.aggregationMinCount = 5
                }

                return __extends(e, t), e
            }(t.ItemsChart.SettingsData);
            e.SettingsData = n;
            var s = function (e) {
                function n(i, n) {
                    var s = this;
                    e.call(this, i, n), this.layers = {}, this.pendingLayers = [], this.nextId = 0, this.aggregationGridSize = 1, this.zoomLevel = null, this.projectFun = function (t, e) {
                        return s.chart.scene.project(t, e)
                    }, this.unprojectFun = function (t, e) {
                        return s.chart.scene.unproject(t, e)
                    };
                    var o = this.projectFun(this.dataSettings.bounds[0], this.dataSettings.bounds[1]), r = this.projectFun(this.dataSettings.bounds[2], this.dataSettings.bounds[3]);
                    this.projectedBounds = new t.Base.Rect(Math.min(o.x, r.x), Math.min(o.y, r.y), Math.max(o.x, r.x), Math.max(o.y, r.y))
                }

                return __extends(n, e), n.deArrayPoints = function (t) {
                    for (var e = [], i = 0; i < t.length; i++)for (var n = t[i], s = 0; s < n.length; s++) {
                        var o = n[s];
                        e.push(o)
                    }
                    return e
                }, n.prototype.getProjectedBounds = function () {
                    return this.projectedBounds
                }, n.prototype.setViewParams = function (t, e, i, n, s) {
                    this.zoomLevel = this.dataSettings.perZoomData ? e : null, this.aggregationGridSize = t, this.loadDataArea = this.buildRectArea(s), this.returnDataArea = this.buildRectArea(n), this.visibleArea = this.buildRectArea(i), this.pendingLayers = []
                }, n.prototype.getLayer = function (t) {
                    var e = "", n = null;
                    t && (e += "" + t), null !== this.zoomLevel && (e += "#z" + this.zoomLevel, n = this.zoomLevel);
                    var s;
                    return s = this.layers.hasOwnProperty(e) ? this.layers[e] : this.layers[e] = new i(n, t, e), this.lastLayer = s, s
                }, n.prototype.getData = function (e) {
                    var i, n = this.getLayer(e);
                    n.area.coversArea(this.loadDataArea) ? (n.pendingArea = new t.Base.AreaCollection, i = !1) : n.requestedArea.coversArea(this.loadDataArea) ? i = this.hasPendingRequests() : (n.pendingArea = this.loadDataArea.makeCopy().subtractArea(n.requestedArea), n.pendingArea.isEmpty() || (this.pendingLayers.indexOf(n) < 0 && this.pendingLayers.push(n), this.scheduleRequests(!0)), i = this.hasPendingRequests());
                    var s = this.applyFilters(n, this.returnDataArea);
                    return this.chart.log("Data: returned " + s.nodes.length + " nodes and " + s.links.length + " links for ID: " + e + ", loading=" + i), {
                        nodes: s.nodes,
                        links: s.links,
                        hasData: n.area.intersectsArea(this.visibleArea),
                        loading: i
                    }
                }, n.prototype.applyFilters = function (t, e) {
                    var i, n, s = e.toRects(), o = this.settings.filters.nodeFilter, r = [], a = [], h = {};
                    for (var l in t.nodes) {
                        var u = t.nodes[l], c = u._bounds, p = !o || o(u);
                        if (p)for (i = 0; i < s.length; i++)if (n = s[i], n.overlapsRect(c.x0, c.y0, c.x1, c.y1)) {
                            r.push(u), h[l] = !0;
                            break
                        }
                    }
                    for (var l in t.links) {
                        var d = t.links[l], f = h[d.from], m = h[d.to];
                        if (f || m) a.push(d), f || (h[d.from] = !0, r.push(t.nodes[d.from])), m || (h[d.to] = !0, r.push(t.nodes[d.to])); else {
                            var g = t.nodes[d.from], y = t.nodes[d.to];
                            if (g._x && y._x) {
                                var v = g._x, S = g._y, C = y._x, b = y._y;
                                for (i = 0; i < s.length; i++)if (n = s[i], n.intersectsSegment(v, S, C, b)) {
                                    r.push(g), r.push(y), h[d.from] = !0, h[d.to] = !0;
                                    break
                                }
                            }
                        }
                    }
                    return {nodes: r, links: a}
                }, n.prototype.unprojectRect = function (e) {
                    var i = this.unprojectFun(e.x0, e.y0), n = this.unprojectFun(e.x1, e.y1);
                    return new t.Base.Rect(Math.min(i.lng, n.lng), Math.min(i.lat, n.lat), Math.max(i.lng, n.lng), Math.max(i.lat, n.lat))
                }, n.prototype.projectRect = function (e) {
                    var i = this.projectFun(e.x0, e.y0), n = this.projectFun(e.x1, e.y1);
                    return new t.Base.Rect(Math.min(i.x, n.x), Math.min(i.y, n.y), Math.max(i.x, n.x), Math.max(i.y, n.y))
                }, n.prototype.buildRectArea = function (e) {
                    var i = this.projectedBounds, n = e.x0, s = e.y0, o = e.x1, r = e.y1, a = new t.Base.AreaCollection;
                    if (s = Math.max(s, i.y0), r = Math.min(r, i.y1), this.dataSettings.wrapLng) {
                        var h = i.x1 - i.x0;
                        if (o - n > h) n = i.x0, o = i.x1; else {
                            for (; n < i.x0;)n += h, o += h;
                            for (; n > i.x1;)n -= h, o -= h
                        }
                        o <= i.x1 ? a.addRect(new t.Base.Rect(n, s, o, r)) : (a.addRect(new t.Base.Rect(n, s, i.x1, r)), a.addRect(new t.Base.Rect(i.x0, s, o - h, r)))
                    } else a.addRect(e.clone().clip(i));
                    return a
                }, n.prototype.buildRequest = function () {
                    if (this.pendingLayers.length > 0) {
                        var e = this.pendingLayers[0], i = e.pendingArea.findOverlappingRect(this.dataSettings.maxRequestRect[0], this.dataSettings.maxRequestRect[1]);
                        e.pendingArea.subtractRect(i), e.pendingArea.isEmpty() && t.Base.Helpers.removeFromArray(this.pendingLayers, e);
                        var n = i, s = [], o = [];
                        if (this.dataSettings.perBoundsData) {
                            var r = this.buildAggregationRequest(i);
                            n = r.rectangle, s = r.xcuts, o = r.ycuts
                        }
                        e.requestedArea.addRect(n);
                        var a = this.unprojectRect(n);
                        return {
                            id: e.id,
                            layerId: e.cacheId,
                            west: a.x0,
                            north: a.y1,
                            east: a.x1,
                            south: a.y0,
                            zoom: this.zoomLevel,
                            aggregateLat: o,
                            aggregateLng: s,
                            aggregateMinItems: this.dataSettings.aggregationMinCount
                        }
                    }
                    return null
                }, n.prototype.buildAggregationRequest = function (e) {
                    for (var i = this.aggregationGridSize, n = Math.floor(e.x0 / i) * i, s = Math.ceil(e.x1 / i) * i, o = Math.floor(e.y0 / i) * i, r = Math.ceil(e.y1 / i) * i, a = this.dataSettings.bounds[0], h = this.dataSettings.bounds[1], l = this.dataSettings.bounds[2], u = this.dataSettings.bounds[3], c = [], p = [], d = n; s >= d; d += i)c.push(Math.min(Math.max(this.unprojectFun(d, o).lng, a), l));
                    for (var f = o; r >= f; f += i)p.push(Math.min(Math.max(this.unprojectFun(n, f).lat, h), u));
                    return {rectangle: new t.Base.Rect(n, o, s, r), xcuts: c, ycuts: p}
                }, n.prototype.dataFunc = function (e, i, n) {
                    var s = this.dataSettings;
                    if (s.dataFunction) s.dataFunction(e, i, n); else if (s.url) {
                        var o = [["id", e.id], ["south", e.south.toString(10)], ["west", e.west.toString(10)], ["north", e.north.toString(10)], ["east", e.east.toString(10)], ["aggregateLat", e.aggregateLat.join(",")], ["aggregateLng", e.aggregateLng.join(",")], ["aggregateMinItems", s.aggregationMinCount.toString(10)]];
                        null !== e.zoom && o.push(["zoom", e.zoom.toString(10)]), t.Base.Data.doRequest(s.url, s, o, i, n)
                    } else n({error: "Chart configuration does not define data retrieval function"})
                }, n.prototype.verifyData = function (e, i) {
                    "geojson" === this.dataSettings.format.toLowerCase() && this.convertFromGeoJson(i);
                    var n = !0;
                    i.hasOwnProperty("nodes") || (i.nodes = []), i.hasOwnProperty("links") || (i.links = []);
                    var s = t.Base.Helpers.tryParseFloat(i.west, e ? e.west : 1 / 0), o = t.Base.Helpers.tryParseFloat(i.east, e ? e.east : -1 / 0), r = t.Base.Helpers.tryParseFloat(i.north, e ? e.north : 1 / 0), a = t.Base.Helpers.tryParseFloat(i.south, e ? e.south : -1 / 0);
                    i._bounds = new t.Base.Rect(s, a, o, r);
                    for (var h = {}, l = 0; l < i.nodes.length; l++) {
                        var u = i.nodes[l];
                        if (t.Base.Helpers.isArray(u.coordinates) || (this.chart.error("Data response: Node has no coordinates, or not an array"), n = !1), u.aggregate) t.Base.Helpers.isNumber(u.count) || (this.chart.error("Aggregated node needs `count` field that contains a number."), n = !1); else if (u.hasOwnProperty("id")) {
                            var c = u.id.toString();
                            h.hasOwnProperty(c) && this.chart.error("Data response: Multiple nodes with same id: " + c), h[c] = !0
                        } else this.chart.error("Data response: Node without ID"), n = !1
                    }
                    for (var p = {}, d = 0; d < i.links.length; d++) {
                        var f = i.links[d];
                        f.hasOwnProperty("id") ? p.hasOwnProperty(f.id) && this.chart.error("Data response: Multiple links with the same ID: " + f.id) : f.id = t.Base.Helpers.SeparatorChar + (this.nextId++).toString(10), h[f.from] || h[f.to] || this.chart.error("Data response: Returned link that does not match any node: " + f.id), p[f.id] = !0
                    }
                    return n
                }, n.prototype.addVerifiedData = function (e, i) {
                    var n, s;
                    e ? (s = e.id, n = e.layerId) : (n = "", s = "");
                    var o, r, a = this.layers[n];
                    if (a || (a = this.getLayer(s)), i.clearCache) a.nodes = {}, a.links = {}, a.area = new t.Base.AreaCollection, a.area.addRect(this.projectedBounds); else if (1 / 0 !== i._bounds.x0) {
                        var h = this.projectRect(i._bounds);
                        for (var l in a.nodes)o = a.nodes[l], h.overlaps(o._bounds) && delete a.nodes[l];
                        for (var l in a.links)r = a.links[l], a.nodes[r.from] && a.nodes[r.to] || delete a.links[l];
                        a.area.addRect(h)
                    } else a.area.addRect(this.projectedBounds);
                    for (var u = {}, c = 0; c < i.nodes.length; c++)o = i.nodes[c], o.loaded = !0, o.aggregate ? (o.id = t.Base.Helpers.SeparatorChar + this.nextId, this.nextId++, a.nodes[o.id] = o) : (u[o.id] = !0, a.nodes.hasOwnProperty(o.id) ? t.Base.Helpers.extendDeep(a.nodes[o.id], o) : a.nodes[o.id] = o), o.coordinates && (t.Base.Helpers.isArray(o.coordinates[0]) ? this.prepareShape(o) : this.preparePoint(o));
                    for (var p = {}, d = 0; d < i.links.length; d++)r = i.links[d], p[r.id] = !0, a.links[r.id] = r;
                    var f = {};
                    f[s || ""] = {nodes: u, links: p};
                    var m = {};
                    return m[this.dataSettings.id] = f, {geoChartDataNodesIds: m}
                }, n.prototype.prepareShape = function (e) {
                    for (var i = [], n = t.Base.Rect.createEmpty(), s = 0; s < e.coordinates.length; s++) {
                        var o = e.coordinates[s], r = this.projectLineString(o, n);
                        i.push(r)
                    }
                    e._bounds = n, e._coordinates = i
                }, n.prototype.preparePoint = function (e) {
                    if (2 !== e.coordinates.length)return void this.chart.error("Point coordinates must be an array of two numbers.");
                    var i = e.coordinates, n = i[0], s = i[1], o = this.projectFun(n, s);
                    e._x = o.x, e._y = o.y, e._bounds = new t.Base.Rect(o.x, o.y, o.x, o.y)
                }, n.prototype.projectLineString = function (t, e) {
                    for (var i = [], n = 0; n < t.length - 1; n += 2) {
                        var s = this.projectFun(t[n], t[n + 1]);
                        i.push(s.x), i.push(s.y), e.addPoint(s.x, s.y)
                    }
                    return i
                }, n.prototype.convertFromGeoJson = function (t) {
                    t.nodes = [];
                    for (var e = 0; e < t.features.length; e++) {
                        var i = t.features[e], s = i.properties, o = i.geometry;
                        !s.hasOwnProperty("id") && i.hasOwnProperty("id") && (s.id = i.id);
                        var r = o.coordinates, a = [], h = null;
                        "Point" === o.type ? (a = o, h = "point") : "MultiPoint" === o.type ? (a = n.deArrayPoints(r), h = "point") : "LineString" === o.type ? (a = [n.deArrayPoints(r)], h = "line") : "MultiLineString" === o.type ? (a = r.map(n.deArrayPoints), h = "line") : "Polygon" === o.type ? (a = r.map(n.deArrayPoints), h = "polygon") : "MultiPolygon" === o.type && (a = n.deArrayPoints(r).map(n.deArrayPoints), h = "polygon"), h && (s.coordinates = a, s.type = h, t.nodes.push(s))
                    }
                }, n.prototype.requestFailedPermanently = function () {
                }, n.prototype.exportAreas = function () {
                    var t = this.lastLayer.area.toRects(), e = this.lastLayer.requestedArea.toRects(), i = this.lastLayer.pendingArea.toRects();
                    return this.projectRects(t), this.projectRects(e), this.projectRects(i), {
                        areasRects: t,
                        reqAreasRects: e,
                        pendingAreasRects: i
                    }
                }, n.prototype.projectRects = function (t) {
                    for (var e = 0; e < t.length; e++) {
                        var i = t[e], n = this.projectFun(i.x0, i.y0);
                        if (i.x0 = n.x, i.y0 = n.y, n = this.projectFun(i.x1, i.y1), i.x1 = n.x, i.y1 = n.y, i.y1 < i.y0) {
                            var s = i.y0;
                            i.y0 = i.y1, i.y1 = s
                        }
                    }
                }, n.prototype.removeData = function () {
                    return 1
                }, n.prototype.exportData = function () {
                    return 1
                }, n
            }(t.Base.Data);
            e.Data = s
        }(e = t.GeoChart || (t.GeoChart = {}))
    }(e = t.Internal || (t.Internal = {}))
}(ZoomCharts || (ZoomCharts = {}));
var ZoomCharts;
!function (t) {
    var e;
    !function (t) {
        t.Leaflet = null, "undefined" != typeof L && (t.Leaflet = L)
    }(e = t.Internal || (t.Internal = {}))
}(ZoomCharts || (ZoomCharts = {}));
var ZoomCharts;
!function (t) {
    var e;
    !function (t) {
        var e;
        !function (e) {
            var i = function () {
                function e(t, e, i) {
                    this.layers = i, this.chartContainer = e, this.chart = t, this.wasDragged = null, this.wasZoomed = !1;
                    var n = this;
                    this.updatePosDelegate = function () {
                        return n.updatePos()
                    }, this.onZoomDelegate = function (t) {
                        return n.onZoom(t)
                    }, this.viewResetDelegate = function () {
                        return n.viewReset()
                    }, this.userActionEndDelegate = function () {
                        return n.userActionEnd()
                    }, this.userActionStartDelegate = function () {
                        return n.userActionStart()
                    }
                }

                return e.prototype.onAdd = function (t) {
                    this.map = t, t.getPanes().overlayPane.appendChild(this.chartContainer), t.on("move", this.updatePosDelegate, this), t.on("zoomanim", this.onZoomDelegate, this), t.on("viewreset", this.viewResetDelegate, this), t.on("moveend", this.userActionEndDelegate, this), t.on("movestart", this.userActionStartDelegate, this)
                }, e.prototype.onRemove = function (t) {
                    t.getPanes().overlayPane.removeChild(this.chartContainer), t.off("move", this.updatePosDelegate, this), t.off("zoomanim", this.onZoomDelegate, this), t.off("viewreset", this.viewResetDelegate, this), t.off("moveend", this.userActionEndDelegate, this), t.off("movestart", this.userActionStartDelegate, this)
                }, e.prototype.userActionStart = function () {
                    return this.wasDragged = !0
                }, e.prototype.userActionEnd = function () {
                    var t;
                    t = this.wasDragged === !0 ? "user" : null === this.wasDragged ? "init" : null, t && this.chart.notifyChartUpdate(t), this.wasDragged = !1
                }, e.prototype.viewReset = function () {
                    this.updatePos(), this.userActionEnd()
                }, e.prototype.updatePos = function () {
                    if (this.map) {
                        var e = this.map.options.crs, i = this.chart.scene;
                        this.offset = this.map.containerPointToLayerPoint(t.Leaflet.point(0, 0)), this.chartContainer.setAttribute("class", " "), this.chartContainer.style[t.Leaflet.DomUtil.TRANSFORM] = t.Leaflet.DomUtil.getTranslateString(this.offset);
                        var n = this.map.getPixelBounds(), s = e.transformation.untransform(n.min, e.scale(this.map._zoom));
                        s = e.transformation._transform(s, e.scale(0));
                        var o = e.transformation.untransform(n.max, e.scale(this.map._zoom));
                        o = e.transformation._transform(o, e.scale(0));
                        var r = this.map.getZoom();
                        r !== i.zoomLevel && (i.zoom = Math.pow(2, r), i.zoomLevel = r, this.wasZoomed = !0), i.centerX = (o.x + s.x) / 2, i.centerY = (o.y + s.y) / 2, this.chart.events && !this.layers.resizing && (this.chart.events.notifySceneChanges({position: !0}), this.wasZoomed && (this.chart.events.notifySceneChanges({zoom: !0}), this.wasZoomed = !1), this.chart.events.paintNow())
                    }
                }, e.prototype.onZoom = function (e) {
                    var i = this.map.getZoomScale(e.zoom), n = this.map._getCenterOffset(e.center)._multiplyBy(-i)._add(this.offset);
                    this.chartContainer.setAttribute("class", " leaflet-zoom-animated"), this.chartContainer.style[t.Leaflet.DomUtil.TRANSFORM] = t.Leaflet.DomUtil.getTranslateString(n) + " scale(" + i + ") ", this.wasZoomed = !0
                }, e
            }(), n = function () {
                function t() {
                    this.enabled = !0, this.type = "tile", this.url = "http://otile{s}.mqcdn.com/tiles/1.0.0/map/{z}/{x}/{y}.png", this.params = {
                        subdomains: ["1", "2", "3", "4"],
                        attribution: '&copy; <a target="_blank" href="http://osm.org/copyright">OpenStreetMap</a> contributors, Tiles Courtesy of <a href="http://www.mapquest.com/" target="_blank">MapQuest</a> <img src="http://developer.mapquest.com/content/osm/mq_logo.png">'
                    }
                }

                return t
            }();
            e.SettingsBackground = n;
            var s = function (e) {
                function n(t) {
                    e.call(this, t), this.animationOrder = 100, this.resizing = !1
                }

                return __extends(n, e), n.prototype.createDom = function (s) {
                    var o = this;
                    e.prototype.createDom.call(this, s), this.leafletContainer = t.Base.Helpers.createDom("div", "DVSL-leaflet", null, null), this.container.insertBefore(this.leafletContainer, this.canvas), this.container.removeChild(this.canvas), this.container.removeChild(this.outerBorder), this.container.removeChild(this.interactionContainer), this.interactionContainer.appendChild(this.canvas), this.canvas.style.position = "static", this.outerBorder = null, this.menuContainer.className = "DVSL-menu-container", this.itemLayer = new i(this.chart, this.interactionContainer, this), n.setContainerStyle(this.leafletContainer);
                    var r = this.chart.settings.navigation, a = {
                        maxZoom: r.maxZoom,
                        minZoom: r.minZoom,
                        worldCopyJump: !0
                    };
                    this.map = t.Leaflet.map(this.leafletContainer, a);
                    var h = r.maxBounds;
                    this.map.setMaxBounds(new t.Leaflet.LatLngBounds(new t.Leaflet.LatLng(h.south, h.west), new t.Leaflet.LatLng(h.north, h.east)));
                    var l = this.scene.settings.background;
                    l.enabled && ("tile" === l.type ? (this.tileLayer = t.Leaflet.tileLayer(l.url, l.params), this.map.addLayer(this.tileLayer)) : "wms" === l.type && (this.tileLayer = t.Leaflet.tileLayer.wms(l.url, l.params), this.map.addLayer(this.tileLayer))), this.map.addLayer(this.itemLayer), this.crs = this.map.options.crs, this.chart.scene.project = function (t, e) {
                        return o.projectFunc(t, e)
                    }, this.chart.scene.unproject = function (t, e) {
                        return o.unprojectFunc(t, e)
                    }
                }, n.prototype.remove = function () {
                    this.map.remove(), this.map = null
                }, n.prototype.updateSettings = function (i) {
                    if (e.prototype.updateSettings.call(this, i), this.map && (i.background && t.Base.Helpers.warn("Changing of background with updateSettings() is not yet supported."), i.navigation && ((i.navigation.minZoom || i.navigation.maxZoom) && t.Base.Helpers.warn("Changing of navigation.minZoom or navigation.maxZoom with updateSettings() is not yet supported."), i.navigation.maxBounds))) {
                        var n = i.navigation.maxBounds;
                        this.map.setMaxBounds(new t.Leaflet.LatLngBounds(new t.Leaflet.LatLng(n.south, n.west), new t.Leaflet.LatLng(n.north, n.east)))
                    }
                }, n.prototype.projectFunc = function (e, i) {
                    return this.crs.latLngToPoint(new t.Leaflet.LatLng(i, e), 0)
                }, n.prototype.unprojectFunc = function (e, i) {
                    return this.crs.pointToLatLng(new t.Leaflet.Point(e, i), 0)
                }, n.prototype.doAnimations = function (t) {
                    if (e.prototype.doAnimations.call(this, t), t.changes.bounds) {
                        var i = this.scene;
                        i.x0 = i.chartLeft, i.y0 = i.chartTop, i.width = i.chartWidth, i.height = i.chartHeight, i.leftMargin = 0, i.rightMargin = 0, i.topMargin = 0, i.bottomMargin = 0, this.resizing = !0, this.map.invalidateSize(), this.resizing = !1, this.interactionContainer.style.width = i.chartWidth + "px", this.interactionContainer.style.height = i.chartHeight + "px"
                    }
                }, n
            }(t.Base.DomLayer);
            e.DomLayer = s
        }(e = t.GeoChart || (t.GeoChart = {}))
    }(e = t.Internal || (t.Internal = {}))
}(ZoomCharts || (ZoomCharts = {}));
var ZoomCharts;
!function (t) {
    var e;
    !function (t) {
        var e;
        !function (e) {
            var i = function () {
                function t() {
                    this.enabled = !1, this.distance = 60, this.maxZoom = 18, this.weightFunction = null, this.aggregationFunction = null
                }

                return t
            }();
            e.SettingsAggregation = i;
            var n = function () {
                function e(t, e, i) {
                    this.zoom = e.zoom, this.scene = e, this.settings = t, this.chart = i
                }

                return e.orientation = function (t, e, i) {
                    var n = (e.x - t.x) * (i.y - t.y) - (e.y - t.y) * (i.x - t.x);
                    return 0 === n ? 0 : n > 0 ? 1 : -1
                }, e.distanceLineToPoint = function (t, e, i) {
                    var n = Math.sqrt((e.x - t.x) * (e.x - t.x) + (e.y - t.y) * (e.y - t.y));
                    return Math.abs((i.x - t.x) * (e.y - t.y) - (i.y - t.y) * (e.x - t.x)) / n
                }, e.prototype.findMainNodes = function (e, i) {
                    var n = {}, s = {}, o = {}, r = t.Base.Helpers.isFunction(this.settings.weightFunction);
                    if (r) {
                        for (var a = 0; a < e.length; a++)o[e[a].id] = this.settings.weightFunction(e[a]);
                        e.sort(function (t, e) {
                            return o[e.id] - o[t.id]
                        })
                    }
                    for (var h, l, u, c = this.zoom / (this.settings.distance / 2), p = [], d = {}, a = 0; a < e.length; a++) {
                        var f = e[a], m = Math.floor(f._x * c), g = Math.floor(f._y * c);
                        if (h = s[m] || (s[m] = {}), void 0 === h[g] && void 0 === h[g - 1] && void 0 === h[g + 1] && (l = s[m - 1] || (s[m - 1] = {}), void 0 === l[g] && void 0 === l[g - 1] && void 0 === l[g + 1] && (u = s[m + 1] || (s[m + 1] = {}), void 0 === u[g] && void 0 === u[g - 1] && void 0 === u[g + 1]))) {
                            h[g] = p.length, h[g + 1] = p.length, h[g - 1] = p.length, l[g] = p.length, l[g + 1] = p.length, l[g - 1] = p.length, u[g] = p.length, u[g + 1] = p.length, u[g - 1] = p.length;
                            var y = r ? o[f.id] || 0 : 1, v = {
                                id: "__aggr_" + f.id,
                                aggregatedWeight: y,
                                _originalWeight: y,
                                _x: f._x,
                                _y: f._y,
                                _bounds: f._bounds,
                                aggregatedNodes: [f],
                                loaded: !0
                            };
                            p.push(v), n[f.id] = v, d[a] = !0
                        }
                    }
                    for (var S = [], a = 0; a < e.length; a++)if (!d[a]) {
                        var f = e[a], m = Math.floor(f._x * c), g = Math.floor(f._y * c), C = p[s[m][g]];
                        if (!C) {
                            h = s[m] || (s[m] = {}), l = s[m - 1] || (s[m - 1] = {}), u = s[m + 1] || (s[m + 1] = {}), S.push(h[g]), S.push(h[g - 1]), S.push(h[g + 1]), S.push(l[g]), S.push(l[g - 1]), S.push(l[g + 1]), S.push(u[g]), S.push(u[g - 1]), S.push(u[g + 1]);
                            for (var b = 1 / 0; S.length > 0;) {
                                var x = S.pop();
                                if (void 0 !== x) {
                                    var _ = p[x], w = (_._x - f._x) * (_._x - f._x) + (_._y - f._y) * (_._y - f._y);
                                    b > w && (b = w, C = _)
                                }
                            }
                        }
                        var L = r ? o[f.id] || 0 : 1;
                        (C.aggregatedWeight > 0 || L > 0) && (C._x = (C._x * C.aggregatedWeight + f._x * L) / (C.aggregatedWeight + L), C._y = (C._y * C.aggregatedWeight + f._y * L) / (C.aggregatedWeight + L)), C._originalWeight < L && (C._originalWeight = L, C.id = "__aggr_" + f.id), n[f.id] = C, C.aggregatedNodes.push(f), C.aggregatedWeight += L
                    }
                    for (var a = 0; a < p.length; a++) {
                        var f = p[a], T = this.scene.unproject(f._x, f._y);
                        f.coordinates = [T.lng, T.lat]
                    }
                    if (this.settings.postProcessAggregatedNodes) {
                        var M = [];
                        this.settings.postProcessAggregatedNodes(p, n, M);
                        for (var a = 0; a < M.length; a++) {
                            var f = M[a], P = this.scene.project(f.coordinates[0], f.coordinates[1]);
                            f._x = P.x, f._y = P.y
                        }
                    }
                    var k = this.aggregateLinks(i, n);
                    return this.findConvexShapes(p), {nodes: p, links: k}
                }, e.prototype.aggregateLinks = function (t, e) {
                    for (var i = [], n = {}, s = 0; s < t.length; s++) {
                        var o = t[s], r = e[o.from], a = e[o.to];
                        if (r)if (a) {
                            var h = void 0, l = r.id + "-" + a.id;
                            n[l] ? (h = n[l], h.value ? h.value += o.value : h.value = o.value, h.aggregatedLinks.push(o)) : (h = {
                                    id: l,
                                    from: r.id,
                                    to: a.id,
                                    aggregatedLinks: [o],
                                    value: o.value
                                }, i.push(h), n[l] = h)
                        } else this.chart.error("Link with ID '" + o.id + "' specifies non existant end node: '" + o.to + "'"); else this.chart.error("Link with ID '" + o.id + "' specifies non existant start node: '" + o.from + "'")
                    }
                    return i
                }, e.prototype.findConvexShapes = function (t) {
                    for (var i = 0; i < t.length; i++) {
                        for (var n = [], s = t[i].aggregatedNodes, o = s[0], r = s[0], a = 1; a < s.length; a++) {
                            var h = s[a];
                            h._x <= o._x && (o = s[a]), h._x >= r._x && (r = s[a])
                        }
                        for (var l = [], u = [], a = 0; a < s.length; a++) {
                            var h = s[a];
                            if (null != h) {
                                var c = e.orientation({x: o._x, y: o._y}, {
                                    x: r._x,
                                    y: r._y
                                }, {x: h._x, y: h._y});
                                c > 0 ? l.push(h) : 0 > c && u.push(h)
                            }
                        }
                        var p = [o], d = {};
                        n = [], this.separateOuterPoints(o, r, u, n, d), p = p.concat(n.sort(function (t, e) {
                            return t._x - e._x
                        })), p.push(r), n = [], this.separateOuterPoints(r, o, l, n, d), p = p.concat(n.sort(function (t, e) {
                            return e._x - t._x
                        })), t[i].convexShape = p
                    }
                }, e.prototype.separateOuterPoints = function (t, i, n, s, o) {
                    if (0 !== n.length) {
                        if (1 === n.length)return o[n[0].id] = 1, void s.push(n[0]);
                        for (var r = 0, a = null, h = 0; h < n.length; h++) {
                            var l = n[h], u = e.distanceLineToPoint({
                                x: t._x,
                                y: t._y
                            }, {x: i._x, y: i._y}, {x: l._x, y: l._y});
                            u > r && (r = u, a = l)
                        }
                        o[a.id] || (s.push(a), o[a.id] = 1);
                        for (var c = [], p = [], h = 0; h < n.length; h++) {
                            var l = n[h];
                            if (!o[l.id]) {
                                var d = e.orientation({x: t._x, y: t._y}, {
                                    x: a._x,
                                    y: a._y
                                }, {x: l._x, y: l._y});
                                0 !== d && 0 > d && p.push(l);
                                var f = e.orientation({x: a._x, y: a._y}, {
                                    x: i._x,
                                    y: i._y
                                }, {x: l._x, y: l._y});
                                0 !== f && 0 > f && c.push(l)
                            }
                        }
                        this.separateOuterPoints(t, a, p, s, o), this.separateOuterPoints(a, i, c, s, o)
                    }
                }, e.prototype.aggregate = function (e, i) {
                    if (this.zoom > Math.pow(2, this.settings.maxZoom)) {
                        var n, s = [], o = [], r = t.Base.Helpers.isFunction(this.settings.weightFunction);
                        for (n = 0; n < e.length; n++) {
                            var a = e[n];
                            s.push({
                                id: "__aggr_" + a.id,
                                aggregatedWeight: r ? this.settings.weightFunction(a) : 1,
                                _x: a._x,
                                _y: a._y,
                                _bounds: a._bounds,
                                coordinates: a.coordinates,
                                aggregatedNodes: [a],
                                loaded: !0
                            })
                        }
                        for (n = 0; n < i.length; n++) {
                            var h = i[n];
                            o.push({
                                from: "__aggr_" + h.from,
                                to: "__aggr_" + h.to,
                                value: h.value,
                                id: "__aggr_" + h.from + "-__aggr_" + h.to,
                                aggregatedLinks: [h]
                            })
                        }
                        return {nodes: s, links: o}
                    }
                    return this.findMainNodes(e, i)
                }, e
            }();
            e.Aggregation = n
        }(e = t.GeoChart || (t.GeoChart = {}))
    }(e = t.Internal || (t.Internal = {}))
}(ZoomCharts || (ZoomCharts = {}));
var ZoomCharts;
!function (t) {
    var e;
    !function (t) {
        var e;
        !function (e) {
            var i = function (i) {
                function s(o) {
                    i.call(this, t.Base.SettingsMapping.GeoChartSettings), this._computedLayers = [], this.theme = s.FlatTheme, this.area = new n, this.background = new e.SettingsBackground, this.data = [], this.style = {
                        fadeTime: 200,
                        selection: {
                            fillColor: "rgba(200, 200, 255 ,0.7)",
                            sizeConstant: 5,
                            sizeProportional: .2
                        }
                    }, this.layerTypes = {
                        shapes: {type: "shapes"},
                        items: {type: "items"},
                        aggregateOnShapes: {type: "aggregateOnShapes"},
                        charts: {type: "charts"}
                    }, this.layersDefault = null, this.layers = [], this.navigation = {
                        initialLat: 40,
                        initialLng: 25,
                        initialZoom: 3,
                        minZoom: 0,
                        maxZoom: 18,
                        maxBounds: {west: -1 / 0, north: -85, east: 1 / 0, south: 85},
                        initialDrilldown: [""],
                        drilldownLayer: "default"
                    }, this.filters = {nodeFilter: null}, this.interaction = new c, this.toolbar = new t.Base.SettingsToolbar(!1, [new t.Base.SettingsToolbarItem("fullscreen")], "bottom", "left"), t.Base.Helpers.isStyleSheetDefined(".leaflet-container") || this.advanced.assets.push("assets://leaflet.css"), this.area.defaultHeight = 500, this.advanced.style.loadingArcStyle.r = 15, this.advanced.style.loadingArcStyle.lineColor = "red", this.advanced.style.loadingArcStyle.lineWidth = 7, this.apply(o), this._initializing = !1
                }

                return __extends(s, i), s.prototype.apply = function (e) {
                    this.applyCompatibility(e, [{
                        from: "layersDefault",
                        alternative: "layerTypes"
                    }]);
                    var n = i.prototype.apply.call(this, e);
                    return (this._initializing || n.layers || n.layerTypes) && (this._computedLayers = t.Base.SettingsHelper.mergeDefaultValues(this.layers, this.layersDefault, this.layerTypes, r.createInstance, r.getMapping, "layers"), n._computedLayers = this._computedLayers), n
                }, s.FlatTheme = {advanced: {themeCSSClass: "DVSL-flat"}}, s
            }(t.ItemsChart.Settings);
            e.Settings = i;
            var n = function (t) {
                function e() {
                    t.apply(this, arguments), this.style = new s
                }

                return __extends(e, t), e
            }(t.Base.SettingsArea);
            e.SettingsArea = n;
            var s = function (t) {
                function e() {
                    t.apply(this, arguments)
                }

                return __extends(e, t), e
            }(t.Base.SettingsAreaStyle);
            e.SettingsAreaStyle = s;
            var o = function (t) {
                function e() {
                    t.call(this), this.aggregatedShape = {
                        lineColor: "rgb(0,0,128,0.5)",
                        lineWidth: 1,
                        fillColor: "rgba(0,0,128,0.3)"
                    }, this.scaleObjectsWithZoom = !1, this.node.radius = 10, this.node.fillColor = "orange", this.node.lineColor = "red", this.linkLabel.scaleWithSize = !1, this.linkLabel.scaleWithZoom = !1, this.linkLabel.backgroundStyle.fillColor = "white", this.linkLabel.backgroundStyle.lineColor = "black", this.nodeLabel.scaleWithSize = !1, this.nodeLabel.scaleWithZoom = !1, this.nodeLabel.backgroundStyle.fillColor = "white", this.nodeLabel.backgroundStyle.lineColor = "black"
                }

                return __extends(e, t), e
            }(t.ItemsChart.SettingsNodesLayerStyle);
            e.SettingsNodesLayerStyle = o;
            var r = function () {
                function e() {
                    this.enabled = !0, this.id = "default", this.name = "", this.type = "shapes", this.minZoom = 0, this.maxZoom = 20, this.perZoomStyle = !1, this.data = {id: "default"}
                }

                return e.getMapping = function (e, i) {
                    if (e && i.type && e.type !== i.type)throw new Error("It is not possible to change the value of `type` property for an existing layer.");
                    switch (e ? e.type : i.type) {
                        case"shapes":
                            return t.Base.SettingsMapping.GeoChartSettingsLayerShapes;
                        case"items":
                            return t.Base.SettingsMapping.GeoChartSettingsLayerItems;
                        case"charts":
                            return t.Base.SettingsMapping.GeoChartSettingsLayerCharts;
                        case"aggregateOnShapes":
                            return t.Base.SettingsMapping.GeoChartSettingsLayerAggregated;
                        default:
                            throw new Error("The value '" + i.type + "' is not valid for the `type` property of a layer. Valid values are: shapes, items, charts, aggregateOnShapes.")
                    }
                }, e.createInstance = function (t, e) {
                    switch (e || t.type) {
                        case"shapes":
                            return new a;
                        case"items":
                            return new h;
                        case"charts":
                            return new u;
                        case"aggregateOnShapes":
                            return new l;
                        default:
                            throw new Error("The value '" + (e || t.type) + "' is not valid for the `type` property of a layer. Valid values are: shapes, items, charts, aggregateOnShapes.")
                    }
                }, e
            }();
            e.SettingsLayerBase = r;
            var a = function (t) {
                function i() {
                    t.call(this), this.style = new e.SettingsShapesLayerStyle, this.type = "shapes"
                }

                return __extends(i, t), i
            }(r);
            e.SettingsLayerShapes = a;
            var h = function (t) {
                function i() {
                    t.call(this), this.style = new o, this.aggregation = new e.SettingsAggregation, this.layout = new e.SettingsNodesLayout, this.type = "items"
                }

                return __extends(i, t), i
            }(r);
            e.SettingsLayerItems = h;
            var l = function (t) {
                function e() {
                    t.call(this), this.shapesLayer = null, this.aggregationField = null, this.aggregation = "count", this.aggregationFunction = null, this.styleFunction = null, this.type = "aggregateOnShapes"
                }

                return __extends(e, t), e
            }(r);
            e.SettingsLayerAggregated = l;
            var u = function (t) {
                function e() {
                    t.call(this), this.shapesLayer = null, this.chartType = "piechart", this.settings = null, this.settingsFunction = null, this.autoSize = !1, this.data = {id: null}, this.type = "charts"
                }

                return __extends(e, t), e
            }(r);
            e.SettingsLayerCharts = u;
            var c = function (t) {
                function e() {
                    t.call(this), this.mode = "drilldown", this.nodesMovable = !1, this.selection.enabled = !1
                }

                return __extends(e, t), e
            }(t.ItemsChart.SettingsInteraction);
            e.SettingsInteraction = c
        }(e = t.GeoChart || (t.GeoChart = {}))
    }(e = t.Internal || (t.Internal = {}))
}(ZoomCharts || (ZoomCharts = {}));
var ZoomCharts;
!function (t) {
    var e;
    !function (t) {
        var e;
        !function (e) {
            var i = function () {
                function t() {
                    this.mode = "static", this.nodeSpacing = 3, this.anchorStrength = 1
                }

                return t
            }();
            e.SettingsNodesLayout = i;
            var n = function () {
                function t() {
                }

                return t
            }(), s = function () {
                function e(e, i, n) {
                    this.cpRequestInitiated = !1, this.scene = e, this.settings = n, this.layer = i, this.random = new t.Base.Random(1)
                }

                return e.prototype.doAnimations = function (e, i) {
                    var n = !1, s = this.layer.hasTopologyChanges(), o = "dynamic" === this.settings.mode;
                    if (o && "undefined" == typeof t.Chipmunk)return this.cpRequestInitiated || (this.scene.assetsLoader.loadAssetsList(["assets://cp.js"], function () {
                    }), this.cpRequestInitiated = !0), void(e.animating = !0);
                    for (var r = this.layer.nodes(), a = this.layer.getGeometry(), h = a.txm, l = a.txa, u = a.tym, c = a.tya, p = a.zoom, d = 0; d < r.length; d += 1) {
                        var f = r[d];
                        f.shape.adaptToViewport(h, l, u, c, p)
                    }
                    if (s && (this.random = new t.Base.Random(1), this.placeNewNodes(o), n = !0), o) {
                        this.placeModifiedNodes();
                        var m = this.updateLayout(e.dtime, s, i, e.changes.zoom);
                        m && (e.animating = !0, n = !0)
                    } else this.placeModifiedNodes(), this.computeNodeAnchorCoordinates();
                    n && (e.changes.position = !0)
                }, e.prototype.computeNodeAnchorCoordinates = function () {
                    for (var t = this.layer.getNodesSceneZoom(), e = 0, i = this.layer.nodes(); e < i.length; e++) {
                        var n = i[e], s = n.shape.getAnchor();
                        n.x = n.anchorX - s.x * t, n.y = n.anchorY - s.y * t
                    }
                }, e.prototype.placeNewNodes = function (t) {
                    for (var e = {}, i = this.layer.getNodesSceneZoom(), n = 0, s = this.layer.nodes(); n < s.length; n++) {
                        var o = s[n], r = o.shape.getAnchor();
                        o.anchorX = o.data._x, o.anchorY = o.data._y, (null === o.x || null === o.y) && (o.x = o.anchorX - r.x * i, o.y = o.anchorY - r.y * i, t && (o.x += this.random.get() * i), e[o.id] = !0)
                    }
                    return {newNodes: e, majorChanges: !1}
                }, e.prototype.placeModifiedNodes = function () {
                    for (var t in this.layer.modifiedNodes) {
                        var e = this.layer.modifiedNodes[t];
                        e.anchorX = e.data._x, e.anchorY = e.data._y
                    }
                }, e.prototype.removeNode = function (t) {
                    var e = this.idToState[t.id], i = this.cpSpace;
                    i.removeShape(e.shape), e.locked || (i.removeBody(e.body), i.removeShape(e.anchorShape)), delete this.idToState[t.id]
                }, e.prototype.addNode = function (e, i) {
                    var s = new n, o = this.cpSpace, r = this.layer.getNodesSceneZoom(), a = e.shape.getAnchor();
                    if (s.locked = i, this.idToState[e.id] = s, i); else {
                        var h = o.addBody(new t.Chipmunk.Body(1, 1 / 0));
                        s.body = h, h.setPos(t.Chipmunk.v(e.x + a.x * r, e.y + a.y * r))
                    }
                    return s
                }, e.prototype.updateLayout = function (e, i, n, s) {
                    this.cpSpace || (this.cpSpace = new t.Chipmunk.Space, this.cpSpace.sleepTimeThreshold = 1, this.cpSpace.damping = .2, this.idToState = {});
                    var o = this.cpSpace, r = this.idToState, a = this.settings.nodeSpacing, h = this.settings.anchorStrength, l = this.layer.getNodesSceneZoom();
                    this.zoom = l, this.cpSpace.collisionSlop = 2 * l, this.cpSpace.idleSpeedThreshold = 5 * l;
                    var u, c, p, d, f, m, g, y, v = this.layer.nodes();
                    if (i) {
                        for (var S in this.layer.deletedNodes)this.removeNode(this.layer.deletedNodes[S]);
                        for (var S in this.layer.newNodes) {
                            var C = this.layer.newNodes[S];
                            m = C.userLock || C.locks > 0 || C.anchorMode === t.ItemsChart.NodeAnchorMode.Fixed, this.addNode(C, m)
                        }
                    }
                    if (n || i)for (var b = 0; b < v.length; b += 1) {
                        var C = v[b], x = r[C.id];
                        m = C.userLock || C.locks > 0 || C.anchorMode === t.ItemsChart.NodeAnchorMode.Fixed, m !== x.locked && (x.body && (y = x.body.p), this.removeNode(C), x = this.addNode(C, m)), f = (Math.max(C.bounds.w(), C.bounds.h()) + a) / 2 * l;
                        var _ = C.shape.getAnchor();
                        p = C.anchorX, d = C.anchorY, (s || x.prevAX !== p || x.prevAY !== d || x.prevR !== f) && (x.locked ? (u = x.shape, u && o.removeShape(u), y || (y = t.Chipmunk.v(p - _.x * l, d - _.y * l)), y.x -= _.x * l, y.y -= _.y * l, u = o.addShape(new t.Chipmunk.CircleShape(o.staticBody, f, y)), x.p = y, u.setElasticity(0), u.setFriction(0), x.shape = u) : (x.prevR !== f && (u = x.shape, u && o.removeShape(u), u = o.addShape(new t.Chipmunk.CircleShape(x.body, f, t.Chipmunk.v(-_.x * l, -_.y * l))), u.setElasticity(0), u.setFriction(0), x.shape = u), (s || x.prevAX !== p || x.prevAY !== d) && (c = x.anchorShape, c && o.removeShape(c), c = o.addShape(new t.Chipmunk.CircleShape(o.staticBody, 2 * l, t.Chipmunk.v(p, d))), c.setElasticity(0), c.setFriction(0), x.anchorShape = c)), x.prevAX = p, x.prevAY = d, x.prevR = f)
                    }
                    for (var b = 0; b < v.length; b += 1) {
                        var C = v[b], x = r[C.id];
                        if (!x.locked) {
                            var w = C.anchorX, L = C.anchorY, T = x.body.p.x, M = x.body.p.y;
                            g = x.body;
                            var P = T - w, k = M - L, D = g.vx, I = g.vy;
                            P += .5 * D, k += .5 * I;
                            var A = -Math.abs(3 * P) * t.Base.Helpers.sign(P), B = 0;
                            B = 0 > k ? -2 * k : -5 * k, g.f = t.Chipmunk.v(A * h, B * h)
                        }
                    }
                    o.step(1 / 60);
                    for (var E = !0, b = 0; b < v.length; b += 1) {
                        var C = v[b], x = r[C.id], _ = C.shape.getAnchor();
                        x.locked ? x.p ? (C.x = x.p.x, C.y = x.p.y) : (C.x = C.data._x - _.x * l, C.y = C.data._y - _.y * l) : (C.x = x.body.p.x - _.x * l, C.y = x.body.p.y - _.y * l, E = E && x.body.isSleeping())
                    }
                    return !E
                }, e
            }();
            e.NodesLayout = s
        }(e = t.GeoChart || (t.GeoChart = {}))
    }(e = t.Internal || (t.Internal = {}))
}(ZoomCharts || (ZoomCharts = {}));
var ZoomCharts;
!function (t) {
    var e;
    !function (t) {
        var e;
        !function (e) {
            var i = function (i) {
                function n(t, n, s, o) {
                    i.call(this, t, n, s, o), this.layout = null, this.hoveredNode = null, this.layout = new e.NodesLayout(t, this, s.layout)
                }

                return __extends(n, i), n.prototype.postprocessStyle = function (t) {
                    i.prototype.postprocessStyle.call(this, t);
                    var e = t.changes.zoom || this.hasStyleChanges();
                    this.layout.doAnimations(t, e)
                }, n.prototype.paintHoverShape = function (e) {
                    if (null === this.hoveredNode || !this.hoveredNode.hovered || this.hoveredNode.removed) {
                        var i = this.modifiedNodes;
                        this.hoveredNode = null;
                        for (var n in i)if (i[n].hovered) {
                            this.hoveredNode = i[n];
                            break
                        }
                    }
                    if (null !== this.hoveredNode) {
                        var s = this.hoveredNode.data.convexShape;
                        if (s && !(s.length < 2)) {
                            var o = this.getGeometry(), r = {}, a = t.Base.Graphics.beginStrokeAndFill(e, this.style.aggregatedShape);
                            r[s[0].id] = 1, a.moveTo(s[0]._x * o.txm + o.txa, s[0]._y * o.tym + o.tya);
                            for (var h = 1; h < s.length; h++)r[s[h].id] = 1, a.lineTo(s[h]._x * o.txm + o.txa, s[h]._y * o.tym + o.tya);
                            a.closePath(), t.Base.Graphics.endStrokeAndFill(e, a, this.style.aggregatedShape);
                            for (var h = 0; h < this.hoveredNode.data.aggregatedNodes.length; h++) {
                                var l = this.hoveredNode.data.aggregatedNodes[h];
                                r[l.id] || (a = t.Base.Graphics.beginStroke(e, this.style.aggregatedShape), a.arc(l._x * o.txm + o.txa, l._y * o.tym + o.tya, 1, 0, 2 * Math.PI), t.Base.Graphics.endStroke(e, a, this.style.aggregatedShape))
                            }
                        }
                    }
                }, n.prototype.paint = function (t) {
                    this.paintHoverShape(t.context), i.prototype.paint.call(this, t)
                }, n
            }(t.ItemsChart.NodesLayer);
            e.NodesLayer = i
        }(e = t.GeoChart || (t.GeoChart = {}))
    }(e = t.Internal || (t.Internal = {}))
}(ZoomCharts || (ZoomCharts = {}));
var ZoomCharts;
!function (t) {
    var e;
    !function (t) {
        var e;
        !function (e) {
            var i = function (e) {
                function i() {
                    e.call(this), this.stack = [], this.zoomLevel = 0, this.project = null, this.unproject = null
                }

                return __extends(i, e), i.prototype.push = function (t) {
                    return this.stack.push(t)
                }, i.prototype.peek = function () {
                    return 0 === this.stack.length ? null : this.stack[this.stack.length - 1]
                }, i.prototype.pop = function () {
                    return 0 === this.stack.length ? null : this.stack.pop()
                }, i.prototype.getVisibleBoundsLatLon = function () {
                    var e = this.fromDisplay(this.x0, this.y0), i = e.x, n = e.y;
                    e = this.fromDisplay(this.x0 + this.width, this.y0 + this.height);
                    var s = e.x, o = e.y;
                    return this.unprojectRect(new t.Base.Rect(i, n, s, o))
                }, i.prototype.unprojectRect = function (e) {
                    var i = this.unproject(e.x0, e.y0), n = this.unproject(e.x1, e.y1);
                    return new t.Base.Rect(Math.min(i.lng, n.lng), Math.min(i.lat, n.lat), Math.max(i.lng, n.lng), Math.max(i.lat, n.lat))
                }, i
            }(t.ItemsChart.Scene);
            e.Scene = i
        }(e = t.GeoChart || (t.GeoChart = {}))
    }(e = t.Internal || (t.Internal = {}))
}(ZoomCharts || (ZoomCharts = {}));
var ZoomCharts;
!function (t) {
    var e;
    !function (t) {
        var e;
        !function (e) {
            var i = function (t) {
                function e() {
                    t.apply(this, arguments), this.shapeSimplificationPrecision = 1.5, this.node = {
                        fillColor: "#c7dae0",
                        lineColor: null,
                        lineWidth: null,
                        radius: 30,
                        shadowColor: null,
                        lineDash: null,
                        expandable: !1
                    }
                }

                return __extends(e, t), e
            }(e.SettingsNodesLayerStyle);
            e.SettingsShapesLayerStyle = i;
            var n = function (e) {
                function i(t, i) {
                    e.call(this, t, i)
                }

                return __extends(i, e), i.prototype.postprocessNode = function (t) {
                    e.prototype.postprocessNode.call(this, t), t.currentItems = [], t.label, this.postprocessItems(t)
                }, i.prototype.postprocessLink = function (i) {
                    e.prototype.postprocessLink.call(this, i);
                    var n = [];
                    if (i.label) {
                        var s = new t.Base.Label(i.labelStyle);
                        s.text = i.label.toString(), s.px = 0, s.py = 0, n.push(s)
                    }
                    i.currentItems = n, this.postprocessItems(i)
                }, i
            }(t.ItemsChart.ItemsStyle);
            e.ShapesStyle = n
        }(e = t.GeoChart || (t.GeoChart = {}))
    }(e = t.Internal || (t.Internal = {}))
}(ZoomCharts || (ZoomCharts = {}));
var ZoomCharts;
!function (t) {
    var e;
    !function (t) {
        var e;
        !function (e) {
            var i = function (i) {
                function n(t, e) {
                    i.call(this, t, e), this.style = e.style
                }

                return __extends(n, i), n.prototype.createStyleUpdater = function (t) {
                    return new e.ShapesStyle(t, this)
                }, n.prototype.paintSelection = function (t, e) {
                    var i = this.getGeometry(), n = i.txm, s = i.txa, o = i.tym, r = i.tya, a = 1 / n, h = t.context, l = this.style.selection;
                    h.beginPath();
                    for (var u = 0; u < e.length; u++)for (var c = e[u], p = 0, d = this.getNodeCoords(c, a); p < d.length; p++) {
                        var f = d[p], m = f[0] * n + s, g = f[1] * o + r;
                        h.moveTo(m, g);
                        for (var y = 2; y <= f.length - 2; y += 2)h.lineTo(f[y] * n + s, f[y + 1] * o + r);
                        h.closePath()
                    }
                    return h.fillStyle = l.fillColor, h.strokeStyle = l.fillColor, h.lineWidth = 2 * l.sizeConstant, h.fill(), h.stroke()
                }, n.prototype.paintNodes = function (e, i) {
                    for (var n = e.context, s = this.getGeometry(), o = s.txm, r = s.txa, a = s.tym, h = s.tya, l = s.zoom, u = s.x0w, c = s.y0w, p = s.x1w, d = s.y1w, f = 1 / o, m = l > this.style.nodeDetailMinZoom, g = this.style.nodeDetailMinSize * this.style.nodeDetailMinSize * f * f, y = this.style.nodeLabelScaleBase, v = 0; v < i.length; v++) {
                        var S = i[v];
                        if (S.removed) this.deleteNode(S); else if (S.data) {
                            var C = S.bounds;
                            if (!(C.x1 < u || C.x0 > p || C.y1 < c || C.y0 > d)) {
                                var b = S.opacity, x = m && C.area() > g || S.hovered;
                                if (1 > b && (n.globalAlpha = b), S.fillColor || S.lineColor) {
                                    for (var _ = t.Base.Graphics.beginStrokeAndFill(n, S), w = 0, L = this.getNodeCoords(S, f); w < L.length; w++) {
                                        var T = L[w], M = T[0] * o + r, P = T[1] * a + h;
                                        _.moveTo(M, P);
                                        for (var k = 2; k <= T.length - 2; k += 2)_.lineTo(T[k] * o + r, T[k + 1] * a + h);
                                        _.closePath()
                                    }
                                    t.Base.Graphics.endStrokeAndFill(n, _, S)
                                }
                                if (x) {
                                    var D = (C.x1 + C.x0) / 2 * o + r, I = (C.y1 + C.y0) / 2 * a + h, A = (C.x1 - C.x0) / 2 * o, B = (C.y1 - C.y0) / 2 * a;
                                    this.paintNodeDetails(S, D, I, A, B, l, y, e)
                                }
                                1 > b && (n.globalAlpha = 1)
                            }
                        }
                    }
                    return !1
                }, n.prototype.findObjectAt = function (e, i, n) {
                    for (var s = this.scene.fromDisplay(e, i), o = s.x, r = s.y, a = 1 / this.scene.zoom, h = n * a, l = null, u = this.nodes(), c = u.length - 1; c >= 0; c--) {
                        var p = u[c];
                        if (!p.removed) {
                            var d = this.getNodeCoords(p, a), f = t.Base.Geometry.distanceToPolygonSq(o, r, d), m = h * h;
                            if (0 >= f)return {object: p, details: null};
                            if (m > f) {
                                var g = Math.sqrt(f);
                                h > g && (h = g, l = p)
                            }
                        }
                    }
                    return {object: l, details: null}
                }, n.prototype.getNodeCoords = function (e, i) {
                    var n = this.style.shapeSimplificationPrecision;
                    if (!(n > 0))return e.coordinates;
                    n *= i;
                    var s = e.coordinatesCachePrecision;
                    if (n >= s && 2 * s > n)return e.coordinatesCache;
                    var o, r = [];
                    o = n > s ? e.coordinatesCache : e.coordinates;
                    for (var a = 0; a < o.length; a++) {
                        var h = o[a], l = t.Base.Geometry.computeBoundsSize(h);
                        l > 4 * n && (h.length > 10 && (h = t.Base.Geometry.simplify(h, n)), r.push(h))
                    }
                    return e.coordinatesCachePrecision = n, e.coordinatesCache = r, r
                }, n
            }(t.ItemsChart.ItemsLayer);
            e.ShapesLayer = i
        }(e = t.GeoChart || (t.GeoChart = {}))
    }(e = t.Internal || (t.Internal = {}))
}(ZoomCharts || (ZoomCharts = {}));
var ZoomCharts;
!function (t) {
    var e;
    !function (e) {
        var i;
        !function (i) {
            var n = function (t) {
                function e(e, i, n) {
                    t.call(this, e), this.layerSettings = n, this.parentId = null, this.baseLayer = i
                }

                return __extends(e, t), e.prototype.updateStyle = function () {
                    throw"Implement this"
                }, e.prototype.postprocessStyle = function () {
                    throw"Implement this"
                }, e.prototype.paint = function () {
                    throw"Implement this"
                }, e.prototype.findObjectAt = function () {
                    return null
                }, e.prototype.getLegendItems = function () {
                    return []
                }, e.prototype.nodes = function () {
                    return this.baseLayer.nodes()
                }, e.prototype.links = function () {
                    return this.baseLayer.links()
                }, e.prototype.getModified = function () {
                    return this.baseLayer.getModified()
                }, e.prototype.hasTopologyChanges = function () {
                    return this.baseLayer.hasTopologyChanges()
                }, e.prototype.hasStyleChanges = function () {
                    return this.baseLayer.hasStyleChanges()
                }, e.prototype.clearModified = function () {
                }, e.prototype.getGeometry = function () {
                    return this.baseLayer.getGeometry()
                }, e
            }(e.Base.Layer);
            i.OverlayLayerBase = n;
            var s = function (e) {
                function i(t, i, n, s) {
                    e.call(this, t, i, n), this.idToChart = {}, this.chart = s, this.style = this.layerSettings.style
                }

                return __extends(i, e), i.prototype.updateStyle = function () {
                }, i.prototype.postprocessStyle = function () {
                    for (var t in this.baseLayer.newNodes) {
                        var e = this.baseLayer.newNodes[t];
                        this.idToChart[t] = this.createChart(e)
                    }
                    var i;
                    for (var t in this.baseLayer.modifiedNodes) {
                        var e = this.baseLayer.modifiedNodes[t];
                        this.baseLayer.newNodes.hasOwnProperty(t) || (i = this.idToChart[t], i ? this.updateChart(i, e) : this.idToChart[t] = this.createChart(e))
                    }
                    for (var t in this.baseLayer.deletedNodes)i = this.idToChart[t], i && (delete this.idToChart[t], this.removeChart(i));
                    for (var n = 0, s = this.nodes(); n < s.length; n++) {
                        var e = s[n];
                        i = this.idToChart[e.id], i && this.updateXY(i, e)
                    }
                }, i.prototype.paint = function () {
                }, i.prototype.createChart = function (e) {
                    var i = this.layerSettings.chartType, n = this.getChartSettings(e);
                    if (!n)return null;
                    n.parentChart = this.chart.api, n.area ? n.area.width || (n.area.width = 100, n.area.height = 100) : n.area = {
                            width: 100,
                            height: 100
                        };
                    var s;
                    return s = "piechart" === i ? new t.PieChart(n) : "facetchart" === i ? new t.FacetChart(n) : "timechart" === i ? new t.TimeChart(n) : null
                }, i.prototype.getChartSettings = function (t) {
                    return this.layerSettings.settingsFunction ? this.layerSettings.settingsFunction(t, t.data) : this.layerSettings.settings
                }, i.prototype.updateChart = function (t, e) {
                    var i = this.getChartSettings(e);
                    t.updateSettings(i)
                }, i.prototype.removeChart = function (t) {
                    t.remove()
                }, i.prototype.updateXY = function (t, e) {
                    var i = this.scene.toDisplay(e.x, e.y), n = i.x, s = i.y, o = 0, r = 0, a = t._impl.settings.area;
                    if (this.layerSettings.autoSize)throw"TODO: implement autoSize";
                    o = a.width, r = a.height;
                    var h = n - o / 2, l = s - r / 2;
                    (a.left !== h || a.top !== l || a.width !== o || a.height !== r) && t.updateSettings({
                        area: {
                            left: n - o / 2,
                            top: s - r / 2,
                            width: o,
                            height: r
                        }
                    })
                }, i.prototype.remove = function () {
                    for (var t in this.idToChart)this.removeChart(this.idToChart[t]);
                    this.idToChart = {}
                }, i
            }(n);
            i.ChartsLayer = s
        }(i = e.GeoChart || (e.GeoChart = {}))
    }(e = t.Internal || (t.Internal = {}))
}(ZoomCharts || (ZoomCharts = {}));
var ZoomCharts;
!function (t) {
    var e;
    !function (t) {
        var e;
        !function (e) {
            var i = function () {
                function i(e, i, n, s) {
                    this.drilldownId = s, this.layerSettings = n, this.data = i, this.chart = e, this.loading = !0, this.scene = e.scene, this.layer = this.createLayer(), this.layer.drilldownId = this.drilldownId, this.dataBounds = t.Base.Rect.createEmpty(), this.expandedNode = null
                }

                return i.calculateShapeCentroid = function (e) {
                    var i, n, s = 0, o = 0;
                    for (i = 0; i < e.coordinates.length; i++)n = t.Base.Geometry.calculatePolyArea(e.coordinates[i]), Math.abs(n) > Math.abs(o) && (o = n, s = i);
                    if (0 === o)return e.x = (e.bounds.x0 + e.bounds.x1) / 2, void(e.y = (e.bounds.y0 + e.bounds.y1) / 2);
                    var r = t.Base.Geometry.calculatePolyCentroid(e.coordinates[s], o);
                    e.x = r.x, e.y = r.y
                }, i.prototype.createLayer = function () {
                    return "shapes" === this.layerSettings.type ? new e.ShapesLayer(this.scene, this.layerSettings) : "items" === this.layerSettings.type ? new e.NodesLayer(this.scene, this.chart.events, this.layerSettings, !1) : null
                }, i.prototype.onSceneChange = function (t) {
                    var i, n, s, o = this.data.dataSettings, r = this.layerSettings, a = o.prefetchRatio;
                    o.perBoundsData ? (i = this.chart.scene.getVisibleBounds(), n = i.clone().inflate(1 + a / 2), s = i.clone().inflate(1 + a)) : n = s = i = this.data.getProjectedBounds();
                    var h = t.changes.geoChartDataNodesIds ? (t.changes.geoChartDataNodesIds[o.id] || {})[this.drilldownId || ""] : null, l = r.aggregation && r.aggregation.enabled;
                    if (this.dataBounds.isEmpty() || h || !i.isInside(this.dataBounds) || t.changes.zoom && (o.perZoomData || l)) {
                        this.loading = !1, this.data.setViewParams(o.aggregationGridSize / this.scene.zoom, this.scene.zoomLevel, i, n, s);
                        var u = this.data.getData(this.drilldownId), c = u.nodes, p = u.links, d = u.hasData, f = u.loading, m = c.length;
                        if (d || m > 0) {
                            if (this.chart.log("Layer " + this.layerSettings.id + ": Updating view rect to " + n + ", contains " + m + " objects"), l) {
                                var g = new e.Aggregation(r.aggregation, this.scene, this.chart), y = g.aggregate(c, p);
                                c = y.nodes, p = y.links
                            }
                            this.applyVisibleNodes(this.layer, c, p, null), this.dataBounds = n
                        }
                        this.loading = f
                    } else i.area() * (1 + a) * (1 + a) < this.dataBounds.area() / 5 && (n = i.inflate(1 + a), this.chart.log("Layer " + this.layerSettings.id + ": Shrinking view to " + n), this.shrinkVisibleBounds(n), this.dataBounds = n);
                    if (r.perZoomStyle && t.changes.zoom) {
                        for (var v = 0, S = this.layer.nodes(); v < S.length; v++)this.layer.touchNode(S[v]);
                        for (var C = 0, b = this.layer.links(); C < b.length; C++)this.layer.touchLink(b[C])
                    }
                }, i.prototype.updateStyle = function (t) {
                    this.layer.setBounds(this.scene.x0, this.scene.y0, this.scene.x0 + this.scene.width, this.scene.y0 + this.scene.height), this.layer.updateStyle(t)
                }, i.prototype.postprocessStyle = function (t) {
                    this.layer.postprocessStyle(t)
                }, i.prototype.remove = function () {
                }, i.prototype.paint = function (t) {
                    this.layer.paint(t)
                }, i.prototype.findObjectAt = function (t, e, i) {
                    return this.layer.findObjectAt(t, e, i)
                }, i.prototype.findObjectById = function (t) {
                    return this.layer.findObjectById(t)
                }, i.prototype.touchObject = function (t) {
                    var e = this.layer, i = e.findObjectById(t);
                    i && e.touchNodeOrLink(i)
                }, i.prototype.setExpandedNode = function (t) {
                    this.expandedNode && (this.expandedNode.expanded = !1, this.layer.touchNode(this.expandedNode), this.expandedNode = null), t && (this.expandedNode = this.layer.idToNode[t], this.expandedNode && (this.expandedNode.expanded = !0, this.layer.touchNode(this.expandedNode)))
                }, i.prototype.applyVisibleNodes = function (t, e, n, s) {
                    for (var o = t.idToNode, r = {}, a = {}, h = "shapes" === this.layerSettings.type, l = 0; l < e.length; l++) {
                        var u = e[l], c = h && u._coordinates || !h && u.hasOwnProperty("_x");
                        if (c) {
                            var p = u.id;
                            r[p] = !0;
                            var d = t.addNode(p);
                            d.data = u, h && (d.coordinates = u._coordinates, d.bounds = u._bounds, i.calculateShapeCentroid(d)), d.parentNode = s
                        }
                    }
                    for (var f = 0; f < n.length; f++) {
                        var m = n[f], g = t.addLink(m.id, m.from, m.to);
                        g.data = m, a[g.id] = !0
                    }
                    for (var p in o) {
                        var d = o[p];
                        if (!r.hasOwnProperty(p)) {
                            t.removeNode(d);
                            for (var y = 0; y < d.links.length; y++)t.removeLink(d.links[y])
                        }
                    }
                    var v = t.idToLink;
                    for (var p in v)a.hasOwnProperty(p) || t.removeLink(v[p])
                }, i.prototype.shrinkVisibleBounds = function (t) {
                    for (var e in this.layer.idToNode) {
                        var i = this.layer.idToNode[e];
                        i.data._bounds.isOutside(t) && this.layer.removeNode(e)
                    }
                }, i
            }(), n = function () {
                function t(t, e, i, n) {
                    this.data = null, this.drilldownId = n, this.layerSettings = i, this.baseLayer = e, this.chart = t, this.scene = t.scene, this.loading = !1, this.layer = this.createLayer()
                }

                return t.prototype.createLayer = function () {
                    return "charts" === this.layerSettings.type ? new e.ChartsLayer(this.scene, this.baseLayer.layer, this.layerSettings, this.chart) : null
                }, t.prototype.onSceneChange = function () {
                }, t.prototype.updateStyle = function (t) {
                    this.layer.updateStyle(t)
                }, t.prototype.postprocessStyle = function (t) {
                    this.layer.postprocessStyle(t)
                }, t.prototype.setExpandedNode = function () {
                }, t.prototype.paint = function (t) {
                    this.layer.paint(t)
                }, t.prototype.findObjectAt = function () {
                    return null
                }, t.prototype.findObjectById = function () {
                    return null
                }, t.prototype.touchObject = function () {
                }, t.prototype.remove = function () {
                    this.layer.remove()
                }, t
            }(), s = function () {
                function e(e, i, n, s, o) {
                    this.firstTime = !0, this.drilldownId = o, this.layerSettings = s, this.data = n, this.baseLayer = i, this.chart = e, this.loading = !0, this.scene = e.scene, this.dataBounds = t.Base.Rect.createEmpty(), this.nodeToAggregated = {}, this.pendingNodes = {}
                }

                return e.prototype.onSceneChange = function (t) {
                    if (this.firstTime || this.layerSettings.perZoomStyle && t.changes.zoom || t.changes.data) {
                        this.firstTime = !1;
                        for (var e = this.baseLayer.layer, i = 0, n = e.nodes(); i < n.length; i++)e.touchNode(n[i]);
                        for (var s = 0, o = e.links(); s < o.length; s++)e.touchLink(o[s])
                    }
                }, e.prototype.updateStyle = function (e) {
                    var i = this.data.dataSettings, n = this.layerSettings, s = this.baseLayer.layer.modifiedNodes, o = e.changes.geoChartDataNodesIds ? (e.changes.geoChartDataNodesIds[i.id] || {})[this.drilldownId || ""] : null;
                    if (t.Base.Helpers.hasProperties(s) || t.Base.Helpers.hasProperties(o)) {
                        var r = n.styleFunction;
                        for (var a in s) {
                            var h = s[a];
                            this.nodeToAggregated.hasOwnProperty(h.id) ? r(h, this.nodeToAggregated[h.id]) : this.pendingNodes[a] = h
                        }
                        if (!t.Base.Helpers.hasProperties(this.pendingNodes))return void(this.loading = !1);
                        var l;
                        if (i.perBoundsData) {
                            l = t.Base.Rect.createEmpty();
                            for (var a in this.pendingNodes) {
                                var h = this.pendingNodes[a];
                                l.addRect(h.data._bounds)
                            }
                        } else l = this.data.getProjectedBounds();
                        this.data.setViewParams(i.aggregationGridSize / this.scene.zoom, this.scene.zoomLevel, l, l, l);
                        var u = this.data.getData(this.drilldownId), c = u.nodes, p = u.loading;
                        if (!p) {
                            for (var a in this.pendingNodes) {
                                var h = this.pendingNodes[a], d = this.computeAggr(h.data._bounds, h.data._coordinates, c);
                                this.nodeToAggregated[h.id] = d, r && r(h, d)
                            }
                            this.pendingNodes = {}
                        }
                        this.loading = p
                    }
                }, e.prototype.postprocessStyle = function () {
                }, e.prototype.computeAggr = function (e, i, n) {
                    var s = this.layerSettings;
                    if (s.aggregationFunction) {
                        for (var o = [], r = 0; r < n.length; r++) {
                            var a = n[r], h = a._x, l = a._y;
                            e.containsPoint(h, l) && t.Base.Geometry.isInsidePolygon(h, l, i) && o.push(a)
                        }
                        return s.aggregationFunction(o)
                    }
                    var u = s.aggregation, c = s.aggregationField, p = 0, d = function () {
                        for (; p < n.length && (!e.containsPoint(n[p]._x, n[p]._y) || !t.Base.Geometry.isInsidePolygon(n[p]._x, n[p]._y, i));)p += 1;
                        return p < n.length
                    }, f = function () {
                        var t = n[p][c];
                        return p += 1, t
                    };
                    return t.Base.Helpers.aggregate(u, d, f)
                }, e.prototype.setExpandedNode = function () {
                }, e.prototype.paint = function () {
                }, e.prototype.findObjectAt = function () {
                    return null
                }, e.prototype.findObjectById = function () {
                    return null
                }, e.prototype.touchObject = function () {
                }, e.prototype.remove = function () {
                }, e
            }(), o = function () {
                function t(t, e, i, n) {
                    this.layers = [], this.firstTime = !0, this.layerSettings = n, this.data = i, this.renderer = e, this.chart = t, this.loading = !0, this.scene = t.scene
                }

                return t.prototype.onSceneChange = function (t) {
                    if (t.changes.navigation || this.firstTime) {
                        this.firstTime = !1;
                        for (var e = this.scene.stack, i = 0; i < Math.min(this.layers.length, e.length) && e[i] === this.layers[i].drilldownId;)i += 1;
                        for (; this.layers.length > i;) {
                            var n = this.layers.pop();
                            this.renderer.removeSimpleLayer(n);
                            var s = this.layers.length > 0 ? this.layers[this.layers.length - 1] : null;
                            s && s.setExpandedNode(null)
                        }
                        for (; this.layers.length < e.length;) {
                            var o = e[this.layers.length], s = this.layers.length > 0 ? this.layers[this.layers.length - 1] : null;
                            s && s.setExpandedNode(o);
                            var n = this.renderer.createSimpleLayer(this.data, this.layerSettings, o);
                            if (!n)break;
                            this.layers.push(n)
                        }
                    }
                    this.loading = !1;
                    for (var r = 0; r < this.layers.length; r++) {
                        var a = this.layers[r];
                        a.onSceneChange(t), this.loading = this.loading || a.loading
                    }
                }, t.prototype.updateStyle = function (t) {
                    for (var e = 0; e < this.layers.length; e++) {
                        var i = this.layers[e];
                        i.updateStyle(t)
                    }
                }, t.prototype.postprocessStyle = function (t) {
                    for (var e = 0; e < this.layers.length; e++) {
                        var i = this.layers[e];
                        i.postprocessStyle(t)
                    }
                }, t.prototype.paint = function (t) {
                    for (var e = 0; e < this.layers.length; e++) {
                        var i = this.layers[e];
                        i.paint(t)
                    }
                }, t.prototype.findObjectAt = function (t, e, i) {
                    for (var n = this.layers.length - 1; n >= 0; n--) {
                        var s = this.layers[n].findObjectAt(t, e, i);
                        if (s)return s
                    }
                    return null
                }, t.prototype.findObjectById = function (t) {
                    for (var e = this.layers.length - 1; e >= 0; e--) {
                        var i = this.layers[e].findObjectById(t);
                        if (i)return i
                    }
                    return null
                }, t.prototype.touchObject = function (t) {
                    for (var e = 0; e <= this.layers.length; e++)this.layers[e].touchObject(t)
                }, t.prototype.remove = function () {
                    for (var t = 0; t < this.layers.length; t++) {
                        var e = this.layers[t];
                        this.renderer.removeSimpleLayer(e)
                    }
                    this.layers = []
                }, t
            }();
            e.DrilldownLayer = o;
            var r = function (e) {
                function r(t) {
                    e.call(this), this.animationOrder = 900, this.paintOrder = 10, this.updateOrder = 10, this.layers = [], this.idToLayer = {}, this.idToSimpleLayer = {}, this.drilldownLayer = null, this.chart = t, this.scene = t.scene, this.events = t.events
                }

                return __extends(r, e), r.prototype.createData = function (t) {
                    var e = null;
                    return t.id && (e = this.chart.getData(t.id)), e
                }, r.prototype.isOverlayLayer = function (t) {
                    return "charts" === t.type || "aggregateOnShapes" === t.type
                }, r.prototype.createSimpleLayer = function (t, e, o) {
                    var r;
                    if (this.isOverlayLayer(e)) {
                        var a = this.idToSimpleLayer[e.shapesLayer + o];
                        if (!a)return this.chart.error("ItemsOnShape layer: shapesLayer " + e.shapesLayer + " not found, must come first in the layers array."), null;
                        "charts" === e.type ? r = new n(this.chart, a, e, o) : "aggregateOnShapes" === e.type && (r = new s(this.chart, a, t, e, o))
                    } else r = new i(this.chart, t, e, o);
                    return this.idToSimpleLayer[e.id + o] = r, r
                }, r.prototype.removeLayer = function (t) {
                    t instanceof o ? t.remove() : this.removeSimpleLayer(t)
                }, r.prototype.removeSimpleLayer = function (t) {
                    t.remove();
                    var e = t.layerSettings.id + t.drilldownId;
                    delete this.idToSimpleLayer[e]
                }, r.prototype.onSceneChange = function (t) {
                    var e = !1, i = t.changes;
                    if (i.settingsChanges && i.settingsChanges._computedLayers) {
                        for (var n in i.settingsChanges.layers) {
                            var s = this.idToLayer[n];
                            s && (this.removeLayer(s), delete this.idToLayer[n])
                        }
                        e = !0
                    } else(i.zoom || i.data) && (e = !0);
                    if (e) {
                        var r = this.idToLayer;
                        this.layers = [], this.idToLayer = {};
                        var a = this.scene.zoomLevel;
                        this.drilldownLayer = null;
                        for (var h = this.scene.settings.navigation.drilldownLayer, l = 0; l < this.chart.settings._computedLayers.length; l++) {
                            var u = this.chart.settings._computedLayers[l], c = u.enabled && u.minZoom <= a && u.maxZoom >= a, p = r[u.id];
                            if (c) {
                                var d = this.createData(u.data), f = !1;
                                if (d && d.dataSettings.perDrilldownData && (f = !0), this.isOverlayLayer(u)) {
                                    var m = this.idToLayer[u.shapesLayer];
                                    if (!m) {
                                        this.chart.error("Overlay layer: shapeLayer " + u.shapesLayer + " not found, must come first in the layers array.");
                                        continue
                                    }
                                    p && p.baseLayer !== m && (this.removeLayer(p), p = null), f = f || m.data.dataSettings.perDrilldownData
                                }
                                var s = void 0;
                                if (p && p.data === d) s = p; else if (p && this.removeLayer(p), f) s = new o(this.chart, this, d, u); else if (s = this.createSimpleLayer(d, u, null), !s)continue;
                                u.id === h && (this.drilldownLayer = s), this.layers.push(s), this.idToLayer[u.id] = s
                            } else p && this.removeLayer(p)
                        }
                        for (var n in r) {
                            var s = r[n];
                            this.idToLayer.hasOwnProperty(n) || this.removeLayer(s)
                        }
                    }
                    for (var g = 0; g < this.layers.length; g++) {
                        var s = this.layers[g];
                        s.onSceneChange(t)
                    }
                }, r.prototype.doAnimations = function (t) {
                    for (var e = 0; e < this.layers.length; e++) {
                        var i = this.layers[e];
                        i.updateStyle(t)
                    }
                    for (var n = !1, e = 0; e < this.layers.length; e++) {
                        var i = this.layers[e];
                        i.postprocessStyle(t), n = n || i.loading
                    }
                    this.scene.loading = n
                }, r.prototype.paintScene = function (e) {
                    t.Base.Graphics.pushClip(e.context, this.scene.x0, this.scene.y0, this.scene.width, this.scene.height);
                    for (var i = !1, n = 0; n < this.layers.length; n++) {
                        var s = this.layers[n];
                        s.paint(e), i = i || s.loading
                    }
                    t.Base.Graphics.popClip(e.context), this.scene.loading = i
                }, r.prototype.findObjectById = function (t) {
                    for (var e = this.layers.length - 1; e >= 0; e--) {
                        var i = this.layers[e], n = i.findObjectById(t);
                        if (n)return n
                    }
                    return null
                }, r.prototype.touchObjects = function (t) {
                    for (var e = this.layers.length - 1; e >= 0; e--)for (var i = this.layers[e], n = 0; n < t.length; n++)i.touchObject(t[n])
                }, r.prototype.findObjectAt = function (t, e, i) {
                    for (var n = this.layers.length - 1; n >= 0; n--) {
                        var s = this.layers[n], o = s.findObjectAt(t, e, i);
                        if (o)return o
                    }
                    return null
                }, r.prototype.paintDataBounds = function (t) {
                    var e = t.context, i = this.scene.mainData.exportAreas(), n = i.areasRects, s = i.reqAreasRects, o = i.pendingAreasRects;
                    this.paintRects(e, s, {fillColor: "rgba(255,0,0, 0.2)"}), this.paintRects(e, n, {fillColor: "rgba(0,255,0, 0.3)"}), this.paintRects(e, o, {fillColor: "rgba(0,0,255, 0.5)"})
                }, r.prototype.paintRects = function (e, i, n) {
                    var s = this.scene.toDisplayTransform(), o = s.xm, r = s.xa, a = s.ym, h = s.ya;
                    e.beginPath();
                    for (var l = 0; l < i.length; l++) {
                        var u = i[l], c = u.x0 * o + r, p = u.y0 * a + h, d = u.x1 * o + r, f = u.y1 * a + h;
                        e.rect(c, p, d - c, f - p)
                    }
                    t.Base.Graphics.fill(e, n)
                }, r
            }(t.Base.ChartElement);
            e.Renderer = r
        }(e = t.GeoChart || (t.GeoChart = {}))
    }(e = t.Internal || (t.Internal = {}))
}(ZoomCharts || (ZoomCharts = {}));
var ZoomCharts;
!function (t) {
    var e;
    !function (t) {
        var e;
        !function (e) {
            var i = function (t) {
                function e(e) {
                    t.call(this), this.animationOrder = 1e3, this.paintOrder = 5, this.updateOrder = 1300, this.chart = e, this.scene = this.chart.scene
                }

                return __extends(e, t), e.prototype.showInitialNodes = function () {
                    var t = this.scene.settings.navigation.initialDrilldown;
                    return this.scene.stack = t, this.chart.events.notifySceneChanges({navigation: !0})
                }, e.prototype.onPanZoom = function () {
                }, e.prototype.onNewDataObject = function () {
                }, e.prototype.expandNode = function (t) {
                    var e = t.layer.drilldownId, i = t.id;
                    if (i === this.scene.peek())return !1;
                    for (; this.scene.peek() !== e;)this.scene.pop();
                    return this.scene.push(i), this.chart.events.notifySceneChanges({navigation: !0}), !0
                }, e.prototype.collapseNode = function () {
                    throw"Not implemented"
                }, e
            }(t.Base.ChartElement);
            e.Navigator = i
        }(e = t.GeoChart || (t.GeoChart = {}))
    }(e = t.Internal || (t.Internal = {}))
}(ZoomCharts || (ZoomCharts = {}));
var ZoomCharts;
!function (t) {
    var e;
    !function (t) {
        var e;
        !function (e) {
            var i = function (i) {
                function n(n, s) {
                    if (null == t.Leaflet)throw new Error("Leaflet.js must be included in the page in order to use GeoChart. If it is, please make sure that L.noConflict() is not called before ZoomCharts library.");
                    i.call(this, new e.Settings(n), new e.Scene, s), this._map = this._domLayer.map, this.navigator = this.events.addElement(new e.Navigator(this)), this.menu = this.events.addElement(new t.ItemsChart.Menu(this)), this.info = this.events.addElement(new t.ItemsChart.InfoPopup(this)), this.renderer = this.events.addElement(new e.Renderer(this)), this.scene.loading = !1, this.navigator.showInitialNodes(), this.finalInitialize(), null !== this.settings.navigation.initialLat && this.setView(this.settings.navigation.initialLat, this.settings.navigation.initialLng, this.settings.navigation.initialZoom)
                }

                return __extends(n, i), n.prototype.getMap = function () {
                    return this._map
                }, n.prototype.createDomLayer = function () {
                    return this._domLayer = new e.DomLayer(this), this._domLayer
                }, n.prototype.createDataObj = function (t) {
                    return new e.Data(this, t)
                }, n.prototype.onSettingsChanged = function (t) {
                    var e = {}, i = t.navigation && t.navigation.initialDrilldown;
                    i && this.navigator.showInitialNodes(), t.filters && (e.filters = !0), t.style && (e.style = !0), this.events.notifySceneChanges(e)
                }, n.prototype.saveNavigation = function () {
                    return this._map ? this.scene.getVisibleBoundsLatLon() : null
                }, n.prototype.restoreNavigation = function (t) {
                    this.setBounds(t)
                }, n.prototype.save = function () {
                    return ""
                }, n.prototype.restore = function (t) {
                }, n.prototype.setZoomLevel = function (t) {
                    this._map.setZoom(t)
                }, n.prototype.setView = function (t, e, i) {
                    return this._map.setView(L.latLng(t, e), i)
                }, n.prototype.setBounds = function (t) {
                    var e = t;
                    if (void 0 !== e.east) this._map.fitBounds(L.latLngBounds(L.latLng(e.south, e.west), L.latLng(e.north, e.east))); else {
                        var i = t;
                        this._map.fitBounds(L.latLngBounds(L.latLng(i.y1, i.x0), L.latLng(i.y0, i.x1)))
                    }
                }, n.prototype.getNodeDimensions = function (e) {
                    var i = e;
                    if (t.Base.Helpers.isString(e) || (i = this.getNode(e)), !i)return null;
                    var n = this.scene.toDisplay(i.x, i.y), s = n.x, o = n.y, r = i.hHeight * this.scene.zoom, a = i.hWidth * this.scene.zoom;
                    return {x: s, y: o, radius: r, hwidth: a}
                }, n.prototype.expandNode = function (e) {
                    var i = null;
                    i = t.Base.Helpers.isString(e) ? this.getNode(e) : e, this.navigator.expandNode(i)
                }, n.prototype.collapseNode = function (e) {
                    var i = null;
                    i = t.Base.Helpers.isString(e) ? this.getNode(e) : e, this.navigator.collapseNode(i)
                }, n.prototype.getNode = function (t) {
                    return this.renderer.findObjectById(t)
                }, n.prototype.zoomIn = function () {
                    return this.error("ZoomIn: not implmeneted")
                }, n.prototype.hideMenu = function () {
                    return this.menu.hideMenu()
                }, n.prototype.extendEventParams = function (t) {
                    if (t.x || t.y) {
                        var e = this.scene.fromDisplay(t.x, t.y);
                        t.chartX = e.x, t.chartY = e.y
                    }
                    return t.hoverLink = this.scene.hoverLink, t.hoverNode = this.scene.hoverNode, t.hoverItem = this.scene.hoverItem, t.selection = this.scene.selection, t
                }, n.prototype.defaultClick = function (t) {
                    var e = "drilldown" === this.settings.interaction.mode, i = t.clickNode;
                    e && i && i.expandable && this.navigator.expandNode(i) && (this.setBounds(this.scene.unprojectRect(i.data._bounds)), t.preventDefault())
                }, n.prototype.defaultRightClick = function (t) {
                    t.clickNode && (this.menu.toggleNodeMenu(t.clickNode), t.preventDefault()), t.clickLink && (this.menu.toggleLinkMenu(t.x, t.y, t.clickLink), t.preventDefault())
                }, n.prototype.defaultDoubleClick = function (t) {
                    var e = t.clickNode;
                    return e ? 1 : void 0
                }, n
            }(t.ItemsChart.Impl);
            e.Impl = i
        }(e = t.GeoChart || (t.GeoChart = {}))
    }(e = t.Internal || (t.Internal = {}))
}(ZoomCharts || (ZoomCharts = {}));
var ZoomCharts;
!function (t) {
    var e = function (e) {
        function i(n) {
            var s = this;
            e.call(this), this.typeName = "GeoChart", this._impl = i.chartFactoryMethod ? i.chartFactoryMethod(function (e) {
                    return new t.Internal.GeoChart.Impl(e, s)
                }, n) : new t.Internal.GeoChart.Impl(n, this)
        }

        return __extends(i, e), i.prototype.createEmptySettings = function () {
            return t.Internal.Base.SettingsHelper.createEmptySettings(t.Internal.Base.SettingsMapping.GeoChartSettings)
        }, i.prototype.updateSettings = function (i) {
            return t.Internal.Base.SettingsHelper.cleanupEmptySettings(i), e.prototype.updateSettings.call(this, i), this
        }, i.prototype.getNode = function (t) {
            return this._impl.getNode(t)
        }, i.prototype.showNode = function (t) {
            return this._impl.addFocusNode(t, .9)
        }, i.prototype.hideNode = function (t) {
            return this._impl.hideNode(t)
        }, i.prototype.expandNode = function (t) {
            return this._impl.expandNode(t)
        }, i.prototype.collapseNode = function (t) {
            return this._impl.collapseNode(t)
        }, i.prototype.updateStyle = function (t) {
            t ? (this._impl.renderer.touchObjects(t), this._impl.events.requestPaint()) : this._impl.updateStyle(null)
        }, i.prototype.selection = function (e) {
            return t.Internal.Base.Helpers.isArray(e) && this._impl.setSelection(e), this._impl.scene.selection
        }, i.prototype.bounds = function (t) {
            t && this._impl.setBounds(t);
            var e = this._impl.scene.getVisibleBoundsLatLon();
            return {east: e.x1, north: e.y1, west: e.x0, south: e.y0}
        }, i.prototype.back = function () {
            return this._impl.back(), this
        }, i.prototype.zoomIn = function (t, e) {
            return void 0 === e && (e = !0), null == e && (e = !0), this._impl.zoomIn(t, e)
        }, i.prototype.zoomLevel = function (t) {
            return t && this._impl.setZoomLevel(t), this._impl.scene.zoomLevel
        }, i.prototype.getNodeDimensions = function (t) {
            return this._impl.getNodeDimensions(t)
        }, i.prototype.leaflet = function () {
            return this._impl.getMap()
        }, i.chartFactoryMethod = null, i
    }(t.Internal.Base.Api);
    t.GeoChart = e, t.Internal.Base.Helpers.exportSymbol("GeoChart", t.GeoChart)
}(ZoomCharts || (ZoomCharts = {}));